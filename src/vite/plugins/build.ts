import type { Api } from '#api/$'
import type { PolenBuildManifest } from '#api/static/manifest'
import { Ef } from '#dep/effect'
import { Vite } from '#dep/vite/index'
import { debugPolen } from '#singletons/debug'
import * as NodeFileSystem from '@effect/platform-node/NodeFileSystem'
import { FileSystem } from '@effect/platform/FileSystem'
import { Fs, FsLoc } from '@wollybeard/kit'
import packageJson from '../../../package.json' with { type: 'json' }
import { isKitUnusedExternalImport, isRadixModuleLevelDirective } from '../log-filters.js'
import { RoutesManifest } from './routes-manifest.js'

export const Build = (config: Api.Config.Config): Vite.Plugin[] => {
  const debug = debugPolen.sub(`vite-build`)
  debug(`construct`)
  // let viteConfigResolved: Vite.ResolvedConfig

  // const outDir = Path.join(config.paths.project.rootDir, `dist`)

  return [
    BuildManifest(config),
    RoutesManifest(config),
    {
      name: `polen:build-client`,
      apply: `build`,
      applyToEnvironment: Vite.isEnvironmentClient,
      // HACK: For some reason the ?url import doesn't lead to a rewrite in the build.
      // Furthermore we need to rely on the manifest to get its final name because it is
      // generated by the client build before the server build.
      // However, we still need the asset in development.
      // But we cannot exclude the import in build.
      // So this does that for us but it is really hacky.
      // FIXME
      // 1. Raise issue about having ?url lead to expected build path rewrite?
      // 2. And: Move asset generation to server build?
      // 3. And/or: Use Vite Environments API?
      generateBundle(_, bundle, isWrite) {
        if (isWrite) {
          for (const chunkOrAsset of Object.values(bundle)) {
            if (chunkOrAsset.type === `asset` && chunkOrAsset.names.includes(`entry.client.jsx`)) {
              delete bundle[chunkOrAsset.fileName]
            }
          }
        }
      },
      onLog(_, message) {
        if (isRadixModuleLevelDirective(message)) return
        if (isKitUnusedExternalImport(message)) return
      },
      config() {
        return {
          environments: {
            client: {
              build: {
                manifest: true,
                rollupOptions: {
                  input: [FsLoc.encodeSync(config.paths.framework.template.absolute.client.entrypoint)],
                  external: id => id.startsWith(`node:`),
                  onwarn(message) {
                    if (isKitUnusedExternalImport(message)) return
                  },
                },
              },
            },
          },
        }
      },
    },

    {
      name: `polen-ssr-build`,
      apply: `build`,
      applyToEnvironment: Vite.isEnvironmentSsr,
      config() {
        return {
          // Have to configure this here??
          // @see https://github.com/vitejs/vite/issues/20098
          ssr: {
            noExternal: true,
            // Exclude lightningcss from bundling due to native bindings
            // @see https://github.com/parcel-bundler/lightningcss/issues/701
            external: ['lightningcss'],
          },
          environments: {
            ssr: {
              build: {
                // NO EFFECT (see above)
                // Bundle all dependencies instead of externalizing them
                // noExternal: true,
                // The SSR build will follow the client build, and emptying the dir would lose the output of the client build.
                emptyOutDir: false,
                rollupOptions: {
                  input: [FsLoc.encodeSync(config.paths.framework.template.absolute.server.entrypoint)],
                  output: {
                    entryFileNames: FsLoc.encodeSync(config.paths.project.relative.build.relative.serverEntrypoint),
                  },
                },
              },
            },
          },
        }
      },
      onLog(_, message) {
        if (isKitUnusedExternalImport(message)) return
      },
      // generateBundle(_, bundle, isWrite) {
      //   if (isWrite) {
      //     for (const chunkOrAsset of Object.values(bundle)) {
      //       console.log(chunkOrAsset)
      //       if (chunkOrAsset.type === `chunk`) {
      //         if (chunkOrAsset.facadeModuleId === viClientManifest.resolved) {
      //           delete bundle[chunkOrAsset.fileName]
      //         }
      //       }
      //     }
      //   }
      // },
      async closeBundle() {
        /**
         * clean up the manifest. Was generated by client. For server build. Not needed after (unless debugging).
         */
        if (!config.advanced.debug) {
          const viteDir = FsLoc.join(config.paths.project.absolute.build.root, FsLoc.fromString('.vite/'))
          await Ef.runPromise(
            Fs.remove(viteDir, { recursive: true }).pipe(Ef.provide(NodeFileSystem.layer)),
          )
        }
      },
    },
  ]
}

const BuildManifest = (config: Api.Config.Config): Vite.Plugin => {
  return {
    name: `polen:build-manifest`,
    apply: `build`,
    applyToEnvironment: Vite.isEnvironmentClient,
    async generateBundle() {
      const manifest: PolenBuildManifest = {
        type: config.build.architecture === `ssr` ? `ssr` : `ssg`,
        version: packageJson.version,
        basePath: config.build.base ?? `/`,
      }

      // Emit the manifest as an asset
      this.emitFile({
        type: `asset`,
        fileName: `.polen/build.json`,
        source: JSON.stringify(manifest, null, 2),
      })
    },
  }
}
