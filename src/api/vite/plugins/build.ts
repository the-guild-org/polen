import { Vite } from '#dep/vite/index.js'
import { ViteVirtual } from '#lib/vite-virtual/index.js'
import { Fs, Path } from '@wollybeard/kit'
import type { Configurator } from '../../configurator/index.js'
import { isKitUnusedExternalImport, isRadixModuleLevelDirective } from '../log-filters.js'
import { vi } from '../vi.js'

// const viServerEntry = vi([`server`, `entry.jsx`], { allowPluginProcessing: true })

export const Build = (config: Configurator.Config): Vite.Plugin[] => {
  // let viteConfigResolved: Vite.ResolvedConfig

  // const outDir = Path.join(config.paths.project.rootDir, `dist`)

  return [Manifest(config), {
    name: `polen:build-client`,
    apply: `build`,
    applyToEnvironment: Vite.isEnvironmentClient,
    // HACK: For some reason the ?url import doesn't lead to a rewrite in the build.
    // Furthermore we need to rely on the manifest to get its final name because it is
    // generated by the client build before the server build.
    // However, we still need the asset in development.
    // But we cannot exclude the import in build.
    // So this does that for us but it is really hacky.
    // FIXME
    // 1. Raise issue about having ?url lead to expected build path rewrite?
    // 2. And: Move asset generation to server build?
    // 3. And/or: Use Vite Environments API?
    generateBundle(_, bundle, isWrite) {
      if (isWrite) {
        for (const chunkOrAsset of Object.values(bundle)) {
          if (chunkOrAsset.type === `asset` && chunkOrAsset.names.includes(`entry.client.jsx`)) {
            // eslint-disable-next-line
            delete bundle[chunkOrAsset.fileName]
          }
        }
      }
    },
    onLog(_, message) {
      if (isRadixModuleLevelDirective(message)) return
      if (isKitUnusedExternalImport(message)) return
    },
    config() {
      return {
        environments: {
          client: {
            build: {
              manifest: true,
              rollupOptions: {
                input: [config.paths.framework.template.entryClient],
                external: id => id.startsWith(`node:`),
                onwarn(message) {
                  if (isKitUnusedExternalImport(message)) return
                },
              },
            },
          },
        },
      }
    },
  }, {
    name: `polen-ssr-build`,
    apply: `build`,
    applyToEnvironment: Vite.isEnvironmentSsr,
    config() {
      return {
        // Have to configure this here??
        // @see https://github.com/vitejs/vite/issues/20098
        ssr: {
          noExternal: true,
        },
        environments: {
          ssr: {
            build: {
              // NO EFFECT (see above)
              // Bundle all dependencies instead of externalizing them
              // noExternal: true,
              // The SSR build will follow the client build, and emptying the dir would lose the output of the client build.
              emptyOutDir: false,
              rollupOptions: {
                input: [config.paths.framework.template.entryServer],
                // input: viServerEntry.id,
                output: {
                  entryFileNames: `entry.js`,
                },
              },
            },
          },
        },
      }
    },
    // configResolved(config) {
    //   viteConfigResolved = config
    // },
    // ...ViteVirtual.IdentifiedLoader.toHooks(
    //   {
    //     /**
    //      * In development Vite runs the server entrypoint, providing things like
    //      * static file serving.
    //      *
    //      * This module provides that functionality for production.
    //      */
    //     identifier: viServerEntry,
    //     loader: () => {
    //       // Globs in Vite virtual modules must start with a slash
    //       const entrServeryViteGlobPath = `/`
    //         + Path.relative(config.paths.framework.rootDir, config.paths.framework.template.entryServer)
    //       const staticServingPaths = {
    //         // todo
    //         // relative from CWD of process that boots node server
    //         // can easily break! Use path relative in server??
    //         dirPath: `./dist`,
    //         routePath: `/${viteConfigResolved.build.assetsDir}/*`,
    //       }

    //       const code = Str.Builder()

    //       const $ = {
    //         frameworkEntrypoint: `frameworkEntrypoint`,
    //         projectEntrypoint: `projectEntrypoint`,
    //         projectEntrypoints: `projectEntrypoints`,
    //         HonoAid: `HonoAid`,
    //         serveStatic: `serveStatic`,
    //         serve: `serve`,
    //         value: {
    //           port: String(viteConfigResolved.server.port + 1),
    //         },
    //       }

    //       code`import { Hono } from 'hono'`
    //       code``
    //       code`const ${$.frameworkEntrypoint} = new Hono()`
    //       code``
    //       code``
    //       code`// Static Files`
    //       code``
    //       code`import { ${$.serveStatic} } from '@hono/node-server/serve-static'`
    //       code`import { ${$.HonoAid} } from '#lib/hono-aid/index.js'`
    //       code``
    //       code`${$.frameworkEntrypoint}.use(
    // 				'${staticServingPaths.routePath}',
    // 				${$.serveStatic}({ root: '${staticServingPaths.dirPath}' })
    // 			)`
    //       code``
    //       code``
    //       // todo: why do we support multiple entrypoints?
    //       code`// Entrypoints`
    //       code``
    //       code`const ${$.projectEntrypoints} = import.meta.glob(
    // 				['${entrServeryViteGlobPath}'],
    // 				{ import: 'default', eager: true }
    // 			)`
    //       code``
    //       code`for (const ${$.projectEntrypoint} of Object.values(${$.projectEntrypoints})) {
    // 		${$.HonoAid}.delegate(${$.frameworkEntrypoint}, 'all', '*', ${$.projectEntrypoint})
    // 			}`
    //       code``
    //       code``
    //       code`// Start Server`
    //       code``
    //       code`import { ${$.serve} } from '@hono/node-server'` // TODO: support non-node platforms.
    //       code``
    //       code(`const port = process.env.PORT || ${$.value.port}`)
    //       code``
    //       code(`${$.serve}({ fetch: ${$.frameworkEntrypoint}.fetch, port })`)

    //       return code.render()
    //     },
    //   },
    // ),
    onLog(_, message) {
      if (isKitUnusedExternalImport(message)) return
    },

    // generateBundle(_, bundle, isWrite) {
    //   if (isWrite) {
    //     for (const chunkOrAsset of Object.values(bundle)) {
    //       console.log(chunkOrAsset)
    //       if (chunkOrAsset.type === `chunk`) {
    //         if (chunkOrAsset.facadeModuleId === viClientManifest.resolved) {
    //           // eslint-disable-next-line
    //           delete bundle[chunkOrAsset.fileName]
    //         }
    //       }
    //     }
    //   }
    // },
    async closeBundle() {
      /**
       * clean up the manifest. Was generated by client. For server build. Not needed after (unless debugging).
       */
      if (!config.advanced.debug) {
        await Fs.remove(Path.join(config.paths.project.absolute.build.root, `.vite`))
      }
    },
  }]
}

const viClientManifest = vi([`vite`, `client`, `manifest`])

const Manifest = (config: Configurator.Config): Vite.Plugin => {
  let configEnv: Vite.ConfigEnv

  return {
    name: `polen-manifest`,
    config(_, configEnv_) {
      configEnv = configEnv_
    },
    ...ViteVirtual.IdentifiedLoader.toHooks(
      {
        identifier: viClientManifest,
        loader: async () => {
          // In development just return an empty manifest
          if (configEnv.mode === Vite.ModeName.development) {
            return `export default {}`
          }

          const manifestPath = Path.join(config.paths.project.absolute.build.root, `.vite`, `manifest.json`)
          const module = await import(manifestPath, { with: { type: `json` } }) as {
            default: Vite.Manifest
          }

          return `export default ${JSON.stringify(module.default)}`
        },
      },
    ),
  }
}
