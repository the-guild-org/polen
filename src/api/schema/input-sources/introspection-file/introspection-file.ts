import { InputSource } from '#api/schema/input-source/$'
import { Catalog } from '#lib/catalog/$'
import { Change } from '#lib/change/$'
import { DateOnly } from '#lib/date-only/$'
import { Grafaid } from '#lib/grafaid'
import { Revision } from '#lib/revision/$'
import { Schema } from '#lib/schema/$'
import { Fs, Json, Path } from '@wollybeard/kit'

/**
 * Configuration for loading schema from an existing introspection file.
 *
 * This source reads a pre-existing `schema.introspection.json` file from your
 * project root. The file should contain a standard GraphQL introspection query
 * result as defined in the GraphQL specification.
 *
 * This is useful when:
 * - You have an introspection file generated by other tools (GraphQL Codegen, Apollo CLI, etc.)
 * - You want to commit the introspection file to version control
 * - You prefer to manage the introspection process separately
 *
 * The file must be in the standard GraphQL introspection format with a
 * `data.__schema` structure.
 *
 * @see https://spec.graphql.org/draft/#sec-Introspection - GraphQL Introspection spec
 *
 * @example
 * ```ts
 * // Uses default path: ./schema.introspection.json
 * introspectionFile: {}
 *
 * // Custom path
 * introspectionFile: {
 *   path: './graphql/introspection.json'
 * }
 * ```
 */
export interface Options {
  /**
   * Path to the introspection file.
   *
   * @default './schema.introspection.json'
   */
  path?: string
}

export interface Config {
  path: string
}

export const normalizeOptions = (options: Options, projectRoot: string): Config => {
  const config: Config = {
    path: options.path
      ? Path.ensureAbsolute(options.path, projectRoot)
      : Path.join(projectRoot, INTROSPECTION_FILE_NAME),
  }

  return config
}

const INTROSPECTION_FILE_NAME = `schema.introspection.json`

// Removed - path is now part of config

export const read = async (
  options: Options,
  projectRoot: string,
): Promise<Catalog.Unversioned.Unversioned | null> => {
  const config = normalizeOptions(options, projectRoot)

  // Check if introspection file exists
  const introspectionFileContent = await Fs.read(config.path)

  if (!introspectionFileContent) {
    return null
  }

  let schema: Grafaid.Schema.Schema

  try {
    const introspectionData = Json.codec.decode(introspectionFileContent)

    // Validate introspection data structure before passing to fromIntrospectionQuery
    if (!introspectionData || typeof introspectionData !== 'object') {
      throw new Error('Introspection data must be a valid JSON object')
    }

    // Allow fromIntrospectionQuery to handle validation of the introspection format
    // It will provide more specific GraphQL-related error messages
    if (!('data' in introspectionData)) {
      throw new Error(
        'Introspection data missing required "data" property (expected GraphQL introspection result format)',
      )
    }

    schema = Grafaid.Schema.fromIntrospectionQuery(introspectionData as any)
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error(`Invalid JSON in ${config.path}: ${error.message}`)
    } else {
      throw new Error(
        `Invalid introspection data in ${config.path}: ${error instanceof Error ? error.message : String(error)}`,
      )
    }
  }

  return createCatalogFromSchema(schema)
}

/**
 * Create a catalog from a schema object.
 * This is the core logic for handling single (unversioned) schemas from introspection.
 */
const createCatalogFromSchema = async (
  schemaData: Grafaid.Schema.Schema,
): Promise<Catalog.Unversioned.Unversioned> => {
  const date = new Date()
  const dateString = date.toISOString().split('T')[0]!
  const after = schemaData
  const before = Grafaid.Schema.empty
  const changes = await Change.calcChangeset({
    before,
    after,
  })

  const revision = Revision.make({
    _tag: 'Revision',
    date: DateOnly.make(dateString),
    changes,
  })

  // Create unversioned schema
  const schema = Schema.Unversioned.make({
    _tag: 'SchemaUnversioned',
    revisions: [revision],
    definition: after, // GraphQLSchema object
  })

  // Return catalog
  return Catalog.Unversioned.make({
    _tag: 'CatalogUnversioned',
    schema,
    revisions: [revision],
  })
}

export const loader = InputSource.create({
  name: 'introspectionFile',
  isApplicable: async (options: Options, context) => {
    // Check if the introspection file exists
    const normalizedConfig = normalizeOptions(options, context.paths.project.rootDir)
    const fileContent = await Fs.read(normalizedConfig.path)
    return !!fileContent
  },
  readIfApplicableOrThrow: async (options: Options, context) => {
    return await read(options, context.paths.project.rootDir)
  },
})
