import { InputSource } from '#api/schema/input-source/$'
import {
  createSingleRevisionCatalog,
  mapToInputSourceError,
  normalizePathToAbs,
} from '#api/schema/input-source/helpers'
import { S } from '#dep/effect'
import { Ef } from '#dep/effect'
import type { FileSystem } from '@effect/platform'
import { Fs, FsLoc, Json } from '@wollybeard/kit'
import { Catalog, Grafaid } from 'graphql-kit'
import * as IntrospectionSchema from './introspection-schema.js'

/**
 * Configuration for loading schema from an existing introspection file.
 *
 * This source reads a pre-existing `schema.introspection.json` file from your
 * project root. The file should contain a standard GraphQL introspection query
 * result as defined in the GraphQL specification.
 *
 * This is useful when:
 * - You have an introspection file generated by other tools (GraphQL Codegen, Apollo CLI, etc.)
 * - You want to commit the introspection file to version control
 * - You prefer to manage the introspection process separately
 *
 * The file must be in the standard GraphQL introspection format with a
 * `data.__schema` structure.
 *
 * @see https://spec.graphql.org/draft/#sec-Introspection - GraphQL Introspection spec
 *
 * @example
 * ```ts
 * // Uses default path: ./schema.introspection.json
 * introspectionFile: {}
 *
 * // Custom path
 * introspectionFile: {
 *   path: './graphql/introspection.json'
 * }
 * ```
 */
export interface Options {
  /**
   * Path to the introspection file.
   *
   * @default './schema.introspection.json'
   */
  path?: string | FsLoc.AbsFile | FsLoc.RelFile
}

export interface Config {
  path: FsLoc.AbsFile
}

export const normalizeOptions = (options: Options, projectRoot: FsLoc.AbsDir): Config => {
  const config: Config = {
    path: normalizePathToAbs.file(
      options.path,
      projectRoot,
      FsLoc.fromString(INTROSPECTION_FILE_NAME) as FsLoc.RelFile,
    ),
  }

  return config
}

const INTROSPECTION_FILE_NAME = `schema.introspection.json`

// Removed - path is now part of config

export const read = (
  options: Options,
  projectRoot: FsLoc.AbsDir,
): Ef.Effect<Catalog.Unversioned | null, InputSource.InputSourceError, FileSystem.FileSystem> =>
  Ef.gen(function*() {
    const config = normalizeOptions(options, projectRoot)

    // Check if introspection file exists
    const exists = yield* Ef.either(Fs.exists(config.path))
    if (exists._tag === 'Left' || !exists.right) {
      return null
    }

    const introspectionFileContent = yield* Fs.readString(config.path).pipe(
      Ef.mapError(mapToInputSourceError('introspectionFile')),
    )

    let schema: Grafaid.Schema.Schema

    // Parse JSON
    const jsonData = yield* Ef.try({
      try: () => Json.codec.decode(introspectionFileContent),
      catch: (error) => {
        if (error instanceof SyntaxError) {
          return new InputSource.InputSourceError(
            {
              source: 'introspectionFile',
              message: `Invalid JSON in ${FsLoc.encodeSync(config.path)}: ${error.message}`,
              cause: error,
            },
          )
        }
        return new InputSource.InputSourceError(
          {
            source: 'introspectionFile',
            message: `Failed to parse JSON in ${FsLoc.encodeSync(config.path)}: ${error}`,
            cause: error,
          },
        )
      },
    })

    // Validate using Effect Schema
    const validatedData = yield* Ef.try({
      try: () => {
        return S.decodeUnknownSync(IntrospectionSchema.IntrospectionQuery)(jsonData)
      },
      catch: (error) => {
        if (IntrospectionSchema.isParseError(error)) {
          return new InputSource.InputSourceError({
            source: 'introspectionFile',
            message: `Invalid introspection format in ${FsLoc.encodeSync(config.path)}: ${
              IntrospectionSchema.formatError(error)
            }`,
            cause: error,
          })
        }
        return new InputSource.InputSourceError({
          source: 'introspectionFile',
          message: `Validation failed for ${FsLoc.encodeSync(config.path)}: ${error}`,
          cause: error,
        })
      },
    })

    schema = Grafaid.Schema.fromIntrospectionQuery(validatedData as any)

    return yield* createSingleRevisionCatalog(schema, 'introspectionFile')
  })

export const loader = InputSource.create({
  name: 'introspectionFile',
  isApplicable: (options: Options, context) =>
    Ef.gen(function*() {
      // Check if the introspection file exists
      const normalizedConfig = normalizeOptions(options, context.paths.project.rootDir)
      const exists = yield* Ef.either(Fs.exists(normalizedConfig.path))
      return exists._tag === 'Right' && exists.right
    }),
  readIfApplicableOrThrow: (options: Options, context) => read(options, context.paths.project.rootDir),
})
