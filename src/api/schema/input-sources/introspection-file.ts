import { InputSource } from '#api/schema/input-source/$'
import { Catalog } from '#lib/catalog/$'
import { Change } from '#lib/change/$'
import { DateOnly } from '#lib/date-only/$'
import { Grafaid } from '#lib/grafaid'
import { Revision } from '#lib/revision/$'
import { Schema } from '#lib/schema/$'
import { FileSystem } from '@effect/platform/FileSystem'
import { Fs, Json, Path } from '@wollybeard/kit'
import { Effect } from 'effect'

/**
 * Configuration for loading schema from an existing introspection file.
 *
 * This source reads a pre-existing `schema.introspection.json` file from your
 * project root. The file should contain a standard GraphQL introspection query
 * result as defined in the GraphQL specification.
 *
 * This is useful when:
 * - You have an introspection file generated by other tools (GraphQL Codegen, Apollo CLI, etc.)
 * - You want to commit the introspection file to version control
 * - You prefer to manage the introspection process separately
 *
 * The file must be in the standard GraphQL introspection format with a
 * `data.__schema` structure.
 *
 * @see https://spec.graphql.org/draft/#sec-Introspection - GraphQL Introspection spec
 *
 * @example
 * ```ts
 * // Uses default path: ./schema.introspection.json
 * introspectionFile: {}
 *
 * // Custom path
 * introspectionFile: {
 *   path: './graphql/introspection.json'
 * }
 * ```
 */
export interface Options {
  /**
   * Path to the introspection file.
   *
   * @default './schema.introspection.json'
   */
  path?: string
}

export interface Config {
  path: string
}

export const normalizeOptions = (options: Options, projectRoot: string): Config => {
  const config: Config = {
    path: options.path
      ? Path.ensureAbsolute(options.path, projectRoot)
      : Path.join(projectRoot, INTROSPECTION_FILE_NAME),
  }

  return config
}

const INTROSPECTION_FILE_NAME = `schema.introspection.json`

// Removed - path is now part of config

export const read = (
  options: Options,
  projectRoot: string,
): Effect.Effect<Catalog.Unversioned.Unversioned | null, InputSource.InputSourceError, FileSystem> =>
  Effect.gen(function*() {
    const config = normalizeOptions(options, projectRoot)
    const fs = yield* FileSystem

    // Check if introspection file exists
    const exists = yield* Effect.either(fs.exists(config.path))
    if (exists._tag === 'Left' || !exists.right) {
      return null
    }

    const introspectionFileContent = yield* fs.readFileString(config.path).pipe(
      Effect.mapError((error) =>
        new InputSource.InputSourceError({
          source: 'introspectionFile',
          message: `Failed to read file ${config.path}: ${error}`,
          cause: error,
        })
      ),
    )

    let schema: Grafaid.Schema.Schema

    const introspectionData = yield* Effect.try({
      try: () => Json.codec.decode(introspectionFileContent),
      catch: (error) => {
        if (error instanceof SyntaxError) {
          return new InputSource.InputSourceError(
            {
              source: 'introspectionFile',
              message: `Invalid JSON in ${config.path}: ${error.message}`,
              cause: error,
            },
          )
        }
        return new InputSource.InputSourceError(
          {
            source: 'introspectionFile',
            message: `Failed to parse JSON in ${config.path}: ${error}`,
            cause: error,
          },
        )
      },
    })

    // Validate introspection data structure before passing to fromIntrospectionQuery
    if (!introspectionData || typeof introspectionData !== 'object') {
      return yield* Effect.fail(
        new InputSource.InputSourceError({
          source: 'introspectionFile',
          message: 'Introspection data must be a valid JSON object',
        }),
      )
    }

    // Allow fromIntrospectionQuery to handle validation of the introspection format
    // It will provide more specific GraphQL-related error messages
    if (!('data' in introspectionData)) {
      return yield* Effect.fail(
        new InputSource.InputSourceError({
          source: 'introspectionFile',
          message: 'Introspection data missing required "data" property (expected GraphQL introspection result format)',
        }),
      )
    }

    schema = Grafaid.Schema.fromIntrospectionQuery(introspectionData as any)

    return yield* createCatalogFromSchema(schema)
  })

/**
 * Create a catalog from a schema object.
 * This is the core logic for handling single (unversioned) schemas from introspection.
 */
const createCatalogFromSchema = (
  schemaData: Grafaid.Schema.Schema,
): Effect.Effect<Catalog.Unversioned.Unversioned, InputSource.InputSourceError> =>
  Effect.gen(function*() {
    const date = new Date()
    const dateString = date.toISOString().split('T')[0]!
    const after = schemaData
    const before = Grafaid.Schema.empty
    const changes = yield* Change.calcChangeset({
      before,
      after,
    }).pipe(
      Effect.mapError((error) =>
        new InputSource.InputSourceError({
          source: 'introspectionFile',
          message: `Failed to calculate changeset: ${error}`,
          cause: error,
        })
      ),
    )

    const revision = Revision.make({
      date: DateOnly.make(dateString),
      changes,
    })

    // Create unversioned schema
    const schema = Schema.Unversioned.make({
      revisions: [revision],
      definition: after, // GraphQLSchema object
    })

    // Return catalog
    return Catalog.Unversioned.make({
      schema,
    })
  })

export const loader = InputSource.createEffect({
  name: 'introspectionFile',
  isApplicable: (options: Options, context) =>
    Effect.gen(function*() {
      // Check if the introspection file exists
      const normalizedConfig = normalizeOptions(options, context.paths.project.rootDir)
      const fs = yield* FileSystem
      const exists = yield* Effect.either(fs.exists(normalizedConfig.path))
      return exists._tag === 'Right' && exists.right
    }),
  readIfApplicableOrThrow: (options: Options, context) => read(options, context.paths.project.rootDir),
})
