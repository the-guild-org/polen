var __create = Object.create,
  __defProp$1 = Object.defineProperty,
  __getOwnPropDesc = Object.getOwnPropertyDescriptor,
  __getOwnPropNames = Object.getOwnPropertyNames,
  __getProtoOf = Object.getPrototypeOf,
  __hasOwnProp = Object.prototype.hasOwnProperty,
  __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports),
  __export = (target, all$8) => {
    for (var name in all$8) __defProp$1(target, name, { get: all$8[name], enumerable: !0 })
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == `object` || typeof from == `function`) {
      for (var keys$6 = __getOwnPropNames(from), i$14 = 0, n$19 = keys$6.length, key$1; i$14 < n$19; i$14++) {
        key$1 = keys$6[i$14],
          !__hasOwnProp.call(to, key$1) && key$1 !== except
          && __defProp$1(to, key$1, {
            get: (k$1 => from[k$1]).bind(null, key$1),
            enumerable: !(desc = __getOwnPropDesc(from, key$1)) || desc.enumerable,
          })
      }
    }
    return to
  },
  __toESM = (
    mod,
    isNodeMode,
    target,
  ) => (target = mod == null ? {} : __create(__getProtoOf(mod)),
    __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, `default`, { value: mod, enumerable: !0 }) : target,
      mod,
    )),
  __toDynamicImportESM = isNodeMode => mod => __toESM(mod.default, isNodeMode),
  require_react_jsx_runtime_production = __commonJSMin(exports => {
    var REACT_ELEMENT_TYPE$2 = Symbol.for(`react.transitional.element`),
      REACT_FRAGMENT_TYPE$2 = Symbol.for(`react.fragment`)
    function jsxProd(type$2, config, maybeKey) {
      var key$1 = null
      if (
        maybeKey !== void 0 && (key$1 = `` + maybeKey),
          config.key !== void 0 && (key$1 = `` + config.key),
          `key` in config
      ) for (var propName in maybeKey = {}, config) propName !== `key` && (maybeKey[propName] = config[propName])
      else maybeKey = config
      return config = maybeKey.ref, {
        $$typeof: REACT_ELEMENT_TYPE$2,
        type: type$2,
        key: key$1,
        ref: config === void 0 ? null : config,
        props: maybeKey,
      }
    }
    exports.Fragment = REACT_FRAGMENT_TYPE$2, exports.jsx = jsxProd, exports.jsxs = jsxProd
  }),
  require_jsx_runtime = __commonJSMin((exports, module) => {
    module.exports = require_react_jsx_runtime_production()
  }),
  require_scheduler_production = __commonJSMin(exports => {
    function push$2(heap, node$1) {
      var index$4 = heap.length
      heap.push(node$1)
      a: for (; 0 < index$4;) {
        var parentIndex = index$4 - 1 >>> 1, parent = heap[parentIndex]
        if (0 < compare$1(parent, node$1)) heap[parentIndex] = node$1, heap[index$4] = parent, index$4 = parentIndex
        else break a
      }
    }
    function peek(heap) {
      return heap.length === 0 ? null : heap[0]
    }
    function pop$1(heap) {
      if (heap.length === 0) return null
      var first$2 = heap[0], last$3 = heap.pop()
      if (last$3 !== first$2) {
        heap[0] = last$3
        a: for (var index$4 = 0, length$1 = heap.length, halfLength = length$1 >>> 1; index$4 < halfLength;) {
          var leftIndex = 2 * (index$4 + 1) - 1,
            left$2 = heap[leftIndex],
            rightIndex = leftIndex + 1,
            right$2 = heap[rightIndex]
          if (0 > compare$1(left$2, last$3)) {
            rightIndex < length$1 && 0 > compare$1(right$2, left$2)
              ? (heap[index$4] = right$2, heap[rightIndex] = last$3, index$4 = rightIndex)
              : (heap[index$4] = left$2, heap[leftIndex] = last$3, index$4 = leftIndex)
          } else if (rightIndex < length$1 && 0 > compare$1(right$2, last$3)) {
            heap[index$4] = right$2, heap[rightIndex] = last$3, index$4 = rightIndex
          } else break a
        }
      }
      return first$2
    }
    function compare$1(a$22, b$3) {
      var diff$10 = a$22.sortIndex - b$3.sortIndex
      return diff$10 === 0 ? a$22.id - b$3.id : diff$10
    }
    if (typeof performance == `object` && typeof performance.now == `function`) {
      var localPerformance = performance
      exports.unstable_now = function() {
        return localPerformance.now()
      }
    } else {
      var localDate = Date, initialTime = localDate.now()
      exports.unstable_now = function() {
        return localDate.now() - initialTime
      }
    }
    var taskQueue = [],
      timerQueue = [],
      taskIdCounter = 1,
      currentTask = null,
      currentPriorityLevel = 3,
      isPerformingWork = !1,
      isHostCallbackScheduled = !1,
      isHostTimeoutScheduled = !1,
      needsPaint = !1,
      localSetTimeout = typeof setTimeout == `function` ? setTimeout : null,
      localClearTimeout = typeof clearTimeout == `function` ? clearTimeout : null,
      localSetImmediate = typeof setImmediate < `u` ? setImmediate : null
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); timer !== null;) {
        if (timer.callback === null) pop$1(timerQueue)
        else if (timer.startTime <= currentTime) {
          pop$1(timerQueue), timer.sortIndex = timer.expirationTime, push$2(taskQueue, timer)
        } else break
        timer = peek(timerQueue)
      }
    }
    function handleTimeout(currentTime) {
      if (isHostTimeoutScheduled = !1, advanceTimers(currentTime), !isHostCallbackScheduled) {
        if (peek(taskQueue) !== null) {
          isHostCallbackScheduled = !0,
            isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline())
        } else {
          var firstTimer = peek(timerQueue)
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime)
        }
      }
    }
    var isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1
    function shouldYieldToHost() {
      return needsPaint ? !0 : exports.unstable_now() - startTime < frameInterval ? !1 : !0
    }
    function performWorkUntilDeadline() {
      if (needsPaint = !1, isMessageLoopRunning) {
        var currentTime = exports.unstable_now()
        startTime = currentTime
        var hasMoreWork = !0
        try {
          a: {
            isHostCallbackScheduled = !1,
              isHostTimeoutScheduled
              && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1),
              isPerformingWork = !0
            var previousPriorityLevel = currentPriorityLevel
            try {
              b: {
                for (
                  advanceTimers(currentTime), currentTask = peek(taskQueue);
                  currentTask !== null && !(currentTask.expirationTime > currentTime && shouldYieldToHost());
                ) {
                  var callback = currentTask.callback
                  if (typeof callback == `function`) {
                    currentTask.callback = null, currentPriorityLevel = currentTask.priorityLevel
                    var continuationCallback = callback(currentTask.expirationTime <= currentTime)
                    if (currentTime = exports.unstable_now(), typeof continuationCallback == `function`) {
                      currentTask.callback = continuationCallback, advanceTimers(currentTime), hasMoreWork = !0
                      break b
                    }
                    currentTask === peek(taskQueue) && pop$1(taskQueue), advanceTimers(currentTime)
                  } else pop$1(taskQueue)
                  currentTask = peek(taskQueue)
                }
                if (currentTask !== null) hasMoreWork = !0
                else {
                  var firstTimer = peek(timerQueue)
                  firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime),
                    hasMoreWork = !1
                }
              }
              break a
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1
            }
            hasMoreWork = void 0
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1
        }
      }
    }
    var schedulePerformWorkUntilDeadline
    if (typeof localSetImmediate == `function`) {
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline)
      }
    } else if (typeof MessageChannel < `u`) {
      var channel = new MessageChannel(), port = channel.port2
      channel.port1.onmessage = performWorkUntilDeadline,
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null)
        }
    } else {schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0)
      }}
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now())
      }, ms)
    }
    exports.unstable_IdlePriority = 5,
      exports.unstable_ImmediatePriority = 1,
      exports.unstable_LowPriority = 4,
      exports.unstable_NormalPriority = 3,
      exports.unstable_Profiling = null,
      exports.unstable_UserBlockingPriority = 2,
      exports.unstable_cancelCallback = function(task) {
        task.callback = null
      },
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps
          ? console.error(
            `forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported`,
          )
          : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5
      },
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel
      },
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3
            break
          default:
            priorityLevel = currentPriorityLevel
        }
        var previousPriorityLevel = currentPriorityLevel
        currentPriorityLevel = priorityLevel
        try {
          return eventHandler()
        } finally {
          currentPriorityLevel = previousPriorityLevel
        }
      },
      exports.unstable_requestPaint = function() {
        needsPaint = !0
      },
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break
          default:
            priorityLevel = 3
        }
        var previousPriorityLevel = currentPriorityLevel
        currentPriorityLevel = priorityLevel
        try {
          return eventHandler()
        } finally {
          currentPriorityLevel = previousPriorityLevel
        }
      },
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options$2) {
        var currentTime = exports.unstable_now()
        switch (
          typeof options$2 == `object` && options$2
            ? (options$2 = options$2.delay,
              options$2 = typeof options$2 == `number` && 0 < options$2 ? currentTime + options$2 : currentTime)
            : options$2 = currentTime, priorityLevel
        ) {
          case 1:
            var timeout$2 = -1
            break
          case 2:
            timeout$2 = 250
            break
          case 5:
            timeout$2 = 1073741823
            break
          case 4:
            timeout$2 = 1e4
            break
          default:
            timeout$2 = 5e3
        }
        return timeout$2 = options$2 + timeout$2,
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options$2,
            expirationTime: timeout$2,
            sortIndex: -1,
          },
          options$2 > currentTime
            ? (priorityLevel.sortIndex = options$2,
              push$2(timerQueue, priorityLevel),
              peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled
                ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1)
                : isHostTimeoutScheduled = !0,
                requestHostTimeout(handleTimeout, options$2 - currentTime)))
            : (priorityLevel.sortIndex = timeout$2,
              push$2(taskQueue, priorityLevel),
              isHostCallbackScheduled || isPerformingWork
              || (isHostCallbackScheduled = !0,
                isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline()))),
          priorityLevel
      },
      exports.unstable_shouldYield = shouldYieldToHost,
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel
        return function() {
          var previousPriorityLevel = currentPriorityLevel
          currentPriorityLevel = parentPriorityLevel
          try {
            return callback.apply(this, arguments)
          } finally {
            currentPriorityLevel = previousPriorityLevel
          }
        }
      }
  }),
  require_scheduler = __commonJSMin((exports, module) => {
    module.exports = require_scheduler_production()
  }),
  require_react_production = __commonJSMin(exports => {
    var REACT_ELEMENT_TYPE$1 = Symbol.for(`react.transitional.element`),
      REACT_PORTAL_TYPE$2 = Symbol.for(`react.portal`),
      REACT_FRAGMENT_TYPE$1 = Symbol.for(`react.fragment`),
      REACT_STRICT_MODE_TYPE$1 = Symbol.for(`react.strict_mode`),
      REACT_PROFILER_TYPE$1 = Symbol.for(`react.profiler`),
      REACT_CONSUMER_TYPE$1 = Symbol.for(`react.consumer`),
      REACT_CONTEXT_TYPE$1 = Symbol.for(`react.context`),
      REACT_FORWARD_REF_TYPE$1 = Symbol.for(`react.forward_ref`),
      REACT_SUSPENSE_TYPE$1 = Symbol.for(`react.suspense`),
      REACT_MEMO_TYPE$1 = Symbol.for(`react.memo`),
      REACT_LAZY_TYPE$1 = Symbol.for(`react.lazy`),
      MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator
    function getIteratorFn$1(maybeIterable) {
      return typeof maybeIterable != `object` || !maybeIterable
        ? null
        : (maybeIterable = MAYBE_ITERATOR_SYMBOL$1 && maybeIterable[MAYBE_ITERATOR_SYMBOL$1]
          || maybeIterable[`@@iterator`],
          typeof maybeIterable == `function` ? maybeIterable : null)
    }
    var ReactNoopUpdateQueue = {
        isMounted: function() {
          return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {},
      },
      assign$1 = Object.assign,
      emptyObject = {}
    function Component$6(props, context$2, updater) {
      this.props = props,
        this.context = context$2,
        this.refs = emptyObject,
        this.updater = updater || ReactNoopUpdateQueue
    }
    Component$6.prototype.isReactComponent = {},
      Component$6.prototype.setState = function(partialState, callback) {
        if (typeof partialState != `object` && typeof partialState != `function` && partialState != null) {
          throw Error(
            `takes an object of state variables to update or a function which returns an object of state variables.`,
          )
        }
        this.updater.enqueueSetState(this, partialState, callback, `setState`)
      },
      Component$6.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, `forceUpdate`)
      }
    function ComponentDummy() {}
    ComponentDummy.prototype = Component$6.prototype
    function PureComponent(props, context$2, updater) {
      this.props = props,
        this.context = context$2,
        this.refs = emptyObject,
        this.updater = updater || ReactNoopUpdateQueue
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy()
    pureComponentPrototype.constructor = PureComponent,
      assign$1(pureComponentPrototype, Component$6.prototype),
      pureComponentPrototype.isPureReactComponent = !0
    var isArrayImpl$1 = Array.isArray,
      ReactSharedInternals$2 = { H: null, A: null, T: null, S: null, V: null },
      hasOwnProperty$3 = Object.prototype.hasOwnProperty
    function ReactElement(type$2, key$1, self$1, source, owner, props) {
      return self$1 = props.ref,
        { $$typeof: REACT_ELEMENT_TYPE$1, type: type$2, key: key$1, ref: self$1 === void 0 ? null : self$1, props }
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, void 0, void 0, void 0, oldElement.props)
    }
    function isValidElement(object) {
      return typeof object == `object` && !!object && object.$$typeof === REACT_ELEMENT_TYPE$1
    }
    function escape$1(key$1) {
      var escaperLookup = { '=': `=0`, ':': `=2` }
      return `$` + key$1.replace(/[=:]/g, function(match$13) {
        return escaperLookup[match$13]
      })
    }
    var userProvidedKeyEscapeRegex = /\/+/g
    function getElementKey(element$2, index$4) {
      return typeof element$2 == `object` && element$2 && element$2.key != null
        ? escape$1(`` + element$2.key)
        : index$4.toString(36)
    }
    function noop$1$6() {}
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case `fulfilled`:
          return thenable.value
        case `rejected`:
          throw thenable.reason
        default:
          switch (
            typeof thenable.status == `string`
              ? thenable.then(noop$1$6, noop$1$6)
              : (thenable.status = `pending`,
                thenable.then(function(fulfilledValue) {
                  thenable.status === `pending` && (thenable.status = `fulfilled`, thenable.value = fulfilledValue)
                }, function(error) {
                  thenable.status === `pending` && (thenable.status = `rejected`, thenable.reason = error)
                })), thenable.status
          ) {
            case `fulfilled`:
              return thenable.value
            case `rejected`:
              throw thenable.reason
          }
      }
      throw thenable
    }
    function mapIntoArray(children$3, array$3, escapedPrefix, nameSoFar, callback) {
      var type$2 = typeof children$3
      ;(type$2 === `undefined` || type$2 === `boolean`) && (children$3 = null)
      var invokeCallback = !1
      if (children$3 === null) invokeCallback = !0
      else {switch (type$2) {
          case `bigint`:
          case `string`:
          case `number`:
            invokeCallback = !0
            break
          case `object`:
            switch (children$3.$$typeof) {
              case REACT_ELEMENT_TYPE$1:
              case REACT_PORTAL_TYPE$2:
                invokeCallback = !0
                break
              case REACT_LAZY_TYPE$1:
                return invokeCallback = children$3._init,
                  mapIntoArray(invokeCallback(children$3._payload), array$3, escapedPrefix, nameSoFar, callback)
            }
        }}
      if (invokeCallback) {
        return callback = callback(children$3),
          invokeCallback = nameSoFar === `` ? `.` + getElementKey(children$3, 0) : nameSoFar,
          isArrayImpl$1(callback)
            ? (escapedPrefix = ``,
              invokeCallback != null
              && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, `$&/`) + `/`),
              mapIntoArray(callback, array$3, escapedPrefix, ``, function(c$3) {
                return c$3
              }))
            : callback != null
              && (isValidElement(callback)
                && (callback = cloneAndReplaceKey(
                  callback,
                  escapedPrefix + (callback.key == null || children$3 && children$3.key === callback.key
                    ? ``
                    : (`` + callback.key).replace(userProvidedKeyEscapeRegex, `$&/`) + `/`)
                    + invokeCallback,
                )),
                array$3.push(callback)),
          1
      }
      invokeCallback = 0
      var nextNamePrefix = nameSoFar === `` ? `.` : nameSoFar + `:`
      if (isArrayImpl$1(children$3)) {
        for (var i$14 = 0; i$14 < children$3.length; i$14++) {
          nameSoFar = children$3[i$14],
            type$2 = nextNamePrefix + getElementKey(nameSoFar, i$14),
            invokeCallback += mapIntoArray(nameSoFar, array$3, escapedPrefix, type$2, callback)
        }
      } else if (i$14 = getIteratorFn$1(children$3), typeof i$14 == `function`) {
        for (children$3 = i$14.call(children$3), i$14 = 0; !(nameSoFar = children$3.next()).done;) {
          nameSoFar = nameSoFar.value,
            type$2 = nextNamePrefix + getElementKey(nameSoFar, i$14++),
            invokeCallback += mapIntoArray(nameSoFar, array$3, escapedPrefix, type$2, callback)
        }
      } else if (type$2 === `object`) {
        if (typeof children$3.then == `function`) {
          return mapIntoArray(resolveThenable(children$3), array$3, escapedPrefix, nameSoFar, callback)
        }
        throw array$3 = String(children$3),
          Error(
            `Objects are not valid as a React child (found: ` + (array$3 === `[object Object]`
              ? `object with keys {` + Object.keys(children$3).join(`, `) + `}`
              : array$3)
              + `). If you meant to render a collection of children, use an array instead.`,
          )
      }
      return invokeCallback
    }
    function mapChildren(children$3, func, context$2) {
      if (children$3 == null) return children$3
      var result = [], count$2 = 0
      return mapIntoArray(children$3, result, ``, ``, function(child) {
        return func.call(context$2, child, count$2++)
      }),
        result
    }
    function lazyInitializer(payload) {
      if (payload._status === -1) {
        var ctor = payload._result
        ctor = ctor(),
          ctor.then(function(moduleObject) {
            ;(payload._status === 0 || payload._status === -1) && (payload._status = 1, payload._result = moduleObject)
          }, function(error) {
            ;(payload._status === 0 || payload._status === -1) && (payload._status = 2, payload._result = error)
          }),
          payload._status === -1 && (payload._status = 0, payload._result = ctor)
      }
      if (payload._status === 1) return payload._result.default
      throw payload._result
    }
    var reportGlobalError$1 = typeof reportError == `function` ? reportError : function(error) {
      if (typeof window == `object` && typeof window.ErrorEvent == `function`) {
        var event = new window.ErrorEvent(`error`, {
          bubbles: !0,
          cancelable: !0,
          message: typeof error == `object` && error && typeof error.message == `string`
            ? String(error.message)
            : String(error),
          error,
        })
        if (!window.dispatchEvent(event)) return
      } else if (typeof process == `object` && typeof process.emit == `function`) {
        process.emit(`uncaughtException`, error)
        return
      }
      console.error(error)
    }
    function noop$7() {}
    exports.Children = {
      map: mapChildren,
      forEach: function(children$3, forEachFunc, forEachContext) {
        mapChildren(children$3, function() {
          forEachFunc.apply(this, arguments)
        }, forEachContext)
      },
      count: function(children$3) {
        var n$19 = 0
        return mapChildren(children$3, function() {
          n$19++
        }),
          n$19
      },
      toArray: function(children$3) {
        return mapChildren(children$3, function(child) {
          return child
        }) || []
      },
      only: function(children$3) {
        if (!isValidElement(children$3)) {
          throw Error(`React.Children.only expected to receive a single React element child.`)
        }
        return children$3
      },
    },
      exports.Component = Component$6,
      exports.Fragment = REACT_FRAGMENT_TYPE$1,
      exports.Profiler = REACT_PROFILER_TYPE$1,
      exports.PureComponent = PureComponent,
      exports.StrictMode = REACT_STRICT_MODE_TYPE$1,
      exports.Suspense = REACT_SUSPENSE_TYPE$1,
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals$2,
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size$14) {
          return ReactSharedInternals$2.H.useMemoCache(size$14)
        },
      },
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments)
        }
      },
      exports.cloneElement = function(element$2, config, children$3) {
        if (element$2 == null) throw Error(`The argument must be a React element, but you passed ` + element$2 + `.`)
        var props = assign$1({}, element$2.props), key$1 = element$2.key, owner = void 0
        if (config != null) {
          for (
            propName in config.ref !== void 0 && (owner = void 0),
              config.key !== void 0 && (key$1 = `` + config.key),
              config
          ) {
            !hasOwnProperty$3.call(config, propName) || propName === `key` || propName === `__self`
              || propName === `__source` || propName === `ref` && config.ref === void 0
              || (props[propName] = config[propName])
          }
        }
        var propName = arguments.length - 2
        if (propName === 1) props.children = children$3
        else if (1 < propName) {
          for (var childArray = Array(propName), i$14 = 0; i$14 < propName; i$14++) {
            childArray[i$14] = arguments[i$14 + 2]
          }
          props.children = childArray
        }
        return ReactElement(element$2.type, key$1, void 0, void 0, owner, props)
      },
      exports.createContext = function(defaultValue) {
        return defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE$1,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        },
          defaultValue.Provider = defaultValue,
          defaultValue.Consumer = { $$typeof: REACT_CONSUMER_TYPE$1, _context: defaultValue },
          defaultValue
      },
      exports.createElement = function(type$2, config, children$3) {
        var propName, props = {}, key$1 = null
        if (config != null) {
          for (propName in config.key !== void 0 && (key$1 = `` + config.key), config) {
            hasOwnProperty$3.call(config, propName) && propName !== `key` && propName !== `__self`
              && propName !== `__source` && (props[propName] = config[propName])
          }
        }
        var childrenLength = arguments.length - 2
        if (childrenLength === 1) props.children = children$3
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i$14 = 0; i$14 < childrenLength; i$14++) {
            childArray[i$14] = arguments[i$14 + 2]
          }
          props.children = childArray
        }
        if (type$2 && type$2.defaultProps) {
          for (propName in childrenLength = type$2.defaultProps, childrenLength) {
            props[propName] === void 0 && (props[propName] = childrenLength[propName])
          }
        }
        return ReactElement(type$2, key$1, void 0, void 0, null, props)
      },
      exports.createRef = function() {
        return { current: null }
      },
      exports.forwardRef = function(render$3) {
        return { $$typeof: REACT_FORWARD_REF_TYPE$1, render: render$3 }
      },
      exports.isValidElement = isValidElement,
      exports.lazy = function(ctor) {
        return { $$typeof: REACT_LAZY_TYPE$1, _payload: { _status: -1, _result: ctor }, _init: lazyInitializer }
      },
      exports.memo = function(type$2, compare$2) {
        return { $$typeof: REACT_MEMO_TYPE$1, type: type$2, compare: compare$2 === void 0 ? null : compare$2 }
      },
      exports.startTransition = function(scope$2) {
        var prevTransition = ReactSharedInternals$2.T, currentTransition = {}
        ReactSharedInternals$2.T = currentTransition
        try {
          var returnValue = scope$2(), onStartTransitionFinish = ReactSharedInternals$2.S
          onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue),
            typeof returnValue == `object` && returnValue && typeof returnValue.then == `function`
            && returnValue.then(noop$7, reportGlobalError$1)
        } catch (error) {
          reportGlobalError$1(error)
        } finally {
          ReactSharedInternals$2.T = prevTransition
        }
      },
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals$2.H.useCacheRefresh()
      },
      exports.use = function(usable) {
        return ReactSharedInternals$2.H.use(usable)
      },
      exports.useActionState = function(action, initialState$1, permalink) {
        return ReactSharedInternals$2.H.useActionState(action, initialState$1, permalink)
      },
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals$2.H.useCallback(callback, deps)
      },
      exports.useContext = function(Context) {
        return ReactSharedInternals$2.H.useContext(Context)
      },
      exports.useDebugValue = function() {},
      exports.useDeferredValue = function(value$2, initialValue) {
        return ReactSharedInternals$2.H.useDeferredValue(value$2, initialValue)
      },
      exports.useEffect = function(create$2, createDeps, update$5) {
        var dispatcher = ReactSharedInternals$2.H
        if (typeof update$5 == `function`) throw Error(`useEffect CRUD overload is not enabled in this build of React.`)
        return dispatcher.useEffect(create$2, createDeps)
      },
      exports.useId = function() {
        return ReactSharedInternals$2.H.useId()
      },
      exports.useImperativeHandle = function(ref, create$2, deps) {
        return ReactSharedInternals$2.H.useImperativeHandle(ref, create$2, deps)
      },
      exports.useInsertionEffect = function(create$2, deps) {
        return ReactSharedInternals$2.H.useInsertionEffect(create$2, deps)
      },
      exports.useLayoutEffect = function(create$2, deps) {
        return ReactSharedInternals$2.H.useLayoutEffect(create$2, deps)
      },
      exports.useMemo = function(create$2, deps) {
        return ReactSharedInternals$2.H.useMemo(create$2, deps)
      },
      exports.useOptimistic = function(passthrough$1, reducer) {
        return ReactSharedInternals$2.H.useOptimistic(passthrough$1, reducer)
      },
      exports.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals$2.H.useReducer(reducer, initialArg, init)
      },
      exports.useRef = function(initialValue) {
        return ReactSharedInternals$2.H.useRef(initialValue)
      },
      exports.useState = function(initialState$1) {
        return ReactSharedInternals$2.H.useState(initialState$1)
      },
      exports.useSyncExternalStore = function(subscribe$1, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals$2.H.useSyncExternalStore(subscribe$1, getSnapshot, getServerSnapshot)
      },
      exports.useTransition = function() {
        return ReactSharedInternals$2.H.useTransition()
      },
      exports.version = `19.1.0`
  }),
  require_react = __commonJSMin((exports, module) => {
    module.exports = require_react_production()
  }),
  require_react_dom_production = __commonJSMin(exports => {
    var React$4 = require_react()
    function formatProdErrorMessage$1(code$3) {
      var url = `https://react.dev/errors/` + code$3
      if (1 < arguments.length) {
        url += `?args[]=` + encodeURIComponent(arguments[1])
        for (var i$14 = 2; i$14 < arguments.length; i$14++) url += `&args[]=` + encodeURIComponent(arguments[i$14])
      }
      return `Minified React error #` + code$3 + `; visit ` + url
        + ` for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
    }
    function noop$5() {}
    var Internals = {
        d: {
          f: noop$5,
          r: function() {
            throw Error(formatProdErrorMessage$1(522))
          },
          D: noop$5,
          C: noop$5,
          L: noop$5,
          m: noop$5,
          X: noop$5,
          S: noop$5,
          M: noop$5,
        },
        p: 0,
        findDOMNode: null,
      },
      REACT_PORTAL_TYPE$1 = Symbol.for(`react.portal`)
    function createPortal$1(children$3, containerInfo, implementation) {
      var key$1 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
      return {
        $$typeof: REACT_PORTAL_TYPE$1,
        key: key$1 == null ? null : `` + key$1,
        children: children$3,
        containerInfo,
        implementation,
      }
    }
    var ReactSharedInternals$1 = React$4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
    function getCrossOriginStringAs(as$6, input) {
      if (as$6 === `font`) return ``
      if (typeof input == `string`) return input === `use-credentials` ? input : ``
    }
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals,
      exports.createPortal = function(children$3, container) {
        var key$1 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
        if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11) {
          throw Error(formatProdErrorMessage$1(299))
        }
        return createPortal$1(children$3, container, null, key$1)
      },
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals$1.T, previousUpdatePriority = Internals.p
        try {
          if (ReactSharedInternals$1.T = null, Internals.p = 2, fn) return fn()
        } finally {
          ReactSharedInternals$1.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f()
        }
      },
      exports.preconnect = function(href, options$2) {
        typeof href == `string`
          && (options$2
            ? (options$2 = options$2.crossOrigin,
              options$2 = typeof options$2 == `string` ? options$2 === `use-credentials` ? options$2 : `` : void 0)
            : options$2 = null,
            Internals.d.C(href, options$2))
      },
      exports.prefetchDNS = function(href) {
        typeof href == `string` && Internals.d.D(href)
      },
      exports.preinit = function(href, options$2) {
        if (typeof href == `string` && options$2 && typeof options$2.as == `string`) {
          var as$6 = options$2.as,
            crossOrigin = getCrossOriginStringAs(as$6, options$2.crossOrigin),
            integrity = typeof options$2.integrity == `string` ? options$2.integrity : void 0,
            fetchPriority = typeof options$2.fetchPriority == `string` ? options$2.fetchPriority : void 0
          as$6 === `style`
            ? Internals.d.S(href, typeof options$2.precedence == `string` ? options$2.precedence : void 0, {
              crossOrigin,
              integrity,
              fetchPriority,
            })
            : as$6 === `script`
              && Internals.d.X(href, {
                crossOrigin,
                integrity,
                fetchPriority,
                nonce: typeof options$2.nonce == `string` ? options$2.nonce : void 0,
              })
        }
      },
      exports.preinitModule = function(href, options$2) {
        if (typeof href == `string`) {
          if (typeof options$2 == `object` && options$2) {
            if (options$2.as == null || options$2.as === `script`) {
              var crossOrigin = getCrossOriginStringAs(options$2.as, options$2.crossOrigin)
              Internals.d.M(href, {
                crossOrigin,
                integrity: typeof options$2.integrity == `string` ? options$2.integrity : void 0,
                nonce: typeof options$2.nonce == `string` ? options$2.nonce : void 0,
              })
            }
          } else options$2 ?? Internals.d.M(href)
        }
      },
      exports.preload = function(href, options$2) {
        if (typeof href == `string` && typeof options$2 == `object` && options$2 && typeof options$2.as == `string`) {
          var as$6 = options$2.as, crossOrigin = getCrossOriginStringAs(as$6, options$2.crossOrigin)
          Internals.d.L(href, as$6, {
            crossOrigin,
            integrity: typeof options$2.integrity == `string` ? options$2.integrity : void 0,
            nonce: typeof options$2.nonce == `string` ? options$2.nonce : void 0,
            type: typeof options$2.type == `string` ? options$2.type : void 0,
            fetchPriority: typeof options$2.fetchPriority == `string` ? options$2.fetchPriority : void 0,
            referrerPolicy: typeof options$2.referrerPolicy == `string` ? options$2.referrerPolicy : void 0,
            imageSrcSet: typeof options$2.imageSrcSet == `string` ? options$2.imageSrcSet : void 0,
            imageSizes: typeof options$2.imageSizes == `string` ? options$2.imageSizes : void 0,
            media: typeof options$2.media == `string` ? options$2.media : void 0,
          })
        }
      },
      exports.preloadModule = function(href, options$2) {
        if (typeof href == `string`) {
          if (options$2) {
            var crossOrigin = getCrossOriginStringAs(options$2.as, options$2.crossOrigin)
            Internals.d.m(href, {
              as: typeof options$2.as == `string` && options$2.as !== `script` ? options$2.as : void 0,
              crossOrigin,
              integrity: typeof options$2.integrity == `string` ? options$2.integrity : void 0,
            })
          } else Internals.d.m(href)
        }
      },
      exports.requestFormReset = function(form) {
        Internals.d.r(form)
      },
      exports.unstable_batchedUpdates = function(fn, a$22) {
        return fn(a$22)
      },
      exports.useFormState = function(action, initialState$1, permalink) {
        return ReactSharedInternals$1.H.useFormState(action, initialState$1, permalink)
      },
      exports.useFormStatus = function() {
        return ReactSharedInternals$1.H.useHostTransitionStatus()
      },
      exports.version = `19.1.0`
  }),
  require_react_dom = __commonJSMin((exports, module) => {
    function checkDCE$1() {
      if (
        !(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > `u` || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != `function`)
      ) {
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1)
        } catch (err) {
          console.error(err)
        }
      }
    }
    checkDCE$1(), module.exports = require_react_dom_production()
  }),
  require_react_dom_client_production = __commonJSMin(exports => {
    var Scheduler = require_scheduler(), React$3 = require_react(), ReactDOM$1 = require_react_dom()
    function formatProdErrorMessage(code$3) {
      var url = `https://react.dev/errors/` + code$3
      if (1 < arguments.length) {
        url += `?args[]=` + encodeURIComponent(arguments[1])
        for (var i$14 = 2; i$14 < arguments.length; i$14++) url += `&args[]=` + encodeURIComponent(arguments[i$14])
      }
      return `Minified React error #` + code$3 + `; visit ` + url
        + ` for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`
    }
    function isValidContainer(node$1) {
      return !(!node$1 || node$1.nodeType !== 1 && node$1.nodeType !== 9 && node$1.nodeType !== 11)
    }
    function getNearestMountedFiber(fiber) {
      var node$1 = fiber, nearestMounted = fiber
      if (fiber.alternate) for (; node$1.return;) node$1 = node$1.return
      else {
        fiber = node$1
        do node$1 = fiber, node$1.flags & 4098 && (nearestMounted = node$1.return), fiber = node$1.return
        while (fiber)
      }
      return node$1.tag === 3 ? nearestMounted : null
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (fiber.tag === 13) {
        var suspenseState = fiber.memoizedState
        if (
          suspenseState === null && (fiber = fiber.alternate, fiber !== null && (suspenseState = fiber.memoizedState)),
            suspenseState !== null
        ) return suspenseState.dehydrated
      }
      return null
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber) throw Error(formatProdErrorMessage(188))
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate
      if (!alternate) {
        if (alternate = getNearestMountedFiber(fiber), alternate === null) throw Error(formatProdErrorMessage(188))
        return alternate === fiber ? fiber : null
      }
      for (var a$22 = fiber, b$3 = alternate;;) {
        var parentA = a$22.return
        if (parentA === null) break
        var parentB = parentA.alternate
        if (parentB === null) {
          if (b$3 = parentA.return, b$3 !== null) {
            a$22 = b$3
            continue
          }
          break
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB;) {
            if (parentB === a$22) return assertIsMounted(parentA), fiber
            if (parentB === b$3) return assertIsMounted(parentA), alternate
            parentB = parentB.sibling
          }
          throw Error(formatProdErrorMessage(188))
        }
        if (a$22.return !== b$3.return) a$22 = parentA, b$3 = parentB
        else {
          for (var didFindChild = !1, child$0 = parentA.child; child$0;) {
            if (child$0 === a$22) {
              didFindChild = !0, a$22 = parentA, b$3 = parentB
              break
            }
            if (child$0 === b$3) {
              didFindChild = !0, b$3 = parentA, a$22 = parentB
              break
            }
            child$0 = child$0.sibling
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0;) {
              if (child$0 === a$22) {
                didFindChild = !0, a$22 = parentB, b$3 = parentA
                break
              }
              if (child$0 === b$3) {
                didFindChild = !0, b$3 = parentB, a$22 = parentA
                break
              }
              child$0 = child$0.sibling
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189))
          }
        }
        if (a$22.alternate !== b$3) throw Error(formatProdErrorMessage(190))
      }
      if (a$22.tag !== 3) throw Error(formatProdErrorMessage(188))
      return a$22.stateNode.current === a$22 ? fiber : alternate
    }
    function findCurrentHostFiberImpl(node$1) {
      var tag$3 = node$1.tag
      if (tag$3 === 5 || tag$3 === 26 || tag$3 === 27 || tag$3 === 6) return node$1
      for (node$1 = node$1.child; node$1 !== null;) {
        if (tag$3 = findCurrentHostFiberImpl(node$1), tag$3 !== null) return tag$3
        node$1 = node$1.sibling
      }
      return null
    }
    var assign = Object.assign,
      REACT_LEGACY_ELEMENT_TYPE = Symbol.for(`react.element`),
      REACT_ELEMENT_TYPE = Symbol.for(`react.transitional.element`),
      REACT_PORTAL_TYPE = Symbol.for(`react.portal`),
      REACT_FRAGMENT_TYPE = Symbol.for(`react.fragment`),
      REACT_STRICT_MODE_TYPE = Symbol.for(`react.strict_mode`),
      REACT_PROFILER_TYPE = Symbol.for(`react.profiler`),
      REACT_PROVIDER_TYPE = Symbol.for(`react.provider`),
      REACT_CONSUMER_TYPE = Symbol.for(`react.consumer`),
      REACT_CONTEXT_TYPE = Symbol.for(`react.context`),
      REACT_FORWARD_REF_TYPE = Symbol.for(`react.forward_ref`),
      REACT_SUSPENSE_TYPE = Symbol.for(`react.suspense`),
      REACT_SUSPENSE_LIST_TYPE = Symbol.for(`react.suspense_list`),
      REACT_MEMO_TYPE = Symbol.for(`react.memo`),
      REACT_LAZY_TYPE = Symbol.for(`react.lazy`)
    Symbol.for(`react.scope`)
    var REACT_ACTIVITY_TYPE = Symbol.for(`react.activity`)
    Symbol.for(`react.legacy_hidden`), Symbol.for(`react.tracing_marker`)
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(`react.memo_cache_sentinel`)
    Symbol.for(`react.view_transition`)
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
    function getIteratorFn(maybeIterable) {
      return typeof maybeIterable != `object` || !maybeIterable
        ? null
        : (maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[`@@iterator`],
          typeof maybeIterable == `function` ? maybeIterable : null)
    }
    var REACT_CLIENT_REFERENCE = Symbol.for(`react.client.reference`)
    function getComponentNameFromType(type$2) {
      if (type$2 == null) return null
      if (typeof type$2 == `function`) {
        return type$2.$$typeof === REACT_CLIENT_REFERENCE
          ? null
          : type$2.displayName || type$2.name || null
      }
      if (typeof type$2 == `string`) return type$2
      switch (type$2) {
        case REACT_FRAGMENT_TYPE:
          return `Fragment`
        case REACT_PROFILER_TYPE:
          return `Profiler`
        case REACT_STRICT_MODE_TYPE:
          return `StrictMode`
        case REACT_SUSPENSE_TYPE:
          return `Suspense`
        case REACT_SUSPENSE_LIST_TYPE:
          return `SuspenseList`
        case REACT_ACTIVITY_TYPE:
          return `Activity`
      }
      if (typeof type$2 == `object`) {
        switch (type$2.$$typeof) {
          case REACT_PORTAL_TYPE:
            return `Portal`
          case REACT_CONTEXT_TYPE:
            return (type$2.displayName || `Context`) + `.Provider`
          case REACT_CONSUMER_TYPE:
            return (type$2._context.displayName || `Context`) + `.Consumer`
          case REACT_FORWARD_REF_TYPE:
            var innerType = type$2.render
            return type$2 = type$2.displayName,
              type$2
              || (type$2 = innerType.displayName || innerType.name || ``,
                type$2 = type$2 === `` ? `ForwardRef` : `ForwardRef(` + type$2 + `)`),
              type$2
          case REACT_MEMO_TYPE:
            return innerType = type$2.displayName || null,
              innerType === null ? getComponentNameFromType(type$2.type) || `Memo` : innerType
          case REACT_LAZY_TYPE:
            innerType = type$2._payload, type$2 = type$2._init
            try {
              return getComponentNameFromType(type$2(innerType))
            } catch {}
        }
      }
      return null
    }
    var isArrayImpl = Array.isArray,
      ReactSharedInternals = React$3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      ReactDOMSharedInternals = ReactDOM$1.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      sharedNotPendingObject = { pending: !1, data: null, method: null, action: null },
      valueStack = [],
      index$3 = -1
    function createCursor(defaultValue) {
      return { current: defaultValue }
    }
    function pop(cursor) {
      0 > index$3 || (cursor.current = valueStack[index$3], valueStack[index$3] = null, index$3--)
    }
    function push$1(cursor, value$2) {
      index$3++, valueStack[index$3] = cursor.current, cursor.current = value$2
    }
    var contextStackCursor = createCursor(null),
      contextFiberStackCursor = createCursor(null),
      rootInstanceStackCursor = createCursor(null),
      hostTransitionProviderCursor = createCursor(null)
    function pushHostContainer(fiber, nextRootInstance) {
      switch (
        push$1(rootInstanceStackCursor, nextRootInstance),
          push$1(contextFiberStackCursor, fiber),
          push$1(contextStackCursor, null),
          nextRootInstance.nodeType
      ) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement) && (fiber = fiber.namespaceURI)
            ? getOwnHostContext(fiber)
            : 0
          break
        default:
          if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) {
            nextRootInstance = getOwnHostContext(nextRootInstance),
              fiber = getChildHostContextProd(nextRootInstance, fiber)
          } else {switch (fiber) {
              case `svg`:
                fiber = 1
                break
              case `math`:
                fiber = 2
                break
              default:
                fiber = 0
            }}
      }
      pop(contextStackCursor), push$1(contextStackCursor, fiber)
    }
    function popHostContainer() {
      pop(contextStackCursor), pop(contextFiberStackCursor), pop(rootInstanceStackCursor)
    }
    function pushHostContext(fiber) {
      fiber.memoizedState !== null && push$1(hostTransitionProviderCursor, fiber)
      var context$2 = contextStackCursor.current,
        JSCompiler_inline_result = getChildHostContextProd(context$2, fiber.type)
      context$2 !== JSCompiler_inline_result
        && (push$1(contextFiberStackCursor, fiber), push$1(contextStackCursor, JSCompiler_inline_result))
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor)),
        hostTransitionProviderCursor.current === fiber
        && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject)
    }
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty,
      scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
      cancelCallback$1 = Scheduler.unstable_cancelCallback,
      shouldYield = Scheduler.unstable_shouldYield,
      requestPaint = Scheduler.unstable_requestPaint,
      now = Scheduler.unstable_now,
      getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
      ImmediatePriority = Scheduler.unstable_ImmediatePriority,
      UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
      NormalPriority$1 = Scheduler.unstable_NormalPriority,
      LowPriority = Scheduler.unstable_LowPriority,
      IdlePriority = Scheduler.unstable_IdlePriority,
      log$1$1 = Scheduler.log,
      unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
      rendererID = null,
      injectedHook = null
    function setIsStrictModeForDevtools(newIsStrictMode) {
      if (
        typeof log$1$1 == `function` && unstable_setDisableYieldValue(newIsStrictMode),
          injectedHook && typeof injectedHook.setStrictMode == `function`
      ) {
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode)
        } catch {}
      }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$2 = Math.log, LN2 = Math.LN2
    function clz32Fallback(x$2) {
      return x$2 >>>= 0, x$2 === 0 ? 32 : 31 - (log$2(x$2) / LN2 | 0) | 0
    }
    var nextTransitionLane = 256, nextRetryLane = 4194304
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42
      if (pendingSyncLanes !== 0) return pendingSyncLanes
      switch (lanes & -lanes) {
        case 1:
          return 1
        case 2:
          return 2
        case 4:
          return 4
        case 8:
          return 8
        case 16:
          return 16
        case 32:
          return 32
        case 64:
          return 64
        case 128:
          return 128
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 4194048
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560
        case 67108864:
          return 67108864
        case 134217728:
          return 134217728
        case 268435456:
          return 268435456
        case 536870912:
          return 536870912
        case 1073741824:
          return 0
        default:
          return lanes
      }
    }
    function getNextLanes(root$5, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root$5.pendingLanes
      if (pendingLanes === 0) return 0
      var nextLanes = 0, suspendedLanes = root$5.suspendedLanes, pingedLanes = root$5.pingedLanes
      root$5 = root$5.warmLanes
      var nonIdlePendingLanes = pendingLanes & 134217727
      return nonIdlePendingLanes === 0
        ? (nonIdlePendingLanes = pendingLanes & ~suspendedLanes,
          nonIdlePendingLanes === 0
            ? pingedLanes === 0
              ? rootHasPendingCommit
                || (rootHasPendingCommit = pendingLanes & ~root$5,
                  rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))
              : nextLanes = getHighestPriorityLanes(pingedLanes)
            : nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
        : (pendingLanes = nonIdlePendingLanes & ~suspendedLanes,
          pendingLanes === 0
            ? (pingedLanes &= nonIdlePendingLanes,
              pingedLanes === 0
                ? rootHasPendingCommit
                  || (rootHasPendingCommit = nonIdlePendingLanes & ~root$5,
                    rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))
                : nextLanes = getHighestPriorityLanes(pingedLanes))
            : nextLanes = getHighestPriorityLanes(pendingLanes)),
        nextLanes === 0
          ? 0
          : wipLanes !== 0 && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === 0
              && (suspendedLanes = nextLanes & -nextLanes,
                rootHasPendingCommit = wipLanes & -wipLanes,
                suspendedLanes >= rootHasPendingCommit || suspendedLanes === 32 && rootHasPendingCommit & 4194048)
          ? wipLanes
          : nextLanes
    }
    function checkIfRootIsPrerendering(root$5, renderLanes$1) {
      return (root$5.pendingLanes & ~(root$5.suspendedLanes & ~root$5.pingedLanes) & renderLanes$1) === 0
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1
        default:
          return -1
      }
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane
      return nextTransitionLane <<= 1, !(nextTransitionLane & 4194048) && (nextTransitionLane = 256), lane
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane
      return nextRetryLane <<= 1, !(nextRetryLane & 62914560) && (nextRetryLane = 4194304), lane
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i$14 = 0; 31 > i$14; i$14++) laneMap.push(initial)
      return laneMap
    }
    function markRootUpdated$1(root$5, updateLane) {
      root$5.pendingLanes |= updateLane,
        updateLane !== 268435456 && (root$5.suspendedLanes = 0, root$5.pingedLanes = 0, root$5.warmLanes = 0)
    }
    function markRootFinished(root$5, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root$5.pendingLanes
      root$5.pendingLanes = remainingLanes,
        root$5.suspendedLanes = 0,
        root$5.pingedLanes = 0,
        root$5.warmLanes = 0,
        root$5.expiredLanes &= remainingLanes,
        root$5.entangledLanes &= remainingLanes,
        root$5.errorRecoveryDisabledLanes &= remainingLanes,
        root$5.shellSuspendCounter = 0
      var entanglements = root$5.entanglements,
        expirationTimes = root$5.expirationTimes,
        hiddenUpdates = root$5.hiddenUpdates
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
        var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5
        entanglements[index$5] = 0, expirationTimes[index$5] = -1
        var hiddenUpdatesForLane = hiddenUpdates[index$5]
        if (hiddenUpdatesForLane !== null) {
          for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
            var update$5 = hiddenUpdatesForLane[index$5]
            update$5 !== null && (update$5.lane &= -536870913)
          }
        }
        remainingLanes &= ~lane
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root$5, spawnedLane, 0),
        suspendedRetryLanes !== 0 && updatedLanes === 0 && root$5.tag !== 0
        && (root$5.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes))
    }
    function markSpawnedDeferredLane(root$5, spawnedLane, entangledLanes) {
      root$5.pendingLanes |= spawnedLane, root$5.suspendedLanes &= ~spawnedLane
      var spawnedLaneIndex = 31 - clz32(spawnedLane)
      root$5.entangledLanes |= spawnedLane,
        root$5.entanglements[spawnedLaneIndex] = root$5.entanglements[spawnedLaneIndex] | 1073741824
          | entangledLanes & 4194090
    }
    function markRootEntangled(root$5, entangledLanes) {
      var rootEntangledLanes = root$5.entangledLanes |= entangledLanes
      for (root$5 = root$5.entanglements; rootEntangledLanes;) {
        var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6
        lane & entangledLanes | root$5[index$6] & entangledLanes && (root$5[index$6] |= entangledLanes),
          rootEntangledLanes &= ~lane
      }
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1
          break
        case 8:
          lane = 4
          break
        case 32:
          lane = 16
          break
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128
          break
        case 268435456:
          lane = 134217728
          break
        default:
          lane = 0
      }
      return lane
    }
    function lanesToEventPriority(lanes) {
      return lanes &= -lanes, 2 < lanes ? 8 < lanes ? lanes & 134217727 ? 32 : 268435456 : 8 : 2
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p
      return updatePriority === 0
        ? (updatePriority = window.event, updatePriority === void 0 ? 32 : getEventPriority(updatePriority.type))
        : updatePriority
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p
      try {
        return ReactDOMSharedInternals.p = priority, fn()
      } finally {
        ReactDOMSharedInternals.p = previousPriority
      }
    }
    var randomKey = Math.random().toString(36).slice(2),
      internalInstanceKey = `__reactFiber$` + randomKey,
      internalPropsKey = `__reactProps$` + randomKey,
      internalContainerInstanceKey = `__reactContainer$` + randomKey,
      internalEventHandlersKey = `__reactEvents$` + randomKey,
      internalEventHandlerListenersKey = `__reactListeners$` + randomKey,
      internalEventHandlesSetKey = `__reactHandles$` + randomKey,
      internalRootNodeResourcesKey = `__reactResources$` + randomKey,
      internalHoistableMarker = `__reactMarker$` + randomKey
    function detachDeletedInstance(node$1) {
      delete node$1[internalInstanceKey],
        delete node$1[internalPropsKey],
        delete node$1[internalEventHandlersKey],
        delete node$1[internalEventHandlerListenersKey],
        delete node$1[internalEventHandlesSetKey]
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey]
      if (targetInst) return targetInst
      for (var parentNode = targetNode.parentNode; parentNode;) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          if (
            parentNode = targetInst.alternate,
              targetInst.child !== null || parentNode !== null && parentNode.child !== null
          ) {
            for (targetNode = getParentSuspenseInstance(targetNode); targetNode !== null;) {
              if (parentNode = targetNode[internalInstanceKey]) return parentNode
              targetNode = getParentSuspenseInstance(targetNode)
            }
          }
          return targetInst
        }
        targetNode = parentNode, parentNode = targetNode.parentNode
      }
      return null
    }
    function getInstanceFromNode(node$1) {
      if (node$1 = node$1[internalInstanceKey] || node$1[internalContainerInstanceKey]) {
        var tag$3 = node$1.tag
        if (tag$3 === 5 || tag$3 === 6 || tag$3 === 13 || tag$3 === 26 || tag$3 === 27 || tag$3 === 3) return node$1
      }
      return null
    }
    function getNodeFromInstance(inst) {
      var tag$3 = inst.tag
      if (tag$3 === 5 || tag$3 === 26 || tag$3 === 27 || tag$3 === 6) return inst.stateNode
      throw Error(formatProdErrorMessage(33))
    }
    function getResourcesFromRoot(root$5) {
      var resources = root$5[internalRootNodeResourcesKey]
      return resources ||= root$5[internalRootNodeResourcesKey] = {
        hoistableStyles: new Map(),
        hoistableScripts: new Map(),
      },
        resources
    }
    function markNodeAsHoistable(node$1) {
      node$1[internalHoistableMarker] = !0
    }
    var allNativeEvents = new Set(), registrationNameDependencies = {}
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies),
        registerDirectEvent(registrationName + `Capture`, dependencies)
    }
    function registerDirectEvent(registrationName, dependencies) {
      for (
        registrationNameDependencies[registrationName] = dependencies, registrationName = 0;
        registrationName < dependencies.length;
        registrationName++
      ) allNativeEvents.add(dependencies[registrationName])
    }
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        `^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$`,
      ),
      illegalAttributeNameCache = {},
      validatedAttributeNameCache = {}
    function isAttributeNameSafe(attributeName) {
      return hasOwnProperty$2.call(validatedAttributeNameCache, attributeName)
        ? !0
        : hasOwnProperty$2.call(illegalAttributeNameCache, attributeName)
        ? !1
        : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)
        ? validatedAttributeNameCache[attributeName] = !0
        : (illegalAttributeNameCache[attributeName] = !0, !1)
    }
    function setValueForAttribute(node$1, name, value$2) {
      if (isAttributeNameSafe(name)) {
        if (value$2 === null) node$1.removeAttribute(name)
        else {
          switch (typeof value$2) {
            case `undefined`:
            case `function`:
            case `symbol`:
              node$1.removeAttribute(name)
              return
            case `boolean`:
              var prefix$8 = name.toLowerCase().slice(0, 5)
              if (prefix$8 !== `data-` && prefix$8 !== `aria-`) {
                node$1.removeAttribute(name)
                return
              }
          }
          node$1.setAttribute(name, `` + value$2)
        }
      }
    }
    function setValueForKnownAttribute(node$1, name, value$2) {
      if (value$2 === null) node$1.removeAttribute(name)
      else {
        switch (typeof value$2) {
          case `undefined`:
          case `function`:
          case `symbol`:
          case `boolean`:
            node$1.removeAttribute(name)
            return
        }
        node$1.setAttribute(name, `` + value$2)
      }
    }
    function setValueForNamespacedAttribute(node$1, namespace, name, value$2) {
      if (value$2 === null) node$1.removeAttribute(name)
      else {
        switch (typeof value$2) {
          case `undefined`:
          case `function`:
          case `symbol`:
          case `boolean`:
            node$1.removeAttribute(name)
            return
        }
        node$1.setAttributeNS(namespace, name, `` + value$2)
      }
    }
    var prefix, suffix
    function describeBuiltInComponentFrame(name) {
      if (prefix === void 0) {
        try {
          throw Error()
        } catch (x$2) {
          var match$13 = x$2.stack.trim().match(/\n( *(at )?)/)
          prefix = match$13 && match$13[1] || ``,
            suffix = -1 < x$2.stack.indexOf(`
    at`)
              ? ` (<anonymous>)`
              : -1 < x$2.stack.indexOf(`@`)
              ? `@unknown:0:0`
              : ``
        }
      }
      return `
` + prefix + name + suffix
    }
    var reentry = !1
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return ``
      reentry = !0
      var previousPrepareStackTrace = Error.prepareStackTrace
      Error.prepareStackTrace = void 0
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error()
                }
                if (
                  Object.defineProperty(Fake.prototype, `props`, {
                    set: function() {
                      throw Error()
                    },
                  }), typeof Reflect == `object` && Reflect.construct
                ) {
                  try {
                    Reflect.construct(Fake, [])
                  } catch (x$2) {
                    var control = x$2
                  }
                  Reflect.construct(fn, [], Fake)
                } else {
                  try {
                    Fake.call()
                  } catch (x$9) {
                    control = x$9
                  }
                  fn.call(Fake.prototype)
                }
              } else {
                try {
                  throw Error()
                } catch (x$10) {
                  control = x$10
                }
                ;(Fake = fn()) && typeof Fake.catch == `function` && Fake.catch(function() {})
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack == `string`) return [sample.stack, control.stack]
            }
            return [null, null]
          },
        }
        RunInRootFrame.DetermineComponentFrameRoot.displayName = `DetermineComponentFrameRoot`
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, `name`)
        namePropDescriptor && namePropDescriptor.configurable
          && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, `name`, {
            value: `DetermineComponentFrameRoot`,
          })
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
          sampleStack = _RunInRootFrame$Deter[0],
          controlStack = _RunInRootFrame$Deter[1]
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split(`
`),
            controlLines = controlStack.split(`
`)
          for (
            namePropDescriptor = RunInRootFrame = 0;
            RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes(`DetermineComponentFrameRoot`);
          ) RunInRootFrame++
          for (
            ;
            namePropDescriptor < controlLines.length
            && !controlLines[namePropDescriptor].includes(`DetermineComponentFrameRoot`);
          ) namePropDescriptor++
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) {
            for (
              RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1;
              1 <= RunInRootFrame && 0 <= namePropDescriptor
              && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];
            ) namePropDescriptor--
          }
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) {
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (RunInRootFrame !== 1 || namePropDescriptor !== 1) {
                do if (
                  RunInRootFrame--,
                    namePropDescriptor--,
                    0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]
                ) {
                  var frame = `
` + sampleLines[RunInRootFrame].replace(` at new `, ` at `)
                  return fn.displayName && frame.includes(`<anonymous>`)
                    && (frame = frame.replace(`<anonymous>`, fn.displayName)),
                    frame
                }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor)
              }
              break
            }
          }
        }
      } finally {
        reentry = !1, Error.prepareStackTrace = previousPrepareStackTrace
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : ``)
        ? describeBuiltInComponentFrame(previousPrepareStackTrace)
        : ``
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type)
        case 16:
          return describeBuiltInComponentFrame(`Lazy`)
        case 13:
          return describeBuiltInComponentFrame(`Suspense`)
        case 19:
          return describeBuiltInComponentFrame(`SuspenseList`)
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, !1)
        case 11:
          return describeNativeComponentFrame(fiber.type.render, !1)
        case 1:
          return describeNativeComponentFrame(fiber.type, !0)
        case 31:
          return describeBuiltInComponentFrame(`Activity`)
        default:
          return ``
      }
    }
    function getStackByFiberInDevAndProd(workInProgress$1) {
      try {
        var info = ``
        do info += describeFiber(workInProgress$1), workInProgress$1 = workInProgress$1.return
        while (workInProgress$1)
        return info
      } catch (x$2) {
        return `
Error generating stack: ` + x$2.message + `
` + x$2.stack
      }
    }
    function getToStringValue(value$2) {
      switch (typeof value$2) {
        case `bigint`:
        case `boolean`:
        case `number`:
        case `string`:
        case `undefined`:
          return value$2
        case `object`:
          return value$2
        default:
          return ``
      }
    }
    function isCheckable(elem) {
      var type$2 = elem.type
      return (elem = elem.nodeName) && elem.toLowerCase() === `input` && (type$2 === `checkbox` || type$2 === `radio`)
    }
    function trackValueOnNode(node$1) {
      var valueField = isCheckable(node$1) ? `checked` : `value`,
        descriptor$2 = Object.getOwnPropertyDescriptor(node$1.constructor.prototype, valueField),
        currentValue = `` + node$1[valueField]
      if (
        !node$1.hasOwnProperty(valueField) && descriptor$2 !== void 0 && typeof descriptor$2.get == `function`
        && typeof descriptor$2.set == `function`
      ) {
        var get$12 = descriptor$2.get, set$6 = descriptor$2.set
        return Object.defineProperty(node$1, valueField, {
          configurable: !0,
          get: function() {
            return get$12.call(this)
          },
          set: function(value$2) {
            currentValue = `` + value$2, set$6.call(this, value$2)
          },
        }),
          Object.defineProperty(node$1, valueField, { enumerable: descriptor$2.enumerable }),
          {
            getValue: function() {
              return currentValue
            },
            setValue: function(value$2) {
              currentValue = `` + value$2
            },
            stopTracking: function() {
              node$1._valueTracker = null, delete node$1[valueField]
            },
          }
      }
    }
    function track$1(node$1) {
      node$1._valueTracker ||= trackValueOnNode(node$1)
    }
    function updateValueIfChanged(node$1) {
      if (!node$1) return !1
      var tracker = node$1._valueTracker
      if (!tracker) return !0
      var lastValue = tracker.getValue(), value$2 = ``
      return node$1 && (value$2 = isCheckable(node$1) ? node$1.checked ? `true` : `false` : node$1.value),
        node$1 = value$2,
        node$1 === lastValue ? !1 : (tracker.setValue(node$1), !0)
    }
    function getActiveElement(doc) {
      if (doc ||= typeof document < `u` ? document : void 0, doc === void 0) return null
      try {
        return doc.activeElement || doc.body
      } catch {
        return doc.body
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g
    function escapeSelectorAttributeValueInsideDoubleQuotes(value$2) {
      return value$2.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
        return `\\` + ch.charCodeAt(0).toString(16) + ` `
      })
    }
    function updateInput(element$2, value$2, defaultValue, lastDefaultValue, checked, defaultChecked, type$2, name) {
      element$2.name = ``,
        type$2 != null && typeof type$2 != `function` && typeof type$2 != `symbol` && typeof type$2 != `boolean`
          ? element$2.type = type$2
          : element$2.removeAttribute(`type`),
        value$2 == null
          ? type$2 !== `submit` && type$2 !== `reset` || element$2.removeAttribute(`value`)
          : type$2 === `number`
          ? (value$2 === 0 && element$2.value === `` || element$2.value != value$2)
            && (element$2.value = `` + getToStringValue(value$2))
          : element$2.value !== `` + getToStringValue(value$2) && (element$2.value = `` + getToStringValue(value$2)),
        value$2 == null
          ? defaultValue == null
            ? lastDefaultValue != null && element$2.removeAttribute(`value`)
            : setDefaultValue(element$2, type$2, getToStringValue(defaultValue))
          : setDefaultValue(element$2, type$2, getToStringValue(value$2)),
        checked == null && defaultChecked != null && (element$2.defaultChecked = !!defaultChecked),
        checked != null && (element$2.checked = checked && typeof checked != `function` && typeof checked != `symbol`),
        name != null && typeof name != `function` && typeof name != `symbol` && typeof name != `boolean`
          ? element$2.name = `` + getToStringValue(name)
          : element$2.removeAttribute(`name`)
    }
    function initInput(element$2, value$2, defaultValue, checked, defaultChecked, type$2, name, isHydrating$1) {
      if (
        type$2 != null && typeof type$2 != `function` && typeof type$2 != `symbol` && typeof type$2 != `boolean`
        && (element$2.type = type$2), value$2 != null || defaultValue != null
      ) {
        if (!(type$2 !== `submit` && type$2 !== `reset` || value$2 != null)) return
        defaultValue = defaultValue == null ? `` : `` + getToStringValue(defaultValue),
          value$2 = value$2 == null ? defaultValue : `` + getToStringValue(value$2),
          isHydrating$1 || value$2 === element$2.value || (element$2.value = value$2),
          element$2.defaultValue = value$2
      }
      checked ??= defaultChecked,
        checked = typeof checked != `function` && typeof checked != `symbol` && !!checked,
        element$2.checked = isHydrating$1 ? element$2.checked : !!checked,
        element$2.defaultChecked = !!checked,
        name != null && typeof name != `function` && typeof name != `symbol` && typeof name != `boolean`
        && (element$2.name = name)
    }
    function setDefaultValue(node$1, type$2, value$2) {
      type$2 === `number` && getActiveElement(node$1.ownerDocument) === node$1 || node$1.defaultValue === `` + value$2
        || (node$1.defaultValue = `` + value$2)
    }
    function updateOptions(node$1, multiple, propValue, setDefaultSelected) {
      if (node$1 = node$1.options, multiple) {
        multiple = {}
        for (var i$14 = 0; i$14 < propValue.length; i$14++) multiple[`$` + propValue[i$14]] = !0
        for (propValue = 0; propValue < node$1.length; propValue++) {
          i$14 = multiple.hasOwnProperty(`$` + node$1[propValue].value),
            node$1[propValue].selected !== i$14 && (node$1[propValue].selected = i$14),
            i$14 && setDefaultSelected && (node$1[propValue].defaultSelected = !0)
        }
      } else {
        for (propValue = `` + getToStringValue(propValue), multiple = null, i$14 = 0; i$14 < node$1.length; i$14++) {
          if (node$1[i$14].value === propValue) {
            node$1[i$14].selected = !0, setDefaultSelected && (node$1[i$14].defaultSelected = !0)
            return
          }
          multiple !== null || node$1[i$14].disabled || (multiple = node$1[i$14])
        }
        multiple !== null && (multiple.selected = !0)
      }
    }
    function updateTextarea(element$2, value$2, defaultValue) {
      if (
        value$2 != null
        && (value$2 = `` + getToStringValue(value$2),
          value$2 !== element$2.value && (element$2.value = value$2),
          defaultValue == null)
      ) {
        element$2.defaultValue !== value$2 && (element$2.defaultValue = value$2)
        return
      }
      element$2.defaultValue = defaultValue == null ? `` : `` + getToStringValue(defaultValue)
    }
    function initTextarea(element$2, value$2, defaultValue, children$3) {
      if (value$2 == null) {
        if (children$3 != null) {
          if (defaultValue != null) throw Error(formatProdErrorMessage(92))
          if (isArrayImpl(children$3)) {
            if (1 < children$3.length) throw Error(formatProdErrorMessage(93))
            children$3 = children$3[0]
          }
          defaultValue = children$3
        }
        defaultValue ??= ``, value$2 = defaultValue
      }
      defaultValue = getToStringValue(value$2),
        element$2.defaultValue = defaultValue,
        children$3 = element$2.textContent,
        children$3 === defaultValue && children$3 !== `` && children$3 !== null && (element$2.value = children$3)
    }
    function setTextContent(node$1, text$6) {
      if (text$6) {
        var firstChild = node$1.firstChild
        if (firstChild && firstChild === node$1.lastChild && firstChild.nodeType === 3) {
          firstChild.nodeValue = text$6
          return
        }
      }
      node$1.textContent = text$6
    }
    var unitlessNumbers = new Set(
      `animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp`
        .split(` `),
    )
    function setValueForStyle(style$1, styleName, value$2) {
      var isCustomProperty = styleName.indexOf(`--`) === 0
      value$2 == null || typeof value$2 == `boolean` || value$2 === ``
        ? isCustomProperty
          ? style$1.setProperty(styleName, ``)
          : styleName === `float`
          ? style$1.cssFloat = ``
          : style$1[styleName] = ``
        : isCustomProperty
        ? style$1.setProperty(styleName, value$2)
        : typeof value$2 != `number` || value$2 === 0 || unitlessNumbers.has(styleName)
        ? styleName === `float` ? style$1.cssFloat = value$2 : style$1[styleName] = (`` + value$2).trim()
        : style$1[styleName] = value$2 + `px`
    }
    function setValueForStyles(node$1, styles, prevStyles) {
      if (styles != null && typeof styles != `object`) throw Error(formatProdErrorMessage(62))
      if (node$1 = node$1.style, prevStyles != null) {
        for (var styleName in prevStyles) {
          !prevStyles.hasOwnProperty(styleName) || styles != null && styles.hasOwnProperty(styleName)
            || (styleName.indexOf(`--`) === 0
              ? node$1.setProperty(styleName, ``)
              : styleName === `float`
              ? node$1.cssFloat = ``
              : node$1[styleName] = ``)
        }
        for (var styleName$16 in styles) {
          styleName = styles[styleName$16],
            styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName
            && setValueForStyle(node$1, styleName$16, styleName)
        }
      } else {for (var styleName$17 in styles) {
          styles.hasOwnProperty(styleName$17) && setValueForStyle(node$1, styleName$17, styles[styleName$17])
        }}
    }
    function isCustomElement(tagName) {
      if (tagName.indexOf(`-`) === -1) return !1
      switch (tagName) {
        case `annotation-xml`:
        case `color-profile`:
        case `font-face`:
        case `font-face-src`:
        case `font-face-uri`:
        case `font-face-format`:
        case `font-face-name`:
        case `missing-glyph`:
          return !1
        default:
          return !0
      }
    }
    var aliases = new Map([
        [`acceptCharset`, `accept-charset`],
        [`htmlFor`, `for`],
        [`httpEquiv`, `http-equiv`],
        [`crossOrigin`, `crossorigin`],
        [`accentHeight`, `accent-height`],
        [`alignmentBaseline`, `alignment-baseline`],
        [`arabicForm`, `arabic-form`],
        [`baselineShift`, `baseline-shift`],
        [`capHeight`, `cap-height`],
        [`clipPath`, `clip-path`],
        [`clipRule`, `clip-rule`],
        [`colorInterpolation`, `color-interpolation`],
        [`colorInterpolationFilters`, `color-interpolation-filters`],
        [`colorProfile`, `color-profile`],
        [`colorRendering`, `color-rendering`],
        [`dominantBaseline`, `dominant-baseline`],
        [`enableBackground`, `enable-background`],
        [`fillOpacity`, `fill-opacity`],
        [`fillRule`, `fill-rule`],
        [`floodColor`, `flood-color`],
        [`floodOpacity`, `flood-opacity`],
        [`fontFamily`, `font-family`],
        [`fontSize`, `font-size`],
        [`fontSizeAdjust`, `font-size-adjust`],
        [`fontStretch`, `font-stretch`],
        [`fontStyle`, `font-style`],
        [`fontVariant`, `font-variant`],
        [`fontWeight`, `font-weight`],
        [`glyphName`, `glyph-name`],
        [`glyphOrientationHorizontal`, `glyph-orientation-horizontal`],
        [`glyphOrientationVertical`, `glyph-orientation-vertical`],
        [`horizAdvX`, `horiz-adv-x`],
        [`horizOriginX`, `horiz-origin-x`],
        [`imageRendering`, `image-rendering`],
        [`letterSpacing`, `letter-spacing`],
        [`lightingColor`, `lighting-color`],
        [`markerEnd`, `marker-end`],
        [`markerMid`, `marker-mid`],
        [`markerStart`, `marker-start`],
        [`overlinePosition`, `overline-position`],
        [`overlineThickness`, `overline-thickness`],
        [`paintOrder`, `paint-order`],
        [`panose-1`, `panose-1`],
        [`pointerEvents`, `pointer-events`],
        [`renderingIntent`, `rendering-intent`],
        [`shapeRendering`, `shape-rendering`],
        [`stopColor`, `stop-color`],
        [`stopOpacity`, `stop-opacity`],
        [`strikethroughPosition`, `strikethrough-position`],
        [`strikethroughThickness`, `strikethrough-thickness`],
        [`strokeDasharray`, `stroke-dasharray`],
        [`strokeDashoffset`, `stroke-dashoffset`],
        [`strokeLinecap`, `stroke-linecap`],
        [`strokeLinejoin`, `stroke-linejoin`],
        [`strokeMiterlimit`, `stroke-miterlimit`],
        [`strokeOpacity`, `stroke-opacity`],
        [`strokeWidth`, `stroke-width`],
        [`textAnchor`, `text-anchor`],
        [`textDecoration`, `text-decoration`],
        [`textRendering`, `text-rendering`],
        [`transformOrigin`, `transform-origin`],
        [`underlinePosition`, `underline-position`],
        [`underlineThickness`, `underline-thickness`],
        [`unicodeBidi`, `unicode-bidi`],
        [`unicodeRange`, `unicode-range`],
        [`unitsPerEm`, `units-per-em`],
        [`vAlphabetic`, `v-alphabetic`],
        [`vHanging`, `v-hanging`],
        [`vIdeographic`, `v-ideographic`],
        [`vMathematical`, `v-mathematical`],
        [`vectorEffect`, `vector-effect`],
        [`vertAdvY`, `vert-adv-y`],
        [`vertOriginX`, `vert-origin-x`],
        [`vertOriginY`, `vert-origin-y`],
        [`wordSpacing`, `word-spacing`],
        [`writingMode`, `writing-mode`],
        [`xmlnsXlink`, `xmlns:xlink`],
        [`xHeight`, `x-height`],
      ]),
      isJavaScriptProtocol =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test(`` + url)
        ? `javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')`
        : url
    }
    var currentReplayingEvent = null
    function getEventTarget(nativeEvent) {
      return nativeEvent = nativeEvent.target || nativeEvent.srcElement || window,
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement),
        nativeEvent.nodeType === 3 ? nativeEvent.parentNode : nativeEvent
    }
    var restoreTarget = null, restoreQueue = null
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target)
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case `input`:
            if (
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
              ),
                internalInstance = props.name,
                props.type === `radio` && internalInstance != null
            ) {
              for (props = target; props.parentNode;) props = props.parentNode
              for (
                props = props.querySelectorAll(
                  `input[name="` + escapeSelectorAttributeValueInsideDoubleQuotes(`` + internalInstance)
                    + `"][type="radio"]`,
                ), internalInstance = 0;
                internalInstance < props.length;
                internalInstance++
              ) {
                var otherNode = props[internalInstance]
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null
                  if (!otherProps) throw Error(formatProdErrorMessage(90))
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name,
                  )
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode)
              }
            }
            break a
          case `textarea`:
            updateTextarea(target, props.value, props.defaultValue)
            break a
          case `select`:
            internalInstance = props.value,
              internalInstance != null && updateOptions(target, !!props.multiple, internalInstance, !1)
        }
      }
    }
    var isInsideEventHandler = !1
    function batchedUpdates$1(fn, a$22, b$3) {
      if (isInsideEventHandler) return fn(a$22, b$3)
      isInsideEventHandler = !0
      try {
        var JSCompiler_inline_result = fn(a$22)
        return JSCompiler_inline_result
      } finally {
        if (
          isInsideEventHandler = !1,
            (restoreTarget !== null || restoreQueue !== null)
            && (flushSyncWork$1(),
              restoreTarget
              && (a$22 = restoreTarget,
                fn = restoreQueue,
                restoreQueue = restoreTarget = null,
                restoreStateOfTarget(a$22),
                fn))
        ) for (a$22 = 0; a$22 < fn.length; a$22++) restoreStateOfTarget(fn[a$22])
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode
      if (stateNode === null) return null
      var props = stateNode[internalPropsKey] || null
      if (props === null) return null
      stateNode = props[registrationName]
      a: switch (registrationName) {
        case `onClick`:
        case `onClickCapture`:
        case `onDoubleClick`:
        case `onDoubleClickCapture`:
        case `onMouseDown`:
        case `onMouseDownCapture`:
        case `onMouseMove`:
        case `onMouseMoveCapture`:
        case `onMouseUp`:
        case `onMouseUpCapture`:
        case `onMouseEnter`:
          ;(props = !props.disabled)
            || (inst = inst.type,
              props = !(inst === `button` || inst === `input` || inst === `select` || inst === `textarea`)),
            inst = !props
          break a
        default:
          inst = !1
      }
      if (inst) return null
      if (stateNode && typeof stateNode != `function`) {
        throw Error(formatProdErrorMessage(231, registrationName, typeof stateNode))
      }
      return stateNode
    }
    var canUseDOM$1 = !(typeof window > `u` || window.document === void 0 || window.document.createElement === void 0),
      passiveBrowserEventsSupported = !1
    if (canUseDOM$1) {
      try {
        var options$1 = {}
        Object.defineProperty(options$1, `passive`, {
          get: function() {
            passiveBrowserEventsSupported = !0
          },
        }),
          window.addEventListener(`test`, options$1, options$1),
          window.removeEventListener(`test`, options$1, options$1)
      } catch {
        passiveBrowserEventsSupported = !1
      }
    }
    var root$4 = null, startText = null, fallbackText = null
    function getData() {
      if (fallbackText) return fallbackText
      var start$2,
        startValue = startText,
        startLength = startValue.length,
        end$2,
        endValue = `value` in root$4 ? root$4.value : root$4.textContent,
        endLength = endValue.length
      for (start$2 = 0; start$2 < startLength && startValue[start$2] === endValue[start$2]; start$2++);
      var minEnd = startLength - start$2
      for (end$2 = 1; end$2 <= minEnd && startValue[startLength - end$2] === endValue[endLength - end$2]; end$2++);
      return fallbackText = endValue.slice(start$2, 1 < end$2 ? 1 - end$2 : void 0)
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode
      return `charCode` in nativeEvent
        ? (nativeEvent = nativeEvent.charCode, nativeEvent === 0 && keyCode === 13 && (nativeEvent = 13))
        : nativeEvent = keyCode,
        nativeEvent === 10 && (nativeEvent = 13),
        32 <= nativeEvent || nativeEvent === 13 ? nativeEvent : 0
    }
    function functionThatReturnsTrue() {
      return !0
    }
    function functionThatReturnsFalse() {
      return !1
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        for (
          var propName in this._reactName = reactName,
            this._targetInst = targetInst,
            this.type = reactEventType,
            this.nativeEvent = nativeEvent,
            this.target = nativeEventTarget,
            this.currentTarget = null,
            Interface
        ) {
          Interface.hasOwnProperty(propName)
            && (reactName = Interface[propName],
              this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName])
        }
        return this.isDefaultPrevented =
          (nativeEvent.defaultPrevented == null ? !1 === nativeEvent.returnValue : nativeEvent.defaultPrevented)
            ? functionThatReturnsTrue
            : functionThatReturnsFalse,
          this.isPropagationStopped = functionThatReturnsFalse,
          this
      }
      return assign(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0
          var event = this.nativeEvent
          event
            && (event.preventDefault
              ? event.preventDefault()
              : typeof event.returnValue != `unknown` && (event.returnValue = !1),
              this.isDefaultPrevented = functionThatReturnsTrue)
        },
        stopPropagation: function() {
          var event = this.nativeEvent
          event
            && (event.stopPropagation
              ? event.stopPropagation()
              : typeof event.cancelBubble != `unknown` && (event.cancelBubble = !0),
              this.isPropagationStopped = functionThatReturnsTrue)
        },
        persist: function() {},
        isPersistent: functionThatReturnsTrue,
      }),
        SyntheticBaseEvent
    }
    var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0,
      },
      SyntheticEvent = createSyntheticEvent(EventInterface),
      UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
      SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
      lastMovementX,
      lastMovementY,
      lastMouseEvent,
      MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return event.relatedTarget === void 0
            ? event.fromElement === event.srcElement ? event.toElement : event.fromElement
            : event.relatedTarget
        },
        movementX: function(event) {
          return `movementX` in event
            ? event.movementX
            : (event !== lastMouseEvent && (lastMouseEvent && event.type === `mousemove`
              ? (lastMovementX = event.screenX - lastMouseEvent.screenX,
                lastMovementY = event.screenY - lastMouseEvent.screenY)
              : lastMovementY = lastMovementX = 0,
              lastMouseEvent = event),
              lastMovementX)
        },
        movementY: function(event) {
          return `movementY` in event ? event.movementY : lastMovementY
        },
      }),
      SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
      DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
      SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
      FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
      SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
      AnimationEventInterface = assign({}, EventInterface, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
      SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
      ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return `clipboardData` in event ? event.clipboardData : window.clipboardData
        },
      }),
      SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
      CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
      SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
      normalizeKey = {
        Esc: `Escape`,
        Spacebar: ` `,
        Left: `ArrowLeft`,
        Up: `ArrowUp`,
        Right: `ArrowRight`,
        Down: `ArrowDown`,
        Del: `Delete`,
        Win: `OS`,
        Menu: `ContextMenu`,
        Apps: `ContextMenu`,
        Scroll: `ScrollLock`,
        MozPrintableKey: `Unidentified`,
      },
      translateToKey = {
        8: `Backspace`,
        9: `Tab`,
        12: `Clear`,
        13: `Enter`,
        16: `Shift`,
        17: `Control`,
        18: `Alt`,
        19: `Pause`,
        20: `CapsLock`,
        27: `Escape`,
        32: ` `,
        33: `PageUp`,
        34: `PageDown`,
        35: `End`,
        36: `Home`,
        37: `ArrowLeft`,
        38: `ArrowUp`,
        39: `ArrowRight`,
        40: `ArrowDown`,
        45: `Insert`,
        46: `Delete`,
        112: `F1`,
        113: `F2`,
        114: `F3`,
        115: `F4`,
        116: `F5`,
        117: `F6`,
        118: `F7`,
        119: `F8`,
        120: `F9`,
        121: `F10`,
        122: `F11`,
        123: `F12`,
        144: `NumLock`,
        145: `ScrollLock`,
        224: `Meta`,
      },
      modifierKeyToProp = { Alt: `altKey`, Control: `ctrlKey`, Meta: `metaKey`, Shift: `shiftKey` }
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent
      return nativeEvent.getModifierState
        ? nativeEvent.getModifierState(keyArg)
        : (keyArg = modifierKeyToProp[keyArg])
        ? !!nativeEvent[keyArg]
        : !1
    }
    function getEventModifierState() {
      return modifierStateGetter
    }
    var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key$1 = normalizeKey[nativeEvent.key] || nativeEvent.key
            if (key$1 !== `Unidentified`) return key$1
          }
          return nativeEvent.type === `keypress`
            ? (nativeEvent = getEventCharCode(nativeEvent),
              nativeEvent === 13 ? `Enter` : String.fromCharCode(nativeEvent))
            : nativeEvent.type === `keydown` || nativeEvent.type === `keyup`
            ? translateToKey[nativeEvent.keyCode] || `Unidentified`
            : ``
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return event.type === `keypress` ? getEventCharCode(event) : 0
        },
        keyCode: function(event) {
          return event.type === `keydown` || event.type === `keyup` ? event.keyCode : 0
        },
        which: function(event) {
          return event.type === `keypress`
            ? getEventCharCode(event)
            : event.type === `keydown` || event.type === `keyup`
            ? event.keyCode
            : 0
        },
      }),
      SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
      PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0,
      }),
      SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
      TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState,
      }),
      SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
      TransitionEventInterface = assign({}, EventInterface, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
      SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
      WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return `deltaX` in event ? event.deltaX : `wheelDeltaX` in event ? -event.wheelDeltaX : 0
        },
        deltaY: function(event) {
          return `deltaY` in event
            ? event.deltaY
            : `wheelDeltaY` in event
            ? -event.wheelDeltaY
            : `wheelDelta` in event
            ? -event.wheelDelta
            : 0
        },
        deltaZ: 0,
        deltaMode: 0,
      }),
      SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
      ToggleEventInterface = assign({}, EventInterface, { newState: 0, oldState: 0 }),
      SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
      END_KEYCODES = [9, 13, 27, 32],
      canUseCompositionEvent = canUseDOM$1 && `CompositionEvent` in window,
      documentMode = null
    canUseDOM$1 && `documentMode` in document && (documentMode = document.documentMode)
    var canUseTextInputEvent = canUseDOM$1 && `TextEvent` in window && !documentMode,
      useFallbackCompositionData = canUseDOM$1
        && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode),
      SPACEBAR_CHAR = ` `,
      hasSpaceKeypress = !1
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case `keyup`:
          return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1
        case `keydown`:
          return nativeEvent.keyCode !== 229
        case `keypress`:
        case `mousedown`:
        case `focusout`:
          return !0
        default:
          return !1
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      return nativeEvent = nativeEvent.detail,
        typeof nativeEvent == `object` && `data` in nativeEvent ? nativeEvent.data : null
    }
    var isComposing = !1
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case `compositionend`:
          return getDataFromCustomEvent(nativeEvent)
        case `keypress`:
          return nativeEvent.which === 32 ? (hasSpaceKeypress = !0, SPACEBAR_CHAR) : null
        case `textInput`:
          return domEventName = nativeEvent.data,
            domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
        default:
          return null
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing) {
        return domEventName === `compositionend`
            || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)
          ? (domEventName = getData(), fallbackText = startText = root$4 = null, isComposing = !1, domEventName)
          : null
      }
      switch (domEventName) {
        case `paste`:
          return null
        case `keypress`:
          if (
            !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey)
            || nativeEvent.ctrlKey && nativeEvent.altKey
          ) {
            if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which)
          }
          return null
        case `compositionend`:
          return useFallbackCompositionData && nativeEvent.locale !== `ko` ? null : nativeEvent.data
        default:
          return null
      }
    }
    var supportedInputTypes = {
      color: !0,
      date: !0,
      datetime: !0,
      'datetime-local': !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0,
    }
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase()
      return nodeName === `input` ? !!supportedInputTypes[elem.type] : nodeName === `textarea` ? !0 : !1
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target,
        inst = accumulateTwoPhaseListeners(inst, `onChange`),
        0 < inst.length
        && (nativeEvent = new SyntheticEvent(`onChange`, `change`, null, nativeEvent, target),
          dispatchQueue.push({ event: nativeEvent, listeners: inst }))
    }
    var activeElement$1 = null, activeElementInst$1 = null
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0)
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst)
      if (updateValueIfChanged(targetNode)) return targetInst
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if (domEventName === `change`) return targetInst
    }
    var isInputEventSupported = !1
    if (canUseDOM$1) {
      var JSCompiler_inline_result$jscomp$282
      if (canUseDOM$1) {
        var isSupported$jscomp$inline_417 = `oninput` in document
        if (!isSupported$jscomp$inline_417) {
          var element$jscomp$inline_418 = document.createElement(`div`)
          element$jscomp$inline_418.setAttribute(`oninput`, `return;`),
            isSupported$jscomp$inline_417 = typeof element$jscomp$inline_418.oninput == `function`
        }
        JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417
      } else JSCompiler_inline_result$jscomp$282 = !1
      isInputEventSupported = JSCompiler_inline_result$jscomp$282
        && (!document.documentMode || 9 < document.documentMode)
    }
    function stopWatchingForValueChange() {
      activeElement$1
        && (activeElement$1.detachEvent(`onpropertychange`, handlePropertyChange),
          activeElementInst$1 = activeElement$1 = null)
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName === `value` && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = []
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent)),
          batchedUpdates$1(runEventInBatch, dispatchQueue)
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      domEventName === `focusin`
        ? (stopWatchingForValueChange(),
          activeElement$1 = target,
          activeElementInst$1 = targetInst,
          activeElement$1.attachEvent(`onpropertychange`, handlePropertyChange))
        : domEventName === `focusout` && stopWatchingForValueChange()
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if (domEventName === `selectionchange` || domEventName === `keyup` || domEventName === `keydown`) {
        return getInstIfValueChanged(activeElementInst$1)
      }
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if (domEventName === `click`) return getInstIfValueChanged(targetInst)
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if (domEventName === `input` || domEventName === `change`) return getInstIfValueChanged(targetInst)
    }
    function is$28(x$2, y$3) {
      return x$2 === y$3 && (x$2 !== 0 || 1 / x$2 == 1 / y$3) || x$2 !== x$2 && y$3 !== y$3
    }
    var objectIs$1 = typeof Object.is == `function` ? Object.is : is$28
    function shallowEqual(objA, objB) {
      if (objectIs$1(objA, objB)) return !0
      if (typeof objA != `object` || !objA || typeof objB != `object` || !objB) return !1
      var keysA = Object.keys(objA), keysB = Object.keys(objB)
      if (keysA.length !== keysB.length) return !1
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB]
        if (!hasOwnProperty$2.call(objB, currentKey) || !objectIs$1(objA[currentKey], objB[currentKey])) return !1
      }
      return !0
    }
    function getLeafNode(node$1) {
      for (; node$1 && node$1.firstChild;) node$1 = node$1.firstChild
      return node$1
    }
    function getNodeForCharacterOffset(root$5, offset$3) {
      var node$1 = getLeafNode(root$5)
      root$5 = 0
      for (var nodeEnd; node$1;) {
        if (node$1.nodeType === 3) {
          if (nodeEnd = root$5 + node$1.textContent.length, root$5 <= offset$3 && nodeEnd >= offset$3) {
            return { node: node$1, offset: offset$3 - root$5 }
          }
          root$5 = nodeEnd
        }
        a: {
          for (; node$1;) {
            if (node$1.nextSibling) {
              node$1 = node$1.nextSibling
              break a
            }
            node$1 = node$1.parentNode
          }
          node$1 = void 0
        }
        node$1 = getLeafNode(node$1)
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode
        ? outerNode === innerNode
          ? !0
          : outerNode && outerNode.nodeType === 3
          ? !1
          : innerNode && innerNode.nodeType === 3
          ? containsNode(outerNode, innerNode.parentNode)
          : `contains` in outerNode
          ? outerNode.contains(innerNode)
          : outerNode.compareDocumentPosition
          ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
          : !1
        : !1
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo =
        containerInfo != null && containerInfo.ownerDocument != null && containerInfo.ownerDocument.defaultView != null
          ? containerInfo.ownerDocument.defaultView
          : window
      for (
        var element$2 = getActiveElement(containerInfo.document);
        element$2 instanceof containerInfo.HTMLIFrameElement;
      ) {
        try {
          var JSCompiler_inline_result = typeof element$2.contentWindow.location.href == `string`
        } catch {
          JSCompiler_inline_result = !1
        }
        if (JSCompiler_inline_result) containerInfo = element$2.contentWindow
        else break
        element$2 = getActiveElement(containerInfo.document)
      }
      return element$2
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase()
      return nodeName
        && (nodeName === `input`
            && (elem.type === `text` || elem.type === `search` || elem.type === `tel` || elem.type === `url`
              || elem.type === `password`) || nodeName === `textarea` || elem.contentEditable === `true`)
    }
    var skipSelectionChangeEvent = canUseDOM$1 && `documentMode` in document && 11 >= document.documentMode,
      activeElement = null,
      activeElementInst = null,
      lastSelection = null,
      mouseDown = !1
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget
        ? nativeEventTarget.document
        : nativeEventTarget.nodeType === 9
        ? nativeEventTarget
        : nativeEventTarget.ownerDocument
      mouseDown || activeElement == null || activeElement !== getActiveElement(doc)
        || (doc = activeElement,
          `selectionStart` in doc && hasSelectionCapabilities(doc)
            ? doc = { start: doc.selectionStart, end: doc.selectionEnd }
            : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(),
              doc = {
                anchorNode: doc.anchorNode,
                anchorOffset: doc.anchorOffset,
                focusNode: doc.focusNode,
                focusOffset: doc.focusOffset,
              }),
          lastSelection && shallowEqual(lastSelection, doc)
          || (lastSelection = doc,
            doc = accumulateTwoPhaseListeners(activeElementInst, `onSelect`),
            0 < doc.length
            && (nativeEvent = new SyntheticEvent(`onSelect`, `select`, null, nativeEvent, nativeEventTarget),
              dispatchQueue.push({ event: nativeEvent, listeners: doc }),
              nativeEvent.target = activeElement)))
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {}
      return prefixes[styleProp.toLowerCase()] = eventName.toLowerCase(),
        prefixes[`Webkit` + styleProp] = `webkit` + eventName,
        prefixes[`Moz` + styleProp] = `moz` + eventName,
        prefixes
    }
    var vendorPrefixes = {
        animationend: makePrefixMap(`Animation`, `AnimationEnd`),
        animationiteration: makePrefixMap(`Animation`, `AnimationIteration`),
        animationstart: makePrefixMap(`Animation`, `AnimationStart`),
        transitionrun: makePrefixMap(`Transition`, `TransitionRun`),
        transitionstart: makePrefixMap(`Transition`, `TransitionStart`),
        transitioncancel: makePrefixMap(`Transition`, `TransitionCancel`),
        transitionend: makePrefixMap(`Transition`, `TransitionEnd`),
      },
      prefixedEventNames = {},
      style = {}
    canUseDOM$1 && (style = document.createElement(`div`).style,
      `AnimationEvent` in window
      || (delete vendorPrefixes.animationend.animation,
        delete vendorPrefixes.animationiteration.animation,
        delete vendorPrefixes.animationstart.animation),
      `TransitionEvent` in window || delete vendorPrefixes.transitionend.transition)
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName]
      if (!vendorPrefixes[eventName]) return eventName
      var prefixMap = vendorPrefixes[eventName], styleProp
      for (styleProp in prefixMap) {
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
          return prefixedEventNames[eventName] = prefixMap[styleProp]
        }
      }
      return eventName
    }
    var ANIMATION_END = getVendorPrefixedEventName(`animationend`),
      ANIMATION_ITERATION = getVendorPrefixedEventName(`animationiteration`),
      ANIMATION_START = getVendorPrefixedEventName(`animationstart`),
      TRANSITION_RUN = getVendorPrefixedEventName(`transitionrun`),
      TRANSITION_START = getVendorPrefixedEventName(`transitionstart`),
      TRANSITION_CANCEL = getVendorPrefixedEventName(`transitioncancel`),
      TRANSITION_END = getVendorPrefixedEventName(`transitionend`),
      topLevelEventsToReactNames = new Map(),
      simpleEventPluginEvents =
        `abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel`
          .split(` `)
    simpleEventPluginEvents.push(`scrollEnd`)
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName), registerTwoPhaseEvent(reactName, [domEventName])
    }
    var CapturedStacks = new WeakMap()
    function createCapturedValueAtFiber(value$2, source) {
      if (typeof value$2 == `object` && value$2) {
        var existing = CapturedStacks.get(value$2)
        return existing === void 0
          ? (source = { value: value$2, source, stack: getStackByFiberInDevAndProd(source) },
            CapturedStacks.set(value$2, source),
            source)
          : existing
      }
      return { value: value$2, source, stack: getStackByFiberInDevAndProd(source) }
    }
    var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0
    function finishQueueingConcurrentUpdates() {
      for (
        var endIndex = concurrentQueuesIndex, i$14 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0;
        i$14 < endIndex;
      ) {
        var fiber = concurrentQueues[i$14]
        concurrentQueues[i$14++] = null
        var queue = concurrentQueues[i$14]
        concurrentQueues[i$14++] = null
        var update$5 = concurrentQueues[i$14]
        concurrentQueues[i$14++] = null
        var lane = concurrentQueues[i$14]
        if (concurrentQueues[i$14++] = null, queue !== null && update$5 !== null) {
          var pending$2 = queue.pending
          pending$2 === null ? update$5.next = update$5 : (update$5.next = pending$2.next, pending$2.next = update$5),
            queue.pending = update$5
        }
        lane !== 0 && markUpdateLaneFromFiberToRoot(fiber, update$5, lane)
      }
    }
    function enqueueUpdate$1(fiber, queue, update$5, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber,
        concurrentQueues[concurrentQueuesIndex++] = queue,
        concurrentQueues[concurrentQueuesIndex++] = update$5,
        concurrentQueues[concurrentQueuesIndex++] = lane,
        concurrentlyUpdatedLanes |= lane,
        fiber.lanes |= lane,
        fiber = fiber.alternate,
        fiber !== null && (fiber.lanes |= lane)
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update$5, lane) {
      return enqueueUpdate$1(fiber, queue, update$5, lane), getRootForUpdatedFiber(fiber)
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      return enqueueUpdate$1(fiber, null, null, lane), getRootForUpdatedFiber(fiber)
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update$5, lane) {
      sourceFiber.lanes |= lane
      var alternate = sourceFiber.alternate
      alternate !== null && (alternate.lanes |= lane)
      for (var isHidden$1 = !1, parent = sourceFiber.return; parent !== null;) {
        parent.childLanes |= lane,
          alternate = parent.alternate,
          alternate !== null && (alternate.childLanes |= lane),
          parent.tag === 22
          && (sourceFiber = parent.stateNode, sourceFiber === null || sourceFiber._visibility & 1 || (isHidden$1 = !0)),
          sourceFiber = parent,
          parent = parent.return
      }
      return sourceFiber.tag === 3
        ? (parent = sourceFiber.stateNode,
          isHidden$1 && update$5 !== null
          && (isHidden$1 = 31 - clz32(lane),
            sourceFiber = parent.hiddenUpdates,
            alternate = sourceFiber[isHidden$1],
            alternate === null ? sourceFiber[isHidden$1] = [update$5] : alternate.push(update$5),
            update$5.lane = lane | 536870912),
          parent)
        : null
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount) {
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185))
      }
      for (var parent = sourceFiber.return; parent !== null;) sourceFiber = parent, parent = sourceFiber.return
      return sourceFiber.tag === 3 ? sourceFiber.stateNode : null
    }
    var emptyContextObject = {}
    function FiberNode(tag$3, pendingProps, key$1, mode) {
      this.tag = tag$3,
        this.key = key$1,
        this.sibling =
          this.child =
          this.return =
          this.stateNode =
          this.type =
          this.elementType =
            null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = pendingProps,
        this.dependencies =
          this.memoizedState =
          this.updateQueue =
          this.memoizedProps =
            null,
        this.mode = mode,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function createFiberImplClass(tag$3, pendingProps, key$1, mode) {
      return new FiberNode(tag$3, pendingProps, key$1, mode)
    }
    function shouldConstruct(Component$7) {
      return Component$7 = Component$7.prototype, !(!Component$7 || !Component$7.isReactComponent)
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress$1 = current.alternate
      return workInProgress$1 === null
        ? (workInProgress$1 = createFiberImplClass(current.tag, pendingProps, current.key, current.mode),
          workInProgress$1.elementType = current.elementType,
          workInProgress$1.type = current.type,
          workInProgress$1.stateNode = current.stateNode,
          workInProgress$1.alternate = current,
          current.alternate = workInProgress$1)
        : (workInProgress$1.pendingProps = pendingProps,
          workInProgress$1.type = current.type,
          workInProgress$1.flags = 0,
          workInProgress$1.subtreeFlags = 0,
          workInProgress$1.deletions = null),
        workInProgress$1.flags = current.flags & 65011712,
        workInProgress$1.childLanes = current.childLanes,
        workInProgress$1.lanes = current.lanes,
        workInProgress$1.child = current.child,
        workInProgress$1.memoizedProps = current.memoizedProps,
        workInProgress$1.memoizedState = current.memoizedState,
        workInProgress$1.updateQueue = current.updateQueue,
        pendingProps = current.dependencies,
        workInProgress$1.dependencies = pendingProps === null
          ? null
          : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext },
        workInProgress$1.sibling = current.sibling,
        workInProgress$1.index = current.index,
        workInProgress$1.ref = current.ref,
        workInProgress$1.refCleanup = current.refCleanup,
        workInProgress$1
    }
    function resetWorkInProgress(workInProgress$1, renderLanes$1) {
      workInProgress$1.flags &= 65011714
      var current = workInProgress$1.alternate
      return current === null
        ? (workInProgress$1.childLanes = 0,
          workInProgress$1.lanes = renderLanes$1,
          workInProgress$1.child = null,
          workInProgress$1.subtreeFlags = 0,
          workInProgress$1.memoizedProps = null,
          workInProgress$1.memoizedState = null,
          workInProgress$1.updateQueue = null,
          workInProgress$1.dependencies = null,
          workInProgress$1.stateNode = null)
        : (workInProgress$1.childLanes = current.childLanes,
          workInProgress$1.lanes = current.lanes,
          workInProgress$1.child = current.child,
          workInProgress$1.subtreeFlags = 0,
          workInProgress$1.deletions = null,
          workInProgress$1.memoizedProps = current.memoizedProps,
          workInProgress$1.memoizedState = current.memoizedState,
          workInProgress$1.updateQueue = current.updateQueue,
          workInProgress$1.type = current.type,
          renderLanes$1 = current.dependencies,
          workInProgress$1.dependencies = renderLanes$1 === null
            ? null
            : { lanes: renderLanes$1.lanes, firstContext: renderLanes$1.firstContext }),
        workInProgress$1
    }
    function createFiberFromTypeAndProps(type$2, key$1, pendingProps, owner, mode, lanes) {
      var fiberTag = 0
      if (owner = type$2, typeof type$2 == `function`) shouldConstruct(type$2) && (fiberTag = 1)
      else if (typeof type$2 == `string`) {
        fiberTag = isHostHoistableType(type$2, pendingProps, contextStackCursor.current)
          ? 26
          : type$2 === `html` || type$2 === `head` || type$2 === `body`
          ? 27
          : 5
      } else {a: switch (type$2) {
          case REACT_ACTIVITY_TYPE:
            return type$2 = createFiberImplClass(31, pendingProps, key$1, mode),
              type$2.elementType = REACT_ACTIVITY_TYPE,
              type$2.lanes = lanes,
              type$2
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key$1)
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8, mode |= 24
            break
          case REACT_PROFILER_TYPE:
            return type$2 = createFiberImplClass(12, pendingProps, key$1, mode | 2),
              type$2.elementType = REACT_PROFILER_TYPE,
              type$2.lanes = lanes,
              type$2
          case REACT_SUSPENSE_TYPE:
            return type$2 = createFiberImplClass(13, pendingProps, key$1, mode),
              type$2.elementType = REACT_SUSPENSE_TYPE,
              type$2.lanes = lanes,
              type$2
          case REACT_SUSPENSE_LIST_TYPE:
            return type$2 = createFiberImplClass(19, pendingProps, key$1, mode),
              type$2.elementType = REACT_SUSPENSE_LIST_TYPE,
              type$2.lanes = lanes,
              type$2
          default:
            if (typeof type$2 == `object` && type$2) {
              switch (type$2.$$typeof) {
                case REACT_PROVIDER_TYPE:
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10
                  break a
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9
                  break a
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11
                  break a
                case REACT_MEMO_TYPE:
                  fiberTag = 14
                  break a
                case REACT_LAZY_TYPE:
                  fiberTag = 16, owner = null
                  break a
              }
            }
            fiberTag = 29,
              pendingProps = Error(formatProdErrorMessage(130, type$2 === null ? `null` : typeof type$2, ``)),
              owner = null
        }}
      return key$1 = createFiberImplClass(fiberTag, pendingProps, key$1, mode),
        key$1.elementType = type$2,
        key$1.type = owner,
        key$1.lanes = lanes,
        key$1
    }
    function createFiberFromFragment(elements, mode, lanes, key$1) {
      return elements = createFiberImplClass(7, elements, key$1, mode), elements.lanes = lanes, elements
    }
    function createFiberFromText(content$2, mode, lanes) {
      return content$2 = createFiberImplClass(6, content$2, null, mode), content$2.lanes = lanes, content$2
    }
    function createFiberFromPortal(portal, mode, lanes) {
      return mode = createFiberImplClass(4, portal.children === null ? [] : portal.children, portal.key, mode),
        mode.lanes = lanes,
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation,
        },
        mode
    }
    var forkStack = [],
      forkStackIndex = 0,
      treeForkProvider = null,
      treeForkCount = 0,
      idStack = [],
      idStackIndex = 0,
      treeContextProvider = null,
      treeContextId = 1,
      treeContextOverflow = ``
    function pushTreeFork(workInProgress$1, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount,
        forkStack[forkStackIndex++] = treeForkProvider,
        treeForkProvider = workInProgress$1,
        treeForkCount = totalChildren
    }
    function pushTreeId(workInProgress$1, totalChildren, index$4) {
      idStack[idStackIndex++] = treeContextId,
        idStack[idStackIndex++] = treeContextOverflow,
        idStack[idStackIndex++] = treeContextProvider,
        treeContextProvider = workInProgress$1
      var baseIdWithLeadingBit = treeContextId
      workInProgress$1 = treeContextOverflow
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1
      baseIdWithLeadingBit &= ~(1 << baseLength), index$4 += 1
      var length$1 = 32 - clz32(totalChildren) + baseLength
      if (30 < length$1) {
        var numberOfOverflowBits = baseLength - baseLength % 5
        length$1 = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32),
          baseIdWithLeadingBit >>= numberOfOverflowBits,
          baseLength -= numberOfOverflowBits,
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index$4 << baseLength | baseIdWithLeadingBit,
          treeContextOverflow = length$1 + workInProgress$1
      } else {treeContextId = 1 << length$1 | index$4 << baseLength | baseIdWithLeadingBit,
          treeContextOverflow = workInProgress$1}
    }
    function pushMaterializedTreeId(workInProgress$1) {
      workInProgress$1.return !== null && (pushTreeFork(workInProgress$1, 1), pushTreeId(workInProgress$1, 1, 0))
    }
    function popTreeContext(workInProgress$1) {
      for (; workInProgress$1 === treeForkProvider;) {
        treeForkProvider = forkStack[--forkStackIndex],
          forkStack[forkStackIndex] = null,
          treeForkCount = forkStack[--forkStackIndex],
          forkStack[forkStackIndex] = null
      }
      for (; workInProgress$1 === treeContextProvider;) {
        treeContextProvider = idStack[--idStackIndex],
          idStack[idStackIndex] = null,
          treeContextOverflow = idStack[--idStackIndex],
          idStack[idStackIndex] = null,
          treeContextId = idStack[--idStackIndex],
          idStack[idStackIndex] = null
      }
    }
    var hydrationParentFiber = null,
      nextHydratableInstance = null,
      isHydrating = !1,
      hydrationErrors = null,
      rootOrSingletonContext = !1,
      HydrationMismatchException = Error(formatProdErrorMessage(519))
    function throwOnHydrationMismatch(fiber) {
      var error = Error(formatProdErrorMessage(418, ``))
      throw queueHydrationError(createCapturedValueAtFiber(error, fiber)), HydrationMismatchException
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type$2 = fiber.type, props = fiber.memoizedProps
      switch (instance[internalInstanceKey] = fiber, instance[internalPropsKey] = props, type$2) {
        case `dialog`:
          listenToNonDelegatedEvent(`cancel`, instance), listenToNonDelegatedEvent(`close`, instance)
          break
        case `iframe`:
        case `object`:
        case `embed`:
          listenToNonDelegatedEvent(`load`, instance)
          break
        case `video`:
        case `audio`:
          for (type$2 = 0; type$2 < mediaEventTypes.length; type$2++) {
            listenToNonDelegatedEvent(mediaEventTypes[type$2], instance)
          }
          break
        case `source`:
          listenToNonDelegatedEvent(`error`, instance)
          break
        case `img`:
        case `image`:
        case `link`:
          listenToNonDelegatedEvent(`error`, instance), listenToNonDelegatedEvent(`load`, instance)
          break
        case `details`:
          listenToNonDelegatedEvent(`toggle`, instance)
          break
        case `input`:
          listenToNonDelegatedEvent(`invalid`, instance),
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              !0,
            ),
            track$1(instance)
          break
        case `select`:
          listenToNonDelegatedEvent(`invalid`, instance)
          break
        case `textarea`:
          listenToNonDelegatedEvent(`invalid`, instance),
            initTextarea(instance, props.value, props.defaultValue, props.children),
            track$1(instance)
      }
      type$2 = props.children,
        typeof type$2 != `string` && typeof type$2 != `number` && typeof type$2 != `bigint`
          || instance.textContent === `` + type$2 || !0 === props.suppressHydrationWarning
          || checkForUnmatchedText(instance.textContent, type$2)
          ? (props.popover != null
            && (listenToNonDelegatedEvent(`beforetoggle`, instance), listenToNonDelegatedEvent(`toggle`, instance)),
            props.onScroll != null && listenToNonDelegatedEvent(`scroll`, instance),
            props.onScrollEnd != null && listenToNonDelegatedEvent(`scrollend`, instance),
            props.onClick != null && (instance.onclick = noop$1),
            instance = !0)
          : instance = !1,
        instance || throwOnHydrationMismatch(fiber)
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber;) {
        switch (hydrationParentFiber.tag) {
          case 5:
          case 13:
            rootOrSingletonContext = !1
            return
          case 27:
          case 3:
            rootOrSingletonContext = !0
            return
          default:
            hydrationParentFiber = hydrationParentFiber.return
        }
      }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return !1
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1
      var tag$3 = fiber.tag, JSCompiler_temp
      if (
        (JSCompiler_temp = tag$3 !== 3 && tag$3 !== 27)
        && ((JSCompiler_temp = tag$3 === 5)
          && (JSCompiler_temp = fiber.type,
            JSCompiler_temp = !(JSCompiler_temp !== `form` && JSCompiler_temp !== `button`)
              || shouldSetTextContent(fiber.type, fiber.memoizedProps)),
          JSCompiler_temp = !JSCompiler_temp),
          JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber),
          popToNextHostParent(fiber),
          tag$3 === 13
      ) {
        if (fiber = fiber.memoizedState, fiber = fiber === null ? null : fiber.dehydrated, !fiber) {
          throw Error(formatProdErrorMessage(317))
        }
        a: {
          for (fiber = fiber.nextSibling, tag$3 = 0; fiber;) {
            if (fiber.nodeType === 8) {
              if (JSCompiler_temp = fiber.data, JSCompiler_temp === `/$`) {
                if (tag$3 === 0) {
                  nextHydratableInstance = getNextHydratable(fiber.nextSibling)
                  break a
                }
                tag$3--
              } else JSCompiler_temp !== `$` && JSCompiler_temp !== `$!` && JSCompiler_temp !== `$?` || tag$3++
            }
            fiber = fiber.nextSibling
          }
          nextHydratableInstance = null
        }
      } else {tag$3 === 27
          ? (tag$3 = nextHydratableInstance,
            isSingletonScope(fiber.type)
              ? (fiber = previousHydratableOnEnteringScopedSingleton,
                previousHydratableOnEnteringScopedSingleton = null,
                nextHydratableInstance = fiber)
              : nextHydratableInstance = tag$3)
          : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null}
      return !0
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null, isHydrating = !1
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors
      return queuedErrors !== null
        && (workInProgressRootRecoverableErrors === null
          ? workInProgressRootRecoverableErrors = queuedErrors
          : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors),
          hydrationErrors = null),
        queuedErrors
    }
    function queueHydrationError(error) {
      hydrationErrors === null ? hydrationErrors = [error] : hydrationErrors.push(error)
    }
    var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null
    function pushProvider(providerFiber, context$2, nextValue) {
      push$1(valueCursor, context$2._currentValue), context$2._currentValue = nextValue
    }
    function popProvider(context$2) {
      context$2._currentValue = valueCursor.current, pop(valueCursor)
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes$1, propagationRoot) {
      for (; parent !== null;) {
        var alternate = parent.alternate
        if (
          (parent.childLanes & renderLanes$1) === renderLanes$1
            ? alternate !== null && (alternate.childLanes & renderLanes$1) !== renderLanes$1
              && (alternate.childLanes |= renderLanes$1)
            : (parent.childLanes |= renderLanes$1, alternate !== null && (alternate.childLanes |= renderLanes$1)),
            parent === propagationRoot
        ) break
        parent = parent.return
      }
    }
    function propagateContextChanges(workInProgress$1, contexts, renderLanes$1, forcePropagateEntireTree) {
      var fiber = workInProgress$1.child
      for (fiber !== null && (fiber.return = workInProgress$1); fiber !== null;) {
        var list$3 = fiber.dependencies
        if (list$3 !== null) {
          var nextFiber = fiber.child
          list$3 = list$3.firstContext
          a: for (; list$3 !== null;) {
            var dependency = list$3
            list$3 = fiber
            for (var i$14 = 0; i$14 < contexts.length; i$14++) {
              if (dependency.context === contexts[i$14]) {
                list$3.lanes |= renderLanes$1,
                  dependency = list$3.alternate,
                  dependency !== null && (dependency.lanes |= renderLanes$1),
                  scheduleContextWorkOnParentPath(list$3.return, renderLanes$1, workInProgress$1),
                  forcePropagateEntireTree || (nextFiber = null)
                break a
              }
            }
            list$3 = dependency.next
          }
        } else if (fiber.tag === 18) {
          if (nextFiber = fiber.return, nextFiber === null) throw Error(formatProdErrorMessage(341))
          nextFiber.lanes |= renderLanes$1,
            list$3 = nextFiber.alternate,
            list$3 !== null && (list$3.lanes |= renderLanes$1),
            scheduleContextWorkOnParentPath(nextFiber, renderLanes$1, workInProgress$1),
            nextFiber = null
        } else nextFiber = fiber.child
        if (nextFiber !== null) nextFiber.return = fiber
        else {for (nextFiber = fiber; nextFiber !== null;) {
            if (nextFiber === workInProgress$1) {
              nextFiber = null
              break
            }
            if (fiber = nextFiber.sibling, fiber !== null) {
              fiber.return = nextFiber.return, nextFiber = fiber
              break
            }
            nextFiber = nextFiber.return
          }}
        fiber = nextFiber
      }
    }
    function propagateParentContextChanges(current, workInProgress$1, renderLanes$1, forcePropagateEntireTree) {
      current = null
      for (var parent = workInProgress$1, isInsidePropagationBailout = !1; parent !== null;) {
        if (!isInsidePropagationBailout) {
          if (parent.flags & 524288) isInsidePropagationBailout = !0
          else if (parent.flags & 262144) break
        }
        if (parent.tag === 10) {
          var currentParent = parent.alternate
          if (currentParent === null) throw Error(formatProdErrorMessage(387))
          if (currentParent = currentParent.memoizedProps, currentParent !== null) {
            var context$2 = parent.type
            objectIs$1(parent.pendingProps.value, currentParent.value)
              || (current === null ? current = [context$2] : current.push(context$2))
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          if (currentParent = parent.alternate, currentParent === null) throw Error(formatProdErrorMessage(387))
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState
            && (current === null ? current = [HostTransitionContext] : current.push(HostTransitionContext))
        }
        parent = parent.return
      }
      current !== null && propagateContextChanges(workInProgress$1, current, renderLanes$1, forcePropagateEntireTree),
        workInProgress$1.flags |= 262144
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; currentDependencies !== null;) {
        if (!objectIs$1(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0
        currentDependencies = currentDependencies.next
      }
      return !1
    }
    function prepareToReadContext(workInProgress$1) {
      currentlyRenderingFiber$1 = workInProgress$1,
        lastContextDependency = null,
        workInProgress$1 = workInProgress$1.dependencies,
        workInProgress$1 !== null && (workInProgress$1.firstContext = null)
    }
    function readContext(context$2) {
      return readContextForConsumer(currentlyRenderingFiber$1, context$2)
    }
    function readContextDuringReconciliation(consumer, context$2) {
      return currentlyRenderingFiber$1 === null && prepareToReadContext(consumer),
        readContextForConsumer(consumer, context$2)
    }
    function readContextForConsumer(consumer, context$2) {
      var value$2 = context$2._currentValue
      if (context$2 = { context: context$2, memoizedValue: value$2, next: null }, lastContextDependency === null) {
        if (consumer === null) throw Error(formatProdErrorMessage(308))
        lastContextDependency = context$2,
          consumer.dependencies = { lanes: 0, firstContext: context$2 },
          consumer.flags |= 524288
      } else lastContextDependency = lastContextDependency.next = context$2
      return value$2
    }
    var AbortControllerLocal = typeof AbortController < `u` ? AbortController : function() {
        var listeners = [],
          signal = this.signal = {
            aborted: !1,
            addEventListener: function(type$2, listener) {
              listeners.push(listener)
            },
          }
        this.abort = function() {
          signal.aborted = !0,
            listeners.forEach(function(listener) {
              return listener()
            })
        }
      },
      scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
      NormalPriority = Scheduler.unstable_NormalPriority,
      CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
      }
    function createCache() {
      return { controller: new AbortControllerLocal(), data: new Map(), refCount: 0 }
    }
    function releaseCache(cache) {
      cache.refCount--,
        cache.refCount === 0 && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort()
        })
    }
    var currentEntangledListeners = null,
      currentEntangledPendingCount = 0,
      currentEntangledLane = 0,
      currentEntangledActionThenable = null
    function entangleAsyncAction(transition, thenable) {
      if (currentEntangledListeners === null) {
        var entangledListeners = currentEntangledListeners = []
        currentEntangledPendingCount = 0,
          currentEntangledLane = requestTransitionLane(),
          currentEntangledActionThenable = {
            status: `pending`,
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve)
            },
          }
      }
      return currentEntangledPendingCount++,
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope),
        thenable
    }
    function pingEngtangledActionScope() {
      if (--currentEntangledPendingCount === 0 && currentEntangledListeners !== null) {
        currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = `fulfilled`)
        var listeners = currentEntangledListeners
        currentEntangledListeners = null, currentEntangledLane = 0, currentEntangledActionThenable = null
        for (var i$14 = 0; i$14 < listeners.length; i$14++) (0, listeners[i$14])()
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [],
        thenableWithOverride = {
          status: `pending`,
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve)
          },
        }
      return thenable.then(function() {
        thenableWithOverride.status = `fulfilled`, thenableWithOverride.value = result
        for (var i$14 = 0; i$14 < listeners.length; i$14++) (0, listeners[i$14])(result)
      }, function(error) {
        for (
          thenableWithOverride.status = `rejected`, thenableWithOverride.reason = error, error = 0;
          error < listeners.length;
          error++
        ) (0, listeners[error])(void 0)
      }),
        thenableWithOverride
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S
    ReactSharedInternals.S = function(transition, returnValue) {
      typeof returnValue == `object` && returnValue && typeof returnValue.then == `function`
      && entangleAsyncAction(transition, returnValue),
        prevOnStartTransitionFinish !== null && prevOnStartTransitionFinish(transition, returnValue)
    }
    var resumedCache = createCursor(null)
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current
      return cacheResumedFromPreviousRender === null ? workInProgressRoot.pooledCache : cacheResumedFromPreviousRender
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      prevCachePool === null ? push$1(resumedCache, resumedCache.current) : push$1(resumedCache, prevCachePool.pool)
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool()
      return cacheFromPool === null ? null : { parent: CacheContext._currentValue, pool: cacheFromPool }
    }
    var SuspenseException = Error(formatProdErrorMessage(460)),
      SuspenseyCommitException = Error(formatProdErrorMessage(474)),
      SuspenseActionException = Error(formatProdErrorMessage(542)),
      noopSuspenseyCommitThenable = { then: function() {} }
    function isThenableResolved(thenable) {
      return thenable = thenable.status, thenable === `fulfilled` || thenable === `rejected`
    }
    function noop$3() {}
    function trackUsedThenable(thenableState$2, thenable, index$4) {
      switch (
        index$4 = thenableState$2[index$4],
          index$4 === void 0
            ? thenableState$2.push(thenable)
            : index$4 !== thenable && (thenable.then(noop$3, noop$3), thenable = index$4),
          thenable.status
      ) {
        case `fulfilled`:
          return thenable.value
        case `rejected`:
          throw thenableState$2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState$2), thenableState$2
        default:
          if (typeof thenable.status == `string`) thenable.then(noop$3, noop$3)
          else {
            if (
              thenableState$2 = workInProgressRoot,
                thenableState$2 !== null && 100 < thenableState$2.shellSuspendCounter
            ) throw Error(formatProdErrorMessage(482))
            thenableState$2 = thenable,
              thenableState$2.status = `pending`,
              thenableState$2.then(function(fulfilledValue) {
                if (thenable.status === `pending`) {
                  var fulfilledThenable = thenable
                  fulfilledThenable.status = `fulfilled`, fulfilledThenable.value = fulfilledValue
                }
              }, function(error) {
                if (thenable.status === `pending`) {
                  var rejectedThenable = thenable
                  rejectedThenable.status = `rejected`, rejectedThenable.reason = error
                }
              })
          }
          switch (thenable.status) {
            case `fulfilled`:
              return thenable.value
            case `rejected`:
              throw thenableState$2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState$2), thenableState$2
          }
          throw suspendedThenable = thenable, SuspenseException
      }
    }
    var suspendedThenable = null
    function getSuspendedThenable() {
      if (suspendedThenable === null) throw Error(formatProdErrorMessage(459))
      var thenable = suspendedThenable
      return suspendedThenable = null, thenable
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) {
        throw Error(formatProdErrorMessage(483))
      }
    }
    var hasForceUpdate = !1
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null,
      }
    }
    function cloneUpdateQueue(current, workInProgress$1) {
      current = current.updateQueue,
        workInProgress$1.updateQueue === current
        && (workInProgress$1.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null,
        })
    }
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null }
    }
    function enqueueUpdate(fiber, update$5, lane) {
      var updateQueue = fiber.updateQueue
      if (updateQueue === null) return null
      if (updateQueue = updateQueue.shared, executionContext & 2) {
        var pending$2 = updateQueue.pending
        return pending$2 === null
          ? update$5.next = update$5
          : (update$5.next = pending$2.next, pending$2.next = update$5),
          updateQueue.pending = update$5,
          update$5 = getRootForUpdatedFiber(fiber),
          markUpdateLaneFromFiberToRoot(fiber, null, lane),
          update$5
      }
      return enqueueUpdate$1(fiber, updateQueue, update$5, lane), getRootForUpdatedFiber(fiber)
    }
    function entangleTransitions(root$5, fiber, lane) {
      if (fiber = fiber.updateQueue, fiber !== null && (fiber = fiber.shared, lane & 4194048)) {
        var queueLanes = fiber.lanes
        queueLanes &= root$5.pendingLanes, lane |= queueLanes, fiber.lanes = lane, markRootEntangled(root$5, lane)
      }
    }
    function enqueueCapturedUpdate(workInProgress$1, capturedUpdate) {
      var queue = workInProgress$1.updateQueue, current = workInProgress$1.alternate
      if (current !== null && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null
        if (queue = queue.firstBaseUpdate, queue !== null) {
          do {
            var clone$1 = { lane: queue.lane, tag: queue.tag, payload: queue.payload, callback: null, next: null }
            newLast === null ? newFirst = newLast = clone$1 : newLast = newLast.next = clone$1, queue = queue.next
          } while (queue !== null)
          newLast === null ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate
        } else newFirst = newLast = capturedUpdate
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks,
        }, workInProgress$1.updateQueue = queue
        return
      }
      workInProgress$1 = queue.lastBaseUpdate,
        workInProgress$1 === null ? queue.firstBaseUpdate = capturedUpdate : workInProgress$1.next = capturedUpdate,
        queue.lastBaseUpdate = capturedUpdate
    }
    var didReadFromEntangledAsyncAction = !1
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable
        if (entangledActionThenable !== null) throw entangledActionThenable
      }
    }
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes$1) {
      didReadFromEntangledAsyncAction = !1
      var queue = workInProgress$jscomp$0.updateQueue
      hasForceUpdate = !1
      var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending
      if (pendingQueue !== null) {
        queue.shared.pending = null
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next
        lastPendingUpdate.next = null,
          lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate,
          lastBaseUpdate = lastPendingUpdate
        var current = workInProgress$jscomp$0.alternate
        current !== null
          && (current = current.updateQueue,
            pendingQueue = current.lastBaseUpdate,
            pendingQueue !== lastBaseUpdate && (pendingQueue === null
              ? current.firstBaseUpdate = firstPendingUpdate
              : pendingQueue.next = firstPendingUpdate,
              current.lastBaseUpdate = lastPendingUpdate))
      }
      if (firstBaseUpdate !== null) {
        var newState = queue.baseState
        lastBaseUpdate = 0, current = firstPendingUpdate = lastPendingUpdate = null, pendingQueue = firstBaseUpdate
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane
          if (
            isHiddenUpdate
              ? (workInProgressRootRenderLanes & updateLane) === updateLane
              : (renderLanes$1 & updateLane) === updateLane
          ) {
            updateLane !== 0 && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0),
              current !== null
              && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null,
              })
            a: {
              var workInProgress$1 = workInProgress$jscomp$0, update$5 = pendingQueue
              updateLane = props
              var instance = instance$jscomp$0
              switch (update$5.tag) {
                case 1:
                  if (workInProgress$1 = update$5.payload, typeof workInProgress$1 == `function`) {
                    newState = workInProgress$1.call(instance, newState, updateLane)
                    break a
                  }
                  newState = workInProgress$1
                  break a
                case 3:
                  workInProgress$1.flags = workInProgress$1.flags & -65537 | 128
                case 0:
                  if (
                    workInProgress$1 = update$5.payload,
                      updateLane = typeof workInProgress$1 == `function`
                        ? workInProgress$1.call(instance, newState, updateLane)
                        : workInProgress$1,
                      updateLane == null
                  ) break a
                  newState = assign({}, newState, updateLane)
                  break a
                case 2:
                  hasForceUpdate = !0
              }
            }
            updateLane = pendingQueue.callback,
              updateLane !== null
              && (workInProgress$jscomp$0.flags |= 64,
                isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
                isHiddenUpdate = queue.callbacks,
                isHiddenUpdate === null ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane))
          } else {isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null,
            },
              current === null
                ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState)
                : current = current.next = isHiddenUpdate,
              lastBaseUpdate |= updateLane}
          if (pendingQueue = pendingQueue.next, pendingQueue === null) {
            if (pendingQueue = queue.shared.pending, pendingQueue === null) break
            isHiddenUpdate = pendingQueue,
              pendingQueue = isHiddenUpdate.next,
              isHiddenUpdate.next = null,
              queue.lastBaseUpdate = isHiddenUpdate,
              queue.shared.pending = null
          }
        } while (1)
        current === null && (lastPendingUpdate = newState),
          queue.baseState = lastPendingUpdate,
          queue.firstBaseUpdate = firstPendingUpdate,
          queue.lastBaseUpdate = current,
          firstBaseUpdate === null && (queue.shared.lanes = 0),
          workInProgressRootSkippedLanes |= lastBaseUpdate,
          workInProgress$jscomp$0.lanes = lastBaseUpdate,
          workInProgress$jscomp$0.memoizedState = newState
      }
    }
    function callCallback(callback, context$2) {
      if (typeof callback != `function`) throw Error(formatProdErrorMessage(191, callback))
      callback.call(context$2)
    }
    function commitCallbacks(updateQueue, context$2) {
      var callbacks = updateQueue.callbacks
      if (callbacks !== null) {
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) {
          callCallback(callbacks[updateQueue], context$2)
        }
      }
    }
    var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0)
    function pushHiddenContext(fiber, context$2) {
      fiber = entangledRenderLanes,
        push$1(prevEntangledRenderLanesCursor, fiber),
        push$1(currentTreeHiddenStackCursor, context$2),
        entangledRenderLanes = fiber | context$2.baseLanes
    }
    function reuseHiddenContextOnStack() {
      push$1(prevEntangledRenderLanesCursor, entangledRenderLanes),
        push$1(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current)
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current,
        pop(currentTreeHiddenStackCursor),
        pop(prevEntangledRenderLanesCursor)
    }
    var renderLanes = 0,
      currentlyRenderingFiber = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = !1,
      didScheduleRenderPhaseUpdateDuringThisPass = !1,
      shouldDoubleInvokeUserFnsInHooksDEV = !1,
      localIdCounter = 0,
      thenableIndexCounter$1 = 0,
      thenableState$1 = null,
      globalClientIdCounter = 0
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321))
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (prevDeps === null) return !1
      for (var i$14 = 0; i$14 < prevDeps.length && i$14 < nextDeps.length; i$14++) {
        if (!objectIs$1(nextDeps[i$14], prevDeps[i$14])) return !1
      }
      return !0
    }
    function renderWithHooks(current, workInProgress$1, Component$7, props, secondArg, nextRenderLanes) {
      return renderLanes = nextRenderLanes,
        currentlyRenderingFiber = workInProgress$1,
        workInProgress$1.memoizedState = null,
        workInProgress$1.updateQueue = null,
        workInProgress$1.lanes = 0,
        ReactSharedInternals.H = current === null || current.memoizedState === null
          ? HooksDispatcherOnMount
          : HooksDispatcherOnUpdate,
        shouldDoubleInvokeUserFnsInHooksDEV = !1,
        nextRenderLanes = Component$7(props, secondArg),
        shouldDoubleInvokeUserFnsInHooksDEV = !1,
        didScheduleRenderPhaseUpdateDuringThisPass
        && (nextRenderLanes = renderWithHooksAgain(workInProgress$1, Component$7, props, secondArg)),
        finishRenderingHooks(current),
        nextRenderLanes
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher
      var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null
      if (
        renderLanes = 0,
          workInProgressHook = currentHook = currentlyRenderingFiber = null,
          didScheduleRenderPhaseUpdate = !1,
          thenableIndexCounter$1 = 0,
          thenableState$1 = null,
          didRenderTooFewHooks
      ) throw Error(formatProdErrorMessage(300))
      current === null || didReceiveUpdate
        || (current = current.dependencies,
          current !== null && checkIfContextChanged(current) && (didReceiveUpdate = !0))
    }
    function renderWithHooksAgain(workInProgress$1, Component$7, props, secondArg) {
      currentlyRenderingFiber = workInProgress$1
      var numberOfReRenders = 0
      do {
        if (
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null),
            thenableIndexCounter$1 = 0,
            didScheduleRenderPhaseUpdateDuringThisPass = !1,
            25 <= numberOfReRenders
        ) throw Error(formatProdErrorMessage(301))
        if (numberOfReRenders += 1, workInProgressHook = currentHook = null, workInProgress$1.updateQueue != null) {
          var children$3 = workInProgress$1.updateQueue
          children$3.lastEffect = null,
            children$3.events = null,
            children$3.stores = null,
            children$3.memoCache != null && (children$3.memoCache.index = 0)
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender, children$3 = Component$7(props, secondArg)
      } while (didScheduleRenderPhaseUpdateDuringThisPass)
      return children$3
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0]
      return maybeThenable = typeof maybeThenable.then == `function` ? useThenable(maybeThenable) : maybeThenable,
        dispatcher = dispatcher.useState()[0],
        (currentHook === null ? null : currentHook.memoizedState) !== dispatcher
        && (currentlyRenderingFiber.flags |= 1024),
        maybeThenable
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = localIdCounter !== 0
      return localIdCounter = 0, didRenderIdHook
    }
    function bailoutHooks(current, workInProgress$1, lanes) {
      workInProgress$1.updateQueue = current.updateQueue, workInProgress$1.flags &= -2053, current.lanes &= ~lanes
    }
    function resetHooksOnUnwind(workInProgress$1) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress$1 = workInProgress$1.memoizedState; workInProgress$1 !== null;) {
          var queue = workInProgress$1.queue
          queue !== null && (queue.pending = null), workInProgress$1 = workInProgress$1.next
        }
        didScheduleRenderPhaseUpdate = !1
      }
      renderLanes = 0,
        workInProgressHook = currentHook = currentlyRenderingFiber = null,
        didScheduleRenderPhaseUpdateDuringThisPass = !1,
        thenableIndexCounter$1 = localIdCounter = 0,
        thenableState$1 = null
    }
    function mountWorkInProgressHook() {
      var hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
      return workInProgressHook === null
        ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook
        : workInProgressHook = workInProgressHook.next = hook,
        workInProgressHook
    }
    function updateWorkInProgressHook() {
      if (currentHook === null) {
        var nextCurrentHook = currentlyRenderingFiber.alternate
        nextCurrentHook = nextCurrentHook === null ? null : nextCurrentHook.memoizedState
      } else nextCurrentHook = currentHook.next
      var nextWorkInProgressHook = workInProgressHook === null
        ? currentlyRenderingFiber.memoizedState
        : workInProgressHook.next
      if (nextWorkInProgressHook !== null) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook
      else {
        if (nextCurrentHook === null) {
          throw currentlyRenderingFiber.alternate === null
            ? Error(formatProdErrorMessage(467))
            : Error(formatProdErrorMessage(310))
        }
        currentHook = nextCurrentHook,
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null,
          },
          workInProgressHook === null
            ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook
            : workInProgressHook = workInProgressHook.next = nextCurrentHook
      }
      return workInProgressHook
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null }
    }
    function useThenable(thenable) {
      var index$4 = thenableIndexCounter$1
      return thenableIndexCounter$1 += 1,
        thenableState$1 === null && (thenableState$1 = []),
        thenable = trackUsedThenable(thenableState$1, thenable, index$4),
        index$4 = currentlyRenderingFiber,
        (workInProgressHook === null ? index$4.memoizedState : workInProgressHook.next) === null
        && (index$4 = index$4.alternate,
          ReactSharedInternals.H = index$4 === null || index$4.memoizedState === null
            ? HooksDispatcherOnMount
            : HooksDispatcherOnUpdate),
        thenable
    }
    function use$1(usable) {
      if (typeof usable == `object` && usable) {
        if (typeof usable.then == `function`) return useThenable(usable)
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable)
      }
      throw Error(formatProdErrorMessage(438, String(usable)))
    }
    function useMemoCache(size$14) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue
      if (updateQueue !== null && (memoCache = updateQueue.memoCache), memoCache == null) {
        var current = currentlyRenderingFiber.alternate
        current !== null
          && (current = current.updateQueue,
            current !== null
            && (current = current.memoCache,
              current != null && (memoCache = {
                data: current.data.map(function(array$3) {
                  return array$3.slice()
                }),
                index: 0,
              })))
      }
      if (
        memoCache ??= { data: [], index: 0 },
          updateQueue === null
          && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue),
          updateQueue.memoCache = memoCache,
          updateQueue = memoCache.data[memoCache.index],
          updateQueue === void 0
      ) {
        for (
          updateQueue = memoCache.data[memoCache.index] = Array(size$14), current = 0;
          current < size$14;
          current++
        ) {
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL
        }
      }
      return memoCache.index++, updateQueue
    }
    function basicStateReducer(state, action) {
      return typeof action == `function` ? action(state) : action
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook()
      return updateReducerImpl(hook, currentHook, reducer)
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue
      if (queue === null) throw Error(formatProdErrorMessage(311))
      queue.lastRenderedReducer = reducer
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending
      if (pendingQueue !== null) {
        if (baseQueue !== null) {
          var baseFirst = baseQueue.next
          baseQueue.next = pendingQueue.next, pendingQueue.next = baseFirst
        }
        current.baseQueue = baseQueue = pendingQueue, queue.pending = null
      }
      if (pendingQueue = hook.baseState, baseQueue === null) hook.memoizedState = pendingQueue
      else {
        current = baseQueue.next
        var newBaseQueueFirst = baseFirst = null,
          newBaseQueueLast = null,
          update$5 = current,
          didReadFromEntangledAsyncAction$32 = !1
        do {
          var updateLane = update$5.lane & -536870913
          if (
            updateLane === update$5.lane
              ? (renderLanes & updateLane) === updateLane
              : (workInProgressRootRenderLanes & updateLane) === updateLane
          ) {
            var revertLane = update$5.revertLane
            if (revertLane === 0) {
              newBaseQueueLast !== null
              && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                action: update$5.action,
                hasEagerState: update$5.hasEagerState,
                eagerState: update$5.eagerState,
                next: null,
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = !0)
            } else if ((renderLanes & revertLane) === revertLane) {
              update$5 = update$5.next, revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = !0)
              continue
            } else {updateLane = {
                lane: 0,
                revertLane: update$5.revertLane,
                action: update$5.action,
                hasEagerState: update$5.hasEagerState,
                eagerState: update$5.eagerState,
                next: null,
              },
                newBaseQueueLast === null
                  ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue)
                  : newBaseQueueLast = newBaseQueueLast.next = updateLane,
                currentlyRenderingFiber.lanes |= revertLane,
                workInProgressRootSkippedLanes |= revertLane}
            updateLane = update$5.action,
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane),
              pendingQueue = update$5.hasEagerState ? update$5.eagerState : reducer(pendingQueue, updateLane)
          } else {revertLane = {
              lane: updateLane,
              revertLane: update$5.revertLane,
              action: update$5.action,
              hasEagerState: update$5.hasEagerState,
              eagerState: update$5.eagerState,
              next: null,
            },
              newBaseQueueLast === null
                ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue)
                : newBaseQueueLast = newBaseQueueLast.next = revertLane,
              currentlyRenderingFiber.lanes |= updateLane,
              workInProgressRootSkippedLanes |= updateLane}
          update$5 = update$5.next
        } while (update$5 !== null && update$5 !== current)
        if (
          newBaseQueueLast === null ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst,
            !objectIs$1(pendingQueue, hook.memoizedState)
            && (didReceiveUpdate = !0,
              didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, reducer !== null))
        ) throw reducer
        hook.memoizedState = pendingQueue,
          hook.baseState = baseFirst,
          hook.baseQueue = newBaseQueueLast,
          queue.lastRenderedState = pendingQueue
      }
      return baseQueue === null && (queue.lanes = 0), [hook.memoizedState, queue.dispatch]
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue
      if (queue === null) throw Error(formatProdErrorMessage(311))
      queue.lastRenderedReducer = reducer
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState
      if (lastRenderPhaseUpdate !== null) {
        queue.pending = null
        var update$5 = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next
        do newState = reducer(newState, update$5.action), update$5 = update$5.next
        while (update$5 !== lastRenderPhaseUpdate)
        objectIs$1(newState, hook.memoizedState) || (didReceiveUpdate = !0),
          hook.memoizedState = newState,
          hook.baseQueue === null && (hook.baseState = newState),
          queue.lastRenderedState = newState
      }
      return [newState, dispatch]
    }
    function updateSyncExternalStore(subscribe$1, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating
      if (isHydrating$jscomp$0) {
        if (getServerSnapshot === void 0) throw Error(formatProdErrorMessage(407))
        getServerSnapshot = getServerSnapshot()
      } else getServerSnapshot = getSnapshot()
      var snapshotChanged = !objectIs$1((currentHook || hook).memoizedState, getServerSnapshot)
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0), hook = hook.queue
      var create$2 = subscribeToStore.bind(null, fiber, hook, subscribe$1)
      if (
        updateEffectImpl(2048, 8, create$2, [subscribe$1]),
          hook.getSnapshot !== getSnapshot || snapshotChanged
          || workInProgressHook !== null && workInProgressHook.memoizedState.tag & 1
      ) {
        if (
          fiber.flags |= 2048,
            pushSimpleEffect(
              9,
              createEffectInstance(),
              updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot),
              null,
            ),
            workInProgressRoot === null
        ) throw Error(formatProdErrorMessage(349))
        isHydrating$jscomp$0 || renderLanes & 124 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot)
      }
      return getServerSnapshot
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384,
        fiber = { getSnapshot, value: renderedSnapshot },
        getSnapshot = currentlyRenderingFiber.updateQueue,
        getSnapshot === null
          ? (getSnapshot = createFunctionComponentUpdateQueue(),
            currentlyRenderingFiber.updateQueue = getSnapshot,
            getSnapshot.stores = [fiber])
          : (renderedSnapshot = getSnapshot.stores,
            renderedSnapshot === null ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber))
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot,
        inst.getSnapshot = getSnapshot,
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber)
    }
    function subscribeToStore(fiber, inst, subscribe$1) {
      return subscribe$1(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber)
      })
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot
      inst = inst.value
      try {
        var nextValue = latestGetSnapshot()
        return !objectIs$1(inst, nextValue)
      } catch {
        return !0
      }
    }
    function forceStoreRerender(fiber) {
      var root$5 = enqueueConcurrentRenderForLane(fiber, 2)
      root$5 !== null && scheduleUpdateOnFiber(root$5, fiber, 2)
    }
    function mountStateImpl(initialState$1) {
      var hook = mountWorkInProgressHook()
      if (typeof initialState$1 == `function`) {
        var initialStateInitializer = initialState$1
        if (initialState$1 = initialStateInitializer(), shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0)
          try {
            initialStateInitializer()
          } finally {
            setIsStrictModeForDevtools(!1)
          }
        }
      }
      return hook.memoizedState = hook.baseState = initialState$1,
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState$1,
        },
        hook
    }
    function updateOptimisticImpl(hook, current, passthrough$1, reducer) {
      return hook.baseState = passthrough$1,
        updateReducerImpl(hook, currentHook, typeof reducer == `function` ? reducer : basicStateReducer)
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485))
      if (fiber = actionQueue.action, fiber !== null) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: !0,
          status: `pending`,
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener)
          },
        }
        ReactSharedInternals.T === null ? actionNode.isTransition = !1 : setPendingState(!0),
          setState(actionNode),
          setPendingState = actionQueue.pending,
          setPendingState === null
            ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode))
            : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode)
      }
    }
    function runActionStateAction(actionQueue, node$1) {
      var action = node$1.action, payload = node$1.payload, prevState = actionQueue.state
      if (node$1.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {}
        ReactSharedInternals.T = currentTransition
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S
          onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue),
            handleActionReturnValue(actionQueue, node$1, returnValue)
        } catch (error) {
          onActionError(actionQueue, node$1, error)
        } finally {
          ReactSharedInternals.T = prevTransition
        }
      } else {try {
          prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node$1, prevTransition)
        } catch (error$38) {
          onActionError(actionQueue, node$1, error$38)
        }}
    }
    function handleActionReturnValue(actionQueue, node$1, returnValue) {
      typeof returnValue == `object` && returnValue && typeof returnValue.then == `function`
        ? returnValue.then(function(nextState) {
          onActionSuccess(actionQueue, node$1, nextState)
        }, function(error) {
          return onActionError(actionQueue, node$1, error)
        })
        : onActionSuccess(actionQueue, node$1, returnValue)
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = `fulfilled`,
        actionNode.value = nextState,
        notifyActionListeners(actionNode),
        actionQueue.state = nextState,
        actionNode = actionQueue.pending,
        actionNode !== null
        && (nextState = actionNode.next,
          nextState === actionNode
            ? actionQueue.pending = null
            : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)))
    }
    function onActionError(actionQueue, actionNode, error) {
      var last$3 = actionQueue.pending
      if (actionQueue.pending = null, last$3 !== null) {
        last$3 = last$3.next
        do actionNode.status = `rejected`,
          actionNode.reason = error,
          notifyActionListeners(actionNode),
          actionNode = actionNode.next
        while (actionNode !== last$3)
      }
      actionQueue.action = null
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners
      for (var i$14 = 0; i$14 < actionNode.length; i$14++) (0, actionNode[i$14])()
    }
    function actionStateReducer(oldState, newState) {
      return newState
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState
        if (ssrFormState !== null) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  for (
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance,
                      inRootOrSingleton = rootOrSingletonContext;
                    JSCompiler_inline_result$jscomp$0.nodeType !== 8;
                  ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null
                      break b
                    }
                    if (
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling,
                      ), JSCompiler_inline_result$jscomp$0 === null
                    ) {
                      JSCompiler_inline_result$jscomp$0 = null
                      break b
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data,
                    JSCompiler_inline_result$jscomp$0 = inRootOrSingleton === `F!` || inRootOrSingleton === `F`
                      ? JSCompiler_inline_result$jscomp$0
                      : null
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling),
                    JSCompiler_inline_result = JSCompiler_inline_result$jscomp$0.data === `F!`
                  break a
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result)
            }
            JSCompiler_inline_result = !1
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0])
        }
      }
      return ssrFormState = mountWorkInProgressHook(),
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp,
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp,
        },
        ssrFormState.queue = JSCompiler_inline_result,
        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result),
        JSCompiler_inline_result.dispatch = ssrFormState,
        JSCompiler_inline_result = mountStateImpl(!1),
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          !1,
          JSCompiler_inline_result.queue,
        ),
        JSCompiler_inline_result = mountWorkInProgressHook(),
        JSCompiler_inline_result$jscomp$0 = { state: initialStateProp, dispatch: null, action, pending: null },
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0,
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState,
        ),
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState,
        JSCompiler_inline_result.memoizedState = action,
        [initialStateProp, ssrFormState, !1]
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook()
      return updateActionStateImpl(stateHook, currentHook, action)
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      if (
        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0],
          stateHook = updateReducer(basicStateReducer)[0],
          typeof currentStateHook == `object` && currentStateHook && typeof currentStateHook.then == `function`
      ) {
        try {
          var state = useThenable(currentStateHook)
        } catch (x$2) {
          throw x$2 === SuspenseException ? SuspenseActionException : x$2
        }
      } else state = currentStateHook
      currentStateHook = updateWorkInProgressHook()
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch
      return action !== currentStateHook.memoizedState
        && (currentlyRenderingFiber.flags |= 2048,
          pushSimpleEffect(9, createEffectInstance(), actionStateActionEffect.bind(null, actionQueue, action), null)),
        [state, dispatch, stateHook]
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook
      if (currentStateHook !== null) return updateActionStateImpl(stateHook, currentStateHook, action)
      updateWorkInProgressHook(), stateHook = stateHook.memoizedState, currentStateHook = updateWorkInProgressHook()
      var dispatch = currentStateHook.queue.dispatch
      return currentStateHook.memoizedState = action, [stateHook, dispatch, !1]
    }
    function pushSimpleEffect(tag$3, inst, create$2, createDeps) {
      return tag$3 = { tag: tag$3, create: create$2, deps: createDeps, inst, next: null },
        inst = currentlyRenderingFiber.updateQueue,
        inst === null && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst),
        create$2 = inst.lastEffect,
        create$2 === null
          ? inst.lastEffect = tag$3.next = tag$3
          : (createDeps = create$2.next, create$2.next = tag$3, tag$3.next = createDeps, inst.lastEffect = tag$3),
        tag$3
    }
    function createEffectInstance() {
      return { destroy: void 0, resource: void 0 }
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState
    }
    function mountEffectImpl(fiberFlags, hookFlags, create$2, createDeps) {
      var hook = mountWorkInProgressHook()
      createDeps = createDeps === void 0 ? null : createDeps,
        currentlyRenderingFiber.flags |= fiberFlags,
        hook.memoizedState = pushSimpleEffect(1 | hookFlags, createEffectInstance(), create$2, createDeps)
    }
    function updateEffectImpl(fiberFlags, hookFlags, create$2, deps) {
      var hook = updateWorkInProgressHook()
      deps = deps === void 0 ? null : deps
      var inst = hook.memoizedState.inst
      currentHook !== null && deps !== null && areHookInputsEqual(deps, currentHook.memoizedState.deps)
        ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create$2, deps)
        : (currentlyRenderingFiber.flags |= fiberFlags,
          hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create$2, deps))
    }
    function mountEffect(create$2, createDeps) {
      mountEffectImpl(8390656, 8, create$2, createDeps)
    }
    function updateEffect(create$2, createDeps) {
      updateEffectImpl(2048, 8, create$2, createDeps)
    }
    function updateInsertionEffect(create$2, deps) {
      return updateEffectImpl(4, 2, create$2, deps)
    }
    function updateLayoutEffect(create$2, deps) {
      return updateEffectImpl(4, 4, create$2, deps)
    }
    function imperativeHandleEffect(create$2, ref) {
      if (typeof ref == `function`) {
        create$2 = create$2()
        var refCleanup = ref(create$2)
        return function() {
          typeof refCleanup == `function` ? refCleanup() : ref(null)
        }
      }
      if (ref != null) {
        return create$2 = create$2(), ref.current = create$2, function() {
          ref.current = null
        }
      }
    }
    function updateImperativeHandle(ref, create$2, deps) {
      deps = deps == null ? null : deps.concat([ref]),
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create$2, ref), deps)
    }
    function mountDebugValue() {}
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook()
      deps = deps === void 0 ? null : deps
      var prevState = hook.memoizedState
      return deps !== null && areHookInputsEqual(deps, prevState[1])
        ? prevState[0]
        : (hook.memoizedState = [callback, deps], callback)
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook()
      deps = deps === void 0 ? null : deps
      var prevState = hook.memoizedState
      if (deps !== null && areHookInputsEqual(deps, prevState[1])) return prevState[0]
      if (prevState = nextCreate(), shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0)
        try {
          nextCreate()
        } finally {
          setIsStrictModeForDevtools(!1)
        }
      }
      return hook.memoizedState = [prevState, deps], prevState
    }
    function mountDeferredValueImpl(hook, value$2, initialValue) {
      return initialValue === void 0 || renderLanes & 1073741824
        ? hook.memoizedState = value$2
        : (hook.memoizedState = initialValue,
          hook = requestDeferredLane(),
          currentlyRenderingFiber.lanes |= hook,
          workInProgressRootSkippedLanes |= hook,
          initialValue)
    }
    function updateDeferredValueImpl(hook, prevValue, value$2, initialValue) {
      return objectIs$1(value$2, prevValue)
        ? value$2
        : currentTreeHiddenStackCursor.current === null
        ? renderLanes & 42
          ? (hook = requestDeferredLane(),
            currentlyRenderingFiber.lanes |= hook,
            workInProgressRootSkippedLanes |= hook,
            prevValue)
          : (didReceiveUpdate = !0, hook.memoizedState = value$2)
        : (hook = mountDeferredValueImpl(hook, value$2, initialValue),
          objectIs$1(hook, prevValue) || (didReceiveUpdate = !0),
          hook)
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p
      ReactDOMSharedInternals.p = previousPriority !== 0 && 8 > previousPriority ? previousPriority : 8
      var prevTransition = ReactSharedInternals.T, currentTransition = {}
      ReactSharedInternals.T = currentTransition, dispatchOptimisticSetState(fiber, !1, queue, pendingState)
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S
        if (
          onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue),
            typeof returnValue == `object` && returnValue && typeof returnValue.then == `function`
        ) {
          var thenableForFinishedState = chainThenableValue(returnValue, finishedState)
          dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber))
        } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber))
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function() {}, status: `rejected`, reason: error },
          requestUpdateLane(),
        )
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition
      }
    }
    function noop$2() {}
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (formFiber.tag !== 5) throw Error(formatProdErrorMessage(476))
      var queue = ensureFormComponentIsStateful(formFiber).queue
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        action === null ? noop$2 : function() {
          return requestFormReset$1(formFiber), action(formData)
        },
      )
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState
      if (existingStateHook !== null) return existingStateHook
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject,
        },
        next: null,
      }
      var initialResetState = {}
      return existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState,
        },
        next: null,
      },
        formFiber.memoizedState = existingStateHook,
        formFiber = formFiber.alternate,
        formFiber !== null && (formFiber.memoizedState = existingStateHook),
        existingStateHook
    }
    function requestFormReset$1(formFiber) {
      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue
      dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane())
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext)
    }
    function updateId() {
      return updateWorkInProgressHook().memoizedState
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; provider !== null;) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane()
            fiber = createUpdate(lane)
            var root$41 = enqueueUpdate(provider, fiber, lane)
            root$41 !== null
            && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane)),
              provider = { cache: createCache() },
              fiber.payload = provider
            return
        }
        provider = provider.return
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane()
      action = { lane, revertLane: 0, action, hasEagerState: !1, eagerState: null, next: null },
        isRenderPhaseUpdate(fiber)
          ? enqueueRenderPhaseUpdate(queue, action)
          : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane),
            action !== null
            && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)))
    }
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane()
      dispatchSetStateInternal(fiber, queue, action, lane)
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update$5 = { lane, revertLane: 0, action, hasEagerState: !1, eagerState: null, next: null }
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update$5)
      else {
        var alternate = fiber.alternate
        if (
          fiber.lanes === 0 && (alternate === null || alternate.lanes === 0)
          && (alternate = queue.lastRenderedReducer, alternate !== null)
        ) {
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action)
            if (update$5.hasEagerState = !0, update$5.eagerState = eagerState, objectIs$1(eagerState, currentState)) {
              return enqueueUpdate$1(fiber, queue, update$5, 0),
                workInProgressRoot === null && finishQueueingConcurrentUpdates(),
                !1
            }
          } catch {}
        }
        if (action = enqueueConcurrentHookUpdate(fiber, queue, update$5, lane), action !== null) {
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0
        }
      }
      return !1
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      if (
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: !1,
          eagerState: null,
          next: null,
        }, isRenderPhaseUpdate(fiber)
      ) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479))
        else {throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2),
            throwIfDuringRender !== null && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2)}
      }
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate
      return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber
    }
    function enqueueRenderPhaseUpdate(queue, update$5) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0
      var pending$2 = queue.pending
      pending$2 === null ? update$5.next = update$5 : (update$5.next = pending$2.next, pending$2.next = update$5),
        queue.pending = update$5
    }
    function entangleTransitionUpdate(root$5, queue, lane) {
      if (lane & 4194048) {
        var queueLanes = queue.lanes
        queueLanes &= root$5.pendingLanes, lane |= queueLanes, queue.lanes = lane, markRootEntangled(root$5, lane)
      }
    }
    var ContextOnlyDispatcher = {
        readContext,
        use: use$1,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError,
      },
      HooksDispatcherOnMount = {
        readContext,
        use: use$1,
        useCallback: function(callback, deps) {
          return mountWorkInProgressHook().memoizedState = [callback, deps === void 0 ? null : deps], callback
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create$2, deps) {
          deps = deps == null ? null : deps.concat([ref]),
            mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create$2, ref), deps)
        },
        useLayoutEffect: function(create$2, deps) {
          return mountEffectImpl(4194308, 4, create$2, deps)
        },
        useInsertionEffect: function(create$2, deps) {
          mountEffectImpl(4, 2, create$2, deps)
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook()
          deps = deps === void 0 ? null : deps
          var nextValue = nextCreate()
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(!0)
            try {
              nextCreate()
            } finally {
              setIsStrictModeForDevtools(!1)
            }
          }
          return hook.memoizedState = [nextValue, deps], nextValue
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook()
          if (init !== void 0) {
            var initialState$1 = init(initialArg)
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(!0)
              try {
                init(initialArg)
              } finally {
                setIsStrictModeForDevtools(!1)
              }
            }
          } else initialState$1 = initialArg
          return hook.memoizedState = hook.baseState = initialState$1,
            reducer = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState$1,
            },
            hook.queue = reducer,
            reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer),
            [hook.memoizedState, reducer]
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook()
          return initialValue = { current: initialValue }, hook.memoizedState = initialValue
        },
        useState: function(initialState$1) {
          initialState$1 = mountStateImpl(initialState$1)
          var queue = initialState$1.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue)
          return queue.dispatch = dispatch, [initialState$1.memoizedState, dispatch]
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value$2, initialValue) {
          var hook = mountWorkInProgressHook()
          return mountDeferredValueImpl(hook, value$2, initialValue)
        },
        useTransition: function() {
          var stateHook = mountStateImpl(!1)
          return stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, !0, !1),
            mountWorkInProgressHook().memoizedState = stateHook,
            [!1, stateHook]
        },
        useSyncExternalStore: function(subscribe$1, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook()
          if (isHydrating) {
            if (getServerSnapshot === void 0) throw Error(formatProdErrorMessage(407))
            getServerSnapshot = getServerSnapshot()
          } else {
            if (getServerSnapshot = getSnapshot(), workInProgressRoot === null) throw Error(formatProdErrorMessage(349))
            workInProgressRootRenderLanes & 124 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot)
          }
          hook.memoizedState = getServerSnapshot
          var inst = { value: getServerSnapshot, getSnapshot }
          return hook.queue = inst,
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe$1), [subscribe$1]),
            fiber.flags |= 2048,
            pushSimpleEffect(
              9,
              createEffectInstance(),
              updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot),
              null,
            ),
            getServerSnapshot
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow, idWithLeadingBit = treeContextId
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32)
              + JSCompiler_inline_result,
              identifierPrefix = `` + identifierPrefix + `R` + JSCompiler_inline_result,
              JSCompiler_inline_result = localIdCounter++,
              0 < JSCompiler_inline_result && (identifierPrefix += `H` + JSCompiler_inline_result.toString(32)),
              identifierPrefix += ``
          } else {JSCompiler_inline_result = globalClientIdCounter++,
              identifierPrefix = `` + identifierPrefix + `r` + JSCompiler_inline_result.toString(32) + ``}
          return hook.memoizedState = identifierPrefix
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough$1) {
          var hook = mountWorkInProgressHook()
          hook.memoizedState = hook.baseState = passthrough$1
          var queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }
          return hook.queue = queue,
            hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, queue),
            queue.dispatch = hook,
            [passthrough$1, hook]
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber)
        },
      },
      HooksDispatcherOnUpdate = {
        readContext,
        use: use$1,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer)
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value$2, initialValue) {
          var hook = updateWorkInProgressHook()
          return updateDeferredValueImpl(hook, currentHook.memoizedState, value$2, initialValue)
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0],
            start$2 = updateWorkInProgressHook().memoizedState
          return [typeof booleanOrThenable == `boolean` ? booleanOrThenable : useThenable(booleanOrThenable), start$2]
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough$1, reducer) {
          var hook = updateWorkInProgressHook()
          return updateOptimisticImpl(hook, currentHook, passthrough$1, reducer)
        },
        useMemoCache,
        useCacheRefresh: updateRefresh,
      },
      HooksDispatcherOnRerender = {
        readContext,
        use: use$1,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer)
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value$2, initialValue) {
          var hook = updateWorkInProgressHook()
          return currentHook === null
            ? mountDeferredValueImpl(hook, value$2, initialValue)
            : updateDeferredValueImpl(hook, currentHook.memoizedState, value$2, initialValue)
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
            start$2 = updateWorkInProgressHook().memoizedState
          return [typeof booleanOrThenable == `boolean` ? booleanOrThenable : useThenable(booleanOrThenable), start$2]
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough$1, reducer) {
          var hook = updateWorkInProgressHook()
          return currentHook === null
            ? (hook.baseState = passthrough$1, [passthrough$1, hook.queue.dispatch])
            : updateOptimisticImpl(hook, currentHook, passthrough$1, reducer)
        },
        useMemoCache,
        useCacheRefresh: updateRefresh,
      },
      thenableState = null,
      thenableIndexCounter = 0
    function unwrapThenable(thenable) {
      var index$4 = thenableIndexCounter
      return thenableIndexCounter += 1,
        thenableState === null && (thenableState = []),
        trackUsedThenable(thenableState, thenable, index$4)
    }
    function coerceRef(workInProgress$1, element$2) {
      element$2 = element$2.props.ref, workInProgress$1.ref = element$2 === void 0 ? null : element$2
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      throw newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE
        ? Error(formatProdErrorMessage(525))
        : (returnFiber = Object.prototype.toString.call(newChild),
          Error(formatProdErrorMessage(
            31,
            returnFiber === `[object Object]`
              ? `object with keys {` + Object.keys(newChild).join(`, `) + `}`
              : returnFiber,
          )))
    }
    function resolveLazy(lazyType) {
      var init = lazyType._init
      return init(lazyType._payload)
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions
          deletions === null
            ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16)
            : deletions.push(childToDelete)
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null
        for (; currentFirstChild !== null;) {
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling
        }
        return null
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); currentFirstChild !== null;) {
          currentFirstChild.key === null
            ? existingChildren.set(currentFirstChild.index, currentFirstChild)
            : existingChildren.set(currentFirstChild.key, currentFirstChild),
            currentFirstChild = currentFirstChild.sibling
        }
        return existingChildren
      }
      function useFiber(fiber, pendingProps) {
        return fiber = createWorkInProgress(fiber, pendingProps), fiber.index = 0, fiber.sibling = null, fiber
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        return newFiber.index = newIndex,
          shouldTrackSideEffects
            ? (newIndex = newFiber.alternate,
              newIndex === null
                ? (newFiber.flags |= 67108866, lastPlacedIndex)
                : (newIndex = newIndex.index,
                  newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex))
            : (newFiber.flags |= 1048576, lastPlacedIndex)
      }
      function placeSingleChild(newFiber) {
        return shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= 67108866), newFiber
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        return current === null || current.tag !== 6
          ? (current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current)
          : (current = useFiber(current, textContent), current.return = returnFiber, current)
      }
      function updateElement(returnFiber, current, element$2, lanes) {
        var elementType = element$2.type
        return elementType === REACT_FRAGMENT_TYPE
          ? updateFragment(returnFiber, current, element$2.props.children, lanes, element$2.key)
          : current !== null
              && (current.elementType === elementType
                || typeof elementType == `object` && elementType && elementType.$$typeof === REACT_LAZY_TYPE
                  && resolveLazy(elementType) === current.type)
          ? (current = useFiber(current, element$2.props),
            coerceRef(current, element$2),
            current.return = returnFiber,
            current)
          : (current = createFiberFromTypeAndProps(
            element$2.type,
            element$2.key,
            element$2.props,
            null,
            returnFiber.mode,
            lanes,
          ),
            coerceRef(current, element$2),
            current.return = returnFiber,
            current)
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        return current === null || current.tag !== 4 || current.stateNode.containerInfo !== portal.containerInfo
            || current.stateNode.implementation !== portal.implementation
          ? (current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current)
          : (current = useFiber(current, portal.children || []), current.return = returnFiber, current)
      }
      function updateFragment(returnFiber, current, fragment, lanes, key$1) {
        return current === null || current.tag !== 7
          ? (current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key$1),
            current.return = returnFiber,
            current)
          : (current = useFiber(current, fragment), current.return = returnFiber, current)
      }
      function createChild(returnFiber, newChild, lanes) {
        if (
          typeof newChild == `string` && newChild !== `` || typeof newChild == `number` || typeof newChild == `bigint`
        ) {
          return newChild = createFiberFromText(`` + newChild, returnFiber.mode, lanes),
            newChild.return = returnFiber,
            newChild
        }
        if (typeof newChild == `object` && newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes,
              ),
                coerceRef(lanes, newChild),
                lanes.return = returnFiber,
                lanes
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes),
                newChild.return = returnFiber,
                newChild
            case REACT_LAZY_TYPE:
              var init = newChild._init
              return newChild = init(newChild._payload), createChild(returnFiber, newChild, lanes)
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null),
              newChild.return = returnFiber,
              newChild
          }
          if (typeof newChild.then == `function`) return createChild(returnFiber, unwrapThenable(newChild), lanes)
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
            return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes)
          }
          throwOnInvalidObjectType(returnFiber, newChild)
        }
        return null
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key$1 = oldFiber === null ? null : oldFiber.key
        if (
          typeof newChild == `string` && newChild !== `` || typeof newChild == `number` || typeof newChild == `bigint`
        ) return key$1 === null ? updateTextNode(returnFiber, oldFiber, `` + newChild, lanes) : null
        if (typeof newChild == `object` && newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key$1 ? updateElement(returnFiber, oldFiber, newChild, lanes) : null
            case REACT_PORTAL_TYPE:
              return newChild.key === key$1 ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null
            case REACT_LAZY_TYPE:
              return key$1 = newChild._init,
                newChild = key$1(newChild._payload),
                updateSlot(returnFiber, oldFiber, newChild, lanes)
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            return key$1 === null
              ? updateFragment(returnFiber, oldFiber, newChild, lanes, null)
              : null
          }
          if (typeof newChild.then == `function`) {
            return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes)
          }
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
            return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes)
          }
          throwOnInvalidObjectType(returnFiber, newChild)
        }
        return null
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if (
          typeof newChild == `string` && newChild !== `` || typeof newChild == `number` || typeof newChild == `bigint`
        ) {
          return existingChildren = existingChildren.get(newIdx) || null,
            updateTextNode(returnFiber, existingChildren, `` + newChild, lanes)
        }
        if (typeof newChild == `object` && newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null,
                updateElement(returnFiber, existingChildren, newChild, lanes)
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null,
                updatePortal(returnFiber, existingChildren, newChild, lanes)
            case REACT_LAZY_TYPE:
              var init = newChild._init
              return newChild = init(newChild._payload),
                updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes)
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            return existingChildren = existingChildren.get(newIdx) || null,
              updateFragment(returnFiber, existingChildren, newChild, lanes, null)
          }
          if (typeof newChild.then == `function`) {
            return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes)
          }
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes,
            )
          }
          throwOnInvalidObjectType(returnFiber, newChild)
        }
        return null
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (
          var resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = currentFirstChild = 0,
            nextOldFiber = null;
          oldFiber !== null && newIdx < newChildren.length;
          newIdx++
        ) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes)
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber)
            break
          }
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber),
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx),
            previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber,
            previousNewFiber = newFiber,
            oldFiber = nextOldFiber
        }
        if (newIdx === newChildren.length) {
          return deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
        }
        if (oldFiber === null) {
          for (; newIdx < newChildren.length; newIdx++) {
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes),
              oldFiber !== null
              && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx),
                previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber,
                previousNewFiber = oldFiber)
          }
          return isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) {
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes),
            nextOldFiber !== null
            && (shouldTrackSideEffects && nextOldFiber.alternate !== null
              && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key),
              currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx),
              previousNewFiber === null
                ? resultingFirstChild = nextOldFiber
                : previousNewFiber.sibling = nextOldFiber,
              previousNewFiber = nextOldFiber)
        }
        return shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child)
        }),
          isHydrating && pushTreeFork(returnFiber, newIdx),
          resultingFirstChild
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (newChildren == null) throw Error(formatProdErrorMessage(151))
        for (
          var resultingFirstChild = null,
            previousNewFiber = null,
            oldFiber = currentFirstChild,
            newIdx = currentFirstChild = 0,
            nextOldFiber = null,
            step$3 = newChildren.next();
          oldFiber !== null && !step$3.done;
          newIdx++, step$3 = newChildren.next()
        ) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling
          var newFiber = updateSlot(returnFiber, oldFiber, step$3.value, lanes)
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber)
            break
          }
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber),
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx),
            previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber,
            previousNewFiber = newFiber,
            oldFiber = nextOldFiber
        }
        if (step$3.done) {
          return deleteRemainingChildren(returnFiber, oldFiber),
            isHydrating && pushTreeFork(returnFiber, newIdx),
            resultingFirstChild
        }
        if (oldFiber === null) {
          for (; !step$3.done; newIdx++, step$3 = newChildren.next()) {
            step$3 = createChild(returnFiber, step$3.value, lanes),
              step$3 !== null
              && (currentFirstChild = placeChild(step$3, currentFirstChild, newIdx),
                previousNewFiber === null ? resultingFirstChild = step$3 : previousNewFiber.sibling = step$3,
                previousNewFiber = step$3)
          }
          return isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step$3.done; newIdx++, step$3 = newChildren.next()) {
          step$3 = updateFromMap(oldFiber, returnFiber, newIdx, step$3.value, lanes),
            step$3 !== null
            && (shouldTrackSideEffects && step$3.alternate !== null
              && oldFiber.delete(step$3.key === null ? newIdx : step$3.key),
              currentFirstChild = placeChild(step$3, currentFirstChild, newIdx),
              previousNewFiber === null ? resultingFirstChild = step$3 : previousNewFiber.sibling = step$3,
              previousNewFiber = step$3)
        }
        return shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child)
        }),
          isHydrating && pushTreeFork(returnFiber, newIdx),
          resultingFirstChild
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        if (
          typeof newChild == `object` && newChild && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null
          && (newChild = newChild.props.children), typeof newChild == `object` && newChild
        ) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key$1 = newChild.key; currentFirstChild !== null;) {
                  if (currentFirstChild.key === key$1) {
                    if (key$1 = newChild.type, key$1 === REACT_FRAGMENT_TYPE) {
                      if (currentFirstChild.tag === 7) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
                          lanes = useFiber(currentFirstChild, newChild.props.children),
                          lanes.return = returnFiber,
                          returnFiber = lanes
                        break a
                      }
                    } else if (
                      currentFirstChild.elementType === key$1
                      || typeof key$1 == `object` && key$1 && key$1.$$typeof === REACT_LAZY_TYPE
                        && resolveLazy(key$1) === currentFirstChild.type
                    ) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
                        lanes = useFiber(currentFirstChild, newChild.props),
                        coerceRef(lanes, newChild),
                        lanes.return = returnFiber,
                        returnFiber = lanes
                      break a
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild)
                    break
                  } else deleteChild(returnFiber, currentFirstChild)
                  currentFirstChild = currentFirstChild.sibling
                }
                newChild.type === REACT_FRAGMENT_TYPE
                  ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key),
                    lanes.return = returnFiber,
                    returnFiber = lanes)
                  : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes,
                  ),
                    coerceRef(lanes, newChild),
                    lanes.return = returnFiber,
                    returnFiber = lanes)
              }
              return placeSingleChild(returnFiber)
            case REACT_PORTAL_TYPE:
              a: {
                for (key$1 = newChild.key; currentFirstChild !== null;) {
                  if (currentFirstChild.key === key$1) {
                    if (
                      currentFirstChild.tag === 4
                      && currentFirstChild.stateNode.containerInfo === newChild.containerInfo
                      && currentFirstChild.stateNode.implementation === newChild.implementation
                    ) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
                        lanes = useFiber(currentFirstChild, newChild.children || []),
                        lanes.return = returnFiber,
                        returnFiber = lanes
                      break a
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild)
                      break
                    }
                  } else deleteChild(returnFiber, currentFirstChild)
                  currentFirstChild = currentFirstChild.sibling
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes),
                  lanes.return = returnFiber,
                  returnFiber = lanes
              }
              return placeSingleChild(returnFiber)
            case REACT_LAZY_TYPE:
              return key$1 = newChild._init,
                newChild = key$1(newChild._payload),
                reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes)
          }
          if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes)
          if (getIteratorFn(newChild)) {
            if (key$1 = getIteratorFn(newChild), typeof key$1 != `function`) throw Error(formatProdErrorMessage(150))
            return newChild = key$1.call(newChild),
              reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes)
          }
          if (typeof newChild.then == `function`) {
            return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes)
          }
          if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes,
            )
          }
          throwOnInvalidObjectType(returnFiber, newChild)
        }
        return typeof newChild == `string` && newChild !== `` || typeof newChild == `number`
            || typeof newChild == `bigint`
          ? (newChild = `` + newChild,
            currentFirstChild !== null && currentFirstChild.tag === 6
              ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
                lanes = useFiber(currentFirstChild, newChild),
                lanes.return = returnFiber,
                returnFiber = lanes)
              : (deleteRemainingChildren(returnFiber, currentFirstChild),
                lanes = createFiberFromText(newChild, returnFiber.mode, lanes),
                lanes.return = returnFiber,
                returnFiber = lanes),
            placeSingleChild(returnFiber))
          : deleteRemainingChildren(returnFiber, currentFirstChild)
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter = 0
          var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes)
          return thenableState = null, firstChildFiber
        } catch (x$2) {
          if (x$2 === SuspenseException || x$2 === SuspenseActionException) throw x$2
          var fiber = createFiberImplClass(29, x$2, null, returnFiber.mode)
          return fiber.lanes = lanes, fiber.return = returnFiber, fiber
        }
      }
    }
    var reconcileChildFibers = createChildReconciler(!0),
      mountChildFibers = createChildReconciler(!1),
      suspenseHandlerStackCursor = createCursor(null),
      shellBoundary = null
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate
      push$1(suspenseStackCursor, suspenseStackCursor.current & 1),
        push$1(suspenseHandlerStackCursor, handler),
        shellBoundary === null
        && (current === null || currentTreeHiddenStackCursor.current !== null || current.memoizedState !== null)
        && (shellBoundary = handler)
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (fiber.tag === 22) {
        if (
          push$1(suspenseStackCursor, suspenseStackCursor.current),
            push$1(suspenseHandlerStackCursor, fiber),
            shellBoundary === null
        ) {
          var current = fiber.alternate
          current !== null && current.memoizedState !== null && (shellBoundary = fiber)
        }
      } else reuseSuspenseHandlerOnStack(fiber)
    }
    function reuseSuspenseHandlerOnStack() {
      push$1(suspenseStackCursor, suspenseStackCursor.current),
        push$1(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current)
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor), shellBoundary === fiber && (shellBoundary = null), pop(suspenseStackCursor)
    }
    var suspenseStackCursor = createCursor(0)
    function findFirstSuspended(row) {
      for (var node$1 = row; node$1 !== null;) {
        if (node$1.tag === 13) {
          var state = node$1.memoizedState
          if (
            state !== null
            && (state = state.dehydrated, state === null || state.data === `$?` || isSuspenseInstanceFallback(state))
          ) return node$1
        } else if (node$1.tag === 19 && node$1.memoizedProps.revealOrder !== void 0) {
          if (node$1.flags & 128) return node$1
        } else if (node$1.child !== null) {
          node$1.child.return = node$1, node$1 = node$1.child
          continue
        }
        if (node$1 === row) break
        for (; node$1.sibling === null;) {
          if (node$1.return === null || node$1.return === row) return null
          node$1 = node$1.return
        }
        node$1.sibling.return = node$1.return, node$1 = node$1.sibling
      }
      return null
    }
    function applyDerivedStateFromProps(workInProgress$1, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress$1.memoizedState,
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor),
        getDerivedStateFromProps = getDerivedStateFromProps == null ? ctor : assign({}, ctor, getDerivedStateFromProps),
        workInProgress$1.memoizedState = getDerivedStateFromProps,
        workInProgress$1.lanes === 0 && (workInProgress$1.updateQueue.baseState = getDerivedStateFromProps)
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals
        var lane = requestUpdateLane(), update$5 = createUpdate(lane)
        update$5.payload = payload,
          callback != null && (update$5.callback = callback),
          payload = enqueueUpdate(inst, update$5, lane),
          payload !== null && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane))
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals
        var lane = requestUpdateLane(), update$5 = createUpdate(lane)
        update$5.tag = 1,
          update$5.payload = payload,
          callback != null && (update$5.callback = callback),
          payload = enqueueUpdate(inst, update$5, lane),
          payload !== null && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane))
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals
        var lane = requestUpdateLane(), update$5 = createUpdate(lane)
        update$5.tag = 2,
          callback != null && (update$5.callback = callback),
          callback = enqueueUpdate(inst, update$5, lane),
          callback !== null && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane))
      },
    }
    function checkShouldComponentUpdate(workInProgress$1, ctor, oldProps, newProps, oldState, newState, nextContext) {
      return workInProgress$1 = workInProgress$1.stateNode,
        typeof workInProgress$1.shouldComponentUpdate == `function`
          ? workInProgress$1.shouldComponentUpdate(newProps, newState, nextContext)
          : ctor.prototype && ctor.prototype.isPureReactComponent
          ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
          : !0
    }
    function callComponentWillReceiveProps(workInProgress$1, instance, newProps, nextContext) {
      workInProgress$1 = instance.state,
        typeof instance.componentWillReceiveProps == `function`
        && instance.componentWillReceiveProps(newProps, nextContext),
        typeof instance.UNSAFE_componentWillReceiveProps == `function`
        && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext),
        instance.state !== workInProgress$1 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null)
    }
    function resolveClassComponentProps(Component$7, baseProps) {
      var newProps = baseProps
      if (`ref` in baseProps) {
        for (var propName in newProps = {}, baseProps) {
          propName !== `ref` && (newProps[propName] = baseProps[propName])
        }
      }
      if (Component$7 = Component$7.defaultProps) {
        for (var propName$73 in newProps === baseProps && (newProps = assign({}, newProps)), Component$7) {
          newProps[propName$73] === void 0 && (newProps[propName$73] = Component$7[propName$73])
        }
      }
      return newProps
    }
    var reportGlobalError = typeof reportError == `function` ? reportError : function(error) {
      if (typeof window == `object` && typeof window.ErrorEvent == `function`) {
        var event = new window.ErrorEvent(`error`, {
          bubbles: !0,
          cancelable: !0,
          message: typeof error == `object` && error && typeof error.message == `string`
            ? String(error.message)
            : String(error),
          error,
        })
        if (!window.dispatchEvent(event)) return
      } else if (typeof process == `object` && typeof process.emit == `function`) {
        process.emit(`uncaughtException`, error)
        return
      }
      console.error(error)
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error)
    }
    function defaultOnCaughtError(error) {
      console.error(error)
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error)
    }
    function logUncaughtError(root$5, errorInfo) {
      try {
        var onUncaughtError = root$5.onUncaughtError
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack })
      } catch (e$74) {
        setTimeout(function() {
          throw e$74
        })
      }
    }
    function logCaughtError(root$5, boundary, errorInfo) {
      try {
        var onCaughtError = root$5.onCaughtError
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: boundary.tag === 1 ? boundary.stateNode : null,
        })
      } catch (e$75) {
        setTimeout(function() {
          throw e$75
        })
      }
    }
    function createRootErrorUpdate(root$5, errorInfo, lane) {
      return lane = createUpdate(lane),
        lane.tag = 3,
        lane.payload = { element: null },
        lane.callback = function() {
          logUncaughtError(root$5, errorInfo)
        },
        lane
    }
    function createClassErrorUpdate(lane) {
      return lane = createUpdate(lane), lane.tag = 3, lane
    }
    function initializeClassErrorUpdate(update$5, root$5, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError
      if (typeof getDerivedStateFromError == `function`) {
        var error = errorInfo.value
        update$5.payload = function() {
          return getDerivedStateFromError(error)
        },
          update$5.callback = function() {
            logCaughtError(root$5, fiber, errorInfo)
          }
      }
      var inst = fiber.stateNode
      inst !== null && typeof inst.componentDidCatch == `function` && (update$5.callback = function() {
        logCaughtError(root$5, fiber, errorInfo),
          typeof getDerivedStateFromError != `function`
          && (legacyErrorBoundariesThatAlreadyFailed === null
            ? legacyErrorBoundariesThatAlreadyFailed = new Set([this])
            : legacyErrorBoundariesThatAlreadyFailed.add(this))
        var stack = errorInfo.stack
        this.componentDidCatch(errorInfo.value, { componentStack: stack === null ? `` : stack })
      })
    }
    function throwException(root$5, returnFiber, sourceFiber, value$2, rootRenderLanes) {
      if (sourceFiber.flags |= 32768, typeof value$2 == `object` && value$2 && typeof value$2.then == `function`) {
        if (
          returnFiber = sourceFiber.alternate,
            returnFiber !== null && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0),
            sourceFiber = suspenseHandlerStackCursor.current,
            sourceFiber !== null
        ) {
          switch (sourceFiber.tag) {
            case 13:
              return shellBoundary === null
                ? renderDidSuspendDelayIfPossible()
                : sourceFiber.alternate === null && workInProgressRootExitStatus === 0
                  && (workInProgressRootExitStatus = 3),
                sourceFiber.flags &= -257,
                sourceFiber.flags |= 65536,
                sourceFiber.lanes = rootRenderLanes,
                value$2 === noopSuspenseyCommitThenable
                  ? sourceFiber.flags |= 16384
                  : (returnFiber = sourceFiber.updateQueue,
                    returnFiber === null ? sourceFiber.updateQueue = new Set([value$2]) : returnFiber.add(value$2),
                    attachPingListener(root$5, value$2, rootRenderLanes)),
                !1
            case 22:
              return sourceFiber.flags |= 65536,
                value$2 === noopSuspenseyCommitThenable
                  ? sourceFiber.flags |= 16384
                  : (returnFiber = sourceFiber.updateQueue,
                    returnFiber === null
                      ? (returnFiber = { transitions: null, markerInstances: null, retryQueue: new Set([value$2]) },
                        sourceFiber.updateQueue = returnFiber)
                      : (sourceFiber = returnFiber.retryQueue,
                        sourceFiber === null ? returnFiber.retryQueue = new Set([value$2]) : sourceFiber.add(value$2)),
                    attachPingListener(root$5, value$2, rootRenderLanes)),
                !1
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag))
        }
        return attachPingListener(root$5, value$2, rootRenderLanes), renderDidSuspendDelayIfPossible(), !1
      }
      if (isHydrating) {
        return returnFiber = suspenseHandlerStackCursor.current,
          returnFiber === null
            ? (value$2 !== HydrationMismatchException
              && (returnFiber = Error(formatProdErrorMessage(423), { cause: value$2 }),
                queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))),
              root$5 = root$5.current.alternate,
              root$5.flags |= 65536,
              rootRenderLanes &= -rootRenderLanes,
              root$5.lanes |= rootRenderLanes,
              value$2 = createCapturedValueAtFiber(value$2, sourceFiber),
              rootRenderLanes = createRootErrorUpdate(root$5.stateNode, value$2, rootRenderLanes),
              enqueueCapturedUpdate(root$5, rootRenderLanes),
              workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2))
            : (!(returnFiber.flags & 65536) && (returnFiber.flags |= 256),
              returnFiber.flags |= 65536,
              returnFiber.lanes = rootRenderLanes,
              value$2 !== HydrationMismatchException
              && (root$5 = Error(formatProdErrorMessage(422), { cause: value$2 }),
                queueHydrationError(createCapturedValueAtFiber(root$5, sourceFiber)))),
          !1
      }
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value$2 })
      if (
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber),
          workInProgressRootConcurrentErrors === null
            ? workInProgressRootConcurrentErrors = [wrapperError]
            : workInProgressRootConcurrentErrors.push(wrapperError),
          workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2),
          returnFiber === null
      ) return !0
      value$2 = createCapturedValueAtFiber(value$2, sourceFiber), sourceFiber = returnFiber
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536,
              root$5 = rootRenderLanes & -rootRenderLanes,
              sourceFiber.lanes |= root$5,
              root$5 = createRootErrorUpdate(sourceFiber.stateNode, value$2, root$5),
              enqueueCapturedUpdate(sourceFiber, root$5),
              !1
          case 1:
            if (
              returnFiber = sourceFiber.type,
                wrapperError = sourceFiber.stateNode,
                !(sourceFiber.flags & 128)
                && (typeof returnFiber.getDerivedStateFromError == `function`
                  || wrapperError !== null && typeof wrapperError.componentDidCatch == `function`
                    && (legacyErrorBoundariesThatAlreadyFailed === null
                      || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))
            ) {
              return sourceFiber.flags |= 65536,
                rootRenderLanes &= -rootRenderLanes,
                sourceFiber.lanes |= rootRenderLanes,
                rootRenderLanes = createClassErrorUpdate(rootRenderLanes),
                initializeClassErrorUpdate(rootRenderLanes, root$5, sourceFiber, value$2),
                enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
                !1
            }
        }
        sourceFiber = sourceFiber.return
      } while (sourceFiber !== null)
      return !1
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = !1
    function reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1) {
      workInProgress$1.child = current === null
        ? mountChildFibers(workInProgress$1, null, nextChildren, renderLanes$1)
        : reconcileChildFibers(workInProgress$1, current.child, nextChildren, renderLanes$1)
    }
    function updateForwardRef(current, workInProgress$1, Component$7, nextProps, renderLanes$1) {
      Component$7 = Component$7.render
      var ref = workInProgress$1.ref
      if (`ref` in nextProps) {
        var propsWithoutRef = {}
        for (var key$1 in nextProps) key$1 !== `ref` && (propsWithoutRef[key$1] = nextProps[key$1])
      } else propsWithoutRef = nextProps
      return prepareToReadContext(workInProgress$1),
        nextProps = renderWithHooks(current, workInProgress$1, Component$7, propsWithoutRef, ref, renderLanes$1),
        key$1 = checkDidRenderIdHook(),
        current !== null && !didReceiveUpdate
          ? (bailoutHooks(current, workInProgress$1, renderLanes$1),
            bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1))
          : (isHydrating && key$1 && pushMaterializedTreeId(workInProgress$1),
            workInProgress$1.flags |= 1,
            reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1),
            workInProgress$1.child)
    }
    function updateMemoComponent(current, workInProgress$1, Component$7, nextProps, renderLanes$1) {
      if (current === null) {
        var type$2 = Component$7.type
        return typeof type$2 == `function` && !shouldConstruct(type$2) && type$2.defaultProps === void 0
            && Component$7.compare === null
          ? (workInProgress$1.tag = 15,
            workInProgress$1.type = type$2,
            updateSimpleMemoComponent(current, workInProgress$1, type$2, nextProps, renderLanes$1))
          : (current = createFiberFromTypeAndProps(
            Component$7.type,
            null,
            nextProps,
            workInProgress$1,
            workInProgress$1.mode,
            renderLanes$1,
          ),
            current.ref = workInProgress$1.ref,
            current.return = workInProgress$1,
            workInProgress$1.child = current)
      }
      if (type$2 = current.child, !checkScheduledUpdateOrContext(current, renderLanes$1)) {
        var prevProps = type$2.memoizedProps
        if (
          Component$7 = Component$7.compare,
            Component$7 = Component$7 === null ? shallowEqual : Component$7,
            Component$7(prevProps, nextProps) && current.ref === workInProgress$1.ref
        ) return bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1)
      }
      return workInProgress$1.flags |= 1,
        current = createWorkInProgress(type$2, nextProps),
        current.ref = workInProgress$1.ref,
        current.return = workInProgress$1,
        workInProgress$1.child = current
    }
    function updateSimpleMemoComponent(current, workInProgress$1, Component$7, nextProps, renderLanes$1) {
      if (current !== null) {
        var prevProps = current.memoizedProps
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress$1.ref) {
          if (
            didReceiveUpdate = !1,
              workInProgress$1.pendingProps = nextProps = prevProps,
              checkScheduledUpdateOrContext(current, renderLanes$1)
          ) current.flags & 131072 && (didReceiveUpdate = !0)
          else {return workInProgress$1.lanes = current.lanes,
              bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1)}
        }
      }
      return updateFunctionComponent(current, workInProgress$1, Component$7, nextProps, renderLanes$1)
    }
    function updateOffscreenComponent(current, workInProgress$1, renderLanes$1) {
      var nextProps = workInProgress$1.pendingProps,
        nextChildren = nextProps.children,
        prevState = current === null ? null : current.memoizedState
      if (nextProps.mode === `hidden`) {
        if (workInProgress$1.flags & 128) {
          if (nextProps = prevState === null ? renderLanes$1 : prevState.baseLanes | renderLanes$1, current !== null) {
            for (nextChildren = workInProgress$1.child = current.child, prevState = 0; nextChildren !== null;) {
              prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling
            }
            workInProgress$1.childLanes = prevState & ~nextProps
          } else workInProgress$1.childLanes = 0, workInProgress$1.child = null
          return deferHiddenOffscreenComponent(current, workInProgress$1, nextProps, renderLanes$1)
        }
        if (renderLanes$1 & 536870912) {
          workInProgress$1.memoizedState = { baseLanes: 0, cachePool: null },
            current !== null && pushTransition(workInProgress$1, prevState === null ? null : prevState.cachePool),
            prevState === null ? reuseHiddenContextOnStack() : pushHiddenContext(workInProgress$1, prevState),
            pushOffscreenSuspenseHandler(workInProgress$1)
        } else {return workInProgress$1.lanes = workInProgress$1.childLanes = 536870912,
            deferHiddenOffscreenComponent(
              current,
              workInProgress$1,
              prevState === null ? renderLanes$1 : prevState.baseLanes | renderLanes$1,
              renderLanes$1,
            )}
      } else {prevState === null
          ? (current !== null && pushTransition(workInProgress$1, null),
            reuseHiddenContextOnStack(),
            reuseSuspenseHandlerOnStack(workInProgress$1))
          : (pushTransition(workInProgress$1, prevState.cachePool),
            pushHiddenContext(workInProgress$1, prevState),
            reuseSuspenseHandlerOnStack(workInProgress$1),
            workInProgress$1.memoizedState = null)}
      return reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1), workInProgress$1.child
    }
    function deferHiddenOffscreenComponent(current, workInProgress$1, nextBaseLanes, renderLanes$1) {
      var JSCompiler_inline_result = peekCacheFromPool()
      return JSCompiler_inline_result = JSCompiler_inline_result === null
        ? null
        : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result },
        workInProgress$1.memoizedState = { baseLanes: nextBaseLanes, cachePool: JSCompiler_inline_result },
        current !== null && pushTransition(workInProgress$1, null),
        reuseHiddenContextOnStack(),
        pushOffscreenSuspenseHandler(workInProgress$1),
        current !== null && propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !0),
        null
    }
    function markRef(current, workInProgress$1) {
      var ref = workInProgress$1.ref
      if (ref === null) current !== null && current.ref !== null && (workInProgress$1.flags |= 4194816)
      else {
        if (typeof ref != `function` && typeof ref != `object`) throw Error(formatProdErrorMessage(284))
        ;(current === null || current.ref !== ref) && (workInProgress$1.flags |= 4194816)
      }
    }
    function updateFunctionComponent(current, workInProgress$1, Component$7, nextProps, renderLanes$1) {
      return prepareToReadContext(workInProgress$1),
        Component$7 = renderWithHooks(current, workInProgress$1, Component$7, nextProps, void 0, renderLanes$1),
        nextProps = checkDidRenderIdHook(),
        current !== null && !didReceiveUpdate
          ? (bailoutHooks(current, workInProgress$1, renderLanes$1),
            bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1))
          : (isHydrating && nextProps && pushMaterializedTreeId(workInProgress$1),
            workInProgress$1.flags |= 1,
            reconcileChildren(current, workInProgress$1, Component$7, renderLanes$1),
            workInProgress$1.child)
    }
    function replayFunctionComponent(current, workInProgress$1, nextProps, Component$7, secondArg, renderLanes$1) {
      return prepareToReadContext(workInProgress$1),
        workInProgress$1.updateQueue = null,
        nextProps = renderWithHooksAgain(workInProgress$1, Component$7, nextProps, secondArg),
        finishRenderingHooks(current),
        Component$7 = checkDidRenderIdHook(),
        current !== null && !didReceiveUpdate
          ? (bailoutHooks(current, workInProgress$1, renderLanes$1),
            bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1))
          : (isHydrating && Component$7 && pushMaterializedTreeId(workInProgress$1),
            workInProgress$1.flags |= 1,
            reconcileChildren(current, workInProgress$1, nextProps, renderLanes$1),
            workInProgress$1.child)
    }
    function updateClassComponent(current, workInProgress$1, Component$7, nextProps, renderLanes$1) {
      if (prepareToReadContext(workInProgress$1), workInProgress$1.stateNode === null) {
        var context$2 = emptyContextObject, contextType = Component$7.contextType
        typeof contextType == `object` && contextType && (context$2 = readContext(contextType)),
          context$2 = new Component$7(nextProps, context$2),
          workInProgress$1.memoizedState = context$2.state !== null && context$2.state !== void 0
            ? context$2.state
            : null,
          context$2.updater = classComponentUpdater,
          workInProgress$1.stateNode = context$2,
          context$2._reactInternals = workInProgress$1,
          context$2 = workInProgress$1.stateNode,
          context$2.props = nextProps,
          context$2.state = workInProgress$1.memoizedState,
          context$2.refs = {},
          initializeUpdateQueue(workInProgress$1),
          contextType = Component$7.contextType,
          context$2.context = typeof contextType == `object` && contextType
            ? readContext(contextType)
            : emptyContextObject,
          context$2.state = workInProgress$1.memoizedState,
          contextType = Component$7.getDerivedStateFromProps,
          typeof contextType == `function`
          && (applyDerivedStateFromProps(workInProgress$1, Component$7, contextType, nextProps),
            context$2.state = workInProgress$1.memoizedState),
          typeof Component$7.getDerivedStateFromProps == `function`
          || typeof context$2.getSnapshotBeforeUpdate == `function`
          || typeof context$2.UNSAFE_componentWillMount != `function`
            && typeof context$2.componentWillMount != `function`
          || (contextType = context$2.state,
            typeof context$2.componentWillMount == `function` && context$2.componentWillMount(),
            typeof context$2.UNSAFE_componentWillMount == `function` && context$2.UNSAFE_componentWillMount(),
            contextType !== context$2.state
            && classComponentUpdater.enqueueReplaceState(context$2, context$2.state, null),
            processUpdateQueue(workInProgress$1, nextProps, context$2, renderLanes$1),
            suspendIfUpdateReadFromEntangledAsyncAction(),
            context$2.state = workInProgress$1.memoizedState),
          typeof context$2.componentDidMount == `function` && (workInProgress$1.flags |= 4194308),
          nextProps = !0
      } else if (current === null) {
        context$2 = workInProgress$1.stateNode
        var unresolvedOldProps = workInProgress$1.memoizedProps,
          oldProps = resolveClassComponentProps(Component$7, unresolvedOldProps)
        context$2.props = oldProps
        var oldContext = context$2.context, contextType$jscomp$0 = Component$7.contextType
        contextType = emptyContextObject,
          typeof contextType$jscomp$0 == `object` && contextType$jscomp$0
          && (contextType = readContext(contextType$jscomp$0))
        var getDerivedStateFromProps = Component$7.getDerivedStateFromProps
        contextType$jscomp$0 = typeof getDerivedStateFromProps == `function`
          || typeof context$2.getSnapshotBeforeUpdate == `function`,
          unresolvedOldProps = workInProgress$1.pendingProps !== unresolvedOldProps,
          contextType$jscomp$0
          || typeof context$2.UNSAFE_componentWillReceiveProps != `function`
            && typeof context$2.componentWillReceiveProps != `function`
          || (unresolvedOldProps || oldContext !== contextType)
            && callComponentWillReceiveProps(workInProgress$1, context$2, nextProps, contextType),
          hasForceUpdate = !1
        var oldState = workInProgress$1.memoizedState
        context$2.state = oldState,
          processUpdateQueue(workInProgress$1, nextProps, context$2, renderLanes$1),
          suspendIfUpdateReadFromEntangledAsyncAction(),
          oldContext = workInProgress$1.memoizedState,
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate
            ? (typeof getDerivedStateFromProps == `function`
              && (applyDerivedStateFromProps(workInProgress$1, Component$7, getDerivedStateFromProps, nextProps),
                oldContext = workInProgress$1.memoizedState),
              (oldProps = hasForceUpdate
                  || checkShouldComponentUpdate(
                    workInProgress$1,
                    Component$7,
                    oldProps,
                    nextProps,
                    oldState,
                    oldContext,
                    contextType,
                  ))
                ? (contextType$jscomp$0
                  || typeof context$2.UNSAFE_componentWillMount != `function`
                    && typeof context$2.componentWillMount != `function`
                  || (typeof context$2.componentWillMount == `function` && context$2.componentWillMount(),
                    typeof context$2.UNSAFE_componentWillMount == `function` && context$2.UNSAFE_componentWillMount()),
                  typeof context$2.componentDidMount == `function` && (workInProgress$1.flags |= 4194308))
                : (typeof context$2.componentDidMount == `function` && (workInProgress$1.flags |= 4194308),
                  workInProgress$1.memoizedProps = nextProps,
                  workInProgress$1.memoizedState = oldContext),
              context$2.props = nextProps,
              context$2.state = oldContext,
              context$2.context = contextType,
              nextProps = oldProps)
            : (typeof context$2.componentDidMount == `function` && (workInProgress$1.flags |= 4194308), nextProps = !1)
      } else {
        context$2 = workInProgress$1.stateNode,
          cloneUpdateQueue(current, workInProgress$1),
          contextType = workInProgress$1.memoizedProps,
          contextType$jscomp$0 = resolveClassComponentProps(Component$7, contextType),
          context$2.props = contextType$jscomp$0,
          getDerivedStateFromProps = workInProgress$1.pendingProps,
          oldState = context$2.context,
          oldContext = Component$7.contextType,
          oldProps = emptyContextObject,
          typeof oldContext == `object` && oldContext && (oldProps = readContext(oldContext)),
          unresolvedOldProps = Component$7.getDerivedStateFromProps,
          (oldContext = typeof unresolvedOldProps == `function`
            || typeof context$2.getSnapshotBeforeUpdate == `function`)
          || typeof context$2.UNSAFE_componentWillReceiveProps != `function`
            && typeof context$2.componentWillReceiveProps != `function`
          || (contextType !== getDerivedStateFromProps || oldState !== oldProps)
            && callComponentWillReceiveProps(workInProgress$1, context$2, nextProps, oldProps),
          hasForceUpdate = !1,
          oldState = workInProgress$1.memoizedState,
          context$2.state = oldState,
          processUpdateQueue(workInProgress$1, nextProps, context$2, renderLanes$1),
          suspendIfUpdateReadFromEntangledAsyncAction()
        var newState = workInProgress$1.memoizedState
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate
          || current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies)
          ? (typeof unresolvedOldProps == `function`
            && (applyDerivedStateFromProps(workInProgress$1, Component$7, unresolvedOldProps, nextProps),
              newState = workInProgress$1.memoizedState),
            (contextType$jscomp$0 = hasForceUpdate
                || checkShouldComponentUpdate(
                  workInProgress$1,
                  Component$7,
                  contextType$jscomp$0,
                  nextProps,
                  oldState,
                  newState,
                  oldProps,
                ) || current !== null && current.dependencies !== null && checkIfContextChanged(current.dependencies))
              ? (oldContext
                || typeof context$2.UNSAFE_componentWillUpdate != `function`
                  && typeof context$2.componentWillUpdate != `function`
                || (typeof context$2.componentWillUpdate == `function`
                  && context$2.componentWillUpdate(nextProps, newState, oldProps),
                  typeof context$2.UNSAFE_componentWillUpdate == `function`
                  && context$2.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)),
                typeof context$2.componentDidUpdate == `function` && (workInProgress$1.flags |= 4),
                typeof context$2.getSnapshotBeforeUpdate == `function` && (workInProgress$1.flags |= 1024))
              : (typeof context$2.componentDidUpdate != `function`
                || contextType === current.memoizedProps && oldState === current.memoizedState
                || (workInProgress$1.flags |= 4),
                typeof context$2.getSnapshotBeforeUpdate != `function`
                || contextType === current.memoizedProps && oldState === current.memoizedState
                || (workInProgress$1.flags |= 1024),
                workInProgress$1.memoizedProps = nextProps,
                workInProgress$1.memoizedState = newState),
            context$2.props = nextProps,
            context$2.state = newState,
            context$2.context = oldProps,
            nextProps = contextType$jscomp$0)
          : (typeof context$2.componentDidUpdate != `function`
            || contextType === current.memoizedProps && oldState === current.memoizedState
            || (workInProgress$1.flags |= 4),
            typeof context$2.getSnapshotBeforeUpdate != `function`
            || contextType === current.memoizedProps && oldState === current.memoizedState
            || (workInProgress$1.flags |= 1024),
            nextProps = !1)
      }
      return context$2 = nextProps,
        markRef(current, workInProgress$1),
        nextProps = (workInProgress$1.flags & 128) != 0,
        context$2 || nextProps
          ? (context$2 = workInProgress$1.stateNode,
            Component$7 = nextProps && typeof Component$7.getDerivedStateFromError != `function`
              ? null
              : context$2.render(),
            workInProgress$1.flags |= 1,
            current !== null && nextProps
              ? (workInProgress$1.child = reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1),
                workInProgress$1.child = reconcileChildFibers(workInProgress$1, null, Component$7, renderLanes$1))
              : reconcileChildren(current, workInProgress$1, Component$7, renderLanes$1),
            workInProgress$1.memoizedState = context$2.state,
            current = workInProgress$1.child)
          : current = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1),
        current
    }
    function mountHostRootWithoutHydrating(current, workInProgress$1, nextChildren, renderLanes$1) {
      return resetHydrationState(),
        workInProgress$1.flags |= 256,
        reconcileChildren(current, workInProgress$1, nextChildren, renderLanes$1),
        workInProgress$1.child
    }
    var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }
    function mountSuspenseOffscreenState(renderLanes$1) {
      return { baseLanes: renderLanes$1, cachePool: getSuspendedCache() }
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes$1) {
      return current = current === null ? 0 : current.childLanes & ~renderLanes$1,
        primaryTreeDidDefer && (current |= workInProgressDeferredLane),
        current
    }
    function updateSuspenseComponent(current, workInProgress$1, renderLanes$1) {
      var nextProps = workInProgress$1.pendingProps,
        showFallback = !1,
        didSuspend = (workInProgress$1.flags & 128) != 0,
        JSCompiler_temp
      if (
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = current !== null && current.memoizedState === null
          ? !1
          : (suspenseStackCursor.current & 2) != 0),
          JSCompiler_temp && (showFallback = !0, workInProgress$1.flags &= -129),
          JSCompiler_temp = (workInProgress$1.flags & 32) != 0,
          workInProgress$1.flags &= -33,
          current === null
      ) {
        if (isHydrating) {
          if (
            showFallback
              ? pushPrimaryTreeSuspenseHandler(workInProgress$1)
              : reuseSuspenseHandlerOnStack(workInProgress$1), isHydrating
          ) {
            var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0
            if (JSCompiler_temp$jscomp$0 = nextInstance) {
              c: {
                for (
                  JSCompiler_temp$jscomp$0 = nextInstance, nextInstance = rootOrSingletonContext;
                  JSCompiler_temp$jscomp$0.nodeType !== 8;
                ) {
                  if (!nextInstance) {
                    nextInstance = null
                    break c
                  }
                  if (
                    JSCompiler_temp$jscomp$0 = getNextHydratable(JSCompiler_temp$jscomp$0.nextSibling),
                      JSCompiler_temp$jscomp$0 === null
                  ) {
                    nextInstance = null
                    break c
                  }
                }
                nextInstance = JSCompiler_temp$jscomp$0
              }
              nextInstance === null
                ? JSCompiler_temp$jscomp$0 = !1
                : (workInProgress$1.memoizedState = {
                  dehydrated: nextInstance,
                  treeContext: treeContextProvider === null
                    ? null
                    : { id: treeContextId, overflow: treeContextOverflow },
                  retryLane: 536870912,
                  hydrationErrors: null,
                },
                  JSCompiler_temp$jscomp$0 = createFiberImplClass(18, null, null, 0),
                  JSCompiler_temp$jscomp$0.stateNode = nextInstance,
                  JSCompiler_temp$jscomp$0.return = workInProgress$1,
                  workInProgress$1.child = JSCompiler_temp$jscomp$0,
                  hydrationParentFiber = workInProgress$1,
                  nextHydratableInstance = null,
                  JSCompiler_temp$jscomp$0 = !0)
            }
            JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress$1)
          }
          if (
            nextInstance = workInProgress$1.memoizedState,
              nextInstance !== null && (nextInstance = nextInstance.dehydrated, nextInstance !== null)
          ) {
            return isSuspenseInstanceFallback(nextInstance)
              ? workInProgress$1.lanes = 32
              : workInProgress$1.lanes = 536870912,
              null
          }
          popSuspenseHandler(workInProgress$1)
        }
        return nextInstance = nextProps.children,
          nextProps = nextProps.fallback,
          showFallback
            ? (reuseSuspenseHandlerOnStack(workInProgress$1),
              showFallback = workInProgress$1.mode,
              nextInstance = mountWorkInProgressOffscreenFiber(
                { mode: `hidden`, children: nextInstance },
                showFallback,
              ),
              nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes$1, null),
              nextInstance.return = workInProgress$1,
              nextProps.return = workInProgress$1,
              nextInstance.sibling = nextProps,
              workInProgress$1.child = nextInstance,
              showFallback = workInProgress$1.child,
              showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes$1),
              showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1),
              workInProgress$1.memoizedState = SUSPENDED_MARKER,
              nextProps)
            : (pushPrimaryTreeSuspenseHandler(workInProgress$1),
              mountSuspensePrimaryChildren(workInProgress$1, nextInstance))
      }
      if (
        JSCompiler_temp$jscomp$0 = current.memoizedState,
          JSCompiler_temp$jscomp$0 !== null
          && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, nextInstance !== null)
      ) {
        if (didSuspend) {
          workInProgress$1.flags & 256
            ? (pushPrimaryTreeSuspenseHandler(workInProgress$1),
              workInProgress$1.flags &= -257,
              workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1))
            : workInProgress$1.memoizedState === null
            ? (reuseSuspenseHandlerOnStack(workInProgress$1),
              showFallback = nextProps.fallback,
              nextInstance = workInProgress$1.mode,
              nextProps = mountWorkInProgressOffscreenFiber(
                { mode: `visible`, children: nextProps.children },
                nextInstance,
              ),
              showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes$1, null),
              showFallback.flags |= 2,
              nextProps.return = workInProgress$1,
              showFallback.return = workInProgress$1,
              nextProps.sibling = showFallback,
              workInProgress$1.child = nextProps,
              reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1),
              nextProps = workInProgress$1.child,
              nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes$1),
              nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1),
              workInProgress$1.memoizedState = SUSPENDED_MARKER,
              workInProgress$1 = showFallback)
            : (reuseSuspenseHandlerOnStack(workInProgress$1),
              workInProgress$1.child = current.child,
              workInProgress$1.flags |= 128,
              workInProgress$1 = null)
        } else if (pushPrimaryTreeSuspenseHandler(workInProgress$1), isSuspenseInstanceFallback(nextInstance)) {
          if (JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset, JSCompiler_temp) {
            var digest = JSCompiler_temp.dgst
          }
          JSCompiler_temp = digest,
            nextProps = Error(formatProdErrorMessage(419)),
            nextProps.stack = ``,
            nextProps.digest = JSCompiler_temp,
            queueHydrationError({ value: nextProps, source: null, stack: null }),
            workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1)
        } else if (
          didReceiveUpdate || propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1),
            JSCompiler_temp = (renderLanes$1 & current.childLanes) !== 0,
            didReceiveUpdate || JSCompiler_temp
        ) {
          if (
            JSCompiler_temp = workInProgressRoot,
              JSCompiler_temp !== null
              && (nextProps = renderLanes$1 & -renderLanes$1,
                nextProps = nextProps & 42 ? 1 : getBumpedLaneForHydrationByLane(nextProps),
                nextProps = (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes$1)) === 0 ? nextProps : 0,
                nextProps !== 0 && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
          ) {
            throw JSCompiler_temp$jscomp$0.retryLane = nextProps,
              enqueueConcurrentRenderForLane(current, nextProps),
              scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
              SelectiveHydrationException
          }
          nextInstance.data === `$?` || renderDidSuspendDelayIfPossible(),
            workInProgress$1 = retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1)
        } else {nextInstance.data === `$?`
            ? (workInProgress$1.flags |= 192, workInProgress$1.child = current.child, workInProgress$1 = null)
            : (current = JSCompiler_temp$jscomp$0.treeContext,
              nextHydratableInstance = getNextHydratable(nextInstance.nextSibling),
              hydrationParentFiber = workInProgress$1,
              isHydrating = !0,
              hydrationErrors = null,
              rootOrSingletonContext = !1,
              current !== null
              && (idStack[idStackIndex++] = treeContextId,
                idStack[idStackIndex++] = treeContextOverflow,
                idStack[idStackIndex++] = treeContextProvider,
                treeContextId = current.id,
                treeContextOverflow = current.overflow,
                treeContextProvider = workInProgress$1),
              workInProgress$1 = mountSuspensePrimaryChildren(workInProgress$1, nextProps.children),
              workInProgress$1.flags |= 4096)}
        return workInProgress$1
      }
      return showFallback
        ? (reuseSuspenseHandlerOnStack(workInProgress$1),
          showFallback = nextProps.fallback,
          nextInstance = workInProgress$1.mode,
          JSCompiler_temp$jscomp$0 = current.child,
          digest = JSCompiler_temp$jscomp$0.sibling,
          nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, { mode: `hidden`, children: nextProps.children }),
          nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712,
          digest === null
            ? (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes$1, null),
              showFallback.flags |= 2)
            : showFallback = createWorkInProgress(digest, showFallback),
          showFallback.return = workInProgress$1,
          nextProps.return = workInProgress$1,
          nextProps.sibling = showFallback,
          workInProgress$1.child = nextProps,
          nextProps = showFallback,
          showFallback = workInProgress$1.child,
          nextInstance = current.child.memoizedState,
          nextInstance === null
            ? nextInstance = mountSuspenseOffscreenState(renderLanes$1)
            : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool,
              JSCompiler_temp$jscomp$0 === null
                ? JSCompiler_temp$jscomp$0 = getSuspendedCache()
                : (digest = CacheContext._currentValue,
                  JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent === digest
                    ? JSCompiler_temp$jscomp$0
                    : { parent: digest, pool: digest }),
              nextInstance = {
                baseLanes: nextInstance.baseLanes | renderLanes$1,
                cachePool: JSCompiler_temp$jscomp$0,
              }),
          showFallback.memoizedState = nextInstance,
          showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes$1),
          workInProgress$1.memoizedState = SUSPENDED_MARKER,
          nextProps)
        : (pushPrimaryTreeSuspenseHandler(workInProgress$1),
          renderLanes$1 = current.child,
          current = renderLanes$1.sibling,
          renderLanes$1 = createWorkInProgress(renderLanes$1, { mode: `visible`, children: nextProps.children }),
          renderLanes$1.return = workInProgress$1,
          renderLanes$1.sibling = null,
          current !== null
          && (JSCompiler_temp = workInProgress$1.deletions,
            JSCompiler_temp === null
              ? (workInProgress$1.deletions = [current], workInProgress$1.flags |= 16)
              : JSCompiler_temp.push(current)),
          workInProgress$1.child = renderLanes$1,
          workInProgress$1.memoizedState = null,
          renderLanes$1)
    }
    function mountSuspensePrimaryChildren(workInProgress$1, primaryChildren) {
      return primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: `visible`, children: primaryChildren },
        workInProgress$1.mode,
      ),
        primaryChildren.return = workInProgress$1,
        workInProgress$1.child = primaryChildren
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      return offscreenProps = createFiberImplClass(22, offscreenProps, null, mode),
        offscreenProps.lanes = 0,
        offscreenProps.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null },
        offscreenProps
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress$1, renderLanes$1) {
      return reconcileChildFibers(workInProgress$1, current.child, null, renderLanes$1),
        current = mountSuspensePrimaryChildren(workInProgress$1, workInProgress$1.pendingProps.children),
        current.flags |= 2,
        workInProgress$1.memoizedState = null,
        current
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes$1, propagationRoot) {
      fiber.lanes |= renderLanes$1
      var alternate = fiber.alternate
      alternate !== null && (alternate.lanes |= renderLanes$1),
        scheduleContextWorkOnParentPath(fiber.return, renderLanes$1, propagationRoot)
    }
    function initSuspenseListRenderState(workInProgress$1, isBackwards, tail, lastContentRow, tailMode) {
      var renderState = workInProgress$1.memoizedState
      renderState === null
        ? workInProgress$1.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
        }
        : (renderState.isBackwards = isBackwards,
          renderState.rendering = null,
          renderState.renderingStartTime = 0,
          renderState.last = lastContentRow,
          renderState.tail = tail,
          renderState.tailMode = tailMode)
    }
    function updateSuspenseListComponent(current, workInProgress$1, renderLanes$1) {
      var nextProps = workInProgress$1.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail
      if (
        reconcileChildren(current, workInProgress$1, nextProps.children, renderLanes$1),
          nextProps = suspenseStackCursor.current,
          nextProps & 2
      ) nextProps = nextProps & 1 | 2, workInProgress$1.flags |= 128
      else {
        if (current !== null && current.flags & 128) {
          a: for (current = workInProgress$1.child; current !== null;) {
            if (current.tag === 13) {
              current.memoizedState !== null && scheduleSuspenseWorkOnFiber(current, renderLanes$1, workInProgress$1)
            } else if (current.tag === 19) scheduleSuspenseWorkOnFiber(current, renderLanes$1, workInProgress$1)
            else if (current.child !== null) {
              current.child.return = current, current = current.child
              continue
            }
            if (current === workInProgress$1) break a
            for (; current.sibling === null;) {
              if (current.return === null || current.return === workInProgress$1) break a
              current = current.return
            }
            current.sibling.return = current.return, current = current.sibling
          }
        }
        nextProps &= 1
      }
      switch (push$1(suspenseStackCursor, nextProps), revealOrder) {
        case `forwards`:
          for (renderLanes$1 = workInProgress$1.child, revealOrder = null; renderLanes$1 !== null;) {
            current = renderLanes$1.alternate,
              current !== null && findFirstSuspended(current) === null && (revealOrder = renderLanes$1),
              renderLanes$1 = renderLanes$1.sibling
          }
          renderLanes$1 = revealOrder,
            renderLanes$1 === null
              ? (revealOrder = workInProgress$1.child, workInProgress$1.child = null)
              : (revealOrder = renderLanes$1.sibling, renderLanes$1.sibling = null),
            initSuspenseListRenderState(workInProgress$1, !1, revealOrder, renderLanes$1, tailMode)
          break
        case `backwards`:
          for (
            renderLanes$1 = null, revealOrder = workInProgress$1.child, workInProgress$1.child = null;
            revealOrder !== null;
          ) {
            if (current = revealOrder.alternate, current !== null && findFirstSuspended(current) === null) {
              workInProgress$1.child = revealOrder
              break
            }
            current = revealOrder.sibling,
              revealOrder.sibling = renderLanes$1,
              renderLanes$1 = revealOrder,
              revealOrder = current
          }
          initSuspenseListRenderState(workInProgress$1, !0, renderLanes$1, null, tailMode)
          break
        case `together`:
          initSuspenseListRenderState(workInProgress$1, !1, null, null, void 0)
          break
        default:
          workInProgress$1.memoizedState = null
      }
      return workInProgress$1.child
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1) {
      if (
        current !== null && (workInProgress$1.dependencies = current.dependencies),
          workInProgressRootSkippedLanes |= workInProgress$1.lanes,
          (renderLanes$1 & workInProgress$1.childLanes) === 0
      ) {
        if (current !== null) {
          if (
            propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1),
              (renderLanes$1 & workInProgress$1.childLanes) === 0
          ) return null
        } else return null
      }
      if (current !== null && workInProgress$1.child !== current.child) throw Error(formatProdErrorMessage(153))
      if (workInProgress$1.child !== null) {
        for (
          current = workInProgress$1.child,
            renderLanes$1 = createWorkInProgress(current, current.pendingProps),
            workInProgress$1.child = renderLanes$1,
            renderLanes$1.return = workInProgress$1;
          current.sibling !== null;
        ) {
          current = current.sibling,
            renderLanes$1 = renderLanes$1.sibling = createWorkInProgress(current, current.pendingProps),
            renderLanes$1.return = workInProgress$1
        }
        renderLanes$1.sibling = null
      }
      return workInProgress$1.child
    }
    function checkScheduledUpdateOrContext(current, renderLanes$1) {
      return (current.lanes & renderLanes$1) === 0
        ? (current = current.dependencies, current !== null && checkIfContextChanged(current) ? !0 : !1)
        : !0
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress$1, renderLanes$1) {
      switch (workInProgress$1.tag) {
        case 3:
          pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo),
            pushProvider(workInProgress$1, CacheContext, current.memoizedState.cache),
            resetHydrationState()
          break
        case 27:
        case 5:
          pushHostContext(workInProgress$1)
          break
        case 4:
          pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo)
          break
        case 10:
          pushProvider(workInProgress$1, workInProgress$1.type, workInProgress$1.memoizedProps.value)
          break
        case 13:
          var state = workInProgress$1.memoizedState
          if (state !== null) {
            return state.dehydrated === null
              ? (renderLanes$1 & workInProgress$1.child.childLanes) === 0
                ? (pushPrimaryTreeSuspenseHandler(workInProgress$1),
                  current = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1),
                  current === null ? null : current.sibling)
                : updateSuspenseComponent(current, workInProgress$1, renderLanes$1)
              : (pushPrimaryTreeSuspenseHandler(workInProgress$1), workInProgress$1.flags |= 128, null)
          }
          pushPrimaryTreeSuspenseHandler(workInProgress$1)
          break
        case 19:
          var didSuspendBefore = (current.flags & 128) != 0
          if (
            state = (renderLanes$1 & workInProgress$1.childLanes) !== 0,
              state
              || (propagateParentContextChanges(current, workInProgress$1, renderLanes$1, !1),
                state = (renderLanes$1 & workInProgress$1.childLanes) !== 0),
              didSuspendBefore
          ) {
            if (state) return updateSuspenseListComponent(current, workInProgress$1, renderLanes$1)
            workInProgress$1.flags |= 128
          }
          if (
            didSuspendBefore = workInProgress$1.memoizedState,
              didSuspendBefore !== null
              && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null),
              push$1(suspenseStackCursor, suspenseStackCursor.current),
              state
          ) break
          return null
        case 22:
        case 23:
          return workInProgress$1.lanes = 0, updateOffscreenComponent(current, workInProgress$1, renderLanes$1)
        case 24:
          pushProvider(workInProgress$1, CacheContext, current.memoizedState.cache)
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1)
    }
    function beginWork(current, workInProgress$1, renderLanes$1) {
      if (current !== null) {
        if (current.memoizedProps !== workInProgress$1.pendingProps) didReceiveUpdate = !0
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes$1) && !(workInProgress$1.flags & 128)) {
            return didReceiveUpdate = !1,
              attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress$1, renderLanes$1)
          }
          didReceiveUpdate = current.flags & 131072 ? !0 : !1
        }
      } else {didReceiveUpdate = !1,
          isHydrating && workInProgress$1.flags & 1048576
          && pushTreeId(workInProgress$1, treeForkCount, workInProgress$1.index)}
      switch (workInProgress$1.lanes = 0, workInProgress$1.tag) {
        case 16:
          a: {
            current = workInProgress$1.pendingProps
            var lazyComponent = workInProgress$1.elementType, init = lazyComponent._init
            if (
              lazyComponent = init(lazyComponent._payload),
                workInProgress$1.type = lazyComponent,
                typeof lazyComponent == `function`
            ) {
              shouldConstruct(lazyComponent)
                ? (current = resolveClassComponentProps(lazyComponent, current),
                  workInProgress$1.tag = 1,
                  workInProgress$1 = updateClassComponent(
                    null,
                    workInProgress$1,
                    lazyComponent,
                    current,
                    renderLanes$1,
                  ))
                : (workInProgress$1.tag = 0,
                  workInProgress$1 = updateFunctionComponent(
                    null,
                    workInProgress$1,
                    lazyComponent,
                    current,
                    renderLanes$1,
                  ))
            } else {
              if (lazyComponent != null) {
                if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                  workInProgress$1.tag = 11,
                    workInProgress$1 = updateForwardRef(null, workInProgress$1, lazyComponent, current, renderLanes$1)
                  break a
                } else if (init === REACT_MEMO_TYPE) {
                  workInProgress$1.tag = 14,
                    workInProgress$1 = updateMemoComponent(
                      null,
                      workInProgress$1,
                      lazyComponent,
                      current,
                      renderLanes$1,
                    )
                  break a
                }
              }
              throw workInProgress$1 = getComponentNameFromType(lazyComponent) || lazyComponent,
                Error(formatProdErrorMessage(306, workInProgress$1, ``))
            }
          }
          return workInProgress$1
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress$1,
            workInProgress$1.type,
            workInProgress$1.pendingProps,
            renderLanes$1,
          )
        case 1:
          return lazyComponent = workInProgress$1.type,
            init = resolveClassComponentProps(lazyComponent, workInProgress$1.pendingProps),
            updateClassComponent(current, workInProgress$1, lazyComponent, init, renderLanes$1)
        case 3:
          a: {
            if (pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo), current === null) {
              throw Error(formatProdErrorMessage(387))
            }
            lazyComponent = workInProgress$1.pendingProps
            var prevState = workInProgress$1.memoizedState
            init = prevState.element,
              cloneUpdateQueue(current, workInProgress$1),
              processUpdateQueue(workInProgress$1, lazyComponent, null, renderLanes$1)
            var nextState = workInProgress$1.memoizedState
            if (
              lazyComponent = nextState.cache,
                pushProvider(workInProgress$1, CacheContext, lazyComponent),
                lazyComponent !== prevState.cache
                && propagateContextChanges(workInProgress$1, [CacheContext], renderLanes$1, !0),
                suspendIfUpdateReadFromEntangledAsyncAction(),
                lazyComponent = nextState.element,
                prevState.isDehydrated
            ) {
              if (
                prevState = { element: lazyComponent, isDehydrated: !1, cache: nextState.cache },
                  workInProgress$1.updateQueue.baseState = prevState,
                  workInProgress$1.memoizedState = prevState,
                  workInProgress$1.flags & 256
              ) {
                workInProgress$1 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress$1,
                  lazyComponent,
                  renderLanes$1,
                )
                break a
              } else if (lazyComponent !== init) {
                init = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), workInProgress$1),
                  queueHydrationError(init),
                  workInProgress$1 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress$1,
                    lazyComponent,
                    renderLanes$1,
                  )
                break a
              } else {
                switch (current = workInProgress$1.stateNode.containerInfo, current.nodeType) {
                  case 9:
                    current = current.body
                    break
                  default:
                    current = current.nodeName === `HTML` ? current.ownerDocument.body : current
                }
                for (
                  nextHydratableInstance = getNextHydratable(current.firstChild),
                    hydrationParentFiber = workInProgress$1,
                    isHydrating = !0,
                    hydrationErrors = null,
                    rootOrSingletonContext = !0,
                    renderLanes$1 = mountChildFibers(workInProgress$1, null, lazyComponent, renderLanes$1),
                    workInProgress$1.child = renderLanes$1;
                  renderLanes$1;
                ) renderLanes$1.flags = renderLanes$1.flags & -3 | 4096, renderLanes$1 = renderLanes$1.sibling
              }
            } else {
              if (resetHydrationState(), lazyComponent === init) {
                workInProgress$1 = bailoutOnAlreadyFinishedWork(current, workInProgress$1, renderLanes$1)
                break a
              }
              reconcileChildren(current, workInProgress$1, lazyComponent, renderLanes$1)
            }
            workInProgress$1 = workInProgress$1.child
          }
          return workInProgress$1
        case 26:
          return markRef(current, workInProgress$1),
            current === null
              ? (renderLanes$1 = getResource(workInProgress$1.type, null, workInProgress$1.pendingProps, null))
                ? workInProgress$1.memoizedState = renderLanes$1
                : isHydrating
                  || (renderLanes$1 = workInProgress$1.type,
                    current = workInProgress$1.pendingProps,
                    lazyComponent = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(
                      renderLanes$1,
                    ),
                    lazyComponent[internalInstanceKey] = workInProgress$1,
                    lazyComponent[internalPropsKey] = current,
                    setInitialProperties(lazyComponent, renderLanes$1, current),
                    markNodeAsHoistable(lazyComponent),
                    workInProgress$1.stateNode = lazyComponent)
              : workInProgress$1.memoizedState = getResource(
                workInProgress$1.type,
                current.memoizedProps,
                workInProgress$1.pendingProps,
                current.memoizedState,
              ),
            null
        case 27:
          return pushHostContext(workInProgress$1),
            current === null && isHydrating
            && (lazyComponent = workInProgress$1.stateNode = resolveSingletonInstance(
              workInProgress$1.type,
              workInProgress$1.pendingProps,
              rootInstanceStackCursor.current,
            ),
              hydrationParentFiber = workInProgress$1,
              rootOrSingletonContext = !0,
              init = nextHydratableInstance,
              isSingletonScope(workInProgress$1.type)
                ? (previousHydratableOnEnteringScopedSingleton = init,
                  nextHydratableInstance = getNextHydratable(lazyComponent.firstChild))
                : nextHydratableInstance = init),
            reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1),
            markRef(current, workInProgress$1),
            current === null && (workInProgress$1.flags |= 4194304),
            workInProgress$1.child
        case 5:
          return current === null && isHydrating
            && ((init = lazyComponent = nextHydratableInstance)
              && (lazyComponent = canHydrateInstance(
                lazyComponent,
                workInProgress$1.type,
                workInProgress$1.pendingProps,
                rootOrSingletonContext,
              ),
                lazyComponent === null
                  ? init = !1
                  : (workInProgress$1.stateNode = lazyComponent,
                    hydrationParentFiber = workInProgress$1,
                    nextHydratableInstance = getNextHydratable(lazyComponent.firstChild),
                    rootOrSingletonContext = !1,
                    init = !0)),
              init || throwOnHydrationMismatch(workInProgress$1)),
            pushHostContext(workInProgress$1),
            init = workInProgress$1.type,
            prevState = workInProgress$1.pendingProps,
            nextState = current === null ? null : current.memoizedProps,
            lazyComponent = prevState.children,
            shouldSetTextContent(init, prevState)
              ? lazyComponent = null
              : nextState !== null && shouldSetTextContent(init, nextState) && (workInProgress$1.flags |= 32),
            workInProgress$1.memoizedState !== null
            && (init = renderWithHooks(
              current,
              workInProgress$1,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes$1,
            ),
              HostTransitionContext._currentValue = init),
            markRef(current, workInProgress$1),
            reconcileChildren(current, workInProgress$1, lazyComponent, renderLanes$1),
            workInProgress$1.child
        case 6:
          return current === null && isHydrating
            && ((current = renderLanes$1 = nextHydratableInstance)
              && (renderLanes$1 = canHydrateTextInstance(
                renderLanes$1,
                workInProgress$1.pendingProps,
                rootOrSingletonContext,
              ),
                renderLanes$1 === null
                  ? current = !1
                  : (workInProgress$1.stateNode = renderLanes$1,
                    hydrationParentFiber = workInProgress$1,
                    nextHydratableInstance = null,
                    current = !0)),
              current || throwOnHydrationMismatch(workInProgress$1)),
            null
        case 13:
          return updateSuspenseComponent(current, workInProgress$1, renderLanes$1)
        case 4:
          return pushHostContainer(workInProgress$1, workInProgress$1.stateNode.containerInfo),
            lazyComponent = workInProgress$1.pendingProps,
            current === null
              ? workInProgress$1.child = reconcileChildFibers(workInProgress$1, null, lazyComponent, renderLanes$1)
              : reconcileChildren(current, workInProgress$1, lazyComponent, renderLanes$1),
            workInProgress$1.child
        case 11:
          return updateForwardRef(
            current,
            workInProgress$1,
            workInProgress$1.type,
            workInProgress$1.pendingProps,
            renderLanes$1,
          )
        case 7:
          return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps, renderLanes$1),
            workInProgress$1.child
        case 8:
          return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1),
            workInProgress$1.child
        case 12:
          return reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1),
            workInProgress$1.child
        case 10:
          return lazyComponent = workInProgress$1.pendingProps,
            pushProvider(workInProgress$1, workInProgress$1.type, lazyComponent.value),
            reconcileChildren(current, workInProgress$1, lazyComponent.children, renderLanes$1),
            workInProgress$1.child
        case 9:
          return init = workInProgress$1.type._context,
            lazyComponent = workInProgress$1.pendingProps.children,
            prepareToReadContext(workInProgress$1),
            init = readContext(init),
            lazyComponent = lazyComponent(init),
            workInProgress$1.flags |= 1,
            reconcileChildren(current, workInProgress$1, lazyComponent, renderLanes$1),
            workInProgress$1.child
        case 14:
          return updateMemoComponent(
            current,
            workInProgress$1,
            workInProgress$1.type,
            workInProgress$1.pendingProps,
            renderLanes$1,
          )
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress$1,
            workInProgress$1.type,
            workInProgress$1.pendingProps,
            renderLanes$1,
          )
        case 19:
          return updateSuspenseListComponent(current, workInProgress$1, renderLanes$1)
        case 31:
          return lazyComponent = workInProgress$1.pendingProps,
            renderLanes$1 = workInProgress$1.mode,
            lazyComponent = { mode: lazyComponent.mode, children: lazyComponent.children },
            current === null
              ? (renderLanes$1 = mountWorkInProgressOffscreenFiber(lazyComponent, renderLanes$1),
                renderLanes$1.ref = workInProgress$1.ref,
                workInProgress$1.child = renderLanes$1,
                renderLanes$1.return = workInProgress$1,
                workInProgress$1 = renderLanes$1)
              : (renderLanes$1 = createWorkInProgress(current.child, lazyComponent),
                renderLanes$1.ref = workInProgress$1.ref,
                workInProgress$1.child = renderLanes$1,
                renderLanes$1.return = workInProgress$1,
                workInProgress$1 = renderLanes$1),
            workInProgress$1
        case 22:
          return updateOffscreenComponent(current, workInProgress$1, renderLanes$1)
        case 24:
          return prepareToReadContext(workInProgress$1),
            lazyComponent = readContext(CacheContext),
            current === null
              ? (init = peekCacheFromPool(),
                init === null
                && (init = workInProgressRoot,
                  prevState = createCache(),
                  init.pooledCache = prevState,
                  prevState.refCount++,
                  prevState !== null && (init.pooledCacheLanes |= renderLanes$1),
                  init = prevState),
                workInProgress$1.memoizedState = { parent: lazyComponent, cache: init },
                initializeUpdateQueue(workInProgress$1),
                pushProvider(workInProgress$1, CacheContext, init))
              : ((current.lanes & renderLanes$1) !== 0
                && (cloneUpdateQueue(current, workInProgress$1),
                  processUpdateQueue(workInProgress$1, null, null, renderLanes$1),
                  suspendIfUpdateReadFromEntangledAsyncAction()),
                init = current.memoizedState,
                prevState = workInProgress$1.memoizedState,
                init.parent === lazyComponent
                  ? (lazyComponent = prevState.cache,
                    pushProvider(workInProgress$1, CacheContext, lazyComponent),
                    lazyComponent !== init.cache
                    && propagateContextChanges(workInProgress$1, [CacheContext], renderLanes$1, !0))
                  : (init = { parent: lazyComponent, cache: lazyComponent },
                    workInProgress$1.memoizedState = init,
                    workInProgress$1.lanes === 0
                    && (workInProgress$1.memoizedState = workInProgress$1.updateQueue.baseState = init),
                    pushProvider(workInProgress$1, CacheContext, lazyComponent))),
            reconcileChildren(current, workInProgress$1, workInProgress$1.pendingProps.children, renderLanes$1),
            workInProgress$1.child
        case 29:
          throw workInProgress$1.pendingProps
      }
      throw Error(formatProdErrorMessage(156, workInProgress$1.tag))
    }
    function markUpdate(workInProgress$1) {
      workInProgress$1.flags |= 4
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress$1, resource) {
      if (resource.type !== `stylesheet` || resource.state.loading & 4) workInProgress$1.flags &= -16777217
      else if (workInProgress$1.flags |= 16777216, !preloadResource(resource)) {
        if (
          resource = suspenseHandlerStackCursor.current,
            resource !== null && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes
              ? shellBoundary !== null
              : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes
                  && !(workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary)
        ) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException
        workInProgress$1.flags |= 8192
      }
    }
    function scheduleRetryEffect(workInProgress$1, retryQueue) {
      retryQueue !== null && (workInProgress$1.flags |= 4),
        workInProgress$1.flags & 16384
        && (retryQueue = workInProgress$1.tag === 22 ? 536870912 : claimNextRetryLane(),
          workInProgress$1.lanes |= retryQueue,
          workInProgressSuspendedRetryLanes |= retryQueue)
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating) {
        switch (renderState.tailMode) {
          case `hidden`:
            hasRenderedATailFallback = renderState.tail
            for (var lastTailNode = null; hasRenderedATailFallback !== null;) {
              hasRenderedATailFallback.alternate !== null && (lastTailNode = hasRenderedATailFallback),
                hasRenderedATailFallback = hasRenderedATailFallback.sibling
            }
            lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null
            break
          case `collapsed`:
            lastTailNode = renderState.tail
            for (
              var lastTailNode$113 = null;
              lastTailNode !== null;
            ) {
              lastTailNode.alternate !== null && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling
            }
            lastTailNode$113 === null
              ? hasRenderedATailFallback || renderState.tail === null
                ? renderState.tail = null
                : renderState.tail.sibling = null
              : lastTailNode$113.sibling = null
        }
      }
    }
    function bubbleProperties(completedWork) {
      var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0
      if (didBailout) {
        for (var child$114 = completedWork.child; child$114 !== null;) {
          newChildLanes |= child$114.lanes | child$114.childLanes,
            subtreeFlags |= child$114.subtreeFlags & 65011712,
            subtreeFlags |= child$114.flags & 65011712,
            child$114.return = completedWork,
            child$114 = child$114.sibling
        }
      } else {for (child$114 = completedWork.child; child$114 !== null;) {
          newChildLanes |= child$114.lanes | child$114.childLanes,
            subtreeFlags |= child$114.subtreeFlags,
            subtreeFlags |= child$114.flags,
            child$114.return = completedWork,
            child$114 = child$114.sibling
        }}
      return completedWork.subtreeFlags |= subtreeFlags, completedWork.childLanes = newChildLanes, didBailout
    }
    function completeWork(current, workInProgress$1, renderLanes$1) {
      var newProps = workInProgress$1.pendingProps
      switch (popTreeContext(workInProgress$1), workInProgress$1.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress$1), null
        case 1:
          return bubbleProperties(workInProgress$1), null
        case 3:
          return renderLanes$1 = workInProgress$1.stateNode,
            newProps = null,
            current !== null && (newProps = current.memoizedState.cache),
            workInProgress$1.memoizedState.cache !== newProps && (workInProgress$1.flags |= 2048),
            popProvider(CacheContext),
            popHostContainer(),
            renderLanes$1.pendingContext
            && (renderLanes$1.context = renderLanes$1.pendingContext, renderLanes$1.pendingContext = null),
            (current === null || current.child === null)
            && (popHydrationState(workInProgress$1)
              ? markUpdate(workInProgress$1)
              : current === null || current.memoizedState.isDehydrated && !(workInProgress$1.flags & 256)
                || (workInProgress$1.flags |= 1024, upgradeHydrationErrorsToRecoverable())),
            bubbleProperties(workInProgress$1),
            null
        case 26:
          return renderLanes$1 = workInProgress$1.memoizedState,
            current === null
              ? (markUpdate(workInProgress$1),
                renderLanes$1 === null
                  ? (bubbleProperties(workInProgress$1), workInProgress$1.flags &= -16777217)
                  : (bubbleProperties(workInProgress$1),
                    preloadResourceAndSuspendIfNeeded(workInProgress$1, renderLanes$1)))
              : renderLanes$1
              ? renderLanes$1 === current.memoizedState
                ? (bubbleProperties(workInProgress$1), workInProgress$1.flags &= -16777217)
                : (markUpdate(workInProgress$1),
                  bubbleProperties(workInProgress$1),
                  preloadResourceAndSuspendIfNeeded(workInProgress$1, renderLanes$1))
              : (current.memoizedProps !== newProps && markUpdate(workInProgress$1),
                bubbleProperties(workInProgress$1),
                workInProgress$1.flags &= -16777217),
            null
        case 27:
          popHostContext(workInProgress$1), renderLanes$1 = rootInstanceStackCursor.current
          var type$2 = workInProgress$1.type
          if (current !== null && workInProgress$1.stateNode != null) {
            current.memoizedProps !== newProps && markUpdate(workInProgress$1)
          } else {
            if (!newProps) {
              if (workInProgress$1.stateNode === null) throw Error(formatProdErrorMessage(166))
              return bubbleProperties(workInProgress$1), null
            }
            current = contextStackCursor.current,
              popHydrationState(workInProgress$1)
                ? prepareToHydrateHostInstance(workInProgress$1, current)
                : (current = resolveSingletonInstance(type$2, newProps, renderLanes$1),
                  workInProgress$1.stateNode = current,
                  markUpdate(workInProgress$1))
          }
          return bubbleProperties(workInProgress$1), null
        case 5:
          if (
            popHostContext(workInProgress$1),
              renderLanes$1 = workInProgress$1.type,
              current !== null && workInProgress$1.stateNode != null
          ) current.memoizedProps !== newProps && markUpdate(workInProgress$1)
          else {
            if (!newProps) {
              if (workInProgress$1.stateNode === null) throw Error(formatProdErrorMessage(166))
              return bubbleProperties(workInProgress$1), null
            }
            if (current = contextStackCursor.current, popHydrationState(workInProgress$1)) {
              prepareToHydrateHostInstance(workInProgress$1, current)
            } else {
              switch (type$2 = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current), current) {
                case 1:
                  current = type$2.createElementNS(`http://www.w3.org/2000/svg`, renderLanes$1)
                  break
                case 2:
                  current = type$2.createElementNS(`http://www.w3.org/1998/Math/MathML`, renderLanes$1)
                  break
                default:
                  switch (renderLanes$1) {
                    case `svg`:
                      current = type$2.createElementNS(`http://www.w3.org/2000/svg`, renderLanes$1)
                      break
                    case `math`:
                      current = type$2.createElementNS(`http://www.w3.org/1998/Math/MathML`, renderLanes$1)
                      break
                    case `script`:
                      current = type$2.createElement(`div`),
                        current.innerHTML = `<script><\/script>`,
                        current = current.removeChild(current.firstChild)
                      break
                    case `select`:
                      current = typeof newProps.is == `string`
                        ? type$2.createElement(`select`, { is: newProps.is })
                        : type$2.createElement(`select`),
                        newProps.multiple ? current.multiple = !0 : newProps.size && (current.size = newProps.size)
                      break
                    default:
                      current = typeof newProps.is == `string`
                        ? type$2.createElement(renderLanes$1, { is: newProps.is })
                        : type$2.createElement(renderLanes$1)
                  }
              }
              current[internalInstanceKey] = workInProgress$1, current[internalPropsKey] = newProps
              a: for (type$2 = workInProgress$1.child; type$2 !== null;) {
                if (type$2.tag === 5 || type$2.tag === 6) current.appendChild(type$2.stateNode)
                else if (type$2.tag !== 4 && type$2.tag !== 27 && type$2.child !== null) {
                  type$2.child.return = type$2, type$2 = type$2.child
                  continue
                }
                if (type$2 === workInProgress$1) break a
                for (; type$2.sibling === null;) {
                  if (type$2.return === null || type$2.return === workInProgress$1) break a
                  type$2 = type$2.return
                }
                type$2.sibling.return = type$2.return, type$2 = type$2.sibling
              }
              workInProgress$1.stateNode = current
              a: switch (setInitialProperties(current, renderLanes$1, newProps), renderLanes$1) {
                case `button`:
                case `input`:
                case `select`:
                case `textarea`:
                  current = !!newProps.autoFocus
                  break a
                case `img`:
                  current = !0
                  break a
                default:
                  current = !1
              }
              current && markUpdate(workInProgress$1)
            }
          }
          return bubbleProperties(workInProgress$1), workInProgress$1.flags &= -16777217, null
        case 6:
          if (current && workInProgress$1.stateNode != null) {
            current.memoizedProps !== newProps && markUpdate(workInProgress$1)
          } else {
            if (typeof newProps != `string` && workInProgress$1.stateNode === null) {
              throw Error(formatProdErrorMessage(166))
            }
            if (current = rootInstanceStackCursor.current, popHydrationState(workInProgress$1)) {
              if (
                current = workInProgress$1.stateNode,
                  renderLanes$1 = workInProgress$1.memoizedProps,
                  newProps = null,
                  type$2 = hydrationParentFiber,
                  type$2 !== null
              ) {
                switch (type$2.tag) {
                  case 27:
                  case 5:
                    newProps = type$2.memoizedProps
                }
              }
              current[internalInstanceKey] = workInProgress$1,
                current =
                  current.nodeValue === renderLanes$1 || newProps !== null && !0 === newProps.suppressHydrationWarning
                    || checkForUnmatchedText(current.nodeValue, renderLanes$1)
                    ? !0
                    : !1,
                current || throwOnHydrationMismatch(workInProgress$1)
            } else {current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps),
                current[internalInstanceKey] = workInProgress$1,
                workInProgress$1.stateNode = current}
          }
          return bubbleProperties(workInProgress$1), null
        case 13:
          if (
            newProps = workInProgress$1.memoizedState,
              current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null
          ) {
            if (type$2 = popHydrationState(workInProgress$1), newProps !== null && newProps.dehydrated !== null) {
              if (current === null) {
                if (!type$2) throw Error(formatProdErrorMessage(318))
                if (
                  type$2 = workInProgress$1.memoizedState, type$2 = type$2 === null ? null : type$2.dehydrated, !type$2
                ) throw Error(formatProdErrorMessage(317))
                type$2[internalInstanceKey] = workInProgress$1
              } else {resetHydrationState(),
                  !(workInProgress$1.flags & 128) && (workInProgress$1.memoizedState = null),
                  workInProgress$1.flags |= 4}
              bubbleProperties(workInProgress$1), type$2 = !1
            } else {type$2 = upgradeHydrationErrorsToRecoverable(),
                current !== null && current.memoizedState !== null && (current.memoizedState.hydrationErrors = type$2),
                type$2 = !0}
            if (!type$2) {
              return workInProgress$1.flags & 256
                ? (popSuspenseHandler(workInProgress$1), workInProgress$1)
                : (popSuspenseHandler(workInProgress$1), null)
            }
          }
          if (popSuspenseHandler(workInProgress$1), workInProgress$1.flags & 128) {
            return workInProgress$1.lanes = renderLanes$1, workInProgress$1
          }
          if (
            renderLanes$1 = newProps !== null,
              current = current !== null && current.memoizedState !== null,
              renderLanes$1
          ) {
            newProps = workInProgress$1.child,
              type$2 = null,
              newProps.alternate !== null && newProps.alternate.memoizedState !== null
              && newProps.alternate.memoizedState.cachePool !== null
              && (type$2 = newProps.alternate.memoizedState.cachePool.pool)
            var cache$127 = null
            newProps.memoizedState !== null && newProps.memoizedState.cachePool !== null
            && (cache$127 = newProps.memoizedState.cachePool.pool), cache$127 !== type$2 && (newProps.flags |= 2048)
          }
          return renderLanes$1 !== current && renderLanes$1 && (workInProgress$1.child.flags |= 8192),
            scheduleRetryEffect(workInProgress$1, workInProgress$1.updateQueue),
            bubbleProperties(workInProgress$1),
            null
        case 4:
          return popHostContainer(),
            current === null && listenToAllSupportedEvents(workInProgress$1.stateNode.containerInfo),
            bubbleProperties(workInProgress$1),
            null
        case 10:
          return popProvider(workInProgress$1.type), bubbleProperties(workInProgress$1), null
        case 19:
          if (pop(suspenseStackCursor), type$2 = workInProgress$1.memoizedState, type$2 === null) {
            return bubbleProperties(workInProgress$1), null
          }
          if (newProps = (workInProgress$1.flags & 128) != 0, cache$127 = type$2.rendering, cache$127 === null) {
            if (newProps) cutOffTailIfNeeded(type$2, !1)
            else {
              if (workInProgressRootExitStatus !== 0 || current !== null && current.flags & 128) {
                for (current = workInProgress$1.child; current !== null;) {
                  if (cache$127 = findFirstSuspended(current), cache$127 !== null) {
                    for (
                      workInProgress$1.flags |= 128,
                        cutOffTailIfNeeded(type$2, !1),
                        current = cache$127.updateQueue,
                        workInProgress$1.updateQueue = current,
                        scheduleRetryEffect(workInProgress$1, current),
                        workInProgress$1.subtreeFlags = 0,
                        current = renderLanes$1,
                        renderLanes$1 = workInProgress$1.child;
                      renderLanes$1 !== null;
                    ) {
                      resetWorkInProgress(renderLanes$1, current), renderLanes$1 = renderLanes$1.sibling
                    }
                    return push$1(suspenseStackCursor, suspenseStackCursor.current & 1 | 2), workInProgress$1.child
                  }
                  current = current.sibling
                }
              }
              type$2.tail !== null && now() > workInProgressRootRenderTargetTime
                && (workInProgress$1.flags |= 128,
                  newProps = !0,
                  cutOffTailIfNeeded(type$2, !1),
                  workInProgress$1.lanes = 4194304)
            }
          } else {
            if (!newProps) {
              if (current = findFirstSuspended(cache$127), current !== null) {
                if (
                  workInProgress$1.flags |= 128,
                    newProps = !0,
                    current = current.updateQueue,
                    workInProgress$1.updateQueue = current,
                    scheduleRetryEffect(workInProgress$1, current),
                    cutOffTailIfNeeded(type$2, !0),
                    type$2.tail === null && type$2.tailMode === `hidden` && !cache$127.alternate && !isHydrating
                ) return bubbleProperties(workInProgress$1), null
              } else {2 * now() - type$2.renderingStartTime > workInProgressRootRenderTargetTime
                  && renderLanes$1 !== 536870912
                  && (workInProgress$1.flags |= 128,
                    newProps = !0,
                    cutOffTailIfNeeded(type$2, !1),
                    workInProgress$1.lanes = 4194304)}
            }
            type$2.isBackwards
              ? (cache$127.sibling = workInProgress$1.child, workInProgress$1.child = cache$127)
              : (current = type$2.last,
                current === null ? workInProgress$1.child = cache$127 : current.sibling = cache$127,
                type$2.last = cache$127)
          }
          return type$2.tail === null
            ? (bubbleProperties(workInProgress$1), null)
            : (workInProgress$1 = type$2.tail,
              type$2.rendering = workInProgress$1,
              type$2.tail = workInProgress$1.sibling,
              type$2.renderingStartTime = now(),
              workInProgress$1.sibling = null,
              current = suspenseStackCursor.current,
              push$1(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1),
              workInProgress$1)
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress$1),
            popHiddenContext(),
            newProps = workInProgress$1.memoizedState !== null,
            current === null
              ? newProps && (workInProgress$1.flags |= 8192)
              : current.memoizedState !== null !== newProps && (workInProgress$1.flags |= 8192),
            newProps
              ? renderLanes$1 & 536870912 && !(workInProgress$1.flags & 128)
                && (bubbleProperties(workInProgress$1),
                  workInProgress$1.subtreeFlags & 6 && (workInProgress$1.flags |= 8192))
              : bubbleProperties(workInProgress$1),
            renderLanes$1 = workInProgress$1.updateQueue,
            renderLanes$1 !== null && scheduleRetryEffect(workInProgress$1, renderLanes$1.retryQueue),
            renderLanes$1 = null,
            current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null
            && (renderLanes$1 = current.memoizedState.cachePool.pool),
            newProps = null,
            workInProgress$1.memoizedState !== null && workInProgress$1.memoizedState.cachePool !== null
            && (newProps = workInProgress$1.memoizedState.cachePool.pool),
            newProps !== renderLanes$1 && (workInProgress$1.flags |= 2048),
            current !== null && pop(resumedCache),
            null
        case 24:
          return renderLanes$1 = null,
            current !== null && (renderLanes$1 = current.memoizedState.cache),
            workInProgress$1.memoizedState.cache !== renderLanes$1 && (workInProgress$1.flags |= 2048),
            popProvider(CacheContext),
            bubbleProperties(workInProgress$1),
            null
        case 25:
          return null
        case 30:
          return null
      }
      throw Error(formatProdErrorMessage(156, workInProgress$1.tag))
    }
    function unwindWork(current, workInProgress$1) {
      switch (popTreeContext(workInProgress$1), workInProgress$1.tag) {
        case 1:
          return current = workInProgress$1.flags,
            current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null
        case 3:
          return popProvider(CacheContext),
            popHostContainer(),
            current = workInProgress$1.flags,
            current & 65536 && !(current & 128)
              ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1)
              : null
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress$1), null
        case 13:
          if (
            popSuspenseHandler(workInProgress$1),
              current = workInProgress$1.memoizedState,
              current !== null && current.dehydrated !== null
          ) {
            if (workInProgress$1.alternate === null) throw Error(formatProdErrorMessage(340))
            resetHydrationState()
          }
          return current = workInProgress$1.flags,
            current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null
        case 19:
          return pop(suspenseStackCursor), null
        case 4:
          return popHostContainer(), null
        case 10:
          return popProvider(workInProgress$1.type), null
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress$1),
            popHiddenContext(),
            current !== null && pop(resumedCache),
            current = workInProgress$1.flags,
            current & 65536 ? (workInProgress$1.flags = current & -65537 | 128, workInProgress$1) : null
        case 24:
          return popProvider(CacheContext), null
        case 25:
          return null
        default:
          return null
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      switch (popTreeContext(interruptedWork), interruptedWork.tag) {
        case 3:
          popProvider(CacheContext), popHostContainer()
          break
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork)
          break
        case 4:
          popHostContainer()
          break
        case 13:
          popSuspenseHandler(interruptedWork)
          break
        case 19:
          pop(suspenseStackCursor)
          break
        case 10:
          popProvider(interruptedWork.type)
          break
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork), popHiddenContext(), current !== null && pop(resumedCache)
          break
        case 24:
          popProvider(CacheContext)
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue === null ? null : updateQueue.lastEffect
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next
          updateQueue = firstEffect
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0
              var create$2 = updateQueue.create, inst = updateQueue.inst
              lastEffect = create$2(), inst.destroy = lastEffect
            }
            updateQueue = updateQueue.next
          } while (updateQueue !== firstEffect)
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error)
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue === null ? null : updateQueue.lastEffect
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next
          updateQueue = firstEffect
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy
              if (destroy !== void 0) {
                inst.destroy = void 0, lastEffect = finishedWork
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy
                try {
                  destroy_()
                } catch (error) {
                  captureCommitPhaseError(lastEffect, nearestMountedAncestor, error)
                }
              }
            }
            updateQueue = updateQueue.next
          } while (updateQueue !== firstEffect)
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error)
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue
      if (updateQueue !== null) {
        var instance = finishedWork.stateNode
        try {
          commitCallbacks(updateQueue, instance)
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error)
        }
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(current.type, current.memoizedProps),
        instance.state = current.memoizedState
      try {
        instance.componentWillUnmount()
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error)
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref
        if (ref !== null) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode
              break
            case 30:
              instanceToUse = current.stateNode
              break
            default:
              instanceToUse = current.stateNode
          }
          typeof ref == `function` ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error)
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref, refCleanup = current.refCleanup
      if (ref !== null) {
        if (typeof refCleanup == `function`) {
          try {
            refCleanup()
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error)
          } finally {
            current.refCleanup = null, current = current.alternate, current != null && (current.refCleanup = null)
          }
        } else if (typeof ref == `function`) {
          try {
            ref(null)
          } catch (error$143) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$143)
          }
        } else ref.current = null
      }
    }
    function commitHostMount(finishedWork) {
      var type$2 = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode
      try {
        a: switch (type$2) {
          case `button`:
          case `input`:
          case `select`:
          case `textarea`:
            props.autoFocus && instance.focus()
            break a
          case `img`:
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet)
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error)
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode
        updateProperties(domElement, finishedWork.type, oldProps, newProps), domElement[internalPropsKey] = newProps
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error)
      }
    }
    function isHostParent(fiber) {
      return fiber.tag === 5 || fiber.tag === 3 || fiber.tag === 26 || fiber.tag === 27 && isSingletonScope(fiber.type)
        || fiber.tag === 4
    }
    function getHostSibling(fiber) {
      a: for (;;) {
        for (; fiber.sibling === null;) {
          if (fiber.return === null || isHostParent(fiber.return)) return null
          fiber = fiber.return
        }
        for (
          fiber.sibling.return = fiber.return, fiber = fiber.sibling;
          fiber.tag !== 5 && fiber.tag !== 6 && fiber.tag !== 18;
        ) {
          if (
            fiber.tag === 27 && isSingletonScope(fiber.type) || fiber.flags & 2 || fiber.child === null
            || fiber.tag === 4
          ) continue a
          fiber.child.return = fiber, fiber = fiber.child
        }
        if (!(fiber.flags & 2)) return fiber.stateNode
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node$1, before$2, parent) {
      var tag$3 = node$1.tag
      if (tag$3 === 5 || tag$3 === 6) {
        node$1 = node$1.stateNode,
          before$2
            ? (parent.nodeType === 9 ? parent.body : parent.nodeName === `HTML` ? parent.ownerDocument.body : parent)
              .insertBefore(node$1, before$2)
            : (before$2 = parent.nodeType === 9
              ? parent.body
              : parent.nodeName === `HTML`
              ? parent.ownerDocument.body
              : parent,
              before$2.appendChild(node$1),
              parent = parent._reactRootContainer,
              parent != null || before$2.onclick !== null || (before$2.onclick = noop$1))
      } else if (
        tag$3 !== 4
        && (tag$3 === 27 && isSingletonScope(node$1.type) && (parent = node$1.stateNode, before$2 = null),
          node$1 = node$1.child,
          node$1 !== null)
      ) {
        for (
          insertOrAppendPlacementNodeIntoContainer(node$1, before$2, parent), node$1 = node$1.sibling;
          node$1 !== null;
        ) insertOrAppendPlacementNodeIntoContainer(node$1, before$2, parent), node$1 = node$1.sibling
      }
    }
    function insertOrAppendPlacementNode(node$1, before$2, parent) {
      var tag$3 = node$1.tag
      if (tag$3 === 5 || tag$3 === 6) {
        node$1 = node$1.stateNode, before$2 ? parent.insertBefore(node$1, before$2) : parent.appendChild(node$1)
      } else if (
        tag$3 !== 4
        && (tag$3 === 27 && isSingletonScope(node$1.type) && (parent = node$1.stateNode),
          node$1 = node$1.child,
          node$1 !== null)
      ) {
        for (
          insertOrAppendPlacementNode(node$1, before$2, parent), node$1 = node$1.sibling;
          node$1 !== null;
        ) insertOrAppendPlacementNode(node$1, before$2, parent), node$1 = node$1.sibling
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps
      try {
        for (var type$2 = finishedWork.type, attributes = singleton.attributes; attributes.length;) {
          singleton.removeAttributeNode(attributes[0])
        }
        setInitialProperties(singleton, type$2, props),
          singleton[internalInstanceKey] = finishedWork,
          singleton[internalPropsKey] = props
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error)
      }
    }
    var offscreenSubtreeIsHidden = !1,
      offscreenSubtreeWasHidden = !1,
      needsFormReset = !1,
      PossiblyWeakSet = typeof WeakSet == `function` ? WeakSet : Set,
      nextEffect = null
    function commitBeforeMutationEffects(root$5, firstChild) {
      if (
        root$5 = root$5.containerInfo,
          eventsEnabled = _enabled,
          root$5 = getActiveElementDeep(root$5),
          hasSelectionCapabilities(root$5)
      ) {
        if (`selectionStart` in root$5) var JSCompiler_temp = { start: root$5.selectionStart, end: root$5.selectionEnd }
        else {a: {
            JSCompiler_temp = (JSCompiler_temp = root$5.ownerDocument) && JSCompiler_temp.defaultView || window
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection()
            if (selection && selection.rangeCount !== 0) {
              JSCompiler_temp = selection.anchorNode
              var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode
              selection = selection.focusOffset
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType
              } catch {
                JSCompiler_temp = null
                break a
              }
              var length$1 = 0,
                start$2 = -1,
                end$2 = -1,
                indexWithinAnchor = 0,
                indexWithinFocus = 0,
                node$1 = root$5,
                parentNode = null
              b: for (;;) {
                for (
                  var next;
                  node$1 !== JSCompiler_temp || anchorOffset !== 0 && node$1.nodeType !== 3
                  || (start$2 = length$1 + anchorOffset),
                    node$1 !== focusNode || selection !== 0 && node$1.nodeType !== 3 || (end$2 = length$1 + selection),
                    node$1.nodeType === 3 && (length$1 += node$1.nodeValue.length),
                    (next = node$1.firstChild) !== null;
                ) parentNode = node$1, node$1 = next
                for (;;) {
                  if (node$1 === root$5) break b
                  if (
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start$2 = length$1),
                      parentNode === focusNode && ++indexWithinFocus === selection && (end$2 = length$1),
                      (next = node$1.nextSibling) !== null
                  ) break
                  node$1 = parentNode, parentNode = node$1.parentNode
                }
                node$1 = next
              }
              JSCompiler_temp = start$2 === -1 || end$2 === -1 ? null : { start: start$2, end: end$2 }
            } else JSCompiler_temp = null
          }}
        JSCompiler_temp ||= { start: 0, end: 0 }
      } else JSCompiler_temp = null
      for (
        selectionInformation = { focusedElem: root$5, selectionRange: JSCompiler_temp },
          _enabled = !1,
          nextEffect = firstChild;
        nextEffect !== null;
      ) {
        if (
          firstChild = nextEffect, root$5 = firstChild.child, firstChild.subtreeFlags & 1024 && root$5 !== null
        ) root$5.return = firstChild, nextEffect = root$5
        else {for (; nextEffect !== null;) {
            switch (
              firstChild = nextEffect, focusNode = firstChild.alternate, root$5 = firstChild.flags, firstChild.tag
            ) {
              case 0:
                break
              case 11:
              case 15:
                break
              case 1:
                if (root$5 & 1024 && focusNode !== null) {
                  root$5 = void 0,
                    JSCompiler_temp = firstChild,
                    anchorOffset = focusNode.memoizedProps,
                    focusNode = focusNode.memoizedState,
                    selection = JSCompiler_temp.stateNode
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset,
                      JSCompiler_temp.elementType === JSCompiler_temp.type,
                    )
                    root$5 = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode),
                      selection.__reactInternalSnapshotBeforeUpdate = root$5
                  } catch (error) {
                    captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error)
                  }
                }
                break
              case 3:
                if (root$5 & 1024) {
                  if (
                    root$5 = firstChild.stateNode.containerInfo,
                      JSCompiler_temp = root$5.nodeType,
                      JSCompiler_temp === 9
                  ) clearContainerSparingly(root$5)
                  else if (JSCompiler_temp === 1) {
                    switch (root$5.nodeName) {
                      case `HEAD`:
                      case `HTML`:
                      case `BODY`:
                        clearContainerSparingly(root$5)
                        break
                      default:
                        root$5.textContent = ``
                    }
                  }
                }
                break
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break
              default:
                if (root$5 & 1024) throw Error(formatProdErrorMessage(163))
            }
            if (root$5 = firstChild.sibling, root$5 !== null) {
              root$5.return = firstChild.return, nextEffect = root$5
              break
            }
            nextEffect = firstChild.return
          }}
      }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork),
            flags & 4 && commitHookEffectListMount(5, finishedWork)
          break
        case 1:
          if (recursivelyTraverseLayoutEffects(finishedRoot, finishedWork), flags & 4) {
            if (finishedRoot = finishedWork.stateNode, current === null) {
              try {
                finishedRoot.componentDidMount()
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error)
              }
            } else {
              var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps)
              current = current.memoizedState
              try {
                finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate)
              } catch (error$142) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error$142)
              }
            }
          }
          flags & 64 && commitClassCallbacks(finishedWork),
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return)
          break
        case 3:
          if (
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork),
              flags & 64 && (finishedRoot = finishedWork.updateQueue, finishedRoot !== null)
          ) {
            if (current = null, finishedWork.child !== null) {
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode
                  break
                case 1:
                  current = finishedWork.child.stateNode
              }
            }
            try {
              commitCallbacks(finishedRoot, current)
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error)
            }
          }
          break
        case 27:
          current === null && flags & 4 && commitHostSingletonAcquisition(finishedWork)
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork),
            current === null && flags & 4 && commitHostMount(finishedWork),
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return)
          break
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork)
          break
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork),
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork),
            flags & 64 && (finishedRoot = finishedWork.memoizedState,
              finishedRoot !== null
              && (finishedRoot = finishedRoot.dehydrated,
                finishedRoot !== null
                && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork),
                  registerSuspenseInstanceRetry(finishedRoot, finishedWork))))
          break
        case 22:
          if (flags = finishedWork.memoizedState !== null || offscreenSubtreeIsHidden, !flags) {
            current = current !== null && current.memoizedState !== null || offscreenSubtreeWasHidden,
              prevProps = offscreenSubtreeIsHidden
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden
            offscreenSubtreeIsHidden = flags,
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
                ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  (finishedWork.subtreeFlags & 8772) != 0,
                )
                : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork),
              offscreenSubtreeIsHidden = prevProps,
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden
          }
          break
        case 30:
          break
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork)
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate
      alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate)),
        fiber.child = null,
        fiber.deletions = null,
        fiber.sibling = null,
        fiber.tag === 5 && (alternate = fiber.stateNode, alternate !== null && detachDeletedInstance(alternate)),
        fiber.stateNode = null,
        fiber.return = null,
        fiber.dependencies = null,
        fiber.memoizedProps = null,
        fiber.memoizedState = null,
        fiber.pendingProps = null,
        fiber.stateNode = null,
        fiber.updateQueue = null
    }
    var hostParent = null, hostParentIsContainer = !1
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; parent !== null;) {
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling
      }
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && typeof injectedHook.onCommitFiberUnmount == `function`) {
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber)
        } catch {}
      }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor),
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber),
            deletedFiber.memoizedState
              ? deletedFiber.memoizedState.count--
              : deletedFiber.stateNode
                && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber))
          break
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor)
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = !1),
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber),
            releaseSingletonInstance(deletedFiber.stateNode),
            hostParent = prevHostParent,
            hostParentIsContainer = prevHostParentIsContainer
          break
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor)
        case 6:
          if (
            prevHostParent = hostParent,
              prevHostParentIsContainer = hostParentIsContainer,
              hostParent = null,
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber),
              hostParent = prevHostParent,
              hostParentIsContainer = prevHostParentIsContainer,
              hostParent !== null
          ) {
            if (hostParentIsContainer) {
              try {
                ;(hostParent.nodeType === 9
                  ? hostParent.body
                  : hostParent.nodeName === `HTML`
                  ? hostParent.ownerDocument.body
                  : hostParent).removeChild(deletedFiber.stateNode)
              } catch (error) {
                captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error)
              }
            } else {try {
                hostParent.removeChild(deletedFiber.stateNode)
              } catch (error) {
                captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error)
              }}
          }
          break
        case 18:
          hostParent !== null
            && (hostParentIsContainer
              ? (finishedRoot = hostParent,
                clearSuspenseBoundary(
                  finishedRoot.nodeType === 9
                    ? finishedRoot.body
                    : finishedRoot.nodeName === `HTML`
                    ? finishedRoot.ownerDocument.body
                    : finishedRoot,
                  deletedFiber.stateNode,
                ),
                retryIfBlockedOn(finishedRoot))
              : clearSuspenseBoundary(hostParent, deletedFiber.stateNode))
          break
        case 4:
          prevHostParent = hostParent,
            prevHostParentIsContainer = hostParentIsContainer,
            hostParent = deletedFiber.stateNode.containerInfo,
            hostParentIsContainer = !0,
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber),
            hostParent = prevHostParent,
            hostParentIsContainer = prevHostParentIsContainer
          break
        case 0:
        case 11:
        case 14:
        case 15:
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor),
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor),
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
          break
        case 1:
          offscreenSubtreeWasHidden
          || (safelyDetachRef(deletedFiber, nearestMountedAncestor),
            prevHostParent = deletedFiber.stateNode,
            typeof prevHostParent.componentWillUnmount == `function`
            && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent)),
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
          break
        case 21:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
          break
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden)
            || deletedFiber.memoizedState !== null,
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber),
            offscreenSubtreeWasHidden = prevHostParent
          break
        default:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber)
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (
        finishedWork.memoizedState === null
        && (finishedRoot = finishedWork.alternate,
          finishedRoot !== null
          && (finishedRoot = finishedRoot.memoizedState,
            finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null)))
      ) {
        try {
          retryIfBlockedOn(finishedRoot)
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error)
        }
      }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode
          return retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet()), retryCache
        case 22:
          return finishedWork = finishedWork.stateNode,
            retryCache = finishedWork._retryCache,
            retryCache === null && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
            retryCache
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag))
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork)
      wakeables.forEach(function(wakeable) {
        var retry$1 = resolveRetryWakeable.bind(null, finishedWork, wakeable)
        retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry$1, retry$1))
      })
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions
      if (deletions !== null) {
        for (var i$14 = 0; i$14 < deletions.length; i$14++) {
          var childToDelete = deletions[i$14], root$5 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber
          a: for (; parent !== null;) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode, hostParentIsContainer = !1
                  break a
                }
                break
              case 5:
                hostParent = parent.stateNode, hostParentIsContainer = !1
                break a
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo, hostParentIsContainer = !0
                break a
            }
            parent = parent.return
          }
          if (hostParent === null) throw Error(formatProdErrorMessage(160))
          commitDeletionEffectsOnFiber(root$5, returnFiber, childToDelete),
            hostParent = null,
            hostParentIsContainer = !1,
            root$5 = childToDelete.alternate,
            root$5 !== null && (root$5.return = null),
            childToDelete.return = null
        }
      }
      if (parentFiber.subtreeFlags & 13878) {
        for (
          parentFiber = parentFiber.child;
          parentFiber !== null;
        ) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling
      }
    }
    var currentHoistableRoot = null
    function commitMutationEffectsOnFiber(finishedWork, root$5) {
      var current = finishedWork.alternate, flags = finishedWork.flags
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root$5, finishedWork),
            commitReconciliationEffects(finishedWork),
            flags & 4
            && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
              commitHookEffectListMount(3, finishedWork),
              commitHookEffectListUnmount(5, finishedWork, finishedWork.return))
          break
        case 1:
          recursivelyTraverseMutationEffects(root$5, finishedWork),
            commitReconciliationEffects(finishedWork),
            flags & 512 && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return)),
            flags & 64 && offscreenSubtreeIsHidden
            && (finishedWork = finishedWork.updateQueue,
              finishedWork !== null
              && (flags = finishedWork.callbacks,
                flags !== null
                && (current = finishedWork.shared.hiddenCallbacks,
                  finishedWork.shared.hiddenCallbacks = current === null ? flags : current.concat(flags))))
          break
        case 26:
          var hoistableRoot = currentHoistableRoot
          if (
            recursivelyTraverseMutationEffects(root$5, finishedWork),
              commitReconciliationEffects(finishedWork),
              flags & 512
              && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return)),
              flags & 4
          ) {
            var currentResource = current === null ? null : current.memoizedState
            if (flags = finishedWork.memoizedState, current === null) {
              if (flags === null) {
                if (finishedWork.stateNode === null) {
                  a: {
                    flags = finishedWork.type,
                      current = finishedWork.memoizedProps,
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot
                    b: switch (flags) {
                      case `title`:
                        currentResource = hoistableRoot.getElementsByTagName(`title`)[0],
                          (!currentResource || currentResource[internalHoistableMarker]
                            || currentResource[internalInstanceKey]
                            || currentResource.namespaceURI === `http://www.w3.org/2000/svg`
                            || currentResource.hasAttribute(`itemprop`))
                          && (currentResource = hoistableRoot.createElement(flags),
                            hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector(`head > title`),
                            )),
                          setInitialProperties(currentResource, flags, current),
                          currentResource[internalInstanceKey] = finishedWork,
                          markNodeAsHoistable(currentResource),
                          flags = currentResource
                        break a
                      case `link`:
                        var maybeNodes = getHydratableHoistableCache(`link`, `href`, hoistableRoot).get(
                          flags + (current.href || ``),
                        )
                        if (maybeNodes) {
                          for (var i$14 = 0; i$14 < maybeNodes.length; i$14++) {
                            if (
                              currentResource = maybeNodes[i$14],
                                currentResource.getAttribute(`href`)
                                  === (current.href == null || current.href === `` ? null : current.href)
                                && currentResource.getAttribute(`rel`) === (current.rel == null ? null : current.rel)
                                && currentResource.getAttribute(`title`)
                                  === (current.title == null ? null : current.title)
                                && currentResource.getAttribute(`crossorigin`)
                                  === (current.crossOrigin == null ? null : current.crossOrigin)
                            ) {
                              maybeNodes.splice(i$14, 1)
                              break b
                            }
                          }
                        }
                        currentResource = hoistableRoot.createElement(flags),
                          setInitialProperties(currentResource, flags, current),
                          hoistableRoot.head.appendChild(currentResource)
                        break
                      case `meta`:
                        if (
                          maybeNodes = getHydratableHoistableCache(`meta`, `content`, hoistableRoot).get(
                            flags + (current.content || ``),
                          )
                        ) {
                          for (i$14 = 0; i$14 < maybeNodes.length; i$14++) {
                            if (
                              currentResource = maybeNodes[i$14],
                                currentResource.getAttribute(`content`)
                                  === (current.content == null ? null : `` + current.content)
                                && currentResource.getAttribute(`name`) === (current.name == null ? null : current.name)
                                && currentResource.getAttribute(`property`)
                                  === (current.property == null ? null : current.property)
                                && currentResource.getAttribute(`http-equiv`)
                                  === (current.httpEquiv == null ? null : current.httpEquiv)
                                && currentResource.getAttribute(`charset`)
                                  === (current.charSet == null ? null : current.charSet)
                            ) {
                              maybeNodes.splice(i$14, 1)
                              break b
                            }
                          }
                        }
                        currentResource = hoistableRoot.createElement(flags),
                          setInitialProperties(currentResource, flags, current),
                          hoistableRoot.head.appendChild(currentResource)
                        break
                      default:
                        throw Error(formatProdErrorMessage(468, flags))
                    }
                    currentResource[internalInstanceKey] = finishedWork,
                      markNodeAsHoistable(currentResource),
                      flags = currentResource
                  }
                  finishedWork.stateNode = flags
                } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode)
              } else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)
            } else {currentResource === flags
                ? flags === null && finishedWork.stateNode !== null
                  && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps)
                : (currentResource === null
                  ? current.stateNode !== null && (current = current.stateNode, current.parentNode.removeChild(current))
                  : currentResource.count--,
                  flags === null
                    ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode)
                    : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps))}
          }
          break
        case 27:
          recursivelyTraverseMutationEffects(root$5, finishedWork),
            commitReconciliationEffects(finishedWork),
            flags & 512 && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return)),
            current !== null && flags & 4
            && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps)
          break
        case 5:
          if (
            recursivelyTraverseMutationEffects(root$5, finishedWork),
              commitReconciliationEffects(finishedWork),
              flags & 512
              && (offscreenSubtreeWasHidden || current === null || safelyDetachRef(current, current.return)),
              finishedWork.flags & 32
          ) {
            hoistableRoot = finishedWork.stateNode
            try {
              setTextContent(hoistableRoot, ``)
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error)
            }
          }
          flags & 4 && finishedWork.stateNode != null
          && (hoistableRoot = finishedWork.memoizedProps,
            commitHostUpdate(finishedWork, hoistableRoot, current === null ? hoistableRoot : current.memoizedProps)),
            flags & 1024 && (needsFormReset = !0)
          break
        case 6:
          if (
            recursivelyTraverseMutationEffects(root$5, finishedWork),
              commitReconciliationEffects(finishedWork),
              flags & 4
          ) {
            if (finishedWork.stateNode === null) throw Error(formatProdErrorMessage(162))
            flags = finishedWork.memoizedProps, current = finishedWork.stateNode
            try {
              current.nodeValue = flags
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error)
            }
          }
          break
        case 3:
          if (
            tagCaches = null,
              hoistableRoot = currentHoistableRoot,
              currentHoistableRoot = getHoistableRoot(root$5.containerInfo),
              recursivelyTraverseMutationEffects(root$5, finishedWork),
              currentHoistableRoot = hoistableRoot,
              commitReconciliationEffects(finishedWork),
              flags & 4 && current !== null && current.memoizedState.isDehydrated
          ) {
            try {
              retryIfBlockedOn(root$5.containerInfo)
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error)
            }
          }
          needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork))
          break
        case 4:
          flags = currentHoistableRoot,
            currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo),
            recursivelyTraverseMutationEffects(root$5, finishedWork),
            commitReconciliationEffects(finishedWork),
            currentHoistableRoot = flags
          break
        case 12:
          recursivelyTraverseMutationEffects(root$5, finishedWork), commitReconciliationEffects(finishedWork)
          break
        case 13:
          recursivelyTraverseMutationEffects(root$5, finishedWork),
            commitReconciliationEffects(finishedWork),
            finishedWork.child.flags & 8192
            && finishedWork.memoizedState !== null != (current !== null && current.memoizedState !== null)
            && (globalMostRecentFallbackTime = now()),
            flags & 4
            && (flags = finishedWork.updateQueue,
              flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)))
          break
        case 22:
          hoistableRoot = finishedWork.memoizedState !== null
          var wasHidden = current !== null && current.memoizedState !== null,
            prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden
          if (
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot,
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden,
              recursivelyTraverseMutationEffects(root$5, finishedWork),
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden,
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden,
              commitReconciliationEffects(finishedWork),
              flags & 8192
          ) {
            a: for (
              root$5 = finishedWork.stateNode,
                root$5._visibility = hoistableRoot ? root$5._visibility & -2 : root$5._visibility | 1,
                hoistableRoot
                && (current === null || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden
                  || recursivelyTraverseDisappearLayoutEffects(finishedWork)),
                current = null,
                root$5 = finishedWork;;
            ) {
              if (root$5.tag === 5 || root$5.tag === 26) {
                if (current === null) {
                  wasHidden = current = root$5
                  try {
                    if (currentResource = wasHidden.stateNode, hoistableRoot) {
                      maybeNodes = currentResource.style,
                        typeof maybeNodes.setProperty == `function`
                          ? maybeNodes.setProperty(`display`, `none`, `important`)
                          : maybeNodes.display = `none`
                    } else {
                      i$14 = wasHidden.stateNode
                      var styleProp = wasHidden.memoizedProps.style,
                        display = styleProp != null && styleProp.hasOwnProperty(`display`) ? styleProp.display : null
                      i$14.style.display = display == null || typeof display == `boolean` ? `` : (`` + display).trim()
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error)
                  }
                }
              } else if (root$5.tag === 6) {
                if (current === null) {
                  wasHidden = root$5
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot ? `` : wasHidden.memoizedProps
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error)
                  }
                }
              } else if (
                (root$5.tag !== 22 && root$5.tag !== 23 || root$5.memoizedState === null || root$5 === finishedWork)
                && root$5.child !== null
              ) {
                root$5.child.return = root$5, root$5 = root$5.child
                continue
              }
              if (root$5 === finishedWork) break a
              for (; root$5.sibling === null;) {
                if (root$5.return === null || root$5.return === finishedWork) break a
                current === root$5 && (current = null), root$5 = root$5.return
              }
              current === root$5 && (current = null), root$5.sibling.return = root$5.return, root$5 = root$5.sibling
            }
          }
          flags & 4
            && (flags = finishedWork.updateQueue,
              flags !== null
              && (current = flags.retryQueue,
                current !== null && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))))
          break
        case 19:
          recursivelyTraverseMutationEffects(root$5, finishedWork),
            commitReconciliationEffects(finishedWork),
            flags & 4
            && (flags = finishedWork.updateQueue,
              flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)))
          break
        case 30:
          break
        case 21:
          break
        default:
          recursivelyTraverseMutationEffects(root$5, finishedWork), commitReconciliationEffects(finishedWork)
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags
      if (flags & 2) {
        try {
          for (var hostParentFiber, parentFiber = finishedWork.return; parentFiber !== null;) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber
              break
            }
            parentFiber = parentFiber.return
          }
          if (hostParentFiber == null) throw Error(formatProdErrorMessage(160))
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode, before$2 = getHostSibling(finishedWork)
              insertOrAppendPlacementNode(finishedWork, before$2, parent)
              break
            case 5:
              var parent$144 = hostParentFiber.stateNode
              hostParentFiber.flags & 32 && (setTextContent(parent$144, ``), hostParentFiber.flags &= -33)
              var before$145 = getHostSibling(finishedWork)
              insertOrAppendPlacementNode(finishedWork, before$145, parent$144)
              break
            case 3:
            case 4:
              var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork)
              insertOrAppendPlacementNodeIntoContainer(finishedWork, before$147, parent$146)
              break
            default:
              throw Error(formatProdErrorMessage(161))
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error)
        }
        finishedWork.flags &= -3
      }
      flags & 4096 && (finishedWork.flags &= -4097)
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024) {
        for (parentFiber = parentFiber.child; parentFiber !== null;) {
          var fiber = parentFiber
          recursivelyResetForms(fiber),
            fiber.tag === 5 && fiber.flags & 1024 && fiber.stateNode.reset(),
            parentFiber = parentFiber.sibling
        }
      }
    }
    function recursivelyTraverseLayoutEffects(root$5, parentFiber) {
      if (parentFiber.subtreeFlags & 8772) {
        for (
          parentFiber = parentFiber.child;
          parentFiber !== null;
        ) commitLayoutEffectOnFiber(root$5, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling
      }
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; parentFiber !== null;) {
        var finishedWork = parentFiber
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return),
              recursivelyTraverseDisappearLayoutEffects(finishedWork)
            break
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return)
            var instance = finishedWork.stateNode
            typeof instance.componentWillUnmount == `function`
            && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance),
              recursivelyTraverseDisappearLayoutEffects(finishedWork)
            break
          case 27:
            releaseSingletonInstance(finishedWork.stateNode)
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return), recursivelyTraverseDisappearLayoutEffects(finishedWork)
            break
          case 22:
            finishedWork.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(finishedWork)
            break
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork)
            break
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork)
        }
        parentFiber = parentFiber.sibling
      }
    }
    function recursivelyTraverseReappearLayoutEffects(
      finishedRoot$jscomp$0,
      parentFiber,
      includeWorkInProgressEffects,
    ) {
      for (
        includeWorkInProgressEffects &&= (parentFiber.subtreeFlags & 8772) != 0, parentFiber = parentFiber.child;
        parentFiber !== null;
      ) {
        var current = parentFiber.alternate,
          finishedRoot = finishedRoot$jscomp$0,
          finishedWork = parentFiber,
          flags = finishedWork.flags
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects),
              commitHookEffectListMount(4, finishedWork)
            break
          case 1:
            if (
              recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects),
                current = finishedWork,
                finishedRoot = current.stateNode,
                typeof finishedRoot.componentDidMount == `function`
            ) {
              try {
                finishedRoot.componentDidMount()
              } catch (error) {
                captureCommitPhaseError(current, current.return, error)
              }
            }
            if (current = finishedWork, finishedRoot = current.updateQueue, finishedRoot !== null) {
              var instance = current.stateNode
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks
                if (hiddenCallbacks !== null) {
                  for (
                    finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
                    finishedRoot < hiddenCallbacks.length;
                    finishedRoot++
                  ) callCallback(hiddenCallbacks[finishedRoot], instance)
                }
              } catch (error) {
                captureCommitPhaseError(current, current.return, error)
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork),
              safelyAttachRef(finishedWork, finishedWork.return)
            break
          case 27:
            commitHostSingletonAcquisition(finishedWork)
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects),
              includeWorkInProgressEffects && current === null && flags & 4 && commitHostMount(finishedWork),
              safelyAttachRef(finishedWork, finishedWork.return)
            break
          case 12:
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects)
            break
          case 13:
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects),
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork)
            break
          case 22:
            finishedWork.memoizedState === null
            && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects),
              safelyAttachRef(finishedWork, finishedWork.return)
            break
          case 30:
            break
          default:
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects)
        }
        parentFiber = parentFiber.sibling
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null
      current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null
      && (previousCache = current.memoizedState.cachePool.pool),
        current = null,
        finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null
        && (current = finishedWork.memoizedState.cachePool.pool),
        current !== previousCache
        && (current != null && current.refCount++, previousCache != null && releaseCache(previousCache))
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null,
        finishedWork.alternate !== null && (current = finishedWork.alternate.memoizedState.cache),
        finishedWork = finishedWork.memoizedState.cache,
        finishedWork !== current && (finishedWork.refCount++, current != null && releaseCache(current))
    }
    function recursivelyTraversePassiveMountEffects(root$5, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256) {
        for (parentFiber = parentFiber.child; parentFiber !== null;) {
          commitPassiveMountOnFiber(root$5, parentFiber, committedLanes, committedTransitions),
            parentFiber = parentFiber.sibling
        }
      }
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions),
            flags & 2048 && commitHookEffectListMount(9, finishedWork)
          break
        case 1:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions)
          break
        case 3:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions),
            flags & 2048
            && (finishedRoot = null,
              finishedWork.alternate !== null && (finishedRoot = finishedWork.alternate.memoizedState.cache),
              finishedWork = finishedWork.memoizedState.cache,
              finishedWork !== finishedRoot
              && (finishedWork.refCount++, finishedRoot != null && releaseCache(finishedRoot)))
          break
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions),
              finishedRoot = finishedWork.stateNode
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps,
                id$2 = _finishedWork$memoize2.id,
                onPostCommit = _finishedWork$memoize2.onPostCommit
              typeof onPostCommit == `function`
                && onPostCommit(
                  id$2,
                  finishedWork.alternate === null ? `mount` : `update`,
                  finishedRoot.passiveEffectDuration,
                  -0,
                )
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error)
            }
          } else {recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
            )}
          break
        case 13:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions)
          break
        case 23:
          break
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode,
            id$2 = finishedWork.alternate,
            finishedWork.memoizedState === null
              ? _finishedWork$memoize2._visibility & 2
                ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                )
                : (_finishedWork$memoize2._visibility |= 2,
                  recursivelyTraverseReconnectPassiveEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions,
                    (finishedWork.subtreeFlags & 10256) != 0,
                  ))
              : _finishedWork$memoize2._visibility & 2
              ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions)
              : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork),
            flags & 2048 && commitOffscreenPassiveMountEffects(id$2, finishedWork)
          break
        case 24:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions),
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork)
          break
        default:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions)
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(
      finishedRoot$jscomp$0,
      parentFiber,
      committedLanes$jscomp$0,
      committedTransitions$jscomp$0,
      includeWorkInProgressEffects,
    ) {
      for (
        includeWorkInProgressEffects &&= (parentFiber.subtreeFlags & 10256) != 0, parentFiber = parentFiber.child;
        parentFiber !== null;
      ) {
        var finishedRoot = finishedRoot$jscomp$0,
          finishedWork = parentFiber,
          committedLanes = committedLanes$jscomp$0,
          committedTransitions = committedTransitions$jscomp$0,
          flags = finishedWork.flags
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
            ), commitHookEffectListMount(8, finishedWork)
            break
          case 23:
            break
          case 22:
            var instance = finishedWork.stateNode
            finishedWork.memoizedState === null
              ? (instance._visibility |= 2,
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects,
                ))
              : instance._visibility & 2
              ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects,
              )
              : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork),
              includeWorkInProgressEffects && flags & 2048
              && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork)
            break
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
            ),
              includeWorkInProgressEffects && flags & 2048
              && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork)
            break
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects,
            )
        }
        parentFiber = parentFiber.sibling
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256) {
        for (parentFiber = parentFiber.child; parentFiber !== null;) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork),
                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork)
              break
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork),
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork)
              break
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
          }
          parentFiber = parentFiber.sibling
        }
      }
    }
    var suspenseyCommitFlag = 8192
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag) {
        for (parentFiber = parentFiber.child; parentFiber !== null;) {
          accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling
        }
      }
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber),
            fiber.flags & suspenseyCommitFlag && fiber.memoizedState !== null
            && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps)
          break
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber)
          break
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo),
            recursivelyAccumulateSuspenseyCommit(fiber),
            currentHoistableRoot = previousHoistableRoot
          break
        case 22:
          fiber.memoizedState === null
            && (previousHoistableRoot = fiber.alternate,
              previousHoistableRoot !== null && previousHoistableRoot.memoizedState !== null
                ? (previousHoistableRoot = suspenseyCommitFlag,
                  suspenseyCommitFlag = 16777216,
                  recursivelyAccumulateSuspenseyCommit(fiber),
                  suspenseyCommitFlag = previousHoistableRoot)
                : recursivelyAccumulateSuspenseyCommit(fiber))
          break
        default:
          recursivelyAccumulateSuspenseyCommit(fiber)
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate
      if (previousFiber !== null && (parentFiber = previousFiber.child, parentFiber !== null)) {
        previousFiber.child = null
        do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber
        while (parentFiber !== null)
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions
      if (parentFiber.flags & 16) {
        if (deletions !== null) {
          for (var i$14 = 0; i$14 < deletions.length; i$14++) {
            var childToDelete = deletions[i$14]
            nextEffect = childToDelete, commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber)
          }
        }
        detachAlternateSiblings(parentFiber)
      }
      if (parentFiber.subtreeFlags & 10256) {
        for (parentFiber = parentFiber.child; parentFiber !== null;) {
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling
        }
      }
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork),
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return)
          break
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork)
          break
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork)
          break
        case 22:
          var instance = finishedWork.stateNode
          finishedWork.memoizedState !== null && instance._visibility & 2
            && (finishedWork.return === null || finishedWork.return.tag !== 13)
            ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork))
            : recursivelyTraversePassiveUnmountEffects(finishedWork)
          break
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork)
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions
      if (parentFiber.flags & 16) {
        if (deletions !== null) {
          for (var i$14 = 0; i$14 < deletions.length; i$14++) {
            var childToDelete = deletions[i$14]
            nextEffect = childToDelete, commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber)
          }
        }
        detachAlternateSiblings(parentFiber)
      }
      for (parentFiber = parentFiber.child; parentFiber !== null;) {
        switch (deletions = parentFiber, deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return),
              recursivelyTraverseDisconnectPassiveEffects(deletions)
            break
          case 22:
            i$14 = deletions.stateNode,
              i$14._visibility & 2 && (i$14._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions))
            break
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions)
        }
        parentFiber = parentFiber.sibling
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; nextEffect !== null;) {
        var fiber = nextEffect
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor)
            break
          case 23:
          case 22:
            if (fiber.memoizedState !== null && fiber.memoizedState.cachePool !== null) {
              var cache = fiber.memoizedState.cachePool.pool
              cache != null && cache.refCount++
            }
            break
          case 24:
            releaseCache(fiber.memoizedState.cache)
        }
        if (cache = fiber.child, cache !== null) cache.return = fiber, nextEffect = cache
        else {a: for (fiber = deletedSubtreeRoot; nextEffect !== null;) {
            cache = nextEffect
            var sibling = cache.sibling, returnFiber = cache.return
            if (detachFiberAfterEffects(cache), cache === fiber) {
              nextEffect = null
              break a
            }
            if (sibling !== null) {
              sibling.return = returnFiber, nextEffect = sibling
              break a
            }
            nextEffect = returnFiber
          }}
      }
    }
    var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType)
          return cacheForType === void 0 && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType)),
            cacheForType
        },
      },
      PossiblyWeakMap = typeof WeakMap == `function` ? WeakMap : Map,
      executionContext = 0,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      workInProgressSuspendedReason = 0,
      workInProgressThrownValue = null,
      workInProgressRootDidSkipSuspendedSiblings = !1,
      workInProgressRootIsPrerendering = !1,
      workInProgressRootDidAttachPingListener = !1,
      entangledRenderLanes = 0,
      workInProgressRootExitStatus = 0,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootInterleavedUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      workInProgressDeferredLane = 0,
      workInProgressSuspendedRetryLanes = 0,
      workInProgressRootConcurrentErrors = null,
      workInProgressRootRecoverableErrors = null,
      workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
      globalMostRecentFallbackTime = 0,
      workInProgressRootRenderTargetTime = 1 / 0,
      workInProgressTransitions = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      pendingEffectsStatus = 0,
      pendingEffectsRoot = null,
      pendingFinishedWork = null,
      pendingEffectsLanes = 0,
      pendingEffectsRemainingLanes = 0,
      pendingPassiveTransitions = null,
      pendingRecoverableErrors = null,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null
    function requestUpdateLane() {
      if (executionContext & 2 && workInProgressRootRenderLanes !== 0) {
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes
      }
      if (ReactSharedInternals.T !== null) {
        var actionScopeLane = currentEntangledLane
        return actionScopeLane === 0 ? requestTransitionLane() : actionScopeLane
      }
      return resolveUpdatePriority()
    }
    function requestDeferredLane() {
      workInProgressDeferredLane === 0
        && (workInProgressDeferredLane = !(workInProgressRootRenderLanes & 536870912) || isHydrating
          ? claimNextTransitionLane()
          : 536870912)
      var suspenseHandler = suspenseHandlerStackCursor.current
      return suspenseHandler !== null && (suspenseHandler.flags |= 32), workInProgressDeferredLane
    }
    function scheduleUpdateOnFiber(root$5, fiber, lane) {
      ;(root$5 === workInProgressRoot && (workInProgressSuspendedReason === 2 || workInProgressSuspendedReason === 9)
        || root$5.cancelPendingCommit !== null)
        && (prepareFreshStack(root$5, 0),
          markRootSuspended(root$5, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)),
        markRootUpdated$1(root$5, lane),
        (!(executionContext & 2) || root$5 !== workInProgressRoot)
        && (root$5 === workInProgressRoot
          && (!(executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane),
            workInProgressRootExitStatus === 4
            && markRootSuspended(root$5, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)),
          ensureRootIsScheduled(root$5))
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (executionContext & 6) throw Error(formatProdErrorMessage(327))
      var shouldTimeSlice = !forceSync && (lanes & 124) == 0 && (lanes & root$jscomp$0.expiredLanes) === 0
          || checkIfRootIsPrerendering(root$jscomp$0, lanes),
        exitStatus = shouldTimeSlice
          ? renderRootConcurrent(root$jscomp$0, lanes)
          : renderRootSync(root$jscomp$0, lanes, !0),
        renderWasConcurrent = shouldTimeSlice
      do {
        if (exitStatus === 0) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, !1)
          break
        } else {
          if (
            forceSync = root$jscomp$0.current.alternate,
              renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)
          ) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, !1), renderWasConcurrent = !1
            continue
          }
          if (exitStatus === 2) {
            if (renderWasConcurrent = lanes, root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent) {
              var JSCompiler_inline_result = 0
            } else {JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913,
                JSCompiler_inline_result = JSCompiler_inline_result === 0
                  ? JSCompiler_inline_result & 536870912 ? 536870912 : 0
                  : JSCompiler_inline_result}
            if (JSCompiler_inline_result !== 0) {
              lanes = JSCompiler_inline_result
              a: {
                var root$5 = root$jscomp$0
                exitStatus = workInProgressRootConcurrentErrors
                var wasRootDehydrated = root$5.current.memoizedState.isDehydrated
                if (
                  wasRootDehydrated && (prepareFreshStack(root$5, JSCompiler_inline_result).flags |= 256),
                    JSCompiler_inline_result = renderRootSync(root$5, JSCompiler_inline_result, !1),
                    JSCompiler_inline_result !== 2
                ) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root$5.errorRecoveryDisabledLanes |= renderWasConcurrent,
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent,
                      exitStatus = 4
                    break a
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors,
                    workInProgressRootRecoverableErrors = exitStatus,
                    renderWasConcurrent !== null
                    && (workInProgressRootRecoverableErrors === null
                      ? workInProgressRootRecoverableErrors = renderWasConcurrent
                      : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        renderWasConcurrent,
                      ))
                }
                exitStatus = JSCompiler_inline_result
              }
              if (renderWasConcurrent = !1, exitStatus !== 2) continue
            }
          }
          if (exitStatus === 1) {
            prepareFreshStack(root$jscomp$0, 0), markRootSuspended(root$jscomp$0, lanes, 0, !0)
            break
          }
          a: {
            switch (shouldTimeSlice = root$jscomp$0, renderWasConcurrent = exitStatus, renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345))
              case 4:
                if ((lanes & 4194048) !== lanes) break
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings,
                )
                break a
              case 2:
                workInProgressRootRecoverableErrors = null
                break
              case 3:
              case 5:
                break
              default:
                throw Error(formatProdErrorMessage(329))
            }
            if (
              (lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)
            ) {
              if (
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings,
                ), getNextLanes(shouldTimeSlice, 0, !0) !== 0
              ) break a
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  2,
                  -0,
                  0,
                ),
                exitStatus,
              )
              break a
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              0,
              -0,
              0,
            )
          }
        }
        break
      } while (1)
      ensureRootIsScheduled(root$jscomp$0)
    }
    function commitRootWhenReady(
      root$5,
      finishedWork,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      lanes,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
      didSkipSuspendedSiblings,
      exitStatus,
      suspendedCommitReason,
      completedRenderStartTime,
      completedRenderEndTime,
    ) {
      if (
        root$5.timeoutHandle = -1,
          suspendedCommitReason = finishedWork.subtreeFlags,
          (suspendedCommitReason & 8192 || (suspendedCommitReason & 16785408) == 16785408)
          && (suspendedState = { stylesheets: null, count: 0, unsuspend: noop$4 },
            accumulateSuspenseyCommitOnFiber(finishedWork),
            suspendedCommitReason = waitForCommitToBeReady(),
            suspendedCommitReason !== null)
      ) {
        root$5.cancelPendingCommit = suspendedCommitReason(
          commitRoot.bind(
            null,
            root$5,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            1,
            completedRenderStartTime,
            completedRenderEndTime,
          ),
        ), markRootSuspended(root$5, lanes, spawnedLane, !didSkipSuspendedSiblings)
        return
      }
      commitRoot(
        root$5,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
      )
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node$1 = finishedWork;;) {
        var tag$3 = node$1.tag
        if (
          (tag$3 === 0 || tag$3 === 11 || tag$3 === 15) && node$1.flags & 16384
          && (tag$3 = node$1.updateQueue, tag$3 !== null && (tag$3 = tag$3.stores, tag$3 !== null))
        ) {
          for (var i$14 = 0; i$14 < tag$3.length; i$14++) {
            var check$1 = tag$3[i$14], getSnapshot = check$1.getSnapshot
            check$1 = check$1.value
            try {
              if (!objectIs$1(getSnapshot(), check$1)) return !1
            } catch {
              return !1
            }
          }
        }
        if (tag$3 = node$1.child, node$1.subtreeFlags & 16384 && tag$3 !== null) tag$3.return = node$1, node$1 = tag$3
        else {
          if (node$1 === finishedWork) break
          for (; node$1.sibling === null;) {
            if (node$1.return === null || node$1.return === finishedWork) return !0
            node$1 = node$1.return
          }
          node$1.sibling.return = node$1.return, node$1 = node$1.sibling
        }
      }
      return !0
    }
    function markRootSuspended(root$5, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes,
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes,
        root$5.suspendedLanes |= suspendedLanes,
        root$5.pingedLanes &= ~suspendedLanes,
        didAttemptEntireTree && (root$5.warmLanes |= suspendedLanes),
        didAttemptEntireTree = root$5.expirationTimes
      for (var lanes = suspendedLanes; 0 < lanes;) {
        var index$4 = 31 - clz32(lanes), lane = 1 << index$4
        didAttemptEntireTree[index$4] = -1, lanes &= ~lane
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root$5, spawnedLane, suspendedLanes)
    }
    function flushSyncWork$1() {
      return executionContext & 6 ? !0 : (flushSyncWorkAcrossRoots_impl(0, !1), !1)
    }
    function resetWorkInProgressStack() {
      if (workInProgress !== null) {
        if (workInProgressSuspendedReason === 0) var interruptedWork = workInProgress.return
        else {interruptedWork = workInProgress,
            lastContextDependency = currentlyRenderingFiber$1 = null,
            resetHooksOnUnwind(interruptedWork),
            thenableState = null,
            thenableIndexCounter = 0,
            interruptedWork = workInProgress}
        for (; interruptedWork !== null;) {
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return
        }
        workInProgress = null
      }
    }
    function prepareFreshStack(root$5, lanes) {
      var timeoutHandle = root$5.timeoutHandle
      timeoutHandle !== -1 && (root$5.timeoutHandle = -1, cancelTimeout(timeoutHandle)),
        timeoutHandle = root$5.cancelPendingCommit,
        timeoutHandle !== null && (root$5.cancelPendingCommit = null, timeoutHandle()),
        resetWorkInProgressStack(),
        workInProgressRoot = root$5,
        workInProgress = timeoutHandle = createWorkInProgress(root$5.current, null),
        workInProgressRootRenderLanes = lanes,
        workInProgressSuspendedReason = 0,
        workInProgressThrownValue = null,
        workInProgressRootDidSkipSuspendedSiblings = !1,
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root$5, lanes),
        workInProgressRootDidAttachPingListener = !1,
        workInProgressSuspendedRetryLanes =
          workInProgressDeferredLane =
          workInProgressRootPingedLanes =
          workInProgressRootInterleavedUpdatedLanes =
          workInProgressRootSkippedLanes =
          workInProgressRootExitStatus =
            0,
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null,
        workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
        lanes & 8 && (lanes |= lanes & 32)
      var allEntangledLanes = root$5.entangledLanes
      if (allEntangledLanes !== 0) {
        for (root$5 = root$5.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
          var index$2$1 = 31 - clz32(allEntangledLanes), lane = 1 << index$2$1
          lanes |= root$5[index$2$1], allEntangledLanes &= ~lane
        }
      }
      return entangledRenderLanes = lanes, finishQueueingConcurrentUpdates(), timeoutHandle
    }
    function handleThrow(root$5, thrownValue) {
      currentlyRenderingFiber = null,
        ReactSharedInternals.H = ContextOnlyDispatcher,
        thrownValue === SuspenseException || thrownValue === SuspenseActionException
          ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3)
          : thrownValue === SuspenseyCommitException
          ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4)
          : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException
            ? 8
            : typeof thrownValue == `object` && thrownValue && typeof thrownValue.then == `function`
            ? 6
            : 1,
        workInProgressThrownValue = thrownValue,
        workInProgress === null
        && (workInProgressRootExitStatus = 1,
          logUncaughtError(root$5, createCapturedValueAtFiber(thrownValue, root$5.current)))
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H
      return ReactSharedInternals.H = ContextOnlyDispatcher,
        prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A
      return ReactSharedInternals.A = DefaultAsyncDispatcher, prevAsyncDispatcher
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4,
        workInProgressRootDidSkipSuspendedSiblings
        || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes
          && suspenseHandlerStackCursor.current !== null
        || (workInProgressRootIsPrerendering = !0),
        !(workInProgressRootSkippedLanes & 134217727) && !(workInProgressRootInterleavedUpdatedLanes & 134217727)
        || workInProgressRoot === null
        || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)
    }
    function renderRootSync(root$5, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext
      executionContext |= 2
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher()
      ;(workInProgressRoot !== root$5 || workInProgressRootRenderLanes !== lanes)
        && (workInProgressTransitions = null, prepareFreshStack(root$5, lanes)),
        lanes = !1
      var exitStatus = workInProgressRootExitStatus
      a: do try {
        if (workInProgressSuspendedReason !== 0 && workInProgress !== null) {
          var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue
          switch (workInProgressSuspendedReason) {
            case 8:
              resetWorkInProgressStack(), exitStatus = 6
              break a
            case 3:
            case 2:
            case 9:
            case 6:
              suspenseHandlerStackCursor.current === null && (lanes = !0)
              var reason = workInProgressSuspendedReason
              if (
                workInProgressSuspendedReason = 0,
                  workInProgressThrownValue = null,
                  throwAndUnwindWorkLoop(root$5, unitOfWork, thrownValue, reason),
                  shouldYieldForPrerendering && workInProgressRootIsPrerendering
              ) {
                exitStatus = 0
                break a
              }
              break
            default:
              reason = workInProgressSuspendedReason,
                workInProgressSuspendedReason = 0,
                workInProgressThrownValue = null,
                throwAndUnwindWorkLoop(root$5, unitOfWork, thrownValue, reason)
          }
        }
        workLoopSync(), exitStatus = workInProgressRootExitStatus
        break
      } catch (thrownValue$167) {
        handleThrow(root$5, thrownValue$167)
      }
      while (1)
      return lanes && root$5.shellSuspendCounter++,
        lastContextDependency = currentlyRenderingFiber$1 = null,
        executionContext = prevExecutionContext,
        ReactSharedInternals.H = prevDispatcher,
        ReactSharedInternals.A = prevAsyncDispatcher,
        workInProgress === null
        && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates()),
        exitStatus
    }
    function workLoopSync() {
      for (; workInProgress !== null;) performUnitOfWork(workInProgress)
    }
    function renderRootConcurrent(root$5, lanes) {
      var prevExecutionContext = executionContext
      executionContext |= 2
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher()
      workInProgressRoot !== root$5 || workInProgressRootRenderLanes !== lanes
        ? (workInProgressTransitions = null,
          workInProgressRootRenderTargetTime = now() + 500,
          prepareFreshStack(root$5, lanes))
        : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root$5, lanes)
      a: do try {
        if (workInProgressSuspendedReason !== 0 && workInProgress !== null) {
          lanes = workInProgress
          var thrownValue = workInProgressThrownValue
          b: switch (workInProgressSuspendedReason) {
            case 1:
              workInProgressSuspendedReason = 0,
                workInProgressThrownValue = null,
                throwAndUnwindWorkLoop(root$5, lanes, thrownValue, 1)
              break
            case 2:
            case 9:
              if (isThenableResolved(thrownValue)) {
                workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)
                break
              }
              lanes = function() {
                workInProgressSuspendedReason !== 2 && workInProgressSuspendedReason !== 9
                || workInProgressRoot !== root$5 || (workInProgressSuspendedReason = 7), ensureRootIsScheduled(root$5)
              }, thrownValue.then(lanes, lanes)
              break a
            case 3:
              workInProgressSuspendedReason = 7
              break a
            case 4:
              workInProgressSuspendedReason = 5
              break a
            case 7:
              isThenableResolved(thrownValue)
                ? (workInProgressSuspendedReason = 0,
                  workInProgressThrownValue = null,
                  replaySuspendedUnitOfWork(lanes))
                : (workInProgressSuspendedReason = 0,
                  workInProgressThrownValue = null,
                  throwAndUnwindWorkLoop(root$5, lanes, thrownValue, 7))
              break
            case 5:
              var resource = null
              switch (workInProgress.tag) {
                case 26:
                  resource = workInProgress.memoizedState
                case 5:
                case 27:
                  var hostFiber = workInProgress
                  if (!resource || preloadResource(resource)) {
                    workInProgressSuspendedReason = 0, workInProgressThrownValue = null
                    var sibling = hostFiber.sibling
                    if (sibling !== null) workInProgress = sibling
                    else {
                      var returnFiber = hostFiber.return
                      returnFiber === null
                        ? workInProgress = null
                        : (workInProgress = returnFiber, completeUnitOfWork(returnFiber))
                    }
                    break b
                  }
              }
              workInProgressSuspendedReason = 0,
                workInProgressThrownValue = null,
                throwAndUnwindWorkLoop(root$5, lanes, thrownValue, 5)
              break
            case 6:
              workInProgressSuspendedReason = 0,
                workInProgressThrownValue = null,
                throwAndUnwindWorkLoop(root$5, lanes, thrownValue, 6)
              break
            case 8:
              resetWorkInProgressStack(), workInProgressRootExitStatus = 6
              break a
            default:
              throw Error(formatProdErrorMessage(462))
          }
        }
        workLoopConcurrentByScheduler()
        break
      } catch (thrownValue$169) {
        handleThrow(root$5, thrownValue$169)
      }
      while (1)
      return lastContextDependency = currentlyRenderingFiber$1 = null,
        ReactSharedInternals.H = prevDispatcher,
        ReactSharedInternals.A = prevAsyncDispatcher,
        executionContext = prevExecutionContext,
        workInProgress === null
          ? (workInProgressRoot = null,
            workInProgressRootRenderLanes = 0,
            finishQueueingConcurrentUpdates(),
            workInProgressRootExitStatus)
          : 0
    }
    function workLoopConcurrentByScheduler() {
      for (; workInProgress !== null && !shouldYield();) performUnitOfWork(workInProgress)
    }
    function performUnitOfWork(unitOfWork) {
      var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes)
      unitOfWork.memoizedProps = unitOfWork.pendingProps,
        next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = unitOfWork, current = next.alternate
      switch (next.tag) {
        case 15:
        case 0:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type,
            void 0,
            workInProgressRootRenderLanes,
          )
          break
        case 11:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type.render,
            next.ref,
            workInProgressRootRenderLanes,
          )
          break
        case 5:
          resetHooksOnUnwind(next)
        default:
          unwindInterruptedWork(current, next),
            next = workInProgress = resetWorkInProgress(next, entangledRenderLanes),
            next = beginWork(current, next, entangledRenderLanes)
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps,
        next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next
    }
    function throwAndUnwindWorkLoop(root$5, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber$1 = null,
        resetHooksOnUnwind(unitOfWork),
        thenableState = null,
        thenableIndexCounter = 0
      var returnFiber = unitOfWork.return
      try {
        if (throwException(root$5, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
          workInProgressRootExitStatus = 1,
            logUncaughtError(root$5, createCapturedValueAtFiber(thrownValue, root$5.current)),
            workInProgress = null
          return
        }
      } catch (error) {
        if (returnFiber !== null) throw workInProgress = returnFiber, error
        workInProgressRootExitStatus = 1,
          logUncaughtError(root$5, createCapturedValueAtFiber(thrownValue, root$5.current)),
          workInProgress = null
        return
      }
      unitOfWork.flags & 32768
        ? (isHydrating || suspendedReason === 1
          ? root$5 = !0
          : workInProgressRootIsPrerendering || workInProgressRootRenderLanes & 536870912
          ? root$5 = !1
          : (workInProgressRootDidSkipSuspendedSiblings = root$5 = !0,
            (suspendedReason === 2 || suspendedReason === 9 || suspendedReason === 3 || suspendedReason === 6)
            && (suspendedReason = suspenseHandlerStackCursor.current,
              suspendedReason !== null && suspendedReason.tag === 13 && (suspendedReason.flags |= 16384))),
          unwindUnitOfWork(unitOfWork, root$5))
        : completeUnitOfWork(unitOfWork)
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork
      do {
        if (completedWork.flags & 32768) {
          unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings)
          return
        }
        unitOfWork = completedWork.return
        var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes)
        if (next !== null) {
          workInProgress = next
          return
        }
        if (completedWork = completedWork.sibling, completedWork !== null) {
          workInProgress = completedWork
          return
        }
        workInProgress = completedWork = unitOfWork
      } while (completedWork !== null)
      workInProgressRootExitStatus === 0 && (workInProgressRootExitStatus = 5)
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork)
        if (next !== null) {
          next.flags &= 32767, workInProgress = next
          return
        }
        if (
          next = unitOfWork.return,
            next !== null && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null),
            !skipSiblings && (unitOfWork = unitOfWork.sibling, unitOfWork !== null)
        ) {
          workInProgress = unitOfWork
          return
        }
        workInProgress = unitOfWork = next
      } while (unitOfWork !== null)
      workInProgressRootExitStatus = 6, workInProgress = null
    }
    function commitRoot(
      root$5,
      finishedWork,
      lanes,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes,
    ) {
      root$5.cancelPendingCommit = null
      do flushPendingEffects()
      while (pendingEffectsStatus !== 0)
      if (executionContext & 6) throw Error(formatProdErrorMessage(327))
      if (finishedWork !== null) {
        if (finishedWork === root$5.current) throw Error(formatProdErrorMessage(177))
        if (
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes,
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes,
            markRootFinished(
              root$5,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
            ),
            root$5 === workInProgressRoot
            && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0),
            pendingFinishedWork = finishedWork,
            pendingEffectsRoot = root$5,
            pendingEffectsLanes = lanes,
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate,
            pendingPassiveTransitions = transitions,
            pendingRecoverableErrors = recoverableErrors,
            finishedWork.subtreeFlags & 10256 || finishedWork.flags & 10256
              ? (root$5.callbackNode = null,
                root$5.callbackPriority = 0,
                scheduleCallback$1(NormalPriority$1, function() {
                  return flushPassiveEffects(!0), null
                }))
              : (root$5.callbackNode = null, root$5.callbackPriority = 0),
            recoverableErrors = (finishedWork.flags & 13878) != 0,
            finishedWork.subtreeFlags & 13878 || recoverableErrors
        ) {
          recoverableErrors = ReactSharedInternals.T,
            ReactSharedInternals.T = null,
            transitions = ReactDOMSharedInternals.p,
            ReactDOMSharedInternals.p = 2,
            spawnedLane = executionContext,
            executionContext |= 4
          try {
            commitBeforeMutationEffects(root$5, finishedWork, lanes)
          } finally {
            executionContext = spawnedLane,
              ReactDOMSharedInternals.p = transitions,
              ReactSharedInternals.T = recoverableErrors
          }
        }
        pendingEffectsStatus = 1, flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork()
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === 1) {
        pendingEffectsStatus = 0
        var root$5 = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          rootMutationHasEffect = (finishedWork.flags & 13878) != 0
        if (finishedWork.subtreeFlags & 13878 || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T, ReactSharedInternals.T = null
          var previousPriority = ReactDOMSharedInternals.p
          ReactDOMSharedInternals.p = 2
          var prevExecutionContext = executionContext
          executionContext |= 4
          try {
            commitMutationEffectsOnFiber(finishedWork, root$5)
            var priorSelectionInformation = selectionInformation,
              curFocusedElem = getActiveElementDeep(root$5.containerInfo),
              priorFocusedElem = priorSelectionInformation.focusedElem,
              priorSelectionRange = priorSelectionInformation.selectionRange
            if (
              curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument
              && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)
            ) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                var start$2 = priorSelectionRange.start, end$2 = priorSelectionRange.end
                if (end$2 === void 0 && (end$2 = start$2), `selectionStart` in priorFocusedElem) {
                  priorFocusedElem.selectionStart = start$2,
                    priorFocusedElem.selectionEnd = Math.min(end$2, priorFocusedElem.value.length)
                } else {
                  var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window
                  if (win.getSelection) {
                    var selection = win.getSelection(),
                      length$1 = priorFocusedElem.textContent.length,
                      start$jscomp$0 = Math.min(priorSelectionRange.start, length$1),
                      end$jscomp$0 = priorSelectionRange.end === void 0
                        ? start$jscomp$0
                        : Math.min(priorSelectionRange.end, length$1)
                    !selection.extend && start$jscomp$0 > end$jscomp$0
                      && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem)
                    var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0),
                      endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0)
                    if (
                      startMarker && endMarker
                      && (selection.rangeCount !== 1 || selection.anchorNode !== startMarker.node
                        || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node
                        || selection.focusOffset !== endMarker.offset)
                    ) {
                      var range = doc.createRange()
                      range.setStart(startMarker.node, startMarker.offset),
                        selection.removeAllRanges(),
                        start$jscomp$0 > end$jscomp$0
                          ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset))
                          : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range))
                    }
                  }
                }
              }
              for (doc = [], selection = priorFocusedElem; selection = selection.parentNode;) {
                selection.nodeType === 1
                  && doc.push({ element: selection, left: selection.scrollLeft, top: selection.scrollTop })
              }
              for (
                typeof priorFocusedElem.focus == `function` && priorFocusedElem.focus(), priorFocusedElem = 0;
                priorFocusedElem < doc.length;
                priorFocusedElem++
              ) {
                var info = doc[priorFocusedElem]
                info.element.scrollLeft = info.left, info.element.scrollTop = info.top
              }
            }
            _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null
          } finally {
            executionContext = prevExecutionContext,
              ReactDOMSharedInternals.p = previousPriority,
              ReactSharedInternals.T = rootMutationHasEffect
          }
        }
        root$5.current = finishedWork, pendingEffectsStatus = 2
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === 2) {
        pendingEffectsStatus = 0
        var root$5 = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          rootHasLayoutEffect = (finishedWork.flags & 8772) != 0
        if (finishedWork.subtreeFlags & 8772 || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T, ReactSharedInternals.T = null
          var previousPriority = ReactDOMSharedInternals.p
          ReactDOMSharedInternals.p = 2
          var prevExecutionContext = executionContext
          executionContext |= 4
          try {
            commitLayoutEffectOnFiber(root$5, finishedWork.alternate, finishedWork)
          } finally {
            executionContext = prevExecutionContext,
              ReactDOMSharedInternals.p = previousPriority,
              ReactSharedInternals.T = rootHasLayoutEffect
          }
        }
        pendingEffectsStatus = 3
      }
    }
    function flushSpawnedWork() {
      if (pendingEffectsStatus === 4 || pendingEffectsStatus === 3) {
        pendingEffectsStatus = 0, requestPaint()
        var root$5 = pendingEffectsRoot,
          finishedWork = pendingFinishedWork,
          lanes = pendingEffectsLanes,
          recoverableErrors = pendingRecoverableErrors
        finishedWork.subtreeFlags & 10256 || finishedWork.flags & 10256
          ? pendingEffectsStatus = 5
          : (pendingEffectsStatus = 0,
            pendingFinishedWork = pendingEffectsRoot = null,
            releaseRootPooledCache(root$5, root$5.pendingLanes))
        var remainingLanes = root$5.pendingLanes
        if (
          remainingLanes === 0 && (legacyErrorBoundariesThatAlreadyFailed = null),
            lanesToEventPriority(lanes),
            finishedWork = finishedWork.stateNode,
            injectedHook && typeof injectedHook.onCommitFiberRoot == `function`
        ) {
          try {
            injectedHook.onCommitFiberRoot(rendererID, finishedWork, void 0, (finishedWork.current.flags & 128) == 128)
          } catch {}
        }
        if (recoverableErrors !== null) {
          finishedWork = ReactSharedInternals.T,
            remainingLanes = ReactDOMSharedInternals.p,
            ReactDOMSharedInternals.p = 2,
            ReactSharedInternals.T = null
          try {
            for (
              var onRecoverableError = root$5.onRecoverableError, i$14 = 0;
              i$14 < recoverableErrors.length;
              i$14++
            ) {
              var recoverableError = recoverableErrors[i$14]
              onRecoverableError(recoverableError.value, { componentStack: recoverableError.stack })
            }
          } finally {
            ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes
          }
        }
        pendingEffectsLanes & 3 && flushPendingEffects(),
          ensureRootIsScheduled(root$5),
          remainingLanes = root$5.pendingLanes,
          lanes & 4194090 && remainingLanes & 42
            ? root$5 === rootWithNestedUpdates
              ? nestedUpdateCount++
              : (nestedUpdateCount = 0, rootWithNestedUpdates = root$5)
            : nestedUpdateCount = 0,
          flushSyncWorkAcrossRoots_impl(0, !1)
      }
    }
    function releaseRootPooledCache(root$5, remainingLanes) {
      ;(root$5.pooledCacheLanes &= remainingLanes) === 0
        && (remainingLanes = root$5.pooledCache,
          remainingLanes != null && (root$5.pooledCache = null, releaseCache(remainingLanes)))
    }
    function flushPendingEffects(wasDelayedCommit) {
      return flushMutationEffects(), flushLayoutEffects(), flushSpawnedWork(), flushPassiveEffects(wasDelayedCommit)
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== 5) return !1
      var root$5 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes
      pendingEffectsRemainingLanes = 0
      var renderPriority = lanesToEventPriority(pendingEffectsLanes),
        prevTransition = ReactSharedInternals.T,
        previousPriority = ReactDOMSharedInternals.p
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority,
          ReactSharedInternals.T = null,
          renderPriority = pendingPassiveTransitions,
          pendingPassiveTransitions = null
        var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes
        if (
          pendingEffectsStatus = 0,
            pendingFinishedWork = pendingEffectsRoot = null,
            pendingEffectsLanes = 0,
            executionContext & 6
        ) throw Error(formatProdErrorMessage(331))
        var prevExecutionContext = executionContext
        if (
          executionContext |= 4,
            commitPassiveUnmountOnFiber(root$jscomp$0.current),
            commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, renderPriority),
            executionContext = prevExecutionContext,
            flushSyncWorkAcrossRoots_impl(0, !1),
            injectedHook && typeof injectedHook.onPostCommitFiberRoot == `function`
        ) {
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0)
          } catch {}
        }
        return !0
      } finally {
        ReactDOMSharedInternals.p = previousPriority,
          ReactSharedInternals.T = prevTransition,
          releaseRootPooledCache(root$5, remainingLanes)
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber),
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2),
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2),
        rootFiber !== null && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber))
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (sourceFiber.tag === 3) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error)
      else {for (; nearestMountedAncestor !== null;) {
          if (nearestMountedAncestor.tag === 3) {
            captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error)
            break
          } else if (nearestMountedAncestor.tag === 1) {
            var instance = nearestMountedAncestor.stateNode
            if (
              typeof nearestMountedAncestor.type.getDerivedStateFromError == `function`
              || typeof instance.componentDidCatch == `function`
                && (legacyErrorBoundariesThatAlreadyFailed === null
                  || !legacyErrorBoundariesThatAlreadyFailed.has(instance))
            ) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber),
                error = createClassErrorUpdate(2),
                instance = enqueueUpdate(nearestMountedAncestor, error, 2),
                instance !== null
                && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber),
                  markRootUpdated$1(instance, 2),
                  ensureRootIsScheduled(instance))
              break
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return
        }}
    }
    function attachPingListener(root$5, wakeable, lanes) {
      var pingCache = root$5.pingCache
      if (pingCache === null) {
        pingCache = root$5.pingCache = new PossiblyWeakMap()
        var threadIDs = new Set()
        pingCache.set(wakeable, threadIDs)
      } else {threadIDs = pingCache.get(wakeable),
          threadIDs === void 0 && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs))}
      threadIDs.has(lanes)
        || (workInProgressRootDidAttachPingListener = !0,
          threadIDs.add(lanes),
          root$5 = pingSuspendedRoot.bind(null, root$5, wakeable, lanes),
          wakeable.then(root$5, root$5))
    }
    function pingSuspendedRoot(root$5, wakeable, pingedLanes) {
      var pingCache = root$5.pingCache
      pingCache !== null && pingCache.delete(wakeable),
        root$5.pingedLanes |= root$5.suspendedLanes & pingedLanes,
        root$5.warmLanes &= ~pingedLanes,
        workInProgressRoot === root$5 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes
        && (workInProgressRootExitStatus === 4
            || workInProgressRootExitStatus === 3
              && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes
              && 300 > now() - globalMostRecentFallbackTime
          ? !(executionContext & 2) && prepareFreshStack(root$5, 0)
          : workInProgressRootPingedLanes |= pingedLanes,
          workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes
          && (workInProgressSuspendedRetryLanes = 0)),
        ensureRootIsScheduled(root$5)
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      retryLane === 0 && (retryLane = claimNextRetryLane()),
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane),
        boundaryFiber !== null && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber))
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0
      suspenseState !== null && (retryLane = suspenseState.retryLane), retryTimedOutBoundary(boundaryFiber, retryLane)
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0
      switch (boundaryFiber.tag) {
        case 13:
          var retryCache = boundaryFiber.stateNode, suspenseState = boundaryFiber.memoizedState
          suspenseState !== null && (retryLane = suspenseState.retryLane)
          break
        case 19:
          retryCache = boundaryFiber.stateNode
          break
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache
          break
        default:
          throw Error(formatProdErrorMessage(314))
      }
      retryCache !== null && retryCache.delete(wakeable), retryTimedOutBoundary(boundaryFiber, retryLane)
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback)
    }
    var firstScheduledRoot = null,
      lastScheduledRoot = null,
      didScheduleMicrotask = !1,
      mightHavePendingSyncWork = !1,
      isFlushingWork = !1,
      currentEventTransitionLane = 0
    function ensureRootIsScheduled(root$5) {
      root$5 !== lastScheduledRoot && root$5.next === null
      && (lastScheduledRoot === null
        ? firstScheduledRoot = lastScheduledRoot = root$5
        : lastScheduledRoot = lastScheduledRoot.next = root$5),
        mightHavePendingSyncWork = !0,
        didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateRootScheduleTask())
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = !0
        do for (var didPerformSomeWork = !1, root$174 = firstScheduledRoot; root$174 !== null;) {
          if (!onlyLegacy) {
            if (syncTransitionLanes !== 0) {
              var pendingLanes = root$174.pendingLanes
              if (pendingLanes === 0) var JSCompiler_inline_result = 0
              else {
                var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes
                JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1,
                  JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes),
                  JSCompiler_inline_result = JSCompiler_inline_result & 201326741
                    ? JSCompiler_inline_result & 201326741 | 1
                    : JSCompiler_inline_result
                    ? JSCompiler_inline_result | 2
                    : 0
              }
              JSCompiler_inline_result !== 0
                && (didPerformSomeWork = !0, performSyncWorkOnRoot(root$174, JSCompiler_inline_result))
            } else {JSCompiler_inline_result = workInProgressRootRenderLanes,
                JSCompiler_inline_result = getNextLanes(
                  root$174,
                  root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                  root$174.cancelPendingCommit !== null || root$174.timeoutHandle !== -1,
                ),
                !(JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result)
                || (didPerformSomeWork = !0, performSyncWorkOnRoot(root$174, JSCompiler_inline_result))}
          }
          root$174 = root$174.next
        }
        while (didPerformSomeWork)
        isFlushingWork = !1
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask()
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = !1
      var syncTransitionLanes = 0
      currentEventTransitionLane !== 0
        && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane),
          currentEventTransitionLane = 0)
      for (var currentTime = now(), prev = null, root$5 = firstScheduledRoot; root$5 !== null;) {
        var next = root$5.next, nextLanes = scheduleTaskForRootDuringMicrotask(root$5, currentTime)
        nextLanes === 0
          ? (root$5.next = null,
            prev === null ? firstScheduledRoot = next : prev.next = next,
            next === null && (lastScheduledRoot = prev))
          : (prev = root$5, (syncTransitionLanes !== 0 || nextLanes & 3) && (mightHavePendingSyncWork = !0)),
          root$5 = next
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1)
    }
    function scheduleTaskForRootDuringMicrotask(root$5, currentTime) {
      for (
        var suspendedLanes = root$5.suspendedLanes,
          pingedLanes = root$5.pingedLanes,
          expirationTimes = root$5.expirationTimes,
          lanes = root$5.pendingLanes & -62914561;
        0 < lanes;
      ) {
        var index$3$1 = 31 - clz32(lanes), lane = 1 << index$3$1, expirationTime = expirationTimes[index$3$1]
        expirationTime === -1
          ? ((lane & suspendedLanes) === 0 || (lane & pingedLanes) !== 0)
            && (expirationTimes[index$3$1] = computeExpirationTime(lane, currentTime))
          : expirationTime <= currentTime && (root$5.expiredLanes |= lane), lanes &= ~lane
      }
      if (
        currentTime = workInProgressRoot,
          suspendedLanes = workInProgressRootRenderLanes,
          suspendedLanes = getNextLanes(
            root$5,
            root$5 === currentTime ? suspendedLanes : 0,
            root$5.cancelPendingCommit !== null || root$5.timeoutHandle !== -1,
          ),
          pingedLanes = root$5.callbackNode,
          suspendedLanes === 0
          || root$5 === currentTime && (workInProgressSuspendedReason === 2 || workInProgressSuspendedReason === 9)
          || root$5.cancelPendingCommit !== null
      ) {
        return pingedLanes !== null && pingedLanes !== null && cancelCallback$1(pingedLanes),
          root$5.callbackNode = null,
          root$5.callbackPriority = 0
      }
      if (!(suspendedLanes & 3) || checkIfRootIsPrerendering(root$5, suspendedLanes)) {
        if (currentTime = suspendedLanes & -suspendedLanes, currentTime === root$5.callbackPriority) return currentTime
        switch (pingedLanes !== null && cancelCallback$1(pingedLanes), lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority
            break
          case 32:
            suspendedLanes = NormalPriority$1
            break
          case 268435456:
            suspendedLanes = IdlePriority
            break
          default:
            suspendedLanes = NormalPriority$1
        }
        return pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root$5),
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes),
          root$5.callbackPriority = currentTime,
          root$5.callbackNode = suspendedLanes,
          currentTime
      }
      return pingedLanes !== null && pingedLanes !== null && cancelCallback$1(pingedLanes),
        root$5.callbackPriority = 2,
        root$5.callbackNode = null,
        2
    }
    function performWorkOnRootViaSchedulerTask(root$5, didTimeout) {
      if (pendingEffectsStatus !== 0 && pendingEffectsStatus !== 5) {
        return root$5.callbackNode = null, root$5.callbackPriority = 0, null
      }
      var originalCallbackNode = root$5.callbackNode
      if (flushPendingEffects(!0) && root$5.callbackNode !== originalCallbackNode) return null
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes
      return workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root$5,
        root$5 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
        root$5.cancelPendingCommit !== null || root$5.timeoutHandle !== -1,
      ),
        workInProgressRootRenderLanes$jscomp$0 === 0
          ? null
          : (performWorkOnRoot(root$5, workInProgressRootRenderLanes$jscomp$0, didTimeout),
            scheduleTaskForRootDuringMicrotask(root$5, now()),
            root$5.callbackNode != null && root$5.callbackNode === originalCallbackNode
              ? performWorkOnRootViaSchedulerTask.bind(null, root$5)
              : null)
    }
    function performSyncWorkOnRoot(root$5, lanes) {
      if (flushPendingEffects()) return null
      performWorkOnRoot(root$5, lanes, !0)
    }
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask(function() {
        executionContext & 6
          ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask)
          : processRootScheduleInMicrotask()
      })
    }
    function requestTransitionLane() {
      return currentEventTransitionLane === 0 && (currentEventTransitionLane = claimNextTransitionLane()),
        currentEventTransitionLane
    }
    function coerceFormActionProp(actionProp) {
      return actionProp == null || typeof actionProp == `symbol` || typeof actionProp == `boolean`
        ? null
        : typeof actionProp == `function`
        ? actionProp
        : sanitizeURL(`` + actionProp)
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement(`input`)
      return temp.name = submitter.name,
        temp.value = submitter.value,
        form.id && temp.setAttribute(`form`, form.id),
        submitter.parentNode.insertBefore(temp, submitter),
        form = new FormData(form),
        temp.parentNode.removeChild(temp),
        form
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if (domEventName === `submit` && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action),
          submitter = nativeEvent.submitter
        submitter
          && (domEventName = (domEventName = submitter[internalPropsKey] || null)
            ? coerceFormActionProp(domEventName.formAction)
            : submitter.getAttribute(`formAction`),
            domEventName !== null && (action = domEventName, submitter = null))
        var event = new SyntheticEvent(`action`, `action`, null, nativeEvent, nativeEventTarget)
        dispatchQueue.push({
          event,
          listeners: [{
            instance: null,
            listener: function() {
              if (nativeEvent.defaultPrevented) {
                if (currentEventTransitionLane !== 0) {
                  var formData = submitter
                    ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                    : new FormData(nativeEventTarget)
                  startHostTransition(
                    maybeTargetInst,
                    { pending: !0, data: formData, method: nativeEventTarget.method, action },
                    null,
                    formData,
                  )
                }
              } else {typeof action == `function` && (event.preventDefault(),
                  formData = submitter
                    ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                    : new FormData(nativeEventTarget),
                  startHostTransition(
                    maybeTargetInst,
                    { pending: !0, data: formData, method: nativeEventTarget.method, action },
                    action,
                    formData,
                  ))}
            },
            currentTarget: nativeEventTarget,
          }],
        })
      }
    }
    for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
      var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528],
        domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(),
        capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase()
          + eventName$jscomp$inline_1529.slice(1)
      registerSimpleEvent(domEventName$jscomp$inline_1530, `on` + capitalizedEvent$jscomp$inline_1531)
    }
    registerSimpleEvent(ANIMATION_END, `onAnimationEnd`),
      registerSimpleEvent(ANIMATION_ITERATION, `onAnimationIteration`),
      registerSimpleEvent(ANIMATION_START, `onAnimationStart`),
      registerSimpleEvent(`dblclick`, `onDoubleClick`),
      registerSimpleEvent(`focusin`, `onFocus`),
      registerSimpleEvent(`focusout`, `onBlur`),
      registerSimpleEvent(TRANSITION_RUN, `onTransitionRun`),
      registerSimpleEvent(TRANSITION_START, `onTransitionStart`),
      registerSimpleEvent(TRANSITION_CANCEL, `onTransitionCancel`),
      registerSimpleEvent(TRANSITION_END, `onTransitionEnd`),
      registerDirectEvent(`onMouseEnter`, [`mouseout`, `mouseover`]),
      registerDirectEvent(`onMouseLeave`, [`mouseout`, `mouseover`]),
      registerDirectEvent(`onPointerEnter`, [`pointerout`, `pointerover`]),
      registerDirectEvent(`onPointerLeave`, [`pointerout`, `pointerover`]),
      registerTwoPhaseEvent(`onChange`, `change click focusin focusout input keydown keyup selectionchange`.split(` `)),
      registerTwoPhaseEvent(
        `onSelect`,
        `focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange`.split(` `),
      ),
      registerTwoPhaseEvent(`onBeforeInput`, [`compositionend`, `keypress`, `textInput`, `paste`]),
      registerTwoPhaseEvent(`onCompositionEnd`, `compositionend focusout keydown keypress keyup mousedown`.split(` `)),
      registerTwoPhaseEvent(
        `onCompositionStart`,
        `compositionstart focusout keydown keypress keyup mousedown`.split(` `),
      ),
      registerTwoPhaseEvent(
        `onCompositionUpdate`,
        `compositionupdate focusout keydown keypress keyup mousedown`.split(` `),
      )
    var mediaEventTypes =
        `abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting`
          .split(` `),
      nonDelegatedEvents = new Set(
        `beforetoggle cancel close invalid load scroll scrollend toggle`.split(` `).concat(mediaEventTypes),
      )
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = (eventSystemFlags & 4) != 0
      for (var i$14 = 0; i$14 < dispatchQueue.length; i$14++) {
        var _dispatchQueue$i = dispatchQueue[i$14], event = _dispatchQueue$i.event
        _dispatchQueue$i = _dispatchQueue$i.listeners
        a: {
          var previousInstance = void 0
          if (eventSystemFlags) {
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                instance = _dispatchListeners$i.instance,
                currentTarget = _dispatchListeners$i.currentTarget
              if (
                _dispatchListeners$i = _dispatchListeners$i.listener,
                  instance !== previousInstance && event.isPropagationStopped()
              ) break a
              previousInstance = _dispatchListeners$i, event.currentTarget = currentTarget
              try {
                previousInstance(event)
              } catch (error) {
                reportGlobalError(error)
              }
              event.currentTarget = null, previousInstance = instance
            }
          } else {for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              if (
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                  instance = _dispatchListeners$i.instance,
                  currentTarget = _dispatchListeners$i.currentTarget,
                  _dispatchListeners$i = _dispatchListeners$i.listener,
                  instance !== previousInstance && event.isPropagationStopped()
              ) break a
              previousInstance = _dispatchListeners$i, event.currentTarget = currentTarget
              try {
                previousInstance(event)
              } catch (error) {
                reportGlobalError(error)
              }
              event.currentTarget = null, previousInstance = instance
            }}
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey]
      JSCompiler_inline_result === void 0
        && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set())
      var listenerSetKey = domEventName + `__bubble`
      JSCompiler_inline_result.has(listenerSetKey)
        || (addTrappedEventListener(targetElement, domEventName, 2, !1), JSCompiler_inline_result.add(listenerSetKey))
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0
      isCapturePhaseListener && (eventSystemFlags |= 4),
        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener)
    }
    var listeningMarker = `_reactListening` + Math.random().toString(36).slice(2)
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = !0,
          allNativeEvents.forEach(function(domEventName) {
            domEventName !== `selectionchange`
              && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement),
                listenToNativeEvent(domEventName, !0, rootContainerElement))
          })
        var ownerDocument = rootContainerElement.nodeType === 9
          ? rootContainerElement
          : rootContainerElement.ownerDocument
        ownerDocument === null || ownerDocument[listeningMarker]
          || (ownerDocument[listeningMarker] = !0, listenToNativeEvent(`selectionchange`, !1, ownerDocument))
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent
          break
        case 8:
          listenerWrapper = dispatchContinuousEvent
          break
        default:
          listenerWrapper = dispatchEvent
      }
      eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer),
        listenerWrapper = void 0,
        !passiveBrowserEventsSupported
        || domEventName !== `touchstart` && domEventName !== `touchmove` && domEventName !== `wheel`
        || (listenerWrapper = !0),
        isCapturePhaseListener
          ? listenerWrapper === void 0
            ? targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
            : targetContainer.addEventListener(domEventName, eventSystemFlags, {
              capture: !0,
              passive: listenerWrapper,
            })
          : listenerWrapper === void 0
          ? targetContainer.addEventListener(domEventName, eventSystemFlags, !1)
          : targetContainer.addEventListener(domEventName, eventSystemFlags, { passive: listenerWrapper })
    }
    function dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      targetInst$jscomp$0,
      targetContainer,
    ) {
      var ancestorInst = targetInst$jscomp$0
      if (!(eventSystemFlags & 1) && !(eventSystemFlags & 2) && targetInst$jscomp$0 !== null) {
        a: for (;;) {
          if (targetInst$jscomp$0 === null) return
          var nodeTag = targetInst$jscomp$0.tag
          if (nodeTag === 3 || nodeTag === 4) {
            var container = targetInst$jscomp$0.stateNode.containerInfo
            if (container === targetContainer) break
            if (nodeTag === 4) {
              for (nodeTag = targetInst$jscomp$0.return; nodeTag !== null;) {
                var grandTag = nodeTag.tag
                if ((grandTag === 3 || grandTag === 4) && nodeTag.stateNode.containerInfo === targetContainer) return
                nodeTag = nodeTag.return
              }
            }
            for (; container !== null;) {
              if (nodeTag = getClosestInstanceFromNode(container), nodeTag === null) return
              if (grandTag = nodeTag.tag, grandTag === 5 || grandTag === 6 || grandTag === 26 || grandTag === 27) {
                targetInst$jscomp$0 = ancestorInst = nodeTag
                continue a
              }
              container = container.parentNode
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return
        }
      }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = []
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName)
          if (reactName !== void 0) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName
            switch (domEventName) {
              case `keypress`:
                if (getEventCharCode(nativeEvent) === 0) break a
              case `keydown`:
              case `keyup`:
                SyntheticEventCtor = SyntheticKeyboardEvent
                break
              case `focusin`:
                reactEventType = `focus`, SyntheticEventCtor = SyntheticFocusEvent
                break
              case `focusout`:
                reactEventType = `blur`, SyntheticEventCtor = SyntheticFocusEvent
                break
              case `beforeblur`:
              case `afterblur`:
                SyntheticEventCtor = SyntheticFocusEvent
                break
              case `click`:
                if (nativeEvent.button === 2) break a
              case `auxclick`:
              case `dblclick`:
              case `mousedown`:
              case `mousemove`:
              case `mouseup`:
              case `mouseout`:
              case `mouseover`:
              case `contextmenu`:
                SyntheticEventCtor = SyntheticMouseEvent
                break
              case `drag`:
              case `dragend`:
              case `dragenter`:
              case `dragexit`:
              case `dragleave`:
              case `dragover`:
              case `dragstart`:
              case `drop`:
                SyntheticEventCtor = SyntheticDragEvent
                break
              case `touchcancel`:
              case `touchend`:
              case `touchmove`:
              case `touchstart`:
                SyntheticEventCtor = SyntheticTouchEvent
                break
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent
                break
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent
                break
              case `scroll`:
              case `scrollend`:
                SyntheticEventCtor = SyntheticUIEvent
                break
              case `wheel`:
                SyntheticEventCtor = SyntheticWheelEvent
                break
              case `copy`:
              case `cut`:
              case `paste`:
                SyntheticEventCtor = SyntheticClipboardEvent
                break
              case `gotpointercapture`:
              case `lostpointercapture`:
              case `pointercancel`:
              case `pointerdown`:
              case `pointermove`:
              case `pointerout`:
              case `pointerover`:
              case `pointerup`:
                SyntheticEventCtor = SyntheticPointerEvent
                break
              case `toggle`:
              case `beforetoggle`:
                SyntheticEventCtor = SyntheticToggleEvent
            }
            var inCapturePhase = (eventSystemFlags & 4) != 0,
              accumulateTargetOnly = !inCapturePhase && (domEventName === `scroll` || domEventName === `scrollend`),
              reactEventName = inCapturePhase ? reactName === null ? null : reactName + `Capture` : reactName
            inCapturePhase = []
            for (var instance = targetInst, lastHostComponent; instance !== null;) {
              var _instance = instance
              if (
                lastHostComponent = _instance.stateNode,
                  _instance = _instance.tag,
                  _instance !== 5 && _instance !== 26 && _instance !== 27 || lastHostComponent === null
                  || reactEventName === null
                  || (_instance = getListener(instance, reactEventName),
                    _instance != null
                    && inCapturePhase.push(createDispatchListener(instance, _instance, lastHostComponent))),
                  accumulateTargetOnly
              ) break
              instance = instance.return
            }
            0 < inCapturePhase.length
              && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget),
                dispatchQueue.push({ event: reactName, listeners: inCapturePhase }))
          }
        }
        if (!(eventSystemFlags & 7)) {
          a: {
            if (
              reactName = domEventName === `mouseover` || domEventName === `pointerover`,
                SyntheticEventCtor = domEventName === `mouseout` || domEventName === `pointerout`,
                reactName && nativeEvent !== currentReplayingEvent
                && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement)
                && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])
            ) break a
            if (
              (SyntheticEventCtor || reactName) && (reactName = nativeEventTarget.window === nativeEventTarget
                ? nativeEventTarget
                : (reactName = nativeEventTarget.ownerDocument)
                ? reactName.defaultView || reactName.parentWindow
                : window,
                SyntheticEventCtor
                  ? (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement,
                    SyntheticEventCtor = targetInst,
                    reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null,
                    reactEventType !== null
                    && (accumulateTargetOnly = getNearestMountedFiber(reactEventType),
                      inCapturePhase = reactEventType.tag,
                      reactEventType !== accumulateTargetOnly
                      || inCapturePhase !== 5 && inCapturePhase !== 27 && inCapturePhase !== 6)
                    && (reactEventType = null))
                  : (SyntheticEventCtor = null, reactEventType = targetInst),
                SyntheticEventCtor !== reactEventType)
            ) {
              if (
                inCapturePhase = SyntheticMouseEvent,
                  _instance = `onMouseLeave`,
                  reactEventName = `onMouseEnter`,
                  instance = `mouse`,
                  (domEventName === `pointerout` || domEventName === `pointerover`)
                  && (inCapturePhase = SyntheticPointerEvent,
                    _instance = `onPointerLeave`,
                    reactEventName = `onPointerEnter`,
                    instance = `pointer`),
                  accumulateTargetOnly = SyntheticEventCtor == null
                    ? reactName
                    : getNodeFromInstance(SyntheticEventCtor),
                  lastHostComponent = reactEventType == null ? reactName : getNodeFromInstance(reactEventType),
                  reactName = new inCapturePhase(
                    _instance,
                    instance + `leave`,
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget,
                  ),
                  reactName.target = accumulateTargetOnly,
                  reactName.relatedTarget = lastHostComponent,
                  _instance = null,
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst
                  && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + `enter`,
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget,
                  ),
                    inCapturePhase.target = lastHostComponent,
                    inCapturePhase.relatedTarget = accumulateTargetOnly,
                    _instance = inCapturePhase),
                  accumulateTargetOnly = _instance,
                  SyntheticEventCtor && reactEventType
              ) {
                b: {
                  for (
                    inCapturePhase = SyntheticEventCtor,
                      reactEventName = reactEventType,
                      instance = 0,
                      lastHostComponent = inCapturePhase;
                    lastHostComponent;
                    lastHostComponent = getParent(lastHostComponent)
                  ) instance++
                  for (
                    lastHostComponent = 0, _instance = reactEventName;
                    _instance;
                    _instance = getParent(_instance)
                  ) lastHostComponent++
                  for (; 0 < instance - lastHostComponent;) inCapturePhase = getParent(inCapturePhase), instance--
                  for (; 0 < lastHostComponent - instance;) {
                    reactEventName = getParent(reactEventName), lastHostComponent--
                  }
                  for (; instance--;) {
                    if (
                      inCapturePhase === reactEventName
                      || reactEventName !== null && inCapturePhase === reactEventName.alternate
                    ) break b
                    inCapturePhase = getParent(inCapturePhase), reactEventName = getParent(reactEventName)
                  }
                  inCapturePhase = null
                }
              } else inCapturePhase = null
              SyntheticEventCtor !== null
              && accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                !1,
              ),
                reactEventType !== null && accumulateTargetOnly !== null
                && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  !0,
                )
            }
          }
          a: {
            if (
              reactName = targetInst ? getNodeFromInstance(targetInst) : window,
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase(),
                SyntheticEventCtor === `select` || SyntheticEventCtor === `input` && reactName.type === `file`
            ) var getTargetInstFunc = getTargetInstForChangeEvent
            else if (isTextInputElement(reactName)) {
              if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill
                var handleEventFunc = handleEventsForInputEventPolyfill
              }
            } else {SyntheticEventCtor = reactName.nodeName,
                !SyntheticEventCtor || SyntheticEventCtor.toLowerCase() !== `input`
                  || reactName.type !== `checkbox` && reactName.type !== `radio`
                  ? targetInst && isCustomElement(targetInst.elementType)
                    && (getTargetInstFunc = getTargetInstForChangeEvent)
                  : getTargetInstFunc = getTargetInstForClickEvent}
            if (getTargetInstFunc &&= getTargetInstFunc(domEventName, targetInst)) {
              createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget)
              break a
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst),
              domEventName === `focusout` && targetInst && reactName.type === `number`
              && targetInst.memoizedProps.value != null && setDefaultValue(reactName, `number`, reactName.value)
          }
          switch (handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window, domEventName) {
            case `focusin`:
              ;(isTextInputElement(handleEventFunc) || handleEventFunc.contentEditable === `true`)
                && (activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null)
              break
            case `focusout`:
              lastSelection = activeElementInst = activeElement = null
              break
            case `mousedown`:
              mouseDown = !0
              break
            case `contextmenu`:
            case `mouseup`:
            case `dragend`:
              mouseDown = !1, constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget)
              break
            case `selectionchange`:
              if (skipSelectionChangeEvent) break
            case `keydown`:
            case `keyup`:
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget)
          }
          var fallbackData
          if (canUseCompositionEvent) {
            b: {
              switch (domEventName) {
                case `compositionstart`:
                  var eventType = `onCompositionStart`
                  break b
                case `compositionend`:
                  eventType = `onCompositionEnd`
                  break b
                case `compositionupdate`:
                  eventType = `onCompositionUpdate`
                  break b
              }
              eventType = void 0
            }
          } else {isComposing
              ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = `onCompositionEnd`)
              : domEventName === `keydown` && nativeEvent.keyCode === 229 && (eventType = `onCompositionStart`)}
          eventType
          && (useFallbackCompositionData && nativeEvent.locale !== `ko`
            && (isComposing || eventType !== `onCompositionStart`
              ? eventType === `onCompositionEnd` && isComposing && (fallbackData = getData())
              : (root$4 = nativeEventTarget,
                startText = `value` in root$4 ? root$4.value : root$4.textContent,
                isComposing = !0)),
            handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType),
            0 < handleEventFunc.length
            && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget,
            ),
              dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
              fallbackData
                ? eventType.data = fallbackData
                : (fallbackData = getDataFromCustomEvent(nativeEvent),
                  fallbackData !== null && (eventType.data = fallbackData)))),
            (fallbackData = canUseTextInputEvent
              ? getNativeBeforeInputChars(domEventName, nativeEvent)
              : getFallbackBeforeInputChars(domEventName, nativeEvent))
            && (eventType = accumulateTwoPhaseListeners(targetInst, `onBeforeInput`),
              0 < eventType.length
              && (handleEventFunc = new SyntheticCompositionEvent(
                `onBeforeInput`,
                `beforeinput`,
                null,
                nativeEvent,
                nativeEventTarget,
              ),
                dispatchQueue.push({ event: handleEventFunc, listeners: eventType }),
                handleEventFunc.data = fallbackData)),
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget)
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags)
      })
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return { instance, listener, currentTarget }
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + `Capture`, listeners = []; targetFiber !== null;) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode
        if (
          _instance2 = _instance2.tag,
            _instance2 !== 5 && _instance2 !== 26 && _instance2 !== 27 || stateNode === null
            || (_instance2 = getListener(targetFiber, captureName),
              _instance2 != null && listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)),
              _instance2 = getListener(targetFiber, reactName),
              _instance2 != null && listeners.push(createDispatchListener(targetFiber, _instance2, stateNode))),
            targetFiber.tag === 3
        ) return listeners
        targetFiber = targetFiber.return
      }
      return []
    }
    function getParent(inst) {
      if (inst === null) return null
      do inst = inst.return
      while (inst && inst.tag !== 5 && inst.tag !== 27)
      return inst || null
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; target !== null && target !== common;) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode
        if (_instance3 = _instance3.tag, alternate !== null && alternate === common) break
        _instance3 !== 5 && _instance3 !== 26 && _instance3 !== 27 || stateNode === null
        || (alternate = stateNode,
          inCapturePhase
            ? (stateNode = getListener(target, registrationName),
              stateNode != null && listeners.unshift(createDispatchListener(target, stateNode, alternate)))
            : inCapturePhase
              || (stateNode = getListener(target, registrationName),
                stateNode != null && listeners.push(createDispatchListener(target, stateNode, alternate)))),
          target = target.return
      }
      listeners.length !== 0 && dispatchQueue.push({ event, listeners })
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g
    function normalizeMarkupForTextOrAttribute(markup) {
      return (typeof markup == `string` ? markup : `` + markup).replace(
        NORMALIZE_NEWLINES_REGEX,
        `
`,
      ).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, ``)
    }
    function checkForUnmatchedText(serverText, clientText) {
      return clientText = normalizeMarkupForTextOrAttribute(clientText),
        normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1
    }
    function noop$1() {}
    function setProp(domElement, tag$3, key$1, value$2, props, prevValue) {
      switch (key$1) {
        case `children`:
          typeof value$2 == `string`
            ? tag$3 === `body` || tag$3 === `textarea` && value$2 === `` || setTextContent(domElement, value$2)
            : (typeof value$2 == `number` || typeof value$2 == `bigint`) && tag$3 !== `body`
              && setTextContent(domElement, `` + value$2)
          break
        case `className`:
          setValueForKnownAttribute(domElement, `class`, value$2)
          break
        case `tabIndex`:
          setValueForKnownAttribute(domElement, `tabindex`, value$2)
          break
        case `dir`:
        case `role`:
        case `viewBox`:
        case `width`:
        case `height`:
          setValueForKnownAttribute(domElement, key$1, value$2)
          break
        case `style`:
          setValueForStyles(domElement, value$2, prevValue)
          break
        case `data`:
          if (tag$3 !== `object`) {
            setValueForKnownAttribute(domElement, `data`, value$2)
            break
          }
        case `src`:
        case `href`:
          if (value$2 === `` && (tag$3 !== `a` || key$1 !== `href`)) {
            domElement.removeAttribute(key$1)
            break
          }
          if (
            value$2 == null || typeof value$2 == `function` || typeof value$2 == `symbol` || typeof value$2 == `boolean`
          ) {
            domElement.removeAttribute(key$1)
            break
          }
          value$2 = sanitizeURL(`` + value$2), domElement.setAttribute(key$1, value$2)
          break
        case `action`:
        case `formAction`:
          if (typeof value$2 == `function`) {
            domElement.setAttribute(
              key$1,
              `javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')`,
            )
            break
          } else {typeof prevValue == `function` && (key$1 === `formAction`
              ? (tag$3 !== `input` && setProp(domElement, tag$3, `name`, props.name, props, null),
                setProp(domElement, tag$3, `formEncType`, props.formEncType, props, null),
                setProp(domElement, tag$3, `formMethod`, props.formMethod, props, null),
                setProp(domElement, tag$3, `formTarget`, props.formTarget, props, null))
              : (setProp(domElement, tag$3, `encType`, props.encType, props, null),
                setProp(domElement, tag$3, `method`, props.method, props, null),
                setProp(domElement, tag$3, `target`, props.target, props, null)))}
          if (value$2 == null || typeof value$2 == `symbol` || typeof value$2 == `boolean`) {
            domElement.removeAttribute(key$1)
            break
          }
          value$2 = sanitizeURL(`` + value$2), domElement.setAttribute(key$1, value$2)
          break
        case `onClick`:
          value$2 != null && (domElement.onclick = noop$1)
          break
        case `onScroll`:
          value$2 != null && listenToNonDelegatedEvent(`scroll`, domElement)
          break
        case `onScrollEnd`:
          value$2 != null && listenToNonDelegatedEvent(`scrollend`, domElement)
          break
        case `dangerouslySetInnerHTML`:
          if (value$2 != null) {
            if (typeof value$2 != `object` || !(`__html` in value$2)) throw Error(formatProdErrorMessage(61))
            if (key$1 = value$2.__html, key$1 != null) {
              if (props.children != null) throw Error(formatProdErrorMessage(60))
              domElement.innerHTML = key$1
            }
          }
          break
        case `multiple`:
          domElement.multiple = value$2 && typeof value$2 != `function` && typeof value$2 != `symbol`
          break
        case `muted`:
          domElement.muted = value$2 && typeof value$2 != `function` && typeof value$2 != `symbol`
          break
        case `suppressContentEditableWarning`:
        case `suppressHydrationWarning`:
        case `defaultValue`:
        case `defaultChecked`:
        case `innerHTML`:
        case `ref`:
          break
        case `autoFocus`:
          break
        case `xlinkHref`:
          if (
            value$2 == null || typeof value$2 == `function` || typeof value$2 == `boolean` || typeof value$2 == `symbol`
          ) {
            domElement.removeAttribute(`xlink:href`)
            break
          }
          key$1 = sanitizeURL(`` + value$2),
            domElement.setAttributeNS(`http://www.w3.org/1999/xlink`, `xlink:href`, key$1)
          break
        case `contentEditable`:
        case `spellCheck`:
        case `draggable`:
        case `value`:
        case `autoReverse`:
        case `externalResourcesRequired`:
        case `focusable`:
        case `preserveAlpha`:
          value$2 != null && typeof value$2 != `function` && typeof value$2 != `symbol`
            ? domElement.setAttribute(key$1, `` + value$2)
            : domElement.removeAttribute(key$1)
          break
        case `inert`:
        case `allowFullScreen`:
        case `async`:
        case `autoPlay`:
        case `controls`:
        case `default`:
        case `defer`:
        case `disabled`:
        case `disablePictureInPicture`:
        case `disableRemotePlayback`:
        case `formNoValidate`:
        case `hidden`:
        case `loop`:
        case `noModule`:
        case `noValidate`:
        case `open`:
        case `playsInline`:
        case `readOnly`:
        case `required`:
        case `reversed`:
        case `scoped`:
        case `seamless`:
        case `itemScope`:
          value$2 && typeof value$2 != `function` && typeof value$2 != `symbol`
            ? domElement.setAttribute(key$1, ``)
            : domElement.removeAttribute(key$1)
          break
        case `capture`:
        case `download`:
          !0 === value$2
            ? domElement.setAttribute(key$1, ``)
            : !1 !== value$2 && value$2 != null && typeof value$2 != `function` && typeof value$2 != `symbol`
            ? domElement.setAttribute(key$1, value$2)
            : domElement.removeAttribute(key$1)
          break
        case `cols`:
        case `rows`:
        case `size`:
        case `span`:
          value$2 != null && typeof value$2 != `function` && typeof value$2 != `symbol` && !isNaN(value$2)
            && 1 <= value$2
            ? domElement.setAttribute(key$1, value$2)
            : domElement.removeAttribute(key$1)
          break
        case `rowSpan`:
        case `start`:
          value$2 == null || typeof value$2 == `function` || typeof value$2 == `symbol` || isNaN(value$2)
            ? domElement.removeAttribute(key$1)
            : domElement.setAttribute(key$1, value$2)
          break
        case `popover`:
          listenToNonDelegatedEvent(`beforetoggle`, domElement),
            listenToNonDelegatedEvent(`toggle`, domElement),
            setValueForAttribute(domElement, `popover`, value$2)
          break
        case `xlinkActuate`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/1999/xlink`, `xlink:actuate`, value$2)
          break
        case `xlinkArcrole`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/1999/xlink`, `xlink:arcrole`, value$2)
          break
        case `xlinkRole`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/1999/xlink`, `xlink:role`, value$2)
          break
        case `xlinkShow`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/1999/xlink`, `xlink:show`, value$2)
          break
        case `xlinkTitle`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/1999/xlink`, `xlink:title`, value$2)
          break
        case `xlinkType`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/1999/xlink`, `xlink:type`, value$2)
          break
        case `xmlBase`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/XML/1998/namespace`, `xml:base`, value$2)
          break
        case `xmlLang`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/XML/1998/namespace`, `xml:lang`, value$2)
          break
        case `xmlSpace`:
          setValueForNamespacedAttribute(domElement, `http://www.w3.org/XML/1998/namespace`, `xml:space`, value$2)
          break
        case `is`:
          setValueForAttribute(domElement, `is`, value$2)
          break
        case `innerText`:
        case `textContent`:
          break
        default:
          ;(!(2 < key$1.length) || key$1[0] !== `o` && key$1[0] !== `O` || key$1[1] !== `n` && key$1[1] !== `N`)
            && (key$1 = aliases.get(key$1) || key$1, setValueForAttribute(domElement, key$1, value$2))
      }
    }
    function setPropOnCustomElement(domElement, tag$3, key$1, value$2, props, prevValue) {
      switch (key$1) {
        case `style`:
          setValueForStyles(domElement, value$2, prevValue)
          break
        case `dangerouslySetInnerHTML`:
          if (value$2 != null) {
            if (typeof value$2 != `object` || !(`__html` in value$2)) throw Error(formatProdErrorMessage(61))
            if (key$1 = value$2.__html, key$1 != null) {
              if (props.children != null) throw Error(formatProdErrorMessage(60))
              domElement.innerHTML = key$1
            }
          }
          break
        case `children`:
          typeof value$2 == `string`
            ? setTextContent(domElement, value$2)
            : (typeof value$2 == `number` || typeof value$2 == `bigint`) && setTextContent(domElement, `` + value$2)
          break
        case `onScroll`:
          value$2 != null && listenToNonDelegatedEvent(`scroll`, domElement)
          break
        case `onScrollEnd`:
          value$2 != null && listenToNonDelegatedEvent(`scrollend`, domElement)
          break
        case `onClick`:
          value$2 != null && (domElement.onclick = noop$1)
          break
        case `suppressContentEditableWarning`:
        case `suppressHydrationWarning`:
        case `innerHTML`:
        case `ref`:
          break
        case `innerText`:
        case `textContent`:
          break
        default:
          if (!registrationNameDependencies.hasOwnProperty(key$1)) {
            a: {
              if (
                key$1[0] === `o` && key$1[1] === `n`
                && (props = key$1.endsWith(`Capture`),
                  tag$3 = key$1.slice(2, props ? key$1.length - 7 : void 0),
                  prevValue = domElement[internalPropsKey] || null,
                  prevValue = prevValue == null ? null : prevValue[key$1],
                  typeof prevValue == `function` && domElement.removeEventListener(tag$3, prevValue, props),
                  typeof value$2 == `function`)
              ) {
                typeof prevValue != `function` && prevValue !== null && (key$1 in domElement
                  ? domElement[key$1] = null
                  : domElement.hasAttribute(key$1) && domElement.removeAttribute(key$1)),
                  domElement.addEventListener(tag$3, value$2, props)
                break a
              }
              key$1 in domElement
                ? domElement[key$1] = value$2
                : !0 === value$2
                ? domElement.setAttribute(key$1, ``)
                : setValueForAttribute(domElement, key$1, value$2)
            }
          }
      }
    }
    function setInitialProperties(domElement, tag$3, props) {
      switch (tag$3) {
        case `div`:
        case `span`:
        case `svg`:
        case `path`:
        case `a`:
        case `g`:
        case `p`:
        case `li`:
          break
        case `img`:
          listenToNonDelegatedEvent(`error`, domElement), listenToNonDelegatedEvent(`load`, domElement)
          var hasSrc = !1, hasSrcSet = !1, propKey
          for (propKey in props) {
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey]
              if (propValue != null) {
                switch (propKey) {
                  case `src`:
                    hasSrc = !0
                    break
                  case `srcSet`:
                    hasSrcSet = !0
                    break
                  case `children`:
                  case `dangerouslySetInnerHTML`:
                    throw Error(formatProdErrorMessage(137, tag$3))
                  default:
                    setProp(domElement, tag$3, propKey, propValue, props, null)
                }
              }
            }
          }
          hasSrcSet && setProp(domElement, tag$3, `srcSet`, props.srcSet, props, null),
            hasSrc && setProp(domElement, tag$3, `src`, props.src, props, null)
          return
        case `input`:
          listenToNonDelegatedEvent(`invalid`, domElement)
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null
          for (hasSrc in props) {
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$188 = props[hasSrc]
              if (propValue$188 != null) {
                switch (hasSrc) {
                  case `name`:
                    hasSrcSet = propValue$188
                    break
                  case `type`:
                    propValue = propValue$188
                    break
                  case `checked`:
                    checked = propValue$188
                    break
                  case `defaultChecked`:
                    defaultChecked = propValue$188
                    break
                  case `value`:
                    propKey = propValue$188
                    break
                  case `defaultValue`:
                    defaultValue = propValue$188
                    break
                  case `children`:
                  case `dangerouslySetInnerHTML`:
                    if (propValue$188 != null) throw Error(formatProdErrorMessage(137, tag$3))
                    break
                  default:
                    setProp(domElement, tag$3, hasSrc, propValue$188, props, null)
                }
              }
            }
          }
          initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1),
            track$1(domElement)
          return
        case `select`:
          for (
            hasSrcSet in listenToNonDelegatedEvent(`invalid`, domElement), hasSrc = propValue = propKey = null, props
          ) {
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], defaultValue != null)) {
              switch (hasSrcSet) {
                case `value`:
                  propKey = defaultValue
                  break
                case `defaultValue`:
                  propValue = defaultValue
                  break
                case `multiple`:
                  hasSrc = defaultValue
                default:
                  setProp(domElement, tag$3, hasSrcSet, defaultValue, props, null)
              }
            }
          }
          tag$3 = propKey,
            props = propValue,
            domElement.multiple = !!hasSrc,
            tag$3 == null
              ? props != null && updateOptions(domElement, !!hasSrc, props, !0)
              : updateOptions(domElement, !!hasSrc, tag$3, !1)
          return
        case `textarea`:
          for (
            propValue in listenToNonDelegatedEvent(`invalid`, domElement), propKey = hasSrcSet = hasSrc = null, props
          ) {
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], defaultValue != null)) {
              switch (propValue) {
                case `value`:
                  hasSrc = defaultValue
                  break
                case `defaultValue`:
                  hasSrcSet = defaultValue
                  break
                case `children`:
                  propKey = defaultValue
                  break
                case `dangerouslySetInnerHTML`:
                  if (defaultValue != null) throw Error(formatProdErrorMessage(91))
                  break
                default:
                  setProp(domElement, tag$3, propValue, defaultValue, props, null)
              }
            }
          }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey), track$1(domElement)
          return
        case `option`:
          for (checked in props) {
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], hasSrc != null)) {
              switch (checked) {
                case `selected`:
                  domElement.selected = hasSrc && typeof hasSrc != `function` && typeof hasSrc != `symbol`
                  break
                default:
                  setProp(domElement, tag$3, checked, hasSrc, props, null)
              }
            }
          }
          return
        case `dialog`:
          listenToNonDelegatedEvent(`beforetoggle`, domElement),
            listenToNonDelegatedEvent(`toggle`, domElement),
            listenToNonDelegatedEvent(`cancel`, domElement),
            listenToNonDelegatedEvent(`close`, domElement)
          break
        case `iframe`:
        case `object`:
          listenToNonDelegatedEvent(`load`, domElement)
          break
        case `video`:
        case `audio`:
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) {
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement)
          }
          break
        case `image`:
          listenToNonDelegatedEvent(`error`, domElement), listenToNonDelegatedEvent(`load`, domElement)
          break
        case `details`:
          listenToNonDelegatedEvent(`toggle`, domElement)
          break
        case `embed`:
        case `source`:
        case `link`:
          listenToNonDelegatedEvent(`error`, domElement), listenToNonDelegatedEvent(`load`, domElement)
        case `area`:
        case `base`:
        case `br`:
        case `col`:
        case `hr`:
        case `keygen`:
        case `meta`:
        case `param`:
        case `track`:
        case `wbr`:
        case `menuitem`:
          for (defaultChecked in props) {
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], hasSrc != null)) {
              switch (defaultChecked) {
                case `children`:
                case `dangerouslySetInnerHTML`:
                  throw Error(formatProdErrorMessage(137, tag$3))
                default:
                  setProp(domElement, tag$3, defaultChecked, hasSrc, props, null)
              }
            }
          }
          return
        default:
          if (isCustomElement(tag$3)) {
            for (propValue$188 in props) {
              props.hasOwnProperty(propValue$188)
                && (hasSrc = props[propValue$188],
                  hasSrc !== void 0 && setPropOnCustomElement(domElement, tag$3, propValue$188, hasSrc, props, void 0))
            }
            return
          }
      }
      for (defaultValue in props) {
        props.hasOwnProperty(defaultValue)
          && (hasSrc = props[defaultValue],
            hasSrc != null && setProp(domElement, tag$3, defaultValue, hasSrc, props, null))
      }
    }
    function updateProperties(domElement, tag$3, lastProps, nextProps) {
      switch (tag$3) {
        case `div`:
        case `span`:
        case `svg`:
        case `path`:
        case `a`:
        case `g`:
        case `p`:
        case `li`:
          break
        case `input`:
          var name = null,
            type$2 = null,
            value$2 = null,
            defaultValue = null,
            lastDefaultValue = null,
            checked = null,
            defaultChecked = null
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey]
            if (lastProps.hasOwnProperty(propKey) && lastProp != null) {
              switch (propKey) {
                case `checked`:
                  break
                case `value`:
                  break
                case `defaultValue`:
                  lastDefaultValue = lastProp
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag$3, propKey, null, nextProps, lastProp)
              }
            }
          }
          for (var propKey$205 in nextProps) {
            var propKey = nextProps[propKey$205]
            if (
              lastProp = lastProps[propKey$205],
                nextProps.hasOwnProperty(propKey$205) && (propKey != null || lastProp != null)
            ) {
              switch (propKey$205) {
                case `type`:
                  type$2 = propKey
                  break
                case `name`:
                  name = propKey
                  break
                case `checked`:
                  checked = propKey
                  break
                case `defaultChecked`:
                  defaultChecked = propKey
                  break
                case `value`:
                  value$2 = propKey
                  break
                case `defaultValue`:
                  defaultValue = propKey
                  break
                case `children`:
                case `dangerouslySetInnerHTML`:
                  if (propKey != null) throw Error(formatProdErrorMessage(137, tag$3))
                  break
                default:
                  propKey !== lastProp && setProp(domElement, tag$3, propKey$205, propKey, nextProps, lastProp)
              }
            }
          }
          updateInput(domElement, value$2, defaultValue, lastDefaultValue, checked, defaultChecked, type$2, name)
          return
        case `select`:
          for (
            type$2 in propKey =
              value$2 =
              defaultValue =
              propKey$205 =
                null,
              lastProps
          ) {
            if (lastDefaultValue = lastProps[type$2], lastProps.hasOwnProperty(type$2) && lastDefaultValue != null) {
              switch (type$2) {
                case `value`:
                  break
                case `multiple`:
                  propKey = lastDefaultValue
                default:
                  nextProps.hasOwnProperty(type$2)
                    || setProp(domElement, tag$3, type$2, null, nextProps, lastDefaultValue)
              }
            }
          }
          for (name in nextProps) {
            if (
              type$2 = nextProps[name],
                lastDefaultValue = lastProps[name],
                nextProps.hasOwnProperty(name) && (type$2 != null || lastDefaultValue != null)
            ) {
              switch (name) {
                case `value`:
                  propKey$205 = type$2
                  break
                case `defaultValue`:
                  defaultValue = type$2
                  break
                case `multiple`:
                  value$2 = type$2
                default:
                  type$2 !== lastDefaultValue && setProp(domElement, tag$3, name, type$2, nextProps, lastDefaultValue)
              }
            }
          }
          tag$3 = defaultValue,
            lastProps = value$2,
            nextProps = propKey,
            propKey$205 == null
              ? !!nextProps != !!lastProps
                && (tag$3 == null
                  ? updateOptions(domElement, !!lastProps, lastProps ? [] : ``, !1)
                  : updateOptions(domElement, !!lastProps, tag$3, !0))
              : updateOptions(domElement, !!lastProps, propKey$205, !1)
          return
        case `textarea`:
          for (defaultValue in propKey = propKey$205 = null, lastProps) {
            if (
              name = lastProps[defaultValue],
                lastProps.hasOwnProperty(defaultValue) && name != null && !nextProps.hasOwnProperty(defaultValue)
            ) {
              switch (defaultValue) {
                case `value`:
                  break
                case `children`:
                  break
                default:
                  setProp(domElement, tag$3, defaultValue, null, nextProps, name)
              }
            }
          }
          for (value$2 in nextProps) {
            if (
              name = nextProps[value$2],
                type$2 = lastProps[value$2],
                nextProps.hasOwnProperty(value$2) && (name != null || type$2 != null)
            ) {
              switch (value$2) {
                case `value`:
                  propKey$205 = name
                  break
                case `defaultValue`:
                  propKey = name
                  break
                case `children`:
                  break
                case `dangerouslySetInnerHTML`:
                  if (name != null) throw Error(formatProdErrorMessage(91))
                  break
                default:
                  name !== type$2 && setProp(domElement, tag$3, value$2, name, nextProps, type$2)
              }
            }
          }
          updateTextarea(domElement, propKey$205, propKey)
          return
        case `option`:
          for (var propKey$221 in lastProps) {
            if (
              propKey$205 = lastProps[propKey$221],
                lastProps.hasOwnProperty(propKey$221) && propKey$205 != null && !nextProps.hasOwnProperty(propKey$221)
            ) {
              switch (propKey$221) {
                case `selected`:
                  domElement.selected = !1
                  break
                default:
                  setProp(domElement, tag$3, propKey$221, null, nextProps, propKey$205)
              }
            }
          }
          for (lastDefaultValue in nextProps) {
            if (
              propKey$205 = nextProps[lastDefaultValue],
                propKey = lastProps[lastDefaultValue],
                nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey
                && (propKey$205 != null || propKey != null)
            ) {
              switch (lastDefaultValue) {
                case `selected`:
                  domElement.selected = propKey$205 && typeof propKey$205 != `function`
                    && typeof propKey$205 != `symbol`
                  break
                default:
                  setProp(domElement, tag$3, lastDefaultValue, propKey$205, nextProps, propKey)
              }
            }
          }
          return
        case `img`:
        case `link`:
        case `area`:
        case `base`:
        case `br`:
        case `col`:
        case `embed`:
        case `hr`:
        case `keygen`:
        case `meta`:
        case `param`:
        case `source`:
        case `track`:
        case `wbr`:
        case `menuitem`:
          for (var propKey$226 in lastProps) {
            propKey$205 = lastProps[propKey$226],
              lastProps.hasOwnProperty(propKey$226) && propKey$205 != null && !nextProps.hasOwnProperty(propKey$226)
              && setProp(domElement, tag$3, propKey$226, null, nextProps, propKey$205)
          }
          for (checked in nextProps) {
            if (
              propKey$205 = nextProps[checked],
                propKey = lastProps[checked],
                nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (propKey$205 != null || propKey != null)
            ) {
              switch (checked) {
                case `children`:
                case `dangerouslySetInnerHTML`:
                  if (propKey$205 != null) throw Error(formatProdErrorMessage(137, tag$3))
                  break
                default:
                  setProp(domElement, tag$3, checked, propKey$205, nextProps, propKey)
              }
            }
          }
          return
        default:
          if (isCustomElement(tag$3)) {
            for (var propKey$231 in lastProps) {
              propKey$205 = lastProps[propKey$231],
                lastProps.hasOwnProperty(propKey$231) && propKey$205 !== void 0
                && !nextProps.hasOwnProperty(propKey$231)
                && setPropOnCustomElement(domElement, tag$3, propKey$231, void 0, nextProps, propKey$205)
            }
            for (defaultChecked in nextProps) {
              propKey$205 = nextProps[defaultChecked],
                propKey = lastProps[defaultChecked],
                !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey
                || propKey$205 === void 0 && propKey === void 0
                || setPropOnCustomElement(domElement, tag$3, defaultChecked, propKey$205, nextProps, propKey)
            }
            return
          }
      }
      for (var propKey$236 in lastProps) {
        propKey$205 = lastProps[propKey$236],
          lastProps.hasOwnProperty(propKey$236) && propKey$205 != null && !nextProps.hasOwnProperty(propKey$236)
          && setProp(domElement, tag$3, propKey$236, null, nextProps, propKey$205)
      }
      for (lastProp in nextProps) {
        propKey$205 = nextProps[lastProp],
          propKey = lastProps[lastProp],
          !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || propKey$205 == null && propKey == null
          || setProp(domElement, tag$3, lastProp, propKey$205, nextProps, propKey)
      }
    }
    var eventsEnabled = null, selectionInformation = null
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return rootContainerElement.nodeType === 9 ? rootContainerElement : rootContainerElement.ownerDocument
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case `http://www.w3.org/2000/svg`:
          return 1
        case `http://www.w3.org/1998/Math/MathML`:
          return 2
        default:
          return 0
      }
    }
    function getChildHostContextProd(parentNamespace, type$2) {
      if (parentNamespace === 0) {
        switch (type$2) {
          case `svg`:
            return 1
          case `math`:
            return 2
          default:
            return 0
        }
      }
      return parentNamespace === 1 && type$2 === `foreignObject` ? 0 : parentNamespace
    }
    function shouldSetTextContent(type$2, props) {
      return type$2 === `textarea` || type$2 === `noscript` || typeof props.children == `string`
        || typeof props.children == `number` || typeof props.children == `bigint`
        || typeof props.dangerouslySetInnerHTML == `object` && props.dangerouslySetInnerHTML !== null
          && props.dangerouslySetInnerHTML.__html != null
    }
    var currentPopstateTransitionEvent = null
    function shouldAttemptEagerTransition() {
      var event = window.event
      return event && event.type === `popstate`
        ? event === currentPopstateTransitionEvent ? !1 : (currentPopstateTransitionEvent = event, !0)
        : (currentPopstateTransitionEvent = null, !1)
    }
    var scheduleTimeout = typeof setTimeout == `function` ? setTimeout : void 0,
      cancelTimeout = typeof clearTimeout == `function` ? clearTimeout : void 0,
      localPromise = typeof Promise == `function` ? Promise : void 0,
      scheduleMicrotask = typeof queueMicrotask == `function`
        ? queueMicrotask
        : localPromise === void 0
        ? scheduleTimeout
        : function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick)
        }
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error
      })
    }
    function isSingletonScope(type$2) {
      return type$2 === `head`
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node$1 = suspenseInstance, possiblePreambleContribution = 0, depth = 0
      do {
        var nextNode = node$1.nextSibling
        if (parentInstance.removeChild(node$1), nextNode && nextNode.nodeType === 8) {
          if (node$1 = nextNode.data, node$1 === `/$`) {
            if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
              node$1 = possiblePreambleContribution
              var ownerDocument = parentInstance.ownerDocument
              if (
                node$1 & 1 && releaseSingletonInstance(ownerDocument.documentElement),
                  node$1 & 2 && releaseSingletonInstance(ownerDocument.body),
                  node$1 & 4
              ) {
                for (
                  node$1 = ownerDocument.head, releaseSingletonInstance(node$1), ownerDocument = node$1.firstChild;
                  ownerDocument;
                ) {
                  var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName
                  ownerDocument[internalHoistableMarker] || nodeName === `SCRIPT` || nodeName === `STYLE`
                  || nodeName === `LINK` && ownerDocument.rel.toLowerCase() === `stylesheet`
                  || node$1.removeChild(ownerDocument), ownerDocument = nextNode$jscomp$0
                }
              }
            }
            if (depth === 0) {
              parentInstance.removeChild(nextNode), retryIfBlockedOn(suspenseInstance)
              return
            }
            depth--
          } else {node$1 === `$` || node$1 === `$?` || node$1 === `$!`
              ? depth++
              : possiblePreambleContribution = node$1.charCodeAt(0) - 48}
        } else possiblePreambleContribution = 0
        node$1 = nextNode
      } while (node$1)
      retryIfBlockedOn(suspenseInstance)
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild
      for (nextNode && nextNode.nodeType === 10 && (nextNode = nextNode.nextSibling); nextNode;) {
        var node$1 = nextNode
        switch (nextNode = nextNode.nextSibling, node$1.nodeName) {
          case `HTML`:
          case `HEAD`:
          case `BODY`:
            clearContainerSparingly(node$1), detachDeletedInstance(node$1)
            continue
          case `SCRIPT`:
          case `STYLE`:
            continue
          case `LINK`:
            if (node$1.rel.toLowerCase() === `stylesheet`) continue
        }
        container.removeChild(node$1)
      }
    }
    function canHydrateInstance(instance, type$2, props, inRootOrSingleton) {
      for (; instance.nodeType === 1;) {
        var anyProps = props
        if (instance.nodeName.toLowerCase() !== type$2.toLowerCase()) {
          if (!inRootOrSingleton && (instance.nodeName !== `INPUT` || instance.type !== `hidden`)) break
        } else if (inRootOrSingleton) {
          if (!instance[internalHoistableMarker]) {
            switch (type$2) {
              case `meta`:
                if (!instance.hasAttribute(`itemprop`)) break
                return instance
              case `link`:
                if (
                  name = instance.getAttribute(`rel`),
                    name === `stylesheet` && instance.hasAttribute(`data-precedence`) || name !== anyProps.rel
                    || instance.getAttribute(`href`)
                      !== (anyProps.href == null || anyProps.href === `` ? null : anyProps.href)
                    || instance.getAttribute(`crossorigin`)
                      !== (anyProps.crossOrigin == null ? null : anyProps.crossOrigin)
                    || instance.getAttribute(`title`) !== (anyProps.title == null ? null : anyProps.title)
                ) break
                return instance
              case `style`:
                if (instance.hasAttribute(`data-precedence`)) break
                return instance
              case `script`:
                if (
                  name = instance.getAttribute(`src`),
                    (name !== (anyProps.src == null ? null : anyProps.src)
                      || instance.getAttribute(`type`) !== (anyProps.type == null ? null : anyProps.type)
                      || instance.getAttribute(`crossorigin`)
                        !== (anyProps.crossOrigin == null ? null : anyProps.crossOrigin))
                    && name && instance.hasAttribute(`async`) && !instance.hasAttribute(`itemprop`)
                ) break
                return instance
              default:
                return instance
            }
          }
        } else if (type$2 === `input` && instance.type === `hidden`) {
          var name = anyProps.name == null ? null : `` + anyProps.name
          if (anyProps.type === `hidden` && instance.getAttribute(`name`) === name) return instance
        } else return instance
        if (instance = getNextHydratable(instance.nextSibling), instance === null) break
      }
      return null
    }
    function canHydrateTextInstance(instance, text$6, inRootOrSingleton) {
      if (text$6 === ``) return null
      for (; instance.nodeType !== 3;) {
        if (
          (instance.nodeType !== 1 || instance.nodeName !== `INPUT` || instance.type !== `hidden`) && !inRootOrSingleton
          || (instance = getNextHydratable(instance.nextSibling), instance === null)
        ) return null
      }
      return instance
    }
    function isSuspenseInstanceFallback(instance) {
      return instance.data === `$!` || instance.data === `$?` && instance.ownerDocument.readyState === `complete`
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument
      if (instance.data !== `$?` || ownerDocument.readyState === `complete`) callback()
      else {
        var listener = function() {
          callback(), ownerDocument.removeEventListener(`DOMContentLoaded`, listener)
        }
        ownerDocument.addEventListener(`DOMContentLoaded`, listener), instance._reactRetry = listener
      }
    }
    function getNextHydratable(node$1) {
      for (; node$1 != null; node$1 = node$1.nextSibling) {
        var nodeType = node$1.nodeType
        if (nodeType === 1 || nodeType === 3) break
        if (nodeType === 8) {
          if (
            nodeType = node$1.data,
              nodeType === `$` || nodeType === `$!` || nodeType === `$?` || nodeType === `F!` || nodeType === `F`
          ) break
          if (nodeType === `/$`) return null
        }
      }
      return node$1
    }
    var previousHydratableOnEnteringScopedSingleton = null
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling
      for (var depth = 0; targetInstance;) {
        if (targetInstance.nodeType === 8) {
          var data = targetInstance.data
          if (data === `$` || data === `$!` || data === `$?`) {
            if (depth === 0) return targetInstance
            depth--
          } else data === `/$` && depth++
        }
        targetInstance = targetInstance.previousSibling
      }
      return null
    }
    function resolveSingletonInstance(type$2, props, rootContainerInstance) {
      switch (props = getOwnerDocumentFromRootContainer(rootContainerInstance), type$2) {
        case `html`:
          if (type$2 = props.documentElement, !type$2) throw Error(formatProdErrorMessage(452))
          return type$2
        case `head`:
          if (type$2 = props.head, !type$2) throw Error(formatProdErrorMessage(453))
          return type$2
        case `body`:
          if (type$2 = props.body, !type$2) throw Error(formatProdErrorMessage(454))
          return type$2
        default:
          throw Error(formatProdErrorMessage(451))
      }
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length;) instance.removeAttributeNode(attributes[0])
      detachDeletedInstance(instance)
    }
    var preloadPropsMap = new Map(), preconnectsSet = new Set()
    function getHoistableRoot(container) {
      return typeof container.getRootNode == `function`
        ? container.getRootNode()
        : container.nodeType === 9
        ? container
        : container.ownerDocument
    }
    var previousDispatcher = ReactDOMSharedInternals.d
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript,
    }
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1()
      return previousWasRendering || wasRendering
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form)
      formInst !== null && formInst.tag === 5 && formInst.type === `form`
        ? requestFormReset$1(formInst)
        : previousDispatcher.r(form)
    }
    var globalDocument = typeof document > `u` ? null : document
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument
      if (ownerDocument && typeof href == `string` && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href)
        limitedEscapedHref = `link[rel="` + rel + `"][href="` + limitedEscapedHref + `"]`,
          typeof crossOrigin == `string` && (limitedEscapedHref += `[crossorigin="` + crossOrigin + `"]`),
          preconnectsSet.has(limitedEscapedHref)
          || (preconnectsSet.add(limitedEscapedHref),
            rel = { rel, crossOrigin, href },
            ownerDocument.querySelector(limitedEscapedHref) === null
            && (href = ownerDocument.createElement(`link`),
              setInitialProperties(href, `link`, rel),
              markNodeAsHoistable(href),
              ownerDocument.head.appendChild(href)))
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href), preconnectAs(`dns-prefetch`, href, null)
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin), preconnectAs(`preconnect`, href, crossOrigin)
    }
    function preload(href, as$6, options$2) {
      previousDispatcher.L(href, as$6, options$2)
      var ownerDocument = globalDocument
      if (ownerDocument && href && as$6) {
        var preloadSelector = `link[rel="preload"][as="` + escapeSelectorAttributeValueInsideDoubleQuotes(as$6) + `"]`
        as$6 === `image` && options$2 && options$2.imageSrcSet
          ? (preloadSelector += `[imagesrcset="` + escapeSelectorAttributeValueInsideDoubleQuotes(options$2.imageSrcSet)
            + `"]`,
            typeof options$2.imageSizes == `string`
            && (preloadSelector += `[imagesizes="`
              + escapeSelectorAttributeValueInsideDoubleQuotes(options$2.imageSizes) + `"]`))
          : preloadSelector += `[href="` + escapeSelectorAttributeValueInsideDoubleQuotes(href) + `"]`
        var key$1 = preloadSelector
        switch (as$6) {
          case `style`:
            key$1 = getStyleKey(href)
            break
          case `script`:
            key$1 = getScriptKey(href)
        }
        preloadPropsMap.has(key$1)
          || (href = assign({
            rel: `preload`,
            href: as$6 === `image` && options$2 && options$2.imageSrcSet ? void 0 : href,
            as: as$6,
          }, options$2),
            preloadPropsMap.set(key$1, href),
            ownerDocument.querySelector(preloadSelector) !== null
            || as$6 === `style` && ownerDocument.querySelector(getStylesheetSelectorFromKey(key$1))
            || as$6 === `script` && ownerDocument.querySelector(getScriptSelectorFromKey(key$1))
            || (as$6 = ownerDocument.createElement(`link`),
              setInitialProperties(as$6, `link`, href),
              markNodeAsHoistable(as$6),
              ownerDocument.head.appendChild(as$6)))
      }
    }
    function preloadModule(href, options$2) {
      previousDispatcher.m(href, options$2)
      var ownerDocument = globalDocument
      if (ownerDocument && href) {
        var as$6 = options$2 && typeof options$2.as == `string` ? options$2.as : `script`,
          preloadSelector = `link[rel="modulepreload"][as="` + escapeSelectorAttributeValueInsideDoubleQuotes(as$6)
            + `"][href="` + escapeSelectorAttributeValueInsideDoubleQuotes(href) + `"]`,
          key$1 = preloadSelector
        switch (as$6) {
          case `audioworklet`:
          case `paintworklet`:
          case `serviceworker`:
          case `sharedworker`:
          case `worker`:
          case `script`:
            key$1 = getScriptKey(href)
        }
        if (
          !preloadPropsMap.has(key$1)
          && (href = assign({ rel: `modulepreload`, href }, options$2),
            preloadPropsMap.set(key$1, href),
            ownerDocument.querySelector(preloadSelector) === null)
        ) {
          switch (as$6) {
            case `audioworklet`:
            case `paintworklet`:
            case `serviceworker`:
            case `sharedworker`:
            case `worker`:
            case `script`:
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key$1))) return
          }
          as$6 = ownerDocument.createElement(`link`),
            setInitialProperties(as$6, `link`, href),
            markNodeAsHoistable(as$6),
            ownerDocument.head.appendChild(as$6)
        }
      }
    }
    function preinitStyle(href, precedence, options$2) {
      previousDispatcher.S(href, precedence, options$2)
      var ownerDocument = globalDocument
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key$1 = getStyleKey(href)
        precedence ||= `default`
        var resource = styles.get(key$1)
        if (!resource) {
          var state = { loading: 0, preload: null }
          if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key$1))) state.loading = 5
          else {
            href = assign({ rel: `stylesheet`, href, 'data-precedence': precedence }, options$2),
              (options$2 = preloadPropsMap.get(key$1)) && adoptPreloadPropsForStylesheet(href, options$2)
            var link$2 = resource = ownerDocument.createElement(`link`)
            markNodeAsHoistable(link$2),
              setInitialProperties(link$2, `link`, href),
              link$2._p = new Promise(function(resolve, reject) {
                link$2.onload = resolve, link$2.onerror = reject
              }),
              link$2.addEventListener(`load`, function() {
                state.loading |= 1
              }),
              link$2.addEventListener(`error`, function() {
                state.loading |= 2
              }),
              state.loading |= 4,
              insertStylesheet(resource, precedence, ownerDocument)
          }
          resource = { type: `stylesheet`, instance: resource, count: 1, state }, styles.set(key$1, resource)
        }
      }
    }
    function preinitScript(src, options$2) {
      previousDispatcher.X(src, options$2)
      var ownerDocument = globalDocument
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
          key$1 = getScriptKey(src),
          resource = scripts.get(key$1)
        resource
          || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key$1)),
            resource
            || (src = assign({ src, async: !0 }, options$2),
              (options$2 = preloadPropsMap.get(key$1)) && adoptPreloadPropsForScript(src, options$2),
              resource = ownerDocument.createElement(`script`),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, `link`, src),
              ownerDocument.head.appendChild(resource)),
            resource = { type: `script`, instance: resource, count: 1, state: null },
            scripts.set(key$1, resource))
      }
    }
    function preinitModuleScript(src, options$2) {
      previousDispatcher.M(src, options$2)
      var ownerDocument = globalDocument
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
          key$1 = getScriptKey(src),
          resource = scripts.get(key$1)
        resource
          || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key$1)),
            resource
            || (src = assign({ src, async: !0, type: `module` }, options$2),
              (options$2 = preloadPropsMap.get(key$1)) && adoptPreloadPropsForScript(src, options$2),
              resource = ownerDocument.createElement(`script`),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, `link`, src),
              ownerDocument.head.appendChild(resource)),
            resource = { type: `script`, instance: resource, count: 1, state: null },
            scripts.set(key$1, resource))
      }
    }
    function getResource(type$2, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current)
        ? getHoistableRoot(JSCompiler_inline_result)
        : null
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446))
      switch (type$2) {
        case `meta`:
        case `title`:
          return null
        case `style`:
          return typeof pendingProps.precedence == `string` && typeof pendingProps.href == `string`
            ? (currentProps = getStyleKey(pendingProps.href),
              pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles,
              currentResource = pendingProps.get(currentProps),
              currentResource
              || (currentResource = { type: `style`, instance: null, count: 0, state: null },
                pendingProps.set(currentProps, currentResource)),
              currentResource)
            : { type: `void`, instance: null, count: 0, state: null }
        case `link`:
          if (
            pendingProps.rel === `stylesheet` && typeof pendingProps.href == `string`
            && typeof pendingProps.precedence == `string`
          ) {
            type$2 = getStyleKey(pendingProps.href)
            var styles$244 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles,
              resource$245 = styles$244.get(type$2)
            if (
              resource$245
              || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result,
                resource$245 = { type: `stylesheet`, instance: null, count: 0, state: { loading: 0, preload: null } },
                styles$244.set(type$2, resource$245),
                (styles$244 = JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type$2)))
                && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5),
                preloadPropsMap.has(type$2)
                || (pendingProps = {
                  rel: `preload`,
                  as: `style`,
                  href: pendingProps.href,
                  crossOrigin: pendingProps.crossOrigin,
                  integrity: pendingProps.integrity,
                  media: pendingProps.media,
                  hrefLang: pendingProps.hrefLang,
                  referrerPolicy: pendingProps.referrerPolicy,
                },
                  preloadPropsMap.set(type$2, pendingProps),
                  styles$244 || preloadStylesheet(JSCompiler_inline_result, type$2, pendingProps, resource$245.state))),
                currentProps && currentResource === null
            ) throw Error(formatProdErrorMessage(528, ``))
            return resource$245
          }
          if (currentProps && currentResource !== null) throw Error(formatProdErrorMessage(529, ``))
          return null
        case `script`:
          return currentProps = pendingProps.async,
            pendingProps = pendingProps.src,
            typeof pendingProps == `string` && currentProps && typeof currentProps != `function`
              && typeof currentProps != `symbol`
              ? (currentProps = getScriptKey(pendingProps),
                pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts,
                currentResource = pendingProps.get(currentProps),
                currentResource
                || (currentResource = { type: `script`, instance: null, count: 0, state: null },
                  pendingProps.set(currentProps, currentResource)),
                currentResource)
              : { type: `void`, instance: null, count: 0, state: null }
        default:
          throw Error(formatProdErrorMessage(444, type$2))
      }
    }
    function getStyleKey(href) {
      return `href="` + escapeSelectorAttributeValueInsideDoubleQuotes(href) + `"`
    }
    function getStylesheetSelectorFromKey(key$1) {
      return `link[rel="stylesheet"][` + key$1 + `]`
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, { 'data-precedence': rawProps.precedence, precedence: null })
    }
    function preloadStylesheet(ownerDocument, key$1, preloadProps, state) {
      ownerDocument.querySelector(`link[rel="preload"][as="style"][` + key$1 + `]`)
        ? state.loading = 1
        : (key$1 = ownerDocument.createElement(`link`),
          state.preload = key$1,
          key$1.addEventListener(`load`, function() {
            return state.loading |= 1
          }),
          key$1.addEventListener(`error`, function() {
            return state.loading |= 2
          }),
          setInitialProperties(key$1, `link`, preloadProps),
          markNodeAsHoistable(key$1),
          ownerDocument.head.appendChild(key$1))
    }
    function getScriptKey(src) {
      return `[src="` + escapeSelectorAttributeValueInsideDoubleQuotes(src) + `"]`
    }
    function getScriptSelectorFromKey(key$1) {
      return `script[async]` + key$1
    }
    function acquireResource(hoistableRoot, resource, props) {
      if (resource.count++, resource.instance === null) {
        switch (resource.type) {
          case `style`:
            var instance = hoistableRoot.querySelector(
              `style[data-href~="` + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + `"]`,
            )
            if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance
            var styleProps = assign({}, props, {
              'data-href': props.href,
              'data-precedence': props.precedence,
              href: null,
              precedence: null,
            })
            return instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(`style`),
              markNodeAsHoistable(instance),
              setInitialProperties(instance, `style`, styleProps),
              insertStylesheet(instance, props.precedence, hoistableRoot),
              resource.instance = instance
          case `stylesheet`:
            styleProps = getStyleKey(props.href)
            var instance$250 = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps))
            if (instance$250) {
              return resource.state.loading |= 4,
                resource.instance = instance$250,
                markNodeAsHoistable(instance$250),
                instance$250
            }
            instance = stylesheetPropsFromRawProps(props),
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps),
              instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement(`link`),
              markNodeAsHoistable(instance$250)
            var linkInstance = instance$250
            return linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve, linkInstance.onerror = reject
            }),
              setInitialProperties(instance$250, `link`, instance),
              resource.state.loading |= 4,
              insertStylesheet(instance$250, props.precedence, hoistableRoot),
              resource.instance = instance$250
          case `script`:
            return instance$250 = getScriptKey(props.src),
              (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$250)))
                ? (resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps)
                : (instance = props,
                  (styleProps = preloadPropsMap.get(instance$250))
                  && (instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps)),
                  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot,
                  styleProps = hoistableRoot.createElement(`script`),
                  markNodeAsHoistable(styleProps),
                  setInitialProperties(styleProps, `link`, instance),
                  hoistableRoot.head.appendChild(styleProps),
                  resource.instance = styleProps)
          case `void`:
            return null
          default:
            throw Error(formatProdErrorMessage(443, resource.type))
        }
      } else {resource.type === `stylesheet` && !(resource.state.loading & 4)
          && (instance = resource.instance,
            resource.state.loading |= 4,
            insertStylesheet(instance, props.precedence, hoistableRoot))}
      return resource.instance
    }
    function insertStylesheet(instance, precedence, root$5) {
      for (
        var nodes = root$5.querySelectorAll(`link[rel="stylesheet"][data-precedence],style[data-precedence]`),
          last$3 = nodes.length ? nodes[nodes.length - 1] : null,
          prior = last$3,
          i$14 = 0;
        i$14 < nodes.length;
        i$14++
      ) {
        var node$1 = nodes[i$14]
        if (node$1.dataset.precedence === precedence) prior = node$1
        else if (prior !== last$3) break
      }
      prior
        ? prior.parentNode.insertBefore(instance, prior.nextSibling)
        : (precedence = root$5.nodeType === 9 ? root$5.head : root$5,
          precedence.insertBefore(instance, precedence.firstChild))
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      stylesheetProps.crossOrigin ??= preloadProps.crossOrigin,
        stylesheetProps.referrerPolicy ??= preloadProps.referrerPolicy,
        stylesheetProps.title ??= preloadProps.title
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      scriptProps.crossOrigin ??= preloadProps.crossOrigin,
        scriptProps.referrerPolicy ??= preloadProps.referrerPolicy,
        scriptProps.integrity ??= preloadProps.integrity
    }
    var tagCaches = null
    function getHydratableHoistableCache(type$2, keyAttribute, ownerDocument) {
      if (tagCaches === null) {
        var cache = new Map(), caches = tagCaches = new Map()
        caches.set(ownerDocument, cache)
      } else {caches = tagCaches,
          cache = caches.get(ownerDocument),
          cache || (cache = new Map(), caches.set(ownerDocument, cache))}
      if (cache.has(type$2)) return cache
      for (
        cache.set(type$2, null), ownerDocument = ownerDocument.getElementsByTagName(type$2), caches = 0;
        caches < ownerDocument.length;
        caches++
      ) {
        var node$1 = ownerDocument[caches]
        if (
          !(node$1[internalHoistableMarker] || node$1[internalInstanceKey]
            || type$2 === `link` && node$1.getAttribute(`rel`) === `stylesheet`)
          && node$1.namespaceURI !== `http://www.w3.org/2000/svg`
        ) {
          var nodeKey = node$1.getAttribute(keyAttribute) || ``
          nodeKey = type$2 + nodeKey
          var existing = cache.get(nodeKey)
          existing ? existing.push(node$1) : cache.set(nodeKey, [node$1])
        }
      }
      return cache
    }
    function mountHoistable(hoistableRoot, type$2, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot,
        hoistableRoot.head.insertBefore(
          instance,
          type$2 === `title` ? hoistableRoot.querySelector(`head > title`) : null,
        )
    }
    function isHostHoistableType(type$2, props, hostContext) {
      if (hostContext === 1 || props.itemProp != null) return !1
      switch (type$2) {
        case `meta`:
        case `title`:
          return !0
        case `style`:
          if (typeof props.precedence != `string` || typeof props.href != `string` || props.href === ``) break
          return !0
        case `link`:
          if (
            typeof props.rel != `string` || typeof props.href != `string` || props.href === `` || props.onLoad
            || props.onError
          ) break
          switch (props.rel) {
            case `stylesheet`:
              return type$2 = props.disabled, typeof props.precedence == `string` && type$2 == null
            default:
              return !0
          }
        case `script`:
          if (
            props.async && typeof props.async != `function` && typeof props.async != `symbol` && !props.onLoad
            && !props.onError && props.src && typeof props.src == `string`
          ) return !0
      }
      return !1
    }
    function preloadResource(resource) {
      return resource.type === `stylesheet` && !(resource.state.loading & 3) ? !1 : !0
    }
    var suspendedState = null
    function noop$4() {}
    function suspendResource(hoistableRoot, resource, props) {
      if (suspendedState === null) throw Error(formatProdErrorMessage(475))
      var state = suspendedState
      if (
        resource.type === `stylesheet` && (typeof props.media != `string` || !1 !== matchMedia(props.media).matches)
        && !(resource.state.loading & 4)
      ) {
        if (resource.instance === null) {
          var key$1 = getStyleKey(props.href),
            instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key$1))
          if (instance) {
            hoistableRoot = instance._p,
              typeof hoistableRoot == `object` && hoistableRoot && typeof hoistableRoot.then == `function`
              && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state)),
              resource.state.loading |= 4,
              resource.instance = instance,
              markNodeAsHoistable(instance)
            return
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot,
            props = stylesheetPropsFromRawProps(props),
            (key$1 = preloadPropsMap.get(key$1)) && adoptPreloadPropsForStylesheet(props, key$1),
            instance = instance.createElement(`link`),
            markNodeAsHoistable(instance)
          var linkInstance = instance
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve, linkInstance.onerror = reject
          }),
            setInitialProperties(instance, `link`, props),
            resource.instance = instance
        }
        state.stylesheets === null && (state.stylesheets = new Map()),
          state.stylesheets.set(resource, hoistableRoot),
          (hoistableRoot = resource.state.preload) && !(resource.state.loading & 3)
          && (state.count++,
            resource = onUnsuspend.bind(state),
            hoistableRoot.addEventListener(`load`, resource),
            hoistableRoot.addEventListener(`error`, resource))
      }
    }
    function waitForCommitToBeReady() {
      if (suspendedState === null) throw Error(formatProdErrorMessage(475))
      var state = suspendedState
      return state.stylesheets && state.count === 0 && insertSuspendedStylesheets(state, state.stylesheets),
        0 < state.count
          ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              if (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend) {
                var unsuspend = state.unsuspend
                state.unsuspend = null, unsuspend()
              }
            }, 6e4)
            return state.unsuspend = commit, function() {
              state.unsuspend = null, clearTimeout(stylesheetTimer)
            }
          }
          : null
    }
    function onUnsuspend() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets)
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend
          this.unsuspend = null, unsuspend()
        }
      }
    }
    var precedencesByRoot = null
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null,
        state.unsuspend !== null
        && (state.count++,
          precedencesByRoot = new Map(),
          resources.forEach(insertStylesheetIntoRoot, state),
          precedencesByRoot = null,
          onUnsuspend.call(state))
    }
    function insertStylesheetIntoRoot(root$5, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root$5)
        if (precedences) var last$3 = precedences.get(null)
        else {
          precedences = new Map(), precedencesByRoot.set(root$5, precedences)
          for (
            var nodes = root$5.querySelectorAll(`link[data-precedence],style[data-precedence]`), i$14 = 0;
            i$14 < nodes.length;
            i$14++
          ) {
            var node$1 = nodes[i$14]
            ;(node$1.nodeName === `LINK` || node$1.getAttribute(`media`) !== `not all`)
              && (precedences.set(node$1.dataset.precedence, node$1), last$3 = node$1)
          }
          last$3 && precedences.set(null, last$3)
        }
        nodes = resource.instance,
          node$1 = nodes.getAttribute(`data-precedence`),
          i$14 = precedences.get(node$1) || last$3,
          i$14 === last$3 && precedences.set(null, nodes),
          precedences.set(node$1, nodes),
          this.count++,
          last$3 = onUnsuspend.bind(this),
          nodes.addEventListener(`load`, last$3),
          nodes.addEventListener(`error`, last$3),
          i$14
            ? i$14.parentNode.insertBefore(nodes, i$14.nextSibling)
            : (root$5 = root$5.nodeType === 9 ? root$5.head : root$5, root$5.insertBefore(nodes, root$5.firstChild)),
          resource.state.loading |= 4
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0,
    }
    function FiberRootNode(
      containerInfo,
      tag$3,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      formState,
    ) {
      this.tag = 1,
        this.containerInfo = containerInfo,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode =
          this.next =
          this.pendingContext =
          this.context =
          this.cancelPendingCommit =
            null,
        this.callbackPriority = 0,
        this.expirationTimes = createLaneMap(-1),
        this.entangledLanes =
          this.shellSuspendCounter =
          this.errorRecoveryDisabledLanes =
          this.expiredLanes =
          this.warmLanes =
          this.pingedLanes =
          this.suspendedLanes =
          this.pendingLanes =
            0,
        this.entanglements = createLaneMap(0),
        this.hiddenUpdates = createLaneMap(null),
        this.identifierPrefix = identifierPrefix,
        this.onUncaughtError = onUncaughtError,
        this.onCaughtError = onCaughtError,
        this.onRecoverableError = onRecoverableError,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = formState,
        this.incompleteTransitions = new Map()
    }
    function createFiberRoot(
      containerInfo,
      tag$3,
      hydrate,
      initialChildren,
      hydrationCallbacks,
      isStrictMode,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      transitionCallbacks,
      formState,
    ) {
      return containerInfo = new FiberRootNode(
        containerInfo,
        tag$3,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        formState,
      ),
        tag$3 = 1,
        !0 === isStrictMode && (tag$3 |= 24),
        isStrictMode = createFiberImplClass(3, null, null, tag$3),
        containerInfo.current = isStrictMode,
        isStrictMode.stateNode = containerInfo,
        tag$3 = createCache(),
        tag$3.refCount++,
        containerInfo.pooledCache = tag$3,
        tag$3.refCount++,
        isStrictMode.memoizedState = { element: initialChildren, isDehydrated: hydrate, cache: tag$3 },
        initializeUpdateQueue(isStrictMode),
        containerInfo
    }
    function getContextForSubtree(parentComponent) {
      return parentComponent ? (parentComponent = emptyContextObject, parentComponent) : emptyContextObject
    }
    function updateContainerImpl(rootFiber, lane, element$2, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent),
        container.context === null ? container.context = parentComponent : container.pendingContext = parentComponent,
        container = createUpdate(lane),
        container.payload = { element: element$2 },
        callback = callback === void 0 ? null : callback,
        callback !== null && (container.callback = callback),
        element$2 = enqueueUpdate(rootFiber, container, lane),
        element$2 !== null
        && (scheduleUpdateOnFiber(element$2, rootFiber, lane), entangleTransitions(element$2, rootFiber, lane))
    }
    function markRetryLaneImpl(fiber, retryLane) {
      if (fiber = fiber.memoizedState, fiber !== null && fiber.dehydrated !== null) {
        var a$22 = fiber.retryLane
        fiber.retryLane = a$22 !== 0 && a$22 < retryLane ? a$22 : retryLane
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane), (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane)
    }
    function attemptContinuousHydration(fiber) {
      if (fiber.tag === 13) {
        var root$5 = enqueueConcurrentRenderForLane(fiber, 67108864)
        root$5 !== null && scheduleUpdateOnFiber(root$5, fiber, 67108864), markRetryLaneIfNotHydrated(fiber, 67108864)
      }
    }
    var _enabled = !0
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T
      ReactSharedInternals.T = null
      var previousPriority = ReactDOMSharedInternals.p
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent)
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T
      ReactSharedInternals.T = null
      var previousPriority = ReactDOMSharedInternals.p
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent)
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent)
        if (blockedOn === null) {
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer,
          ), clearIfContinuousEvent(domEventName, nativeEvent)
        } else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
          nativeEvent.stopPropagation()
        } else if (
          clearIfContinuousEvent(domEventName, nativeEvent),
            eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)
        ) {
          for (; blockedOn !== null;) {
            var fiber = getInstanceFromNode(blockedOn)
            if (fiber !== null) {
              switch (fiber.tag) {
                case 3:
                  if (fiber = fiber.stateNode, fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes)
                    if (lanes !== 0) {
                      var root$5 = fiber
                      for (root$5.pendingLanes |= 2, root$5.entangledLanes |= 2; lanes;) {
                        var lane = 1 << 31 - clz32(lanes)
                        root$5.entanglements[1] |= lane, lanes &= ~lane
                      }
                      ensureRootIsScheduled(fiber),
                        !(executionContext & 6)
                        && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, !1))
                    }
                  }
                  break
                case 13:
                  root$5 = enqueueConcurrentRenderForLane(fiber, 2),
                    root$5 !== null && scheduleUpdateOnFiber(root$5, fiber, 2),
                    flushSyncWork$1(),
                    markRetryLaneIfNotHydrated(fiber, 2)
              }
            }
            if (
              fiber = findInstanceBlockingEvent(nativeEvent),
                fiber === null
                && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer,
                ),
                fiber === blockedOn
            ) break
            blockedOn = fiber
          }
          blockedOn !== null && nativeEvent.stopPropagation()
        } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer)
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      return nativeEvent = getEventTarget(nativeEvent), findInstanceBlockingTarget(nativeEvent)
    }
    var return_targetInst = null
    function findInstanceBlockingTarget(targetNode) {
      if (return_targetInst = null, targetNode = getClosestInstanceFromNode(targetNode), targetNode !== null) {
        var nearestMounted = getNearestMountedFiber(targetNode)
        if (nearestMounted === null) targetNode = null
        else {
          var tag$3 = nearestMounted.tag
          if (tag$3 === 13) {
            if (targetNode = getSuspenseInstanceFromFiber(nearestMounted), targetNode !== null) return targetNode
            targetNode = null
          } else if (tag$3 === 3) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              return nearestMounted.tag === 3
                ? nearestMounted.stateNode.containerInfo
                : null
            }
            targetNode = null
          } else nearestMounted !== targetNode && (targetNode = null)
        }
      }
      return return_targetInst = targetNode, null
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case `beforetoggle`:
        case `cancel`:
        case `click`:
        case `close`:
        case `contextmenu`:
        case `copy`:
        case `cut`:
        case `auxclick`:
        case `dblclick`:
        case `dragend`:
        case `dragstart`:
        case `drop`:
        case `focusin`:
        case `focusout`:
        case `input`:
        case `invalid`:
        case `keydown`:
        case `keypress`:
        case `keyup`:
        case `mousedown`:
        case `mouseup`:
        case `paste`:
        case `pause`:
        case `play`:
        case `pointercancel`:
        case `pointerdown`:
        case `pointerup`:
        case `ratechange`:
        case `reset`:
        case `resize`:
        case `seeked`:
        case `submit`:
        case `toggle`:
        case `touchcancel`:
        case `touchend`:
        case `touchstart`:
        case `volumechange`:
        case `change`:
        case `selectionchange`:
        case `textInput`:
        case `compositionstart`:
        case `compositionend`:
        case `compositionupdate`:
        case `beforeblur`:
        case `afterblur`:
        case `beforeinput`:
        case `blur`:
        case `fullscreenchange`:
        case `focus`:
        case `hashchange`:
        case `popstate`:
        case `select`:
        case `selectstart`:
          return 2
        case `drag`:
        case `dragenter`:
        case `dragexit`:
        case `dragleave`:
        case `dragover`:
        case `mousemove`:
        case `mouseout`:
        case `mouseover`:
        case `pointermove`:
        case `pointerout`:
        case `pointerover`:
        case `scroll`:
        case `touchmove`:
        case `wheel`:
        case `mouseenter`:
        case `mouseleave`:
        case `pointerenter`:
        case `pointerleave`:
          return 8
        case `message`:
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2
            case UserBlockingPriority:
              return 8
            case NormalPriority$1:
            case LowPriority:
              return 32
            case IdlePriority:
              return 268435456
            default:
              return 32
          }
        default:
          return 32
      }
    }
    var hasScheduledReplayAttempt = !1,
      queuedFocus = null,
      queuedDrag = null,
      queuedMouse = null,
      queuedPointers = new Map(),
      queuedPointerCaptures = new Map(),
      queuedExplicitHydrationTargets = [],
      discreteReplayableEvents =
        `mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset`
          .split(` `)
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case `focusin`:
        case `focusout`:
          queuedFocus = null
          break
        case `dragenter`:
        case `dragleave`:
          queuedDrag = null
          break
        case `mouseover`:
        case `mouseout`:
          queuedMouse = null
          break
        case `pointerover`:
        case `pointerout`:
          queuedPointers.delete(nativeEvent.pointerId)
          break
        case `gotpointercapture`:
        case `lostpointercapture`:
          queuedPointerCaptures.delete(nativeEvent.pointerId)
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(
      existingQueuedEvent,
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent,
    ) {
      return existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent
        ? (existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer],
        },
          blockedOn !== null
          && (blockedOn = getInstanceFromNode(blockedOn), blockedOn !== null && attemptContinuousHydration(blockedOn)),
          existingQueuedEvent)
        : (existingQueuedEvent.eventSystemFlags |= eventSystemFlags,
          blockedOn = existingQueuedEvent.targetContainers,
          targetContainer !== null && blockedOn.indexOf(targetContainer) === -1 && blockedOn.push(targetContainer),
          existingQueuedEvent)
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case `focusin`:
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent,
          ),
            !0
        case `dragenter`:
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent,
          ),
            !0
        case `mouseover`:
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent,
          ),
            !0
        case `pointerover`:
          var pointerId = nativeEvent.pointerId
          return queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent,
            ),
          ),
            !0
        case `gotpointercapture`:
          return pointerId = nativeEvent.pointerId,
            queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent,
              ),
            ),
            !0
      }
      return !1
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target)
      if (targetInst !== null) {
        var nearestMounted = getNearestMountedFiber(targetInst)
        if (nearestMounted !== null) {
          if (targetInst = nearestMounted.tag, targetInst === 13) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), targetInst !== null) {
              queuedTarget.blockedOn = targetInst,
                runWithPriority(queuedTarget.priority, function() {
                  if (nearestMounted.tag === 13) {
                    var lane = requestUpdateLane()
                    lane = getBumpedLaneForHydrationByLane(lane)
                    var root$5 = enqueueConcurrentRenderForLane(nearestMounted, lane)
                    root$5 !== null && scheduleUpdateOnFiber(root$5, nearestMounted, lane),
                      markRetryLaneIfNotHydrated(nearestMounted, lane)
                  }
                })
              return
            }
          } else if (targetInst === 3 && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = nearestMounted.tag === 3 ? nearestMounted.stateNode.containerInfo : null
            return
          }
        }
      }
      queuedTarget.blockedOn = null
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (queuedEvent.blockedOn !== null) return !1
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent)
        if (nextBlockedOn === null) {
          nextBlockedOn = queuedEvent.nativeEvent
          var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn)
          currentReplayingEvent = nativeEventClone,
            nextBlockedOn.target.dispatchEvent(nativeEventClone),
            currentReplayingEvent = null
        } else {return targetContainers = getInstanceFromNode(nextBlockedOn),
            targetContainers !== null && attemptContinuousHydration(targetContainers),
            queuedEvent.blockedOn = nextBlockedOn,
            !1}
        targetContainers.shift()
      }
      return !0
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key$1, map$20) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map$20.delete(key$1)
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = !1,
        queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null),
        queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null),
        queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null),
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap),
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap)
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked
        && (queuedEvent.blockedOn = null,
          hasScheduledReplayAttempt
          || (hasScheduledReplayAttempt = !0,
            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)))
    }
    var lastScheduledReplayQueue = null
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue
        && (lastScheduledReplayQueue = formReplayingQueue,
          Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null)
            for (var i$14 = 0; i$14 < formReplayingQueue.length; i$14 += 3) {
              var form = formReplayingQueue[i$14],
                submitterOrAction = formReplayingQueue[i$14 + 1],
                formData = formReplayingQueue[i$14 + 2]
              if (typeof submitterOrAction != `function`) {
                if (findInstanceBlockingTarget(submitterOrAction || form) === null) continue
                break
              }
              var formInst = getInstanceFromNode(form)
              formInst !== null
                && (formReplayingQueue.splice(i$14, 3),
                  i$14 -= 3,
                  startHostTransition(
                    formInst,
                    { pending: !0, data: formData, method: form.method, action: submitterOrAction },
                    submitterOrAction,
                    formData,
                  ))
            }
          }))
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked)
      }
      queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, unblocked),
        queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, unblocked),
        queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, unblocked),
        queuedPointers.forEach(unblock),
        queuedPointerCaptures.forEach(unblock)
      for (var i$14 = 0; i$14 < queuedExplicitHydrationTargets.length; i$14++) {
        var queuedTarget = queuedExplicitHydrationTargets[i$14]
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null)
      }
      for (
        ;
        0 < queuedExplicitHydrationTargets.length
        && (i$14 = queuedExplicitHydrationTargets[0], i$14.blockedOn === null);
      ) attemptExplicitHydrationTarget(i$14), i$14.blockedOn === null && queuedExplicitHydrationTargets.shift()
      if (i$14 = (unblocked.ownerDocument || unblocked).$$reactFormReplay, i$14 != null) {
        for (queuedTarget = 0; queuedTarget < i$14.length; queuedTarget += 3) {
          var form = i$14[queuedTarget],
            submitterOrAction = i$14[queuedTarget + 1],
            formProps = form[internalPropsKey] || null
          if (typeof submitterOrAction == `function`) {
            formProps || scheduleReplayQueueIfNeeded(i$14)
          } else if (formProps) {
            var action = null
            if (submitterOrAction && submitterOrAction.hasAttribute(`formAction`)) {
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) {
                action = formProps.formAction
              } else if (findInstanceBlockingTarget(form) !== null) continue
            } else action = formProps.action
            typeof action == `function`
              ? i$14[queuedTarget + 1] = action
              : (i$14.splice(queuedTarget, 3), queuedTarget -= 3), scheduleReplayQueueIfNeeded(i$14)
          }
        }
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children$3) {
      var root$5 = this._internalRoot
      if (root$5 === null) throw Error(formatProdErrorMessage(409))
      var current = root$5.current, lane = requestUpdateLane()
      updateContainerImpl(current, lane, children$3, root$5, null, null)
    },
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root$5 = this._internalRoot
        if (root$5 !== null) {
          this._internalRoot = null
          var container = root$5.containerInfo
          updateContainerImpl(root$5.current, 2, null, root$5, null, null),
            flushSyncWork$1(),
            container[internalContainerInstanceKey] = null
        }
      }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority()
        target = { blockedOn: null, target, priority: updatePriority }
        for (
          var i$14 = 0;
          i$14 < queuedExplicitHydrationTargets.length && updatePriority !== 0
          && updatePriority < queuedExplicitHydrationTargets[i$14].priority;
          i$14++
        );
        queuedExplicitHydrationTargets.splice(i$14, 0, target), i$14 === 0 && attemptExplicitHydrationTarget(target)
      }
    }
    var isomorphicReactPackageVersion$jscomp$inline_1785 = React$3.version
    if (isomorphicReactPackageVersion$jscomp$inline_1785 !== `19.1.0`) {
      throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1785, `19.1.0`))
    }
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals
      if (fiber === void 0) {
        throw typeof componentOrElement.render == `function`
          ? Error(formatProdErrorMessage(188))
          : (componentOrElement = Object.keys(componentOrElement).join(`,`),
            Error(formatProdErrorMessage(268, componentOrElement)))
      }
      return componentOrElement = findCurrentFiberUsingSlowPath(fiber),
        componentOrElement = componentOrElement === null ? null : findCurrentHostFiberImpl(componentOrElement),
        componentOrElement = componentOrElement === null ? null : componentOrElement.stateNode,
        componentOrElement
    }
    var internals$jscomp$inline_2256 = {
      bundleType: 0,
      version: `19.1.0`,
      rendererPackageName: `react-dom`,
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: `19.1.0`,
    }
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < `u`) {
      var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__
      if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber) {
        try {
          rendererID = hook$jscomp$inline_2257.inject(internals$jscomp$inline_2256),
            injectedHook = hook$jscomp$inline_2257
        } catch {}
      }
    }
    exports.hydrateRoot = function(container, initialChildren, options$2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299))
      var isStrictMode = !1,
        identifierPrefix = ``,
        onUncaughtError = defaultOnUncaughtError,
        onCaughtError = defaultOnCaughtError,
        onRecoverableError = defaultOnRecoverableError,
        transitionCallbacks = null,
        formState = null
      return options$2 != null
        && (!0 === options$2.unstable_strictMode && (isStrictMode = !0),
          options$2.identifierPrefix !== void 0 && (identifierPrefix = options$2.identifierPrefix),
          options$2.onUncaughtError !== void 0 && (onUncaughtError = options$2.onUncaughtError),
          options$2.onCaughtError !== void 0 && (onCaughtError = options$2.onCaughtError),
          options$2.onRecoverableError !== void 0 && (onRecoverableError = options$2.onRecoverableError),
          options$2.unstable_transitionCallbacks !== void 0
          && (transitionCallbacks = options$2.unstable_transitionCallbacks),
          options$2.formState !== void 0 && (formState = options$2.formState)),
        initialChildren = createFiberRoot(
          container,
          1,
          !0,
          initialChildren,
          options$2 ?? null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState,
        ),
        initialChildren.context = getContextForSubtree(null),
        options$2 = initialChildren.current,
        isStrictMode = requestUpdateLane(),
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode),
        identifierPrefix = createUpdate(isStrictMode),
        identifierPrefix.callback = null,
        enqueueUpdate(options$2, identifierPrefix, isStrictMode),
        options$2 = isStrictMode,
        initialChildren.current.lanes = options$2,
        markRootUpdated$1(initialChildren, options$2),
        ensureRootIsScheduled(initialChildren),
        container[internalContainerInstanceKey] = initialChildren.current,
        listenToAllSupportedEvents(container),
        new ReactDOMHydrationRoot(initialChildren)
    }
  }),
  require_client = __commonJSMin((exports, module) => {
    function checkDCE() {
      if (
        !(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > `u` || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != `function`)
      ) {
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (err) {
          console.error(err)
        }
      }
    }
    checkDCE(), module.exports = require_react_dom_client_production()
  }),
  import_client = __toESM(require_client()),
  import_react = __toESM(require_react(), 1),
  __typeError = msg => {
    throw TypeError(msg)
  },
  __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(`Cannot ` + msg),
  __privateGet = (
    obj,
    member,
    getter,
  ) => (__accessCheck(obj, member, `read from private field`), getter ? getter.call(obj) : member.get(obj)),
  __privateAdd = (obj, member, value$2) =>
    member.has(obj)
      ? __typeError(`Cannot add the same private member more than once`)
      : member instanceof WeakSet
      ? member.add(obj)
      : member.set(obj, value$2),
  PopStateEventType = `popstate`
function createBrowserHistory(options$2 = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search: search$1, hash: hash$1 } = window2.location
    return createLocation(
      ``,
      { pathname, search: search$1, hash: hash$1 },
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || `default`,
    )
  }
  function createBrowserHref(window2, to) {
    return typeof to == `string` ? to : createPath(to)
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options$2)
}
function invariant$1(value$2, message) {
  if (value$2 === !1 || value$2 == null) throw Error(message)
}
function warning(cond, message) {
  if (!cond) {
    typeof console < `u` && console.warn(message)
    try {
      throw Error(message)
    } catch {}
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10)
}
function getHistoryState(location, index$4) {
  return { usr: location.state, key: location.key, idx: index$4 }
}
function createLocation(current, to, state = null, key$1) {
  let location = {
    pathname: typeof current == `string` ? current : current.pathname,
    search: ``,
    hash: ``,
    ...typeof to == `string` ? parsePath(to) : to,
    state,
    key: to && to.key || key$1 || createKey(),
  }
  return location
}
function createPath({ pathname = `/`, search: search$1 = ``, hash: hash$1 = `` }) {
  return search$1 && search$1 !== `?` && (pathname += search$1.charAt(0) === `?` ? search$1 : `?` + search$1),
    hash$1 && hash$1 !== `#` && (pathname += hash$1.charAt(0) === `#` ? hash$1 : `#` + hash$1),
    pathname
}
function parsePath(path$1) {
  let parsedPath = {}
  if (path$1) {
    let hashIndex = path$1.indexOf(`#`)
    hashIndex >= 0 && (parsedPath.hash = path$1.substring(hashIndex), path$1 = path$1.substring(0, hashIndex))
    let searchIndex = path$1.indexOf(`?`)
    searchIndex >= 0 && (parsedPath.search = path$1.substring(searchIndex), path$1 = path$1.substring(0, searchIndex)),
      path$1 && (parsedPath.pathname = path$1)
  }
  return parsedPath
}
function getUrlBasedHistory(getLocation$1, createHref2, validateLocation, options$2 = {}) {
  let { window: window2 = document.defaultView, v5Compat = !1 } = options$2,
    globalHistory = window2.history,
    action = `POP`,
    listener = null,
    index$4 = getIndex()
  index$4 ?? (index$4 = 0, globalHistory.replaceState({ ...globalHistory.state, idx: index$4 }, ``))
  function getIndex() {
    let state = globalHistory.state || { idx: null }
    return state.idx
  }
  function handlePop() {
    action = `POP`
    let nextIndex = getIndex(), delta = nextIndex == null ? null : nextIndex - index$4
    index$4 = nextIndex, listener && listener({ action, location: history.location, delta })
  }
  function push$3(to, state) {
    action = `PUSH`
    let location = createLocation(history.location, to, state)
    validateLocation && validateLocation(location, to), index$4 = getIndex() + 1
    let historyState = getHistoryState(location, index$4), url = history.createHref(location)
    try {
      globalHistory.pushState(historyState, ``, url)
    } catch (error) {
      if (error instanceof DOMException && error.name === `DataCloneError`) throw error
      window2.location.assign(url)
    }
    v5Compat && listener && listener({ action, location: history.location, delta: 1 })
  }
  function replace2(to, state) {
    action = `REPLACE`
    let location = createLocation(history.location, to, state)
    validateLocation && validateLocation(location, to), index$4 = getIndex()
    let historyState = getHistoryState(location, index$4), url = history.createHref(location)
    globalHistory.replaceState(historyState, ``, url),
      v5Compat && listener && listener({ action, location: history.location, delta: 0 })
  }
  function createURL(to) {
    return createBrowserURLImpl(to)
  }
  let history = {
    get action() {
      return action
    },
    get location() {
      return getLocation$1(window2, globalHistory)
    },
    listen(fn) {
      if (listener) throw Error(`A history only accepts one active listener`)
      return window2.addEventListener(PopStateEventType, handlePop), listener = fn, () => {
        window2.removeEventListener(PopStateEventType, handlePop), listener = null
      }
    },
    createHref(to) {
      return createHref2(window2, to)
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to)
      return { pathname: url.pathname, search: url.search, hash: url.hash }
    },
    push: push$3,
    replace: replace2,
    go(n$19) {
      return globalHistory.go(n$19)
    },
  }
  return history
}
function createBrowserURLImpl(to, isAbsolute = !1) {
  let base = `http://localhost`
  typeof window < `u` && (base = window.location.origin === `null` ? window.location.href : window.location.origin),
    invariant$1(base, `No window.location.(origin|href) available to create URL`)
  let href = typeof to == `string` ? to : createPath(to)
  return href = href.replace(/ $/, `%20`),
    !isAbsolute && href.startsWith(`//`) && (href = base + href),
    new URL(href, base)
}
var _map,
  unstable_RouterContextProvider = class {
    constructor(init) {
      if (__privateAdd(this, _map, new Map()), init) for (let [context$2, value$2] of init) this.set(context$2, value$2)
    }
    get(context$2) {
      if (__privateGet(this, _map).has(context$2)) return __privateGet(this, _map).get(context$2)
      if (context$2.defaultValue !== void 0) return context$2.defaultValue
      throw Error(`No value found for context`)
    }
    set(context$2, value$2) {
      __privateGet(this, _map).set(context$2, value$2)
    }
  }
_map = new WeakMap()
var unsupportedLazyRouteObjectKeys = new Set([`lazy`, `caseSensitive`, `path`, `id`, `index`, `children`])
function isUnsupportedLazyRouteObjectKey(key$1) {
  return unsupportedLazyRouteObjectKeys.has(key$1)
}
var unsupportedLazyRouteFunctionKeys = new Set([
  `lazy`,
  `caseSensitive`,
  `path`,
  `id`,
  `index`,
  `unstable_middleware`,
  `children`,
])
function isUnsupportedLazyRouteFunctionKey(key$1) {
  return unsupportedLazyRouteFunctionKeys.has(key$1)
}
function isIndexRoute(route$1) {
  return route$1.index === !0
}
function convertRoutesToDataRoutes(
  routes$2,
  mapRouteProperties2,
  parentPath = [],
  manifest = {},
  allowInPlaceMutations = !1,
) {
  return routes$2.map((route$1, index$4) => {
    let treePath = [...parentPath, String(index$4)],
      id$2 = typeof route$1.id == `string` ? route$1.id : treePath.join(`-`)
    if (
      invariant$1(route$1.index !== !0 || !route$1.children, `Cannot specify children on an index route`),
        invariant$1(
          allowInPlaceMutations || !manifest[id$2],
          `Found a route id collision on id "${id$2}".  Route id's must be globally unique within Data Router usages`,
        ),
        isIndexRoute(route$1)
    ) {
      let indexRoute = { ...route$1, ...mapRouteProperties2(route$1), id: id$2 }
      return manifest[id$2] = indexRoute, indexRoute
    } else {
      let pathOrLayoutRoute = { ...route$1, ...mapRouteProperties2(route$1), id: id$2, children: void 0 }
      return manifest[id$2] = pathOrLayoutRoute,
        route$1.children
        && (pathOrLayoutRoute.children = convertRoutesToDataRoutes(
          route$1.children,
          mapRouteProperties2,
          treePath,
          manifest,
          allowInPlaceMutations,
        )),
        pathOrLayoutRoute
    }
  })
}
function matchRoutes(routes$2, locationArg, basename$1 = `/`) {
  return matchRoutesImpl(routes$2, locationArg, basename$1, !1)
}
function matchRoutesImpl(routes$2, locationArg, basename$1, allowPartial) {
  let location = typeof locationArg == `string` ? parsePath(locationArg) : locationArg,
    pathname = stripBasename(location.pathname || `/`, basename$1)
  if (pathname == null) return null
  let branches = flattenRoutes(routes$2)
  rankRouteBranches(branches)
  let matches = null
  for (let i$14 = 0; matches == null && i$14 < branches.length; ++i$14) {
    let decoded = decodePath(pathname)
    matches = matchRouteBranch(branches[i$14], decoded, allowPartial)
  }
  return matches
}
function convertRouteMatchToUiMatch(match$13, loaderData) {
  let { route: route$1, pathname, params } = match$13
  return { id: route$1.id, pathname, params, data: loaderData[route$1.id], handle: route$1.handle }
}
function flattenRoutes(routes$2, branches = [], parentsMeta = [], parentPath = ``) {
  let flattenRoute = (route$1, index$4, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route$1.path || `` : relativePath,
      caseSensitive: route$1.caseSensitive === !0,
      childrenIndex: index$4,
      route: route$1,
    }
    meta.relativePath.startsWith(`/`)
      && (invariant$1(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`,
      ),
        meta.relativePath = meta.relativePath.slice(parentPath.length))
    let path$1 = joinPaths([parentPath, meta.relativePath]), routesMeta = parentsMeta.concat(meta)
    route$1.children && route$1.children.length > 0
    && (invariant$1(
      route$1.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${path$1}".`,
    ),
      flattenRoutes(route$1.children, branches, routesMeta, path$1)),
      !(route$1.path == null && !route$1.index)
      && branches.push({ path: path$1, score: computeScore(path$1, route$1.index), routesMeta })
  }
  return routes$2.forEach((route$1, index$4) => {
    if (route$1.path === `` || !route$1.path?.includes(`?`)) flattenRoute(route$1, index$4)
    else for (let exploded of explodeOptionalSegments(route$1.path)) flattenRoute(route$1, index$4, exploded)
  }),
    branches
}
function explodeOptionalSegments(path$1) {
  let segments = path$1.split(`/`)
  if (segments.length === 0) return []
  let [first$2, ...rest] = segments, isOptional = first$2.endsWith(`?`), required = first$2.replace(/\?$/, ``)
  if (rest.length === 0) return isOptional ? [required, ``] : [required]
  let restExploded = explodeOptionalSegments(rest.join(`/`)), result = []
  return result.push(...restExploded.map(subpath => subpath === `` ? required : [required, subpath].join(`/`))),
    isOptional && result.push(...restExploded),
    result.map(exploded => path$1.startsWith(`/`) && exploded === `` ? `/` : exploded)
}
function rankRouteBranches(branches) {
  branches.sort((a$22, b$3) =>
    a$22.score === b$3.score
      ? compareIndexes(a$22.routesMeta.map(meta => meta.childrenIndex), b$3.routesMeta.map(meta => meta.childrenIndex))
      : b$3.score - a$22.score
  )
}
var paramRe = /^:[\w-]+$/,
  dynamicSegmentValue = 3,
  indexRouteValue = 2,
  emptySegmentValue = 1,
  staticSegmentValue = 10,
  splatPenalty = -2,
  isSplat = s$14 => s$14 === `*`
function computeScore(path$1, index$4) {
  let segments = path$1.split(`/`), initialScore = segments.length
  return segments.some(isSplat) && (initialScore += splatPenalty),
    index$4 && (initialScore += indexRouteValue),
    segments.filter(s$14 => !isSplat(s$14)).reduce(
      (score, segment) =>
        score + (paramRe.test(segment) ? dynamicSegmentValue : segment === `` ? emptySegmentValue : staticSegmentValue),
      initialScore,
    )
}
function compareIndexes(a$22, b$3) {
  let siblings$1 = a$22.length === b$3.length && a$22.slice(0, -1).every((n$19, i$14) => n$19 === b$3[i$14])
  return siblings$1 ? a$22[a$22.length - 1] - b$3[b$3.length - 1] : 0
}
function matchRouteBranch(branch, pathname, allowPartial = !1) {
  let { routesMeta } = branch, matchedParams = {}, matchedPathname = `/`, matches = []
  for (let i$14 = 0; i$14 < routesMeta.length; ++i$14) {
    let meta = routesMeta[i$14],
      end$2 = i$14 === routesMeta.length - 1,
      remainingPathname = matchedPathname === `/` ? pathname : pathname.slice(matchedPathname.length) || `/`,
      match$13 = matchPath(
        { path: meta.relativePath, caseSensitive: meta.caseSensitive, end: end$2 },
        remainingPathname,
      ),
      route$1 = meta.route
    if (
      !match$13 && end$2 && allowPartial && !routesMeta[routesMeta.length - 1].route.index
      && (match$13 = matchPath(
        { path: meta.relativePath, caseSensitive: meta.caseSensitive, end: !1 },
        remainingPathname,
      )), !match$13
    ) return null
    Object.assign(matchedParams, match$13.params),
      matches.push({
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match$13.pathname]),
        pathnameBase: normalizePathname(joinPaths([matchedPathname, match$13.pathnameBase])),
        route: route$1,
      }),
      match$13.pathnameBase !== `/` && (matchedPathname = joinPaths([matchedPathname, match$13.pathnameBase]))
  }
  return matches
}
function matchPath(pattern$1, pathname) {
  typeof pattern$1 == `string` && (pattern$1 = { path: pattern$1, caseSensitive: !1, end: !0 })
  let [matcher, compiledParams] = compilePath(pattern$1.path, pattern$1.caseSensitive, pattern$1.end),
    match$13 = pathname.match(matcher)
  if (!match$13) return null
  let matchedPathname = match$13[0],
    pathnameBase = matchedPathname.replace(/(.)\/+$/, `$1`),
    captureGroups = match$13.slice(1),
    params = compiledParams.reduce((memo2, { paramName, isOptional }, index$4) => {
      if (paramName === `*`) {
        let splatValue = captureGroups[index$4] || ``
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, `$1`)
      }
      let value$2 = captureGroups[index$4]
      return isOptional && !value$2
        ? memo2[paramName] = void 0
        : memo2[paramName] = (value$2 || ``).replace(/%2F/g, `/`),
        memo2
    }, {})
  return { params, pathname: matchedPathname, pathnameBase, pattern: pattern$1 }
}
function compilePath(path$1, caseSensitive = !1, end$2 = !0) {
  warning(
    path$1 === `*` || !path$1.endsWith(`*`) || path$1.endsWith(`/*`),
    `Route path "${path$1}" will be treated as if it were "${
      path$1.replace(/\*$/, `/*`)
    }" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${
      path$1.replace(/\*$/, `/*`)
    }".`,
  )
  let params = [],
    regexpSource = `^`
      + path$1.replace(/\/*\*?$/, ``).replace(/^\/*/, `/`).replace(/[\\.*+^${}|()[\]]/g, `\\$&`).replace(
        /\/:([\w-]+)(\?)?/g,
        (
          _$1,
          paramName,
          isOptional,
        ) => (params.push({ paramName, isOptional: isOptional != null }), isOptional ? `/?([^\\/]+)?` : `/([^\\/]+)`),
      )
  path$1.endsWith(`*`)
    ? (params.push({ paramName: `*` }),
      regexpSource += path$1 === `*` || path$1 === `/*` ? `(.*)$` : `(?:\\/(.+)|\\/*)$`)
    : end$2
    ? regexpSource += `\\/*$`
    : path$1 !== `` && path$1 !== `/` && (regexpSource += `(?:(?=\\/|$))`)
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : `i`)
  return [matcher, params]
}
function decodePath(value$2) {
  try {
    return value$2.split(`/`).map(v$4 => decodeURIComponent(v$4).replace(/\//g, `%2F`)).join(`/`)
  } catch (error) {
    return warning(
      !1,
      `The URL path "${value$2}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`,
    ),
      value$2
  }
}
function stripBasename(pathname, basename$1) {
  if (basename$1 === `/`) return pathname
  if (!pathname.toLowerCase().startsWith(basename$1.toLowerCase())) return null
  let startIndex = basename$1.endsWith(`/`) ? basename$1.length - 1 : basename$1.length,
    nextChar = pathname.charAt(startIndex)
  return nextChar && nextChar !== `/` ? null : pathname.slice(startIndex) || `/`
}
function prependBasename({ basename: basename$1, pathname }) {
  return pathname === `/` ? basename$1 : joinPaths([basename$1, pathname])
}
function resolvePath(to, fromPathname = `/`) {
  let { pathname: toPathname, search: search$1 = ``, hash: hash$1 = `` } = typeof to == `string` ? parsePath(to) : to,
    pathname = toPathname
      ? toPathname.startsWith(`/`) ? toPathname : resolvePathname(toPathname, fromPathname)
      : fromPathname
  return { pathname, search: normalizeSearch(search$1), hash: normalizeHash(hash$1) }
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, ``).split(`/`), relativeSegments = relativePath.split(`/`)
  return relativeSegments.forEach(segment => {
    segment === `..` ? segments.length > 1 && segments.pop() : segment !== `.` && segments.push(segment)
  }),
    segments.length > 1 ? segments.join(`/`) : `/`
}
function getInvalidPathError(char, field, dest, path$1) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${
    JSON.stringify(path$1)
  }].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function getPathContributingMatches(matches) {
  return matches.filter((match$13, index$4) => index$4 === 0 || match$13.route.path && match$13.route.path.length > 0)
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches)
  return pathMatches.map((match$13, idx) => idx === pathMatches.length - 1 ? match$13.pathname : match$13.pathnameBase)
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = !1) {
  let to
  typeof toArg == `string`
    ? to = parsePath(toArg)
    : (to = { ...toArg },
      invariant$1(!to.pathname || !to.pathname.includes(`?`), getInvalidPathError(`?`, `pathname`, `search`, to)),
      invariant$1(!to.pathname || !to.pathname.includes(`#`), getInvalidPathError(`#`, `pathname`, `hash`, to)),
      invariant$1(!to.search || !to.search.includes(`#`), getInvalidPathError(`#`, `search`, `hash`, to)))
  let isEmptyPath = toArg === `` || to.pathname === ``, toPathname = isEmptyPath ? `/` : to.pathname, from
  if (toPathname == null) from = locationPathname
  else {
    let routePathnameIndex = routePathnames.length - 1
    if (!isPathRelative && toPathname.startsWith(`..`)) {
      let toSegments = toPathname.split(`/`)
      for (; toSegments[0] === `..`;) toSegments.shift(), --routePathnameIndex
      to.pathname = toSegments.join(`/`)
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : `/`
  }
  let path$1 = resolvePath(to, from),
    hasExplicitTrailingSlash = toPathname && toPathname !== `/` && toPathname.endsWith(`/`),
    hasCurrentTrailingSlash = (isEmptyPath || toPathname === `.`) && locationPathname.endsWith(`/`)
  return !path$1.pathname.endsWith(`/`) && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)
    && (path$1.pathname += `/`),
    path$1
}
var joinPaths = paths => paths.join(`/`).replace(/\/\/+/g, `/`),
  normalizePathname = pathname => pathname.replace(/\/+$/, ``).replace(/^\/*/, `/`),
  normalizeSearch = search$1 =>
    !search$1 || search$1 === `?` ? `` : search$1.startsWith(`?`) ? search$1 : `?` + search$1,
  normalizeHash = hash$1 => !hash$1 || hash$1 === `#` ? `` : hash$1.startsWith(`#`) ? hash$1 : `#` + hash$1,
  redirect = (url, init = 302) => {
    let responseInit = init
    typeof responseInit == `number`
      ? responseInit = { status: responseInit }
      : responseInit.status === void 0 && (responseInit.status = 302)
    let headers = new Headers(responseInit.headers)
    return headers.set(`Location`, url), new Response(null, { ...responseInit, headers })
  },
  ErrorResponseImpl = class {
    constructor(status$2, statusText, data2, internal = !1) {
      this.status = status$2,
        this.statusText = statusText || ``,
        this.internal = internal,
        data2 instanceof Error ? (this.data = data2.toString(), this.error = data2) : this.data = data2
    }
  }
function isRouteErrorResponse(error) {
  return error != null && typeof error.status == `number` && typeof error.statusText == `string`
    && typeof error.internal == `boolean` && `data` in error
}
var validMutationMethodsArr = [`POST`, `PUT`, `PATCH`, `DELETE`],
  validMutationMethods = new Set(validMutationMethodsArr),
  validRequestMethodsArr = [`GET`, ...validMutationMethodsArr],
  validRequestMethods = new Set(validRequestMethodsArr),
  redirectStatusCodes = new Set([301, 302, 303, 307, 308]),
  redirectPreserveMethodStatusCodes = new Set([307, 308]),
  IDLE_NAVIGATION = {
    state: `idle`,
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  IDLE_FETCHER = {
    state: `idle`,
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
  },
  IDLE_BLOCKER = { state: `unblocked`, proceed: void 0, reset: void 0, location: void 0 },
  ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  isAbsoluteUrl = url => ABSOLUTE_URL_REGEX.test(url),
  defaultMapRouteProperties = route$1 => ({ hasErrorBoundary: !!route$1.hasErrorBoundary }),
  TRANSITIONS_STORAGE_KEY = `remix-router-transitions`,
  ResetLoaderDataSymbol = Symbol(`ResetLoaderData`)
function createRouter(init) {
  let routerWindow = init.window ? init.window : typeof window < `u` ? window : void 0,
    isBrowser2 = routerWindow !== void 0 && routerWindow.document !== void 0
      && routerWindow.document.createElement !== void 0
  invariant$1(init.routes.length > 0, `You must provide a non-empty routes array to createRouter`)
  let hydrationRouteProperties2 = init.hydrationRouteProperties || [],
    mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties,
    manifest = {},
    dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest),
    inFlightDataRoutes,
    basename$1 = init.basename || `/`,
    dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware,
    future = { unstable_middleware: !1, ...init.future },
    unlistenHistory = null,
    subscribers = new Set(),
    savedScrollPositions2 = null,
    getScrollRestorationKey2 = null,
    getScrollPosition = null,
    initialScrollRestored = init.hydrationData != null,
    initialMatches = matchRoutes(dataRoutes, init.history.location, basename$1),
    initialMatchesIsFOW = !1,
    initialErrors = null,
    initialized
  if (initialMatches == null && !init.patchRoutesOnNavigation) {
    let error = getInternalRouterError(404, { pathname: init.history.location.pathname }),
      { matches, route: route$1 } = getShortCircuitMatches(dataRoutes)
    initialized = !0, initialMatches = matches, initialErrors = { [route$1.id]: error }
  } else {
    if (initialMatches && !init.hydrationData) {
      let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname)
      fogOfWar.active && (initialMatches = null)
    }
    if (initialMatches) {
      if (initialMatches.some(m$12 => m$12.route.lazy)) initialized = !1
      else if (!initialMatches.some(m$12 => m$12.route.loader)) initialized = !0
      else {
        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null,
          errors = init.hydrationData ? init.hydrationData.errors : null
        if (errors) {
          let idx = initialMatches.findIndex(m$12 => errors[m$12.route.id] !== void 0)
          initialized = initialMatches.slice(0, idx + 1).every(m$12 =>
            !shouldLoadRouteOnHydration(m$12.route, loaderData, errors)
          )
        } else initialized = initialMatches.every(m$12 => !shouldLoadRouteOnHydration(m$12.route, loaderData, errors))
      }
    } else {
      initialized = !1, initialMatches = []
      let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname)
      fogOfWar.active && fogOfWar.matches && (initialMatchesIsFOW = !0, initialMatches = fogOfWar.matches)
    }
  }
  let router$1,
    state = {
      historyAction: init.history.action,
      location: init.history.location,
      matches: initialMatches,
      initialized,
      navigation: IDLE_NAVIGATION,
      restoreScrollPosition: init.hydrationData == null ? null : !1,
      preventScrollReset: !1,
      revalidation: `idle`,
      loaderData: init.hydrationData && init.hydrationData.loaderData || {},
      actionData: init.hydrationData && init.hydrationData.actionData || null,
      errors: init.hydrationData && init.hydrationData.errors || initialErrors,
      fetchers: new Map(),
      blockers: new Map(),
    },
    pendingAction = `POP`,
    pendingPreventScrollReset = !1,
    pendingNavigationController,
    pendingViewTransitionEnabled = !1,
    appliedViewTransitions = new Map(),
    removePageHideEventListener = null,
    isUninterruptedRevalidation = !1,
    isRevalidationRequired = !1,
    cancelledFetcherLoads = new Set(),
    fetchControllers = new Map(),
    incrementingLoadId = 0,
    pendingNavigationLoadId = -1,
    fetchReloadIds = new Map(),
    fetchRedirectIds = new Set(),
    fetchLoadMatches = new Map(),
    activeFetchers = new Map(),
    fetchersQueuedForDeletion = new Set(),
    blockerFunctions = new Map(),
    unblockBlockerHistoryUpdate,
    pendingRevalidationDfd = null
  function initialize() {
    if (
      unlistenHistory = init.history.listen(({ action: historyAction, location, delta }) => {
        if (unblockBlockerHistoryUpdate) {
          unblockBlockerHistoryUpdate(), unblockBlockerHistoryUpdate = void 0
          return
        }
        warning(
          blockerFunctions.size === 0 || delta != null,
          'You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.',
        )
        let blockerKey = shouldBlockNavigation({
          currentLocation: state.location,
          nextLocation: location,
          historyAction,
        })
        if (blockerKey && delta != null) {
          let nextHistoryUpdatePromise = new Promise(resolve => {
            unblockBlockerHistoryUpdate = resolve
          })
          init.history.go(delta * -1),
            updateBlocker(blockerKey, {
              state: `blocked`,
              location,
              proceed() {
                updateBlocker(blockerKey, { state: `proceeding`, proceed: void 0, reset: void 0, location }),
                  nextHistoryUpdatePromise.then(() => init.history.go(delta))
              },
              reset() {
                let blockers = new Map(state.blockers)
                blockers.set(blockerKey, IDLE_BLOCKER), updateState({ blockers })
              },
            })
          return
        }
        return startNavigation(historyAction, location)
      }), isBrowser2
    ) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions)
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions)
      routerWindow.addEventListener(`pagehide`, _saveAppliedTransitions),
        removePageHideEventListener = () => routerWindow.removeEventListener(`pagehide`, _saveAppliedTransitions)
    }
    return state.initialized || startNavigation(`POP`, state.location, { initialHydration: !0 }), router$1
  }
  function dispose() {
    unlistenHistory && unlistenHistory(),
      removePageHideEventListener && removePageHideEventListener(),
      subscribers.clear(),
      pendingNavigationController && pendingNavigationController.abort(),
      state.fetchers.forEach((_$1, key$1) => deleteFetcher(key$1)),
      state.blockers.forEach((_$1, key$1) => deleteBlocker(key$1))
  }
  function subscribe$1(fn) {
    return subscribers.add(fn), () => subscribers.delete(fn)
  }
  function updateState(newState, opts = {}) {
    newState.matches &&= newState.matches.map(m$12 => {
      let route$1 = manifest[m$12.route.id], matchRoute = m$12.route
      return matchRoute.element !== route$1.element || matchRoute.errorElement !== route$1.errorElement
          || matchRoute.hydrateFallbackElement !== route$1.hydrateFallbackElement
        ? { ...m$12, route: route$1 }
        : m$12
    }), state = { ...state, ...newState }
    let unmountedFetchers = [], mountedFetchers = []
    state.fetchers.forEach((fetcher, key$1) => {
      fetcher.state === `idle`
        && (fetchersQueuedForDeletion.has(key$1) ? unmountedFetchers.push(key$1) : mountedFetchers.push(key$1))
    }),
      fetchersQueuedForDeletion.forEach(key$1 => {
        !state.fetchers.has(key$1) && !fetchControllers.has(key$1) && unmountedFetchers.push(key$1)
      }),
      [...subscribers].forEach(subscriber =>
        subscriber(state, {
          deletedFetchers: unmountedFetchers,
          viewTransitionOpts: opts.viewTransitionOpts,
          flushSync: opts.flushSync === !0,
        })
      ),
      unmountedFetchers.forEach(key$1 => deleteFetcher(key$1)),
      mountedFetchers.forEach(key$1 => state.fetchers.delete(key$1))
  }
  function completeNavigation(location, newState, { flushSync } = {}) {
    let isActionReload = state.actionData != null && state.navigation.formMethod != null
        && isMutationMethod(state.navigation.formMethod) && state.navigation.state === `loading`
        && location.state?._isRedirect !== !0,
      actionData
    actionData = newState.actionData
      ? Object.keys(newState.actionData).length > 0 ? newState.actionData : null
      : isActionReload
      ? state.actionData
      : null
    let loaderData = newState.loaderData
        ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors)
        : state.loaderData,
      blockers = state.blockers
    blockers.size > 0 && (blockers = new Map(blockers), blockers.forEach((_$1, k$1) => blockers.set(k$1, IDLE_BLOCKER)))
    let restoreScrollPosition = isUninterruptedRevalidation
        ? !1
        : getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset = pendingPreventScrollReset === !0
        || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod)
          && location.state?._isRedirect !== !0
    inFlightDataRoutes && (dataRoutes = inFlightDataRoutes, inFlightDataRoutes = void 0),
      isUninterruptedRevalidation || pendingAction === `POP`
      || (pendingAction === `PUSH`
        ? init.history.push(location, location.state)
        : pendingAction === `REPLACE` && init.history.replace(location, location.state))
    let viewTransitionOpts
    if (pendingAction === `POP`) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname)
      priorPaths && priorPaths.has(location.pathname)
        ? viewTransitionOpts = { currentLocation: state.location, nextLocation: location }
        : appliedViewTransitions.has(location.pathname)
          && (viewTransitionOpts = { currentLocation: location, nextLocation: state.location })
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname)
      toPaths
        ? toPaths.add(location.pathname)
        : (toPaths = new Set([location.pathname]), appliedViewTransitions.set(state.location.pathname, toPaths)),
        viewTransitionOpts = { currentLocation: state.location, nextLocation: location }
    }
    updateState({
      ...newState,
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: !0,
      navigation: IDLE_NAVIGATION,
      revalidation: `idle`,
      restoreScrollPosition,
      preventScrollReset,
      blockers,
    }, { viewTransitionOpts, flushSync: flushSync === !0 }),
      pendingAction = `POP`,
      pendingPreventScrollReset = !1,
      pendingViewTransitionEnabled = !1,
      isUninterruptedRevalidation = !1,
      isRevalidationRequired = !1,
      pendingRevalidationDfd?.resolve(),
      pendingRevalidationDfd = null
  }
  async function navigate(to, opts) {
    if (typeof to == `number`) {
      init.history.go(to)
      return
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename$1, to, opts?.fromRouteId, opts?.relative),
      { path: path$1, submission, error } = normalizeNavigateOptions(!1, normalizedPath, opts),
      currentLocation = state.location,
      nextLocation = createLocation(state.location, path$1, opts && opts.state)
    nextLocation = { ...nextLocation, ...init.history.encodeLocation(nextLocation) }
    let userReplace = opts && opts.replace != null ? opts.replace : void 0, historyAction = `PUSH`
    userReplace === !0
      ? historyAction = `REPLACE`
      : userReplace === !1
        || submission != null && isMutationMethod(submission.formMethod)
          && submission.formAction === state.location.pathname + state.location.search && (historyAction = `REPLACE`)
    let preventScrollReset = opts && `preventScrollReset` in opts ? opts.preventScrollReset === !0 : void 0,
      flushSync = (opts && opts.flushSync) === !0,
      blockerKey = shouldBlockNavigation({ currentLocation, nextLocation, historyAction })
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: `blocked`,
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, { state: `proceeding`, proceed: void 0, reset: void 0, location: nextLocation }),
            navigate(to, opts)
        },
        reset() {
          let blockers = new Map(state.blockers)
          blockers.set(blockerKey, IDLE_BLOCKER), updateState({ blockers })
        },
      })
      return
    }
    await startNavigation(historyAction, nextLocation, {
      submission,
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.viewTransition,
      flushSync,
    })
  }
  function revalidate() {
    pendingRevalidationDfd ||= createDeferred(), interruptActiveLoads(), updateState({ revalidation: `loading` })
    let promise$2 = pendingRevalidationDfd.promise
    return state.navigation.state === `submitting`
      ? promise$2
      : state.navigation.state === `idle`
      ? (startNavigation(state.historyAction, state.location, { startUninterruptedRevalidation: !0 }), promise$2)
      : (startNavigation(pendingAction || state.historyAction, state.navigation.location, {
        overrideNavigation: state.navigation,
        enableViewTransition: pendingViewTransitionEnabled === !0,
      }),
        promise$2)
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort(),
      pendingNavigationController = null,
      pendingAction = historyAction,
      isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === !0,
      saveScrollPosition(state.location, state.matches),
      pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0,
      pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === !0
    let routesToUse = inFlightDataRoutes || dataRoutes,
      loadingNavigation = opts && opts.overrideNavigation,
      matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW
        ? state.matches
        : matchRoutes(routesToUse, location, basename$1),
      flushSync = (opts && opts.flushSync) === !0
    if (
      matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location)
      && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))
    ) {
      completeNavigation(location, { matches }, { flushSync })
      return
    }
    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname)
    if (fogOfWar.active && fogOfWar.matches && (matches = fogOfWar.matches), !matches) {
      let { error, notFoundMatches, route: route$1 } = handleNavigational404(location.pathname)
      completeNavigation(location, { matches: notFoundMatches, loaderData: {}, errors: { [route$1.id]: error } }, {
        flushSync,
      })
      return
    }
    pendingNavigationController = new AbortController()
    let request$1 = createClientSideRequest(
        init.history,
        location,
        pendingNavigationController.signal,
        opts && opts.submission,
      ),
      scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0,
      ),
      pendingActionResult
    if (opts && opts.pendingError) {
      pendingActionResult = [findNearestBoundary(matches).route.id, { type: `error`, error: opts.pendingError }]
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(
        request$1,
        location,
        opts.submission,
        matches,
        scopedContext,
        fogOfWar.active,
        opts && opts.initialHydration === !0,
        { replace: opts.replace, flushSync },
      )
      if (actionResult.shortCircuited) return
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null,
            completeNavigation(location, {
              matches: actionResult.matches,
              loaderData: {},
              errors: { [routeId]: result.error },
            })
          return
        }
      }
      matches = actionResult.matches || matches,
        pendingActionResult = actionResult.pendingActionResult,
        loadingNavigation = getLoadingNavigation(location, opts.submission),
        flushSync = !1,
        fogOfWar.active = !1,
        request$1 = createClientSideRequest(init.history, request$1.url, request$1.signal)
    }
    let { shortCircuited, matches: updatedMatches, loaderData, errors } = await handleLoaders(
      request$1,
      location,
      matches,
      scopedContext,
      fogOfWar.active,
      loadingNavigation,
      opts && opts.submission,
      opts && opts.fetcherSubmission,
      opts && opts.replace,
      opts && opts.initialHydration === !0,
      flushSync,
      pendingActionResult,
    )
    shortCircuited
      || (pendingNavigationController = null,
        completeNavigation(location, {
          matches: updatedMatches || matches,
          ...getActionDataForCommit(pendingActionResult),
          loaderData,
          errors,
        }))
  }
  async function handleAction(
    request$1,
    location,
    submission,
    matches,
    scopedContext,
    isFogOfWar,
    initialHydration,
    opts = {},
  ) {
    interruptActiveLoads()
    let navigation = getSubmittingNavigation(location, submission)
    if (updateState({ navigation }, { flushSync: opts.flushSync === !0 }), isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, location.pathname, request$1.signal)
      if (discoverResult.type === `aborted`) return { shortCircuited: !0 }
      if (discoverResult.type === `error`) {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [boundaryId, { type: `error`, error: discoverResult.error }],
        }
      } else if (discoverResult.matches) matches = discoverResult.matches
      else {
        let { notFoundMatches, error, route: route$1 } = handleNavigational404(location.pathname)
        return { matches: notFoundMatches, pendingActionResult: [route$1.id, { type: `error`, error }] }
      }
    }
    let result, actionMatch = getTargetMatch(matches, location)
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: `error`,
        error: getInternalRouterError(405, {
          method: request$1.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id,
        }),
      }
    } else {
      let dsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          request$1,
          matches,
          actionMatch,
          initialHydration ? [] : hydrationRouteProperties2,
          scopedContext,
        ),
        results = await callDataStrategy(request$1, dsMatches, scopedContext, null)
      if (result = results[actionMatch.route.id], !result) {
        for (let match$13 of matches) {
          if (results[match$13.route.id]) {
            result = results[match$13.route.id]
            break
          }
        }
      }
      if (request$1.signal.aborted) return { shortCircuited: !0 }
    }
    if (isRedirectResult(result)) {
      let replace2
      if (opts && opts.replace != null) replace2 = opts.replace
      else {
        let location2 = normalizeRedirectLocation(
          result.response.headers.get(`Location`),
          new URL(request$1.url),
          basename$1,
        )
        replace2 = location2 === state.location.pathname + state.location.search
      }
      return await startRedirectNavigation(request$1, result, !0, { submission, replace: replace2 }),
        { shortCircuited: !0 }
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id)
      return (opts && opts.replace) !== !0 && (pendingAction = `PUSH`),
        { matches, pendingActionResult: [boundaryMatch.route.id, result, actionMatch.route.id] }
    }
    return { matches, pendingActionResult: [actionMatch.route.id, result] }
  }
  async function handleLoaders(
    request$1,
    location,
    matches,
    scopedContext,
    isFogOfWar,
    overrideNavigation,
    submission,
    fetcherSubmission,
    replace2,
    initialHydration,
    flushSync,
    pendingActionResult,
  ) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission),
      activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation),
      shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult)
        updateState({ navigation: loadingNavigation, ...actionData === void 0 ? {} : { actionData } }, { flushSync })
      }
      let discoverResult = await discoverRoutes(matches, location.pathname, request$1.signal)
      if (discoverResult.type === `aborted`) return { shortCircuited: !0 }
      if (discoverResult.type === `error`) {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: { [boundaryId]: discoverResult.error },
        }
      } else if (discoverResult.matches) matches = discoverResult.matches
      else {
        let { error, notFoundMatches, route: route$1 } = handleNavigational404(location.pathname)
        return { matches: notFoundMatches, loaderData: {}, errors: { [route$1.id]: error } }
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes,
      { dsMatches, revalidatingFetchers } = getMatchesToLoad(
        request$1,
        scopedContext,
        mapRouteProperties2,
        manifest,
        init.history,
        state,
        matches,
        activeSubmission,
        location,
        initialHydration ? [] : hydrationRouteProperties2,
        initialHydration === !0,
        isRevalidationRequired,
        cancelledFetcherLoads,
        fetchersQueuedForDeletion,
        fetchLoadMatches,
        fetchRedirectIds,
        routesToUse,
        basename$1,
        init.patchRoutesOnNavigation != null,
        pendingActionResult,
      )
    if (
      pendingNavigationLoadId = ++incrementingLoadId,
        !init.dataStrategy && !dsMatches.some(m$12 => m$12.shouldLoad) && revalidatingFetchers.length === 0
    ) {
      let updatedFetchers2 = markFetchRedirectsDone()
      return completeNavigation(location, {
        matches,
        loaderData: {},
        errors: pendingActionResult && isErrorResult(pendingActionResult[1])
          ? { [pendingActionResult[0]]: pendingActionResult[1].error }
          : null,
        ...getActionDataForCommit(pendingActionResult),
        ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {},
      }, { flushSync }),
        { shortCircuited: !0 }
    }
    if (shouldUpdateNavigationState) {
      let updates = {}
      if (!isFogOfWar) {
        updates.navigation = loadingNavigation
        let actionData = getUpdatedActionData(pendingActionResult)
        actionData !== void 0 && (updates.actionData = actionData)
      }
      revalidatingFetchers.length > 0 && (updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers)),
        updateState(updates, { flushSync })
    }
    revalidatingFetchers.forEach(rf => {
      abortFetcher(rf.key), rf.controller && fetchControllers.set(rf.key, rf.controller)
    })
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f$14 => abortFetcher(f$14.key))
    pendingNavigationController
      && pendingNavigationController.signal.addEventListener(`abort`, abortPendingFetchRevalidations)
    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
      dsMatches,
      revalidatingFetchers,
      request$1,
      scopedContext,
    )
    if (request$1.signal.aborted) return { shortCircuited: !0 }
    pendingNavigationController
    && pendingNavigationController.signal.removeEventListener(`abort`, abortPendingFetchRevalidations),
      revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key))
    let redirect2 = findRedirect(loaderResults)
    if (redirect2) {
      return await startRedirectNavigation(request$1, redirect2.result, !0, { replace: replace2 }),
        { shortCircuited: !0 }
    }
    if (redirect2 = findRedirect(fetcherResults), redirect2) {
      return fetchRedirectIds.add(redirect2.key),
        await startRedirectNavigation(request$1, redirect2.result, !0, { replace: replace2 }),
        { shortCircuited: !0 }
    }
    let { loaderData, errors } = processLoaderData(
      state,
      matches,
      loaderResults,
      pendingActionResult,
      revalidatingFetchers,
      fetcherResults,
    )
    initialHydration && state.errors && (errors = { ...state.errors, ...errors })
    let updatedFetchers = markFetchRedirectsDone(),
      didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId),
      shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0
    return { matches, loaderData, errors, ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {} }
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
      return { [pendingActionResult[0]]: pendingActionResult[1].data }
    }
    if (state.actionData) return Object.keys(state.actionData).length === 0 ? null : state.actionData
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    return revalidatingFetchers.forEach(rf => {
      let fetcher = state.fetchers.get(rf.key),
        revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0)
      state.fetchers.set(rf.key, revalidatingFetcher)
    }),
      new Map(state.fetchers)
  }
  async function fetch2(key$1, routeId, href, opts) {
    abortFetcher(key$1)
    let flushSync = (opts && opts.flushSync) === !0,
      routesToUse = inFlightDataRoutes || dataRoutes,
      normalizedPath = normalizeTo(state.location, state.matches, basename$1, href, routeId, opts?.relative),
      matches = matchRoutes(routesToUse, normalizedPath, basename$1),
      fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath)
    if (fogOfWar.active && fogOfWar.matches && (matches = fogOfWar.matches), !matches) {
      setFetcherError(key$1, routeId, getInternalRouterError(404, { pathname: normalizedPath }), { flushSync })
      return
    }
    let { path: path$1, submission, error } = normalizeNavigateOptions(!0, normalizedPath, opts)
    if (error) {
      setFetcherError(key$1, routeId, error, { flushSync })
      return
    }
    let scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0,
      ),
      preventScrollReset = (opts && opts.preventScrollReset) === !0
    if (submission && isMutationMethod(submission.formMethod)) {
      await handleFetcherAction(
        key$1,
        routeId,
        path$1,
        matches,
        scopedContext,
        fogOfWar.active,
        flushSync,
        preventScrollReset,
        submission,
      )
      return
    }
    fetchLoadMatches.set(key$1, { routeId, path: path$1 }),
      await handleFetcherLoader(
        key$1,
        routeId,
        path$1,
        matches,
        scopedContext,
        fogOfWar.active,
        flushSync,
        preventScrollReset,
        submission,
      )
  }
  async function handleFetcherAction(
    key$1,
    routeId,
    path$1,
    requestMatches,
    scopedContext,
    isFogOfWar,
    flushSync,
    preventScrollReset,
    submission,
  ) {
    interruptActiveLoads(), fetchLoadMatches.delete(key$1)
    let existingFetcher = state.fetchers.get(key$1)
    updateFetcherState(key$1, getSubmittingFetcher(submission, existingFetcher), { flushSync })
    let abortController = new AbortController(),
      fetchRequest = createClientSideRequest(init.history, path$1, abortController.signal, submission)
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(
        requestMatches,
        new URL(fetchRequest.url).pathname,
        fetchRequest.signal,
        key$1,
      )
      if (discoverResult.type === `aborted`) return
      if (discoverResult.type === `error`) {
        setFetcherError(key$1, routeId, discoverResult.error, { flushSync })
        return
      } else if (discoverResult.matches) requestMatches = discoverResult.matches
      else {
        setFetcherError(key$1, routeId, getInternalRouterError(404, { pathname: path$1 }), { flushSync })
        return
      }
    }
    let match$13 = getTargetMatch(requestMatches, path$1)
    if (!match$13.route.action && !match$13.route.lazy) {
      let error = getInternalRouterError(405, { method: submission.formMethod, pathname: path$1, routeId })
      setFetcherError(key$1, routeId, error, { flushSync })
      return
    }
    fetchControllers.set(key$1, abortController)
    let originatingLoadId = incrementingLoadId,
      fetchMatches = getTargetedDataStrategyMatches(
        mapRouteProperties2,
        manifest,
        fetchRequest,
        requestMatches,
        match$13,
        hydrationRouteProperties2,
        scopedContext,
      ),
      actionResults = await callDataStrategy(fetchRequest, fetchMatches, scopedContext, key$1),
      actionResult = actionResults[match$13.route.id]
    if (fetchRequest.signal.aborted) {
      fetchControllers.get(key$1) === abortController && fetchControllers.delete(key$1)
      return
    }
    if (fetchersQueuedForDeletion.has(key$1)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key$1, getDoneFetcher(void 0))
        return
      }
    } else {
      if (isRedirectResult(actionResult)) {
        if (fetchControllers.delete(key$1), pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key$1, getDoneFetcher(void 0))
          return
        } else {return fetchRedirectIds.add(key$1),
            updateFetcherState(key$1, getLoadingFetcher(submission)),
            startRedirectNavigation(fetchRequest, actionResult, !1, {
              fetcherSubmission: submission,
              preventScrollReset,
            })}
      }
      if (isErrorResult(actionResult)) {
        setFetcherError(key$1, routeId, actionResult.error)
        return
      }
    }
    let nextLocation = state.navigation.location || state.location,
      revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal),
      routesToUse = inFlightDataRoutes || dataRoutes,
      matches = state.navigation.state === `idle`
        ? state.matches
        : matchRoutes(routesToUse, state.navigation.location, basename$1)
    invariant$1(matches, `Didn't find any matches after fetcher action`)
    let loadId = ++incrementingLoadId
    fetchReloadIds.set(key$1, loadId)
    let loadFetcher = getLoadingFetcher(submission, actionResult.data)
    state.fetchers.set(key$1, loadFetcher)
    let { dsMatches, revalidatingFetchers } = getMatchesToLoad(
      revalidationRequest,
      scopedContext,
      mapRouteProperties2,
      manifest,
      init.history,
      state,
      matches,
      submission,
      nextLocation,
      hydrationRouteProperties2,
      !1,
      isRevalidationRequired,
      cancelledFetcherLoads,
      fetchersQueuedForDeletion,
      fetchLoadMatches,
      fetchRedirectIds,
      routesToUse,
      basename$1,
      init.patchRoutesOnNavigation != null,
      [match$13.route.id, actionResult],
    )
    revalidatingFetchers.filter(rf => rf.key !== key$1).forEach(rf => {
      let staleKey = rf.key,
        existingFetcher2 = state.fetchers.get(staleKey),
        revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0)
      state.fetchers.set(staleKey, revalidatingFetcher),
        abortFetcher(staleKey),
        rf.controller && fetchControllers.set(staleKey, rf.controller)
    }), updateState({ fetchers: new Map(state.fetchers) })
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key))
    abortController.signal.addEventListener(`abort`, abortPendingFetchRevalidations)
    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
      dsMatches,
      revalidatingFetchers,
      revalidationRequest,
      scopedContext,
    )
    if (abortController.signal.aborted) return
    if (
      abortController.signal.removeEventListener(`abort`, abortPendingFetchRevalidations),
        fetchReloadIds.delete(key$1),
        fetchControllers.delete(key$1),
        revalidatingFetchers.forEach(r$26 => fetchControllers.delete(r$26.key)),
        state.fetchers.has(key$1)
    ) {
      let doneFetcher = getDoneFetcher(actionResult.data)
      state.fetchers.set(key$1, doneFetcher)
    }
    let redirect2 = findRedirect(loaderResults)
    if (redirect2) return startRedirectNavigation(revalidationRequest, redirect2.result, !1, { preventScrollReset })
    if (redirect2 = findRedirect(fetcherResults), redirect2) {
      return fetchRedirectIds.add(redirect2.key),
        startRedirectNavigation(revalidationRequest, redirect2.result, !1, { preventScrollReset })
    }
    let { loaderData, errors } = processLoaderData(
      state,
      matches,
      loaderResults,
      void 0,
      revalidatingFetchers,
      fetcherResults,
    )
    abortStaleFetchLoads(loadId),
      state.navigation.state === `loading` && loadId > pendingNavigationLoadId
        ? (invariant$1(pendingAction, `Expected pending action`),
          pendingNavigationController && pendingNavigationController.abort(),
          completeNavigation(state.navigation.location, {
            matches,
            loaderData,
            errors,
            fetchers: new Map(state.fetchers),
          }))
        : (updateState({
          errors,
          loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
          fetchers: new Map(state.fetchers),
        }),
          isRevalidationRequired = !1)
  }
  async function handleFetcherLoader(
    key$1,
    routeId,
    path$1,
    matches,
    scopedContext,
    isFogOfWar,
    flushSync,
    preventScrollReset,
    submission,
  ) {
    let existingFetcher = state.fetchers.get(key$1)
    updateFetcherState(key$1, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
      flushSync,
    })
    let abortController = new AbortController(),
      fetchRequest = createClientSideRequest(init.history, path$1, abortController.signal)
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key$1)
      if (discoverResult.type === `aborted`) return
      if (discoverResult.type === `error`) {
        setFetcherError(key$1, routeId, discoverResult.error, { flushSync })
        return
      } else if (discoverResult.matches) matches = discoverResult.matches
      else {
        setFetcherError(key$1, routeId, getInternalRouterError(404, { pathname: path$1 }), { flushSync })
        return
      }
    }
    let match$13 = getTargetMatch(matches, path$1)
    fetchControllers.set(key$1, abortController)
    let originatingLoadId = incrementingLoadId,
      dsMatches = getTargetedDataStrategyMatches(
        mapRouteProperties2,
        manifest,
        fetchRequest,
        matches,
        match$13,
        hydrationRouteProperties2,
        scopedContext,
      ),
      results = await callDataStrategy(fetchRequest, dsMatches, scopedContext, key$1),
      result = results[match$13.route.id]
    if (
      fetchControllers.get(key$1) === abortController && fetchControllers.delete(key$1), !fetchRequest.signal.aborted
    ) {
      if (fetchersQueuedForDeletion.has(key$1)) {
        updateFetcherState(key$1, getDoneFetcher(void 0))
        return
      }
      if (isRedirectResult(result)) {
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key$1, getDoneFetcher(void 0))
          return
        } else {
          fetchRedirectIds.add(key$1), await startRedirectNavigation(fetchRequest, result, !1, { preventScrollReset })
          return
        }
      }
      if (isErrorResult(result)) {
        setFetcherError(key$1, routeId, result.error)
        return
      }
      updateFetcherState(key$1, getDoneFetcher(result.data))
    }
  }
  async function startRedirectNavigation(
    request$1,
    redirect2,
    isNavigation,
    { submission, fetcherSubmission, preventScrollReset, replace: replace2 } = {},
  ) {
    redirect2.response.headers.has(`X-Remix-Revalidate`) && (isRevalidationRequired = !0)
    let location = redirect2.response.headers.get(`Location`)
    invariant$1(location, `Expected a Location header on the redirect Response`),
      location = normalizeRedirectLocation(location, new URL(request$1.url), basename$1)
    let redirectLocation = createLocation(state.location, location, { _isRedirect: !0 })
    if (isBrowser2) {
      let isDocumentReload = !1
      if (redirect2.response.headers.has(`X-Remix-Reload-Document`)) isDocumentReload = !0
      else if (isAbsoluteUrl(location)) {
        let url = createBrowserURLImpl(location, !0)
        isDocumentReload = url.origin !== routerWindow.location.origin
          || stripBasename(url.pathname, basename$1) == null
      }
      if (isDocumentReload) {
        replace2 ? routerWindow.location.replace(location) : routerWindow.location.assign(location)
        return
      }
    }
    pendingNavigationController = null
    let redirectNavigationType = replace2 === !0 || redirect2.response.headers.has(`X-Remix-Replace`)
        ? `REPLACE`
        : `PUSH`,
      { formMethod, formAction, formEncType } = state.navigation
    !submission && !fetcherSubmission && formMethod && formAction && formEncType
      && (submission = getSubmissionFromNavigation(state.navigation))
    let activeSubmission = submission || fetcherSubmission
    if (
      redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission
      && isMutationMethod(activeSubmission.formMethod)
    ) {
      await startNavigation(redirectNavigationType, redirectLocation, {
        submission: { ...activeSubmission, formAction: location },
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0,
      })
    } else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission)
      await startNavigation(redirectNavigationType, redirectLocation, {
        overrideNavigation,
        fetcherSubmission,
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0,
      })
    }
  }
  async function callDataStrategy(request$1, matches, scopedContext, fetcherKey) {
    let results, dataResults = {}
    try {
      results = await callDataStrategyImpl(dataStrategyImpl, request$1, matches, fetcherKey, scopedContext, !1)
    } catch (e$26) {
      return matches.filter(m$12 => m$12.shouldLoad).forEach(m$12 => {
        dataResults[m$12.route.id] = { type: `error`, error: e$26 }
      }),
        dataResults
    }
    if (request$1.signal.aborted) return dataResults
    for (let [routeId, result] of Object.entries(results)) {
      if (isRedirectDataStrategyResult(result)) {
        let response = result.result
        dataResults[routeId] = {
          type: `redirect`,
          response: normalizeRelativeRoutingRedirectResponse(response, request$1, routeId, matches, basename$1),
        }
      } else dataResults[routeId] = await convertDataStrategyResultToDataResult(result)
    }
    return dataResults
  }
  async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request$1, scopedContext) {
    let loaderResultsPromise = callDataStrategy(request$1, matches, scopedContext, null),
      fetcherResultsPromise = Promise.all(fetchersToLoad.map(async f$14 => {
        if (f$14.matches && f$14.match && f$14.request && f$14.controller) {
          let results = await callDataStrategy(f$14.request, f$14.matches, scopedContext, f$14.key),
            result = results[f$14.match.route.id]
          return { [f$14.key]: result }
        } else {return Promise.resolve({
            [f$14.key]: { type: `error`, error: getInternalRouterError(404, { pathname: f$14.path }) },
          })}
      })),
      loaderResults = await loaderResultsPromise,
      fetcherResults = (await fetcherResultsPromise).reduce((acc, r$26) => Object.assign(acc, r$26), {})
    return { loaderResults, fetcherResults }
  }
  function interruptActiveLoads() {
    isRevalidationRequired = !0,
      fetchLoadMatches.forEach((_$1, key$1) => {
        fetchControllers.has(key$1) && cancelledFetcherLoads.add(key$1), abortFetcher(key$1)
      })
  }
  function updateFetcherState(key$1, fetcher, opts = {}) {
    state.fetchers.set(key$1, fetcher),
      updateState({ fetchers: new Map(state.fetchers) }, { flushSync: (opts && opts.flushSync) === !0 })
  }
  function setFetcherError(key$1, routeId, error, opts = {}) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId)
    deleteFetcher(key$1),
      updateState({ errors: { [boundaryMatch.route.id]: error }, fetchers: new Map(state.fetchers) }, {
        flushSync: (opts && opts.flushSync) === !0,
      })
  }
  function getFetcher(key$1) {
    return activeFetchers.set(key$1, (activeFetchers.get(key$1) || 0) + 1),
      fetchersQueuedForDeletion.has(key$1) && fetchersQueuedForDeletion.delete(key$1),
      state.fetchers.get(key$1) || IDLE_FETCHER
  }
  function deleteFetcher(key$1) {
    let fetcher = state.fetchers.get(key$1)
    fetchControllers.has(key$1) && !(fetcher && fetcher.state === `loading` && fetchReloadIds.has(key$1))
    && abortFetcher(key$1),
      fetchLoadMatches.delete(key$1),
      fetchReloadIds.delete(key$1),
      fetchRedirectIds.delete(key$1),
      fetchersQueuedForDeletion.delete(key$1),
      cancelledFetcherLoads.delete(key$1),
      state.fetchers.delete(key$1)
  }
  function queueFetcherForDeletion(key$1) {
    let count$2 = (activeFetchers.get(key$1) || 0) - 1
    count$2 <= 0
      ? (activeFetchers.delete(key$1), fetchersQueuedForDeletion.add(key$1))
      : activeFetchers.set(key$1, count$2), updateState({ fetchers: new Map(state.fetchers) })
  }
  function abortFetcher(key$1) {
    let controller = fetchControllers.get(key$1)
    controller && (controller.abort(), fetchControllers.delete(key$1))
  }
  function markFetchersDone(keys$6) {
    for (let key$1 of keys$6) {
      let fetcher = getFetcher(key$1), doneFetcher = getDoneFetcher(fetcher.data)
      state.fetchers.set(key$1, doneFetcher)
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [], updatedFetchers = !1
    for (let key$1 of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key$1)
      invariant$1(fetcher, `Expected fetcher: ${key$1}`),
        fetcher.state === `loading` && (fetchRedirectIds.delete(key$1), doneKeys.push(key$1), updatedFetchers = !0)
    }
    return markFetchersDone(doneKeys), updatedFetchers
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = []
    for (let [key$1, id$2] of fetchReloadIds) {
      if (id$2 < landedId) {
        let fetcher = state.fetchers.get(key$1)
        invariant$1(fetcher, `Expected fetcher: ${key$1}`),
          fetcher.state === `loading` && (abortFetcher(key$1), fetchReloadIds.delete(key$1), yeetedKeys.push(key$1))
      }
    }
    return markFetchersDone(yeetedKeys), yeetedKeys.length > 0
  }
  function getBlocker(key$1, fn) {
    let blocker = state.blockers.get(key$1) || IDLE_BLOCKER
    return blockerFunctions.get(key$1) !== fn && blockerFunctions.set(key$1, fn), blocker
  }
  function deleteBlocker(key$1) {
    state.blockers.delete(key$1), blockerFunctions.delete(key$1)
  }
  function updateBlocker(key$1, newBlocker) {
    let blocker = state.blockers.get(key$1) || IDLE_BLOCKER
    invariant$1(
      blocker.state === `unblocked` && newBlocker.state === `blocked`
        || blocker.state === `blocked` && newBlocker.state === `blocked`
        || blocker.state === `blocked` && newBlocker.state === `proceeding`
        || blocker.state === `blocked` && newBlocker.state === `unblocked`
        || blocker.state === `proceeding` && newBlocker.state === `unblocked`,
      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`,
    )
    let blockers = new Map(state.blockers)
    blockers.set(key$1, newBlocker), updateState({ blockers })
  }
  function shouldBlockNavigation({ currentLocation, nextLocation, historyAction }) {
    if (blockerFunctions.size === 0) return
    blockerFunctions.size > 1 && warning(!1, `A router only supports one blocker at a time`)
    let entries$2 = Array.from(blockerFunctions.entries()),
      [blockerKey, blockerFunction] = entries$2[entries$2.length - 1],
      blocker = state.blockers.get(blockerKey)
    if (
      !(blocker && blocker.state === `proceeding`) && blockerFunction({ currentLocation, nextLocation, historyAction })
    ) return blockerKey
  }
  function handleNavigational404(pathname) {
    let error = getInternalRouterError(404, { pathname }),
      routesToUse = inFlightDataRoutes || dataRoutes,
      { matches, route: route$1 } = getShortCircuitMatches(routesToUse)
    return { notFoundMatches: matches, route: route$1, error }
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    if (
      savedScrollPositions2 = positions,
        getScrollPosition = getPosition,
        getScrollRestorationKey2 = getKey || null,
        !initialScrollRestored && state.navigation === IDLE_NAVIGATION
    ) {
      initialScrollRestored = !0
      let y$3 = getSavedScrollPosition(state.location, state.matches)
      y$3 != null && updateState({ restoreScrollPosition: y$3 })
    }
    return () => {
      savedScrollPositions2 = null, getScrollPosition = null, getScrollRestorationKey2 = null
    }
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey2) {
      let key$1 = getScrollRestorationKey2(
        location,
        matches.map(m$12 => convertRouteMatchToUiMatch(m$12, state.loaderData)),
      )
      return key$1 || location.key
    }
    return location.key
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions2 && getScrollPosition) {
      let key$1 = getScrollKey(location, matches)
      savedScrollPositions2[key$1] = getScrollPosition()
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions2) {
      let key$1 = getScrollKey(location, matches), y$3 = savedScrollPositions2[key$1]
      if (typeof y$3 == `number`) return y$3
    }
    return null
  }
  function checkFogOfWar(matches, routesToUse, pathname) {
    if (init.patchRoutesOnNavigation) {
      if (matches) {
        if (Object.keys(matches[0].params).length > 0) {
          let partialMatches = matchRoutesImpl(routesToUse, pathname, basename$1, !0)
          return { active: !0, matches: partialMatches }
        }
      } else {
        let fogMatches = matchRoutesImpl(routesToUse, pathname, basename$1, !0)
        return { active: !0, matches: fogMatches || [] }
      }
    }
    return { active: !1, matches: null }
  }
  async function discoverRoutes(matches, pathname, signal, fetcherKey) {
    if (!init.patchRoutesOnNavigation) return { type: `success`, matches }
    let partialMatches = matches
    for (;;) {
      let isNonHMR = inFlightDataRoutes == null,
        routesToUse = inFlightDataRoutes || dataRoutes,
        localManifest = manifest
      try {
        await init.patchRoutesOnNavigation({
          signal,
          path: pathname,
          matches: partialMatches,
          fetcherKey,
          patch: (routeId, children$3) => {
            signal.aborted || patchRoutesImpl(routeId, children$3, routesToUse, localManifest, mapRouteProperties2, !1)
          },
        })
      } catch (e$26) {
        return { type: `error`, error: e$26, partialMatches }
      } finally {
        isNonHMR && !signal.aborted && (dataRoutes = [...dataRoutes])
      }
      if (signal.aborted) return { type: `aborted` }
      let newMatches = matchRoutes(routesToUse, pathname, basename$1)
      if (newMatches) return { type: `success`, matches: newMatches }
      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename$1, !0)
      if (
        !newPartialMatches
        || partialMatches.length === newPartialMatches.length
          && partialMatches.every((m$12, i$14) => m$12.route.id === newPartialMatches[i$14].route.id)
      ) return { type: `success`, matches: null }
      partialMatches = newPartialMatches
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {}, inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest)
  }
  function patchRoutes(routeId, children$3, unstable_allowElementMutations = !1) {
    let isNonHMR = inFlightDataRoutes == null, routesToUse = inFlightDataRoutes || dataRoutes
    patchRoutesImpl(routeId, children$3, routesToUse, manifest, mapRouteProperties2, unstable_allowElementMutations),
      isNonHMR && (dataRoutes = [...dataRoutes], updateState({}))
  }
  return router$1 = {
    get basename() {
      return basename$1
    },
    get future() {
      return future
    },
    get state() {
      return state
    },
    get routes() {
      return dataRoutes
    },
    get window() {
      return routerWindow
    },
    initialize,
    subscribe: subscribe$1,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: queueFetcherForDeletion,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    _internalSetRoutes,
    _internalSetStateDoNotUseOrYouWillBreakYourApp(newState) {
      updateState(newState)
    },
  },
    router$1
}
function isSubmissionNavigation(opts) {
  return opts != null && (`formData` in opts && opts.formData != null || `body` in opts && opts.body !== void 0)
}
function normalizeTo(location, matches, basename$1, to, fromRouteId, relative) {
  let contextualMatches, activeRouteMatch
  if (fromRouteId) {
    contextualMatches = []
    for (let match$13 of matches) {
      if (contextualMatches.push(match$13), match$13.route.id === fromRouteId) {
        activeRouteMatch = match$13
        break
      }
    }
  } else contextualMatches = matches, activeRouteMatch = matches[matches.length - 1]
  let path$1 = resolveTo(
    to || `.`,
    getResolveToMatches(contextualMatches),
    stripBasename(location.pathname, basename$1) || location.pathname,
    relative === `path`,
  )
  if (
    to ?? (path$1.search = location.search, path$1.hash = location.hash),
      (to == null || to === `` || to === `.`) && activeRouteMatch
  ) {
    let nakedIndex = hasNakedIndexQuery(path$1.search)
    if (activeRouteMatch.route.index && !nakedIndex) {
      path$1.search = path$1.search
        ? path$1.search.replace(/^\?/, `?index&`)
        : `?index`
    } else if (!activeRouteMatch.route.index && nakedIndex) {
      let params = new URLSearchParams(path$1.search), indexValues = params.getAll(`index`)
      params.delete(`index`), indexValues.filter(v$4 => v$4).forEach(v$4 => params.append(`index`, v$4))
      let qs = params.toString()
      path$1.search = qs ? `?${qs}` : ``
    }
  }
  return basename$1 !== `/` && (path$1.pathname = prependBasename({ basename: basename$1, pathname: path$1.pathname })),
    createPath(path$1)
}
function normalizeNavigateOptions(isFetcher, path$1, opts) {
  if (!opts || !isSubmissionNavigation(opts)) return { path: path$1 }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return { path: path$1, error: getInternalRouterError(405, { method: opts.formMethod }) }
  }
  let getInvalidBodyError = () => ({ path: path$1, error: getInternalRouterError(400, { type: `invalid-body` }) }),
    rawFormMethod = opts.formMethod || `get`,
    formMethod = rawFormMethod.toUpperCase(),
    formAction = stripHashFromPath(path$1)
  if (opts.body !== void 0) {
    if (opts.formEncType === `text/plain`) {
      if (!isMutationMethod(formMethod)) return getInvalidBodyError()
      let text$6 = typeof opts.body == `string`
        ? opts.body
        : opts.body instanceof FormData || opts.body instanceof URLSearchParams
        ? Array.from(opts.body.entries()).reduce((acc, [name, value$2]) =>
          `${acc}${name}=${value$2}
`, ``)
        : String(opts.body)
      return {
        path: path$1,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text: text$6,
        },
      }
    } else if (opts.formEncType === `application/json`) {
      if (!isMutationMethod(formMethod)) return getInvalidBodyError()
      try {
        let json = typeof opts.body == `string` ? JSON.parse(opts.body) : opts.body
        return {
          path: path$1,
          submission: { formMethod, formAction, formEncType: opts.formEncType, formData: void 0, json, text: void 0 },
        }
      } catch {
        return getInvalidBodyError()
      }
    }
  }
  invariant$1(typeof FormData == `function`, `FormData is not available in this environment`)
  let searchParams, formData
  if (opts.formData) searchParams = convertFormDataToSearchParams(opts.formData), formData = opts.formData
  else if (opts.body instanceof FormData) searchParams = convertFormDataToSearchParams(opts.body), formData = opts.body
  else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body, formData = convertSearchParamsToFormData(searchParams)
  } else if (opts.body == null) searchParams = new URLSearchParams(), formData = new FormData()
  else {try {
      searchParams = new URLSearchParams(opts.body), formData = convertSearchParamsToFormData(searchParams)
    } catch {
      return getInvalidBodyError()
    }}
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || `application/x-www-form-urlencoded`,
    formData,
    json: void 0,
    text: void 0,
  }
  if (isMutationMethod(submission.formMethod)) return { path: path$1, submission }
  let parsedPath = parsePath(path$1)
  return isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search) && searchParams.append(`index`, ``),
    parsedPath.search = `?${searchParams}`,
    { path: createPath(parsedPath), submission }
}
function getMatchesToLoad(
  request$1,
  scopedContext,
  mapRouteProperties2,
  manifest,
  history,
  state,
  matches,
  submission,
  location,
  lazyRoutePropertiesToSkip,
  initialHydration,
  isRevalidationRequired,
  cancelledFetcherLoads,
  fetchersQueuedForDeletion,
  fetchLoadMatches,
  fetchRedirectIds,
  routesToUse,
  basename$1,
  hasPatchRoutesOnNavigation,
  pendingActionResult,
) {
  let actionResult = pendingActionResult
      ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data
      : void 0,
    currentUrl = history.createURL(state.location),
    nextUrl = history.createURL(location),
    maxIdx
  if (initialHydration && state.errors) {
    let boundaryId = Object.keys(state.errors)[0]
    maxIdx = matches.findIndex(m$12 => m$12.route.id === boundaryId)
  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
    let boundaryId = pendingActionResult[0]
    maxIdx = matches.findIndex(m$12 => m$12.route.id === boundaryId) - 1
  }
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0,
    shouldSkipRevalidation = actionStatus && actionStatus >= 400,
    baseShouldRevalidateArgs = {
      currentUrl,
      currentParams: state.matches[0]?.params || {},
      nextUrl,
      nextParams: matches[0].params,
      ...submission,
      actionResult,
      actionStatus,
    },
    dsMatches = matches.map((match$13, index$4) => {
      let { route: route$1 } = match$13, forceShouldLoad = null
      if (
        maxIdx != null && index$4 > maxIdx
          ? forceShouldLoad = !1
          : route$1.lazy
          ? forceShouldLoad = !0
          : route$1.loader == null
          ? forceShouldLoad = !1
          : initialHydration
          ? forceShouldLoad = shouldLoadRouteOnHydration(route$1, state.loaderData, state.errors)
          : isNewLoader(state.loaderData, state.matches[index$4], match$13) && (forceShouldLoad = !0),
          forceShouldLoad !== null
      ) {
        return getDataStrategyMatch(
          mapRouteProperties2,
          manifest,
          request$1,
          match$13,
          lazyRoutePropertiesToSkip,
          scopedContext,
          forceShouldLoad,
        )
      }
      let defaultShouldRevalidate = shouldSkipRevalidation
          ? !1
          : isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search
            || currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index$4], match$13),
        shouldRevalidateArgs = { ...baseShouldRevalidateArgs, defaultShouldRevalidate },
        shouldLoad = shouldRevalidateLoader(match$13, shouldRevalidateArgs)
      return getDataStrategyMatch(
        mapRouteProperties2,
        manifest,
        request$1,
        match$13,
        lazyRoutePropertiesToSkip,
        scopedContext,
        shouldLoad,
        shouldRevalidateArgs,
      )
    }),
    revalidatingFetchers = []
  return fetchLoadMatches.forEach((f$14, key$1) => {
    if (
      initialHydration || !matches.some(m$12 => m$12.route.id === f$14.routeId) || fetchersQueuedForDeletion.has(key$1)
    ) return
    let fetcher = state.fetchers.get(key$1),
      isMidInitialLoad = fetcher && fetcher.state !== `idle` && fetcher.data === void 0,
      fetcherMatches = matchRoutes(routesToUse, f$14.path, basename$1)
    if (!fetcherMatches) {
      if (hasPatchRoutesOnNavigation && isMidInitialLoad) return
      revalidatingFetchers.push({
        key: key$1,
        routeId: f$14.routeId,
        path: f$14.path,
        matches: null,
        match: null,
        request: null,
        controller: null,
      })
      return
    }
    if (fetchRedirectIds.has(key$1)) return
    let fetcherMatch = getTargetMatch(fetcherMatches, f$14.path),
      fetchController = new AbortController(),
      fetchRequest = createClientSideRequest(history, f$14.path, fetchController.signal),
      fetcherDsMatches = null
    if (cancelledFetcherLoads.has(key$1)) {
      cancelledFetcherLoads.delete(key$1),
        fetcherDsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          fetchRequest,
          fetcherMatches,
          fetcherMatch,
          lazyRoutePropertiesToSkip,
          scopedContext,
        )
    } else if (isMidInitialLoad) {
      isRevalidationRequired
        && (fetcherDsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          fetchRequest,
          fetcherMatches,
          fetcherMatch,
          lazyRoutePropertiesToSkip,
          scopedContext,
        ))
    } else {
      let shouldRevalidateArgs = {
        ...baseShouldRevalidateArgs,
        defaultShouldRevalidate: shouldSkipRevalidation ? !1 : isRevalidationRequired,
      }
      shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)
        && (fetcherDsMatches = getTargetedDataStrategyMatches(
          mapRouteProperties2,
          manifest,
          fetchRequest,
          fetcherMatches,
          fetcherMatch,
          lazyRoutePropertiesToSkip,
          scopedContext,
          shouldRevalidateArgs,
        ))
    }
    fetcherDsMatches
      && revalidatingFetchers.push({
        key: key$1,
        routeId: f$14.routeId,
        path: f$14.path,
        matches: fetcherDsMatches,
        match: fetcherMatch,
        request: fetchRequest,
        controller: fetchController,
      })
  }),
    { dsMatches, revalidatingFetchers }
}
function shouldLoadRouteOnHydration(route$1, loaderData, errors) {
  if (route$1.lazy) return !0
  if (!route$1.loader) return !1
  let hasData = loaderData != null && route$1.id in loaderData,
    hasError = errors != null && errors[route$1.id] !== void 0
  return !hasData && hasError
    ? !1
    : typeof route$1.loader == `function` && route$1.loader.hydrate === !0
    ? !0
    : !hasData && !hasError
}
function isNewLoader(currentLoaderData, currentMatch, match$13) {
  let isNew = !currentMatch || match$13.route.id !== currentMatch.route.id,
    isMissingData = !currentLoaderData.hasOwnProperty(match$13.route.id)
  return isNew || isMissingData
}
function isNewRouteInstance(currentMatch, match$13) {
  let currentPath = currentMatch.route.path
  return currentMatch.pathname !== match$13.pathname
    || currentPath != null && currentPath.endsWith(`*`) && currentMatch.params[`*`] !== match$13.params[`*`]
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg)
    if (typeof routeChoice == `boolean`) return routeChoice
  }
  return arg.defaultShouldRevalidate
}
function patchRoutesImpl(routeId, children$3, routesToUse, manifest, mapRouteProperties2, allowElementMutations) {
  let childrenToPatch
  if (routeId) {
    let route$1 = manifest[routeId]
    invariant$1(route$1, `No route found to patch children into: routeId = ${routeId}`),
      route$1.children ||= [],
      childrenToPatch = route$1.children
  } else childrenToPatch = routesToUse
  let uniqueChildren = [], existingChildren = []
  if (
    children$3.forEach(newRoute => {
      let existingRoute = childrenToPatch.find(existingRoute2 => isSameRoute(newRoute, existingRoute2))
      existingRoute ? existingChildren.push({ existingRoute, newRoute }) : uniqueChildren.push(newRoute)
    }), uniqueChildren.length > 0
  ) {
    let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [
      routeId || `_`,
      `patch`,
      String(childrenToPatch?.length || `0`),
    ], manifest)
    childrenToPatch.push(...newRoutes)
  }
  if (allowElementMutations && existingChildren.length > 0) {
    for (let i$14 = 0; i$14 < existingChildren.length; i$14++) {
      let { existingRoute, newRoute } = existingChildren[i$14],
        existingRouteTyped = existingRoute,
        [newRouteTyped] = convertRoutesToDataRoutes([newRoute], mapRouteProperties2, [], {}, !0)
      Object.assign(existingRouteTyped, {
        element: newRouteTyped.element ? newRouteTyped.element : existingRouteTyped.element,
        errorElement: newRouteTyped.errorElement ? newRouteTyped.errorElement : existingRouteTyped.errorElement,
        hydrateFallbackElement: newRouteTyped.hydrateFallbackElement
          ? newRouteTyped.hydrateFallbackElement
          : existingRouteTyped.hydrateFallbackElement,
      })
    }
  }
}
function isSameRoute(newRoute, existingRoute) {
  return `id` in newRoute && `id` in existingRoute && newRoute.id === existingRoute.id
    ? !0
    : newRoute.index === existingRoute.index && newRoute.path === existingRoute.path
        && newRoute.caseSensitive === existingRoute.caseSensitive
    ? (!newRoute.children || newRoute.children.length === 0)
        && (!existingRoute.children || existingRoute.children.length === 0)
      ? !0
      : newRoute.children.every((aChild, i$14) => existingRoute.children?.some(bChild => isSameRoute(aChild, bChild)))
    : !1
}
var lazyRoutePropertyCache = new WeakMap(),
  loadLazyRouteProperty = ({ key: key$1, route: route$1, manifest, mapRouteProperties: mapRouteProperties2 }) => {
    let routeToUpdate = manifest[route$1.id]
    if (
      invariant$1(routeToUpdate, `No route found in manifest`),
        !routeToUpdate.lazy || typeof routeToUpdate.lazy != `object`
    ) return
    let lazyFn = routeToUpdate.lazy[key$1]
    if (!lazyFn) return
    let cache = lazyRoutePropertyCache.get(routeToUpdate)
    cache || (cache = {}, lazyRoutePropertyCache.set(routeToUpdate, cache))
    let cachedPromise = cache[key$1]
    if (cachedPromise) return cachedPromise
    let propertyPromise = (async () => {
      let isUnsupported = isUnsupportedLazyRouteObjectKey(key$1),
        staticRouteValue = routeToUpdate[key$1],
        isStaticallyDefined = staticRouteValue !== void 0 && key$1 !== `hasErrorBoundary`
      if (isUnsupported) {
        warning(
          !isUnsupported,
          `Route property ` + key$1 + ` is not a supported lazy route property. This property will be ignored.`,
        ), cache[key$1] = Promise.resolve()
      } else if (isStaticallyDefined) {
        warning(
          !1,
          `Route "${routeToUpdate.id}" has a static property "${key$1}" defined. The lazy property will be ignored.`,
        )
      } else {
        let value$2 = await lazyFn()
        value$2 != null
          && (Object.assign(routeToUpdate, { [key$1]: value$2 }),
            Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate)))
      }
      typeof routeToUpdate.lazy == `object`
        && (routeToUpdate.lazy[key$1] = void 0,
          Object.values(routeToUpdate.lazy).every(value$2 => value$2 === void 0) && (routeToUpdate.lazy = void 0))
    })()
    return cache[key$1] = propertyPromise, propertyPromise
  },
  lazyRouteFunctionCache = new WeakMap()
function loadLazyRoute(route$1, type$2, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {
  let routeToUpdate = manifest[route$1.id]
  if (invariant$1(routeToUpdate, `No route found in manifest`), !route$1.lazy) {
    return { lazyRoutePromise: void 0, lazyHandlerPromise: void 0 }
  }
  if (typeof route$1.lazy == `function`) {
    let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate)
    if (cachedPromise) return { lazyRoutePromise: cachedPromise, lazyHandlerPromise: cachedPromise }
    let lazyRoutePromise2 = (async () => {
      invariant$1(typeof route$1.lazy == `function`, `No lazy route function found`)
      let lazyRoute = await route$1.lazy(), routeUpdates = {}
      for (let lazyRouteProperty in lazyRoute) {
        let lazyValue = lazyRoute[lazyRouteProperty]
        if (lazyValue === void 0) continue
        let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty),
          staticRouteValue = routeToUpdate[lazyRouteProperty],
          isStaticallyDefined = staticRouteValue !== void 0 && lazyRouteProperty !== `hasErrorBoundary`
        isUnsupported
          ? warning(
            !isUnsupported,
            `Route property ` + lazyRouteProperty
              + ` is not a supported property to be returned from a lazy route function. This property will be ignored.`,
          )
          : isStaticallyDefined
          ? warning(
            !isStaticallyDefined,
            `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`,
          )
          : routeUpdates[lazyRouteProperty] = lazyValue
      }
      Object.assign(routeToUpdate, routeUpdates),
        Object.assign(routeToUpdate, { ...mapRouteProperties2(routeToUpdate), lazy: void 0 })
    })()
    return lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2),
      lazyRoutePromise2.catch(() => {}),
      { lazyRoutePromise: lazyRoutePromise2, lazyHandlerPromise: lazyRoutePromise2 }
  }
  let lazyKeys = Object.keys(route$1.lazy), lazyPropertyPromises = [], lazyHandlerPromise
  for (let key$1 of lazyKeys) {
    if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key$1)) continue
    let promise$2 = loadLazyRouteProperty({
      key: key$1,
      route: route$1,
      manifest,
      mapRouteProperties: mapRouteProperties2,
    })
    promise$2 && (lazyPropertyPromises.push(promise$2), key$1 === type$2 && (lazyHandlerPromise = promise$2))
  }
  let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(() => {}) : void 0
  return lazyRoutePromise?.catch(() => {}),
    lazyHandlerPromise?.catch(() => {}),
    { lazyRoutePromise, lazyHandlerPromise }
}
async function defaultDataStrategy(args$1) {
  let matchesToLoad = args$1.matches.filter(m$12 => m$12.shouldLoad),
    keyedResults = {},
    results = await Promise.all(matchesToLoad.map(m$12 => m$12.resolve()))
  return results.forEach((result, i$14) => {
    keyedResults[matchesToLoad[i$14].route.id] = result
  }),
    keyedResults
}
async function defaultDataStrategyWithMiddleware(args$1) {
  return args$1.matches.some(m$12 => m$12.route.unstable_middleware)
    ? runMiddlewarePipeline(
      args$1,
      !1,
      () => defaultDataStrategy(args$1),
      (error, routeId) => ({ [routeId]: { type: `error`, result: error } }),
    )
    : defaultDataStrategy(args$1)
}
async function runMiddlewarePipeline(args$1, propagateResult, handler, errorHandler) {
  let { matches, request: request$1, params, context: context$2 } = args$1, middlewareState = { handlerResult: void 0 }
  try {
    let tuples = matches.flatMap(m$12 =>
        m$12.route.unstable_middleware ? m$12.route.unstable_middleware.map(fn => [m$12.route.id, fn]) : []
      ),
      result = await callRouteMiddleware(
        { request: request$1, params, context: context$2 },
        tuples,
        propagateResult,
        middlewareState,
        handler,
      )
    return propagateResult ? result : middlewareState.handlerResult
  } catch (e$26) {
    if (!middlewareState.middlewareError) throw e$26
    let result = await errorHandler(middlewareState.middlewareError.error, middlewareState.middlewareError.routeId)
    return propagateResult || !middlewareState.handlerResult
      ? result
      : Object.assign(middlewareState.handlerResult, result)
  }
}
async function callRouteMiddleware(args$1, middlewares, propagateResult, middlewareState, handler, idx = 0) {
  let { request: request$1 } = args$1
  if (request$1.signal.aborted) {
    throw request$1.signal.reason
      ? request$1.signal.reason
      : Error(`Request aborted without an \`AbortSignal.reason\`: ${request$1.method} ${request$1.url}`)
  }
  let tuple$2 = middlewares[idx]
  if (!tuple$2) return middlewareState.handlerResult = await handler(), middlewareState.handlerResult
  let [routeId, middleware] = tuple$2,
    nextCalled = !1,
    nextResult,
    next = async () => {
      if (nextCalled) throw Error('You may only call `next()` once per middleware')
      nextCalled = !0
      let result = await callRouteMiddleware(args$1, middlewares, propagateResult, middlewareState, handler, idx + 1)
      if (propagateResult) return nextResult = result, nextResult
    }
  try {
    let result = await middleware({ request: args$1.request, params: args$1.params, context: args$1.context }, next)
    return nextCalled ? result === void 0 ? nextResult : result : next()
  } catch (error) {
    throw middlewareState.middlewareError
      ? middlewareState.middlewareError.error !== error && (middlewareState.middlewareError = { routeId, error })
      : middlewareState.middlewareError = { routeId, error },
      error
  }
}
function getDataStrategyMatchLazyPromises(
  mapRouteProperties2,
  manifest,
  request$1,
  match$13,
  lazyRoutePropertiesToSkip,
) {
  let lazyMiddlewarePromise = loadLazyRouteProperty({
      key: `unstable_middleware`,
      route: match$13.route,
      manifest,
      mapRouteProperties: mapRouteProperties2,
    }),
    lazyRoutePromises = loadLazyRoute(
      match$13.route,
      isMutationMethod(request$1.method) ? `action` : `loader`,
      manifest,
      mapRouteProperties2,
      lazyRoutePropertiesToSkip,
    )
  return {
    middleware: lazyMiddlewarePromise,
    route: lazyRoutePromises.lazyRoutePromise,
    handler: lazyRoutePromises.lazyHandlerPromise,
  }
}
function getDataStrategyMatch(
  mapRouteProperties2,
  manifest,
  request$1,
  match$13,
  lazyRoutePropertiesToSkip,
  scopedContext,
  shouldLoad,
  unstable_shouldRevalidateArgs = null,
) {
  let isUsingNewApi = !1,
    _lazyPromises = getDataStrategyMatchLazyPromises(
      mapRouteProperties2,
      manifest,
      request$1,
      match$13,
      lazyRoutePropertiesToSkip,
    )
  return {
    ...match$13,
    _lazyPromises,
    shouldLoad,
    unstable_shouldRevalidateArgs,
    unstable_shouldCallHandler(defaultShouldRevalidate) {
      return isUsingNewApi = !0,
        unstable_shouldRevalidateArgs
          ? typeof defaultShouldRevalidate == `boolean`
            ? shouldRevalidateLoader(match$13, { ...unstable_shouldRevalidateArgs, defaultShouldRevalidate })
            : shouldRevalidateLoader(match$13, unstable_shouldRevalidateArgs)
          : shouldLoad
    },
    resolve(handlerOverride) {
      return isUsingNewApi || shouldLoad
          || handlerOverride && !isMutationMethod(request$1.method) && (match$13.route.lazy || match$13.route.loader)
        ? callLoaderOrAction({
          request: request$1,
          match: match$13,
          lazyHandlerPromise: _lazyPromises?.handler,
          lazyRoutePromise: _lazyPromises?.route,
          handlerOverride,
          scopedContext,
        })
        : Promise.resolve({ type: `data`, result: void 0 })
    },
  }
}
function getTargetedDataStrategyMatches(
  mapRouteProperties2,
  manifest,
  request$1,
  matches,
  targetMatch,
  lazyRoutePropertiesToSkip,
  scopedContext,
  shouldRevalidateArgs = null,
) {
  return matches.map(match$13 =>
    match$13.route.id === targetMatch.route.id
      ? getDataStrategyMatch(
        mapRouteProperties2,
        manifest,
        request$1,
        match$13,
        lazyRoutePropertiesToSkip,
        scopedContext,
        !0,
        shouldRevalidateArgs,
      )
      : {
        ...match$13,
        shouldLoad: !1,
        unstable_shouldRevalidateArgs: shouldRevalidateArgs,
        unstable_shouldCallHandler: () => !1,
        _lazyPromises: getDataStrategyMatchLazyPromises(
          mapRouteProperties2,
          manifest,
          request$1,
          match$13,
          lazyRoutePropertiesToSkip,
        ),
        resolve: () => Promise.resolve({ type: `data`, result: void 0 }),
      }
  )
}
async function callDataStrategyImpl(dataStrategyImpl, request$1, matches, fetcherKey, scopedContext, isStaticHandler) {
  matches.some(m$12 => m$12._lazyPromises?.middleware)
    && await Promise.all(matches.map(m$12 => m$12._lazyPromises?.middleware))
  let dataStrategyArgs = { request: request$1, params: matches[0].params, context: scopedContext, matches },
    unstable_runClientMiddleware = isStaticHandler
      ? () => {
        throw Error(
          'You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`',
        )
      }
      : cb => {
        let typedDataStrategyArgs = dataStrategyArgs
        return runMiddlewarePipeline(
          typedDataStrategyArgs,
          !1,
          () =>
            cb({
              ...typedDataStrategyArgs,
              fetcherKey,
              unstable_runClientMiddleware: () => {
                throw Error(
                  'Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler',
                )
              },
            }),
          (error, routeId) => ({ [routeId]: { type: `error`, result: error } }),
        )
      },
    results = await dataStrategyImpl({ ...dataStrategyArgs, fetcherKey, unstable_runClientMiddleware })
  try {
    await Promise.all(matches.flatMap(m$12 => [m$12._lazyPromises?.handler, m$12._lazyPromises?.route]))
  } catch {}
  return results
}
async function callLoaderOrAction(
  { request: request$1, match: match$13, lazyHandlerPromise, lazyRoutePromise, handlerOverride, scopedContext },
) {
  let result,
    onReject,
    isAction = isMutationMethod(request$1.method),
    type$2 = isAction ? `action` : `loader`,
    runHandler = handler => {
      let reject, abortPromise = new Promise((_$1, r$26) => reject = r$26)
      onReject = () => reject(), request$1.signal.addEventListener(`abort`, onReject)
      let actualHandler = ctx =>
          typeof handler == `function`
            ? handler(
              { request: request$1, params: match$13.params, context: scopedContext },
              ...ctx === void 0 ? [] : [ctx],
            )
            : Promise.reject(
              Error(
                `You cannot call the handler for a route which defines a boolean "${type$2}" [routeId: ${match$13.route.id}]`,
              ),
            ),
        handlerPromise = (async () => {
          try {
            let val = await (handlerOverride ? handlerOverride(ctx => actualHandler(ctx)) : actualHandler())
            return { type: `data`, result: val }
          } catch (e$26) {
            return { type: `error`, result: e$26 }
          }
        })()
      return Promise.race([handlerPromise, abortPromise])
    }
  try {
    let handler = isAction ? match$13.route.action : match$13.route.loader
    if (lazyHandlerPromise || lazyRoutePromise) {
      if (handler) {
        let handlerError,
          [value$2] = await Promise.all([
            runHandler(handler).catch(e$26 => {
              handlerError = e$26
            }),
            lazyHandlerPromise,
            lazyRoutePromise,
          ])
        if (handlerError !== void 0) throw handlerError
        result = value$2
      } else {
        await lazyHandlerPromise
        let handler2 = isAction ? match$13.route.action : match$13.route.loader
        if (handler2) [result] = await Promise.all([runHandler(handler2), lazyRoutePromise])
        else if (type$2 === `action`) {
          let url = new URL(request$1.url), pathname = url.pathname + url.search
          throw getInternalRouterError(405, { method: request$1.method, pathname, routeId: match$13.route.id })
        } else return { type: `data`, result: void 0 }
      }
    } else if (handler) result = await runHandler(handler)
    else {
      let url = new URL(request$1.url), pathname = url.pathname + url.search
      throw getInternalRouterError(404, { pathname })
    }
  } catch (e$26) {
    return { type: `error`, result: e$26 }
  } finally {
    onReject && request$1.signal.removeEventListener(`abort`, onReject)
  }
  return result
}
async function convertDataStrategyResultToDataResult(dataStrategyResult) {
  let { result, type: type$2 } = dataStrategyResult
  if (isResponse(result)) {
    let data2
    try {
      let contentType = result.headers.get(`Content-Type`)
      data2 = contentType && /\bapplication\/json\b/.test(contentType)
        ? result.body == null ? null : await result.json()
        : await result.text()
    } catch (e$26) {
      return { type: `error`, error: e$26 }
    }
    return type$2 === `error`
      ? {
        type: `error`,
        error: new ErrorResponseImpl(result.status, result.statusText, data2),
        statusCode: result.status,
        headers: result.headers,
      }
      : { type: `data`, data: data2, statusCode: result.status, headers: result.headers }
  }
  return type$2 === `error`
    ? isDataWithResponseInit(result)
      ? result.data instanceof Error
        ? {
          type: `error`,
          error: result.data,
          statusCode: result.init?.status,
          headers: result.init?.headers ? new Headers(result.init.headers) : void 0,
        }
        : {
          type: `error`,
          error: new ErrorResponseImpl(result.init?.status || 500, void 0, result.data),
          statusCode: isRouteErrorResponse(result) ? result.status : void 0,
          headers: result.init?.headers ? new Headers(result.init.headers) : void 0,
        }
      : { type: `error`, error: result, statusCode: isRouteErrorResponse(result) ? result.status : void 0 }
    : isDataWithResponseInit(result)
    ? {
      type: `data`,
      data: result.data,
      statusCode: result.init?.status,
      headers: result.init?.headers ? new Headers(result.init.headers) : void 0,
    }
    : { type: `data`, data: result }
}
function normalizeRelativeRoutingRedirectResponse(response, request$1, routeId, matches, basename$1) {
  let location = response.headers.get(`Location`)
  if (
    invariant$1(location, `Redirects returned/thrown from loaders/actions must have a Location header`),
      !isAbsoluteUrl(location)
  ) {
    let trimmedMatches = matches.slice(0, matches.findIndex(m$12 => m$12.route.id === routeId) + 1)
    location = normalizeTo(new URL(request$1.url), trimmedMatches, basename$1, location),
      response.headers.set(`Location`, location)
  }
  return response
}
function normalizeRedirectLocation(location, currentUrl, basename$1) {
  if (isAbsoluteUrl(location)) {
    let normalizedLocation = location,
      url = normalizedLocation.startsWith(`//`)
        ? new URL(currentUrl.protocol + normalizedLocation)
        : new URL(normalizedLocation),
      isSameBasename = stripBasename(url.pathname, basename$1) != null
    if (url.origin === currentUrl.origin && isSameBasename) return url.pathname + url.search + url.hash
  }
  return location
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString(), init = { signal }
  if (submission && isMutationMethod(submission.formMethod)) {
    let { formMethod, formEncType } = submission
    init.method = formMethod.toUpperCase(),
      formEncType === `application/json`
        ? (init.headers = new Headers({ 'Content-Type': formEncType }), init.body = JSON.stringify(submission.json))
        : formEncType === `text/plain`
        ? init.body = submission.text
        : formEncType === `application/x-www-form-urlencoded` && submission.formData
        ? init.body = convertFormDataToSearchParams(submission.formData)
        : init.body = submission.formData
  }
  return new Request(url, init)
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams()
  for (let [key$1, value$2] of formData.entries()) {
    searchParams.append(key$1, typeof value$2 == `string` ? value$2 : value$2.name)
  }
  return searchParams
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData()
  for (let [key$1, value$2] of searchParams.entries()) formData.append(key$1, value$2)
  return formData
}
function processRouteLoaderData(
  matches,
  results,
  pendingActionResult,
  isStaticHandler = !1,
  skipLoaderErrorBubbling = !1,
) {
  let loaderData = {},
    errors = null,
    statusCode,
    foundError = !1,
    loaderHeaders = {},
    pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0
  return matches.forEach(match$13 => {
    if (!(match$13.route.id in results)) return
    let id$2 = match$13.route.id, result = results[id$2]
    if (
      invariant$1(!isRedirectResult(result), `Cannot handle redirect results in processLoaderData`),
        isErrorResult(result)
    ) {
      let error = result.error
      if (
        pendingError !== void 0 && (error = pendingError, pendingError = void 0), errors ||= {}, skipLoaderErrorBubbling
      ) errors[id$2] = error
      else {
        let boundaryMatch = findNearestBoundary(matches, id$2)
        errors[boundaryMatch.route.id] ?? (errors[boundaryMatch.route.id] = error)
      }
      isStaticHandler || (loaderData[id$2] = ResetLoaderDataSymbol),
        foundError || (foundError = !0, statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500),
        result.headers && (loaderHeaders[id$2] = result.headers)
    } else {loaderData[id$2] = result.data,
        result.statusCode && result.statusCode !== 200 && !foundError && (statusCode = result.statusCode),
        result.headers && (loaderHeaders[id$2] = result.headers)}
  }),
    pendingError !== void 0 && pendingActionResult
    && (errors = { [pendingActionResult[0]]: pendingError },
      pendingActionResult[2] && (loaderData[pendingActionResult[2]] = void 0)),
    { loaderData, errors, statusCode: statusCode || 200, loaderHeaders }
}
function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
  let { loaderData, errors } = processRouteLoaderData(matches, results, pendingActionResult)
  return revalidatingFetchers.filter(f$14 => !f$14.matches || f$14.matches.some(m$12 => m$12.shouldLoad)).forEach(
    rf => {
      let { key: key$1, match: match$13, controller } = rf, result = fetcherResults[key$1]
      if (
        invariant$1(result, `Did not find corresponding fetcher result`), !(controller && controller.signal.aborted)
      ) {
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, match$13?.route.id)
          errors && errors[boundaryMatch.route.id] || (errors = { ...errors, [boundaryMatch.route.id]: result.error }),
            state.fetchers.delete(key$1)
        } else if (isRedirectResult(result)) invariant$1(!1, `Unhandled fetcher revalidation redirect`)
        else {
          let doneFetcher = getDoneFetcher(result.data)
          state.fetchers.set(key$1, doneFetcher)
        }
      }
    },
  ),
    { loaderData, errors }
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = Object.entries(newLoaderData).filter(([, v$4]) => v$4 !== ResetLoaderDataSymbol).reduce(
    (merged, [k$1, v$4]) => (merged[k$1] = v$4, merged),
    {},
  )
  for (let match$13 of matches) {
    let id$2 = match$13.route.id
    if (
      !newLoaderData.hasOwnProperty(id$2) && loaderData.hasOwnProperty(id$2) && match$13.route.loader
      && (mergedLoaderData[id$2] = loaderData[id$2]), errors && errors.hasOwnProperty(id$2)
    ) break
  }
  return mergedLoaderData
}
function getActionDataForCommit(pendingActionResult) {
  return pendingActionResult
    ? isErrorResult(pendingActionResult[1])
      ? { actionData: {} }
      : { actionData: { [pendingActionResult[0]]: pendingActionResult[1].data } }
    : {}
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId
    ? matches.slice(0, matches.findIndex(m$12 => m$12.route.id === routeId) + 1)
    : [...matches]
  return eligibleMatches.reverse().find(m$12 => m$12.route.hasErrorBoundary === !0) || matches[0]
}
function getShortCircuitMatches(routes$2) {
  let route$1 = routes$2.length === 1
    ? routes$2[0]
    : routes$2.find(r$26 => r$26.index || !r$26.path || r$26.path === `/`) || { id: `__shim-error-route__` }
  return { matches: [{ params: {}, pathname: ``, pathnameBase: ``, route: route$1 }], route: route$1 }
}
function getInternalRouterError(status$2, { pathname, routeId, method, type: type$2, message } = {}) {
  let statusText = `Unknown Server Error`, errorMessage = `Unknown @remix-run/router error`
  return status$2 === 400
    ? (statusText = `Bad Request`,
      method && pathname && routeId
        ? errorMessage =
          `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`
        : type$2 === `invalid-body` && (errorMessage = `Unable to encode submission body`))
    : status$2 === 403
    ? (statusText = `Forbidden`, errorMessage = `Route "${routeId}" does not match URL "${pathname}"`)
    : status$2 === 404
    ? (statusText = `Not Found`, errorMessage = `No route matches URL "${pathname}"`)
    : status$2 === 405 && (statusText = `Method Not Allowed`,
      method && pathname && routeId
        ? errorMessage =
          `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`
        : method && (errorMessage = `Invalid request method "${method.toUpperCase()}"`)),
    new ErrorResponseImpl(status$2 || 500, statusText, Error(errorMessage), !0)
}
function findRedirect(results) {
  let entries$2 = Object.entries(results)
  for (let i$14 = entries$2.length - 1; i$14 >= 0; i$14--) {
    let [key$1, result] = entries$2[i$14]
    if (isRedirectResult(result)) return { key: key$1, result }
  }
}
function stripHashFromPath(path$1) {
  let parsedPath = typeof path$1 == `string` ? parsePath(path$1) : path$1
  return createPath({ ...parsedPath, hash: `` })
}
function isHashChangeOnly(a$22, b$3) {
  return a$22.pathname !== b$3.pathname || a$22.search !== b$3.search
    ? !1
    : a$22.hash === ``
    ? b$3.hash !== ``
    : a$22.hash === b$3.hash
    ? !0
    : b$3.hash !== ``
}
function isRedirectDataStrategyResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status)
}
function isErrorResult(result) {
  return result.type === `error`
}
function isRedirectResult(result) {
  return (result && result.type) === `redirect`
}
function isDataWithResponseInit(value$2) {
  return typeof value$2 == `object` && !!value$2 && `type` in value$2 && `data` in value$2 && `init` in value$2
    && value$2.type === `DataWithResponseInit`
}
function isResponse(value$2) {
  return value$2 != null && typeof value$2.status == `number` && typeof value$2.statusText == `string`
    && typeof value$2.headers == `object` && value$2.body !== void 0
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toUpperCase())
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toUpperCase())
}
function hasNakedIndexQuery(search$1) {
  return new URLSearchParams(search$1).getAll(`index`).some(v$4 => v$4 === ``)
}
function getTargetMatch(matches, location) {
  let search$1 = typeof location == `string` ? parsePath(location).search : location.search
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search$1 || ``)) return matches[matches.length - 1]
  let pathMatches = getPathContributingMatches(matches)
  return pathMatches[pathMatches.length - 1]
}
function getSubmissionFromNavigation(navigation) {
  let { formMethod, formAction, formEncType, text: text$6, formData, json } = navigation
  if (!(!formMethod || !formAction || !formEncType)) {
    if (text$6 != null) return { formMethod, formAction, formEncType, formData: void 0, json: void 0, text: text$6 }
    if (formData != null) return { formMethod, formAction, formEncType, formData, json: void 0, text: void 0 }
    if (json !== void 0) return { formMethod, formAction, formEncType, formData: void 0, json, text: void 0 }
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: `loading`,
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
    }
    return navigation
  } else {
    let navigation = {
      state: `loading`,
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
    }
    return navigation
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: `submitting`,
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
  }
  return navigation
}
function getLoadingFetcher(submission, data2) {
  if (submission) {
    let fetcher = {
      state: `loading`,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: data2,
    }
    return fetcher
  } else {
    let fetcher = {
      state: `loading`,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data: data2,
    }
    return fetcher
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: `submitting`,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0,
  }
  return fetcher
}
function getDoneFetcher(data2) {
  let fetcher = {
    state: `idle`,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: data2,
  }
  return fetcher
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY)
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions)
      for (let [k$1, v$4] of Object.entries(json || {})) {
        v$4 && Array.isArray(v$4) && transitions.set(k$1, new Set(v$4 || []))
      }
    }
  } catch {}
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {}
    for (let [k$1, v$4] of transitions) json[k$1] = [...v$4]
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json))
    } catch (error) {
      warning(!1, `Failed to save applied view transitions in sessionStorage (${error}).`)
    }
  }
}
function createDeferred() {
  let resolve,
    reject,
    promise$2 = new Promise((res, rej) => {
      resolve = async val => {
        res(val)
        try {
          await promise$2
        } catch {}
      },
        reject = async error => {
          rej(error)
          try {
            await promise$2
          } catch {}
        }
    })
  return { promise: promise$2, resolve, reject }
}
var DataRouterContext = import_react.createContext(null)
DataRouterContext.displayName = `DataRouter`
var DataRouterStateContext = import_react.createContext(null)
DataRouterStateContext.displayName = `DataRouterState`
var RSCRouterContext = import_react.createContext(!1),
  ViewTransitionContext = import_react.createContext({ isTransitioning: !1 })
ViewTransitionContext.displayName = `ViewTransition`
var FetchersContext = import_react.createContext(new Map())
FetchersContext.displayName = `Fetchers`
var AwaitContext = import_react.createContext(null)
AwaitContext.displayName = `Await`
var NavigationContext = import_react.createContext(null)
NavigationContext.displayName = `Navigation`
var LocationContext = import_react.createContext(null)
LocationContext.displayName = `Location`
var RouteContext = import_react.createContext({ outlet: null, matches: [], isDataRoute: !1 })
RouteContext.displayName = `Route`
var RouteErrorContext = import_react.createContext(null)
RouteErrorContext.displayName = `RouteError`
var ENABLE_DEV_WARNINGS = !0
function useHref(to, { relative } = {}) {
  invariant$1(useInRouterContext(), `useHref() may be used only in the context of a <Router> component.`)
  let { basename: basename$1, navigator } = import_react.useContext(NavigationContext),
    { hash: hash$1, pathname, search: search$1 } = useResolvedPath(to, { relative }),
    joinedPathname = pathname
  return basename$1 !== `/` && (joinedPathname = pathname === `/` ? basename$1 : joinPaths([basename$1, pathname])),
    navigator.createHref({ pathname: joinedPathname, search: search$1, hash: hash$1 })
}
function useInRouterContext() {
  return import_react.useContext(LocationContext) != null
}
function useLocation() {
  return invariant$1(useInRouterContext(), `useLocation() may be used only in the context of a <Router> component.`),
    import_react.useContext(LocationContext).location
}
var navigateEffectWarning =
  `You should call navigate() in a React.useEffect(), not when your component is first rendered.`
function useIsomorphicLayoutEffect$1(cb) {
  let isStatic = import_react.useContext(NavigationContext).static
  isStatic || import_react.useLayoutEffect(cb)
}
function useNavigate() {
  let { isDataRoute } = import_react.useContext(RouteContext)
  return isDataRoute ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
  invariant$1(useInRouterContext(), `useNavigate() may be used only in the context of a <Router> component.`)
  let dataRouterContext = import_react.useContext(DataRouterContext),
    { basename: basename$1, navigator } = import_react.useContext(NavigationContext),
    { matches } = import_react.useContext(RouteContext),
    { pathname: locationPathname } = useLocation(),
    routePathnamesJson = JSON.stringify(getResolveToMatches(matches)),
    activeRef = import_react.useRef(!1)
  useIsomorphicLayoutEffect$1(() => {
    activeRef.current = !0
  })
  let navigate = import_react.useCallback((to, options$2 = {}) => {
    if (warning(activeRef.current, navigateEffectWarning), !activeRef.current) return
    if (typeof to == `number`) {
      navigator.go(to)
      return
    }
    let path$1 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options$2.relative === `path`)
    dataRouterContext == null && basename$1 !== `/`
    && (path$1.pathname = path$1.pathname === `/` ? basename$1 : joinPaths([basename$1, path$1.pathname])),
      (options$2.replace ? navigator.replace : navigator.push)(path$1, options$2.state, options$2)
  }, [basename$1, navigator, routePathnamesJson, locationPathname, dataRouterContext])
  return navigate
}
var OutletContext = import_react.createContext(null)
function useOutlet(context$2) {
  let outlet = import_react.useContext(RouteContext).outlet
  return outlet && import_react.createElement(OutletContext.Provider, { value: context$2 }, outlet)
}
function useParams() {
  let { matches } = import_react.useContext(RouteContext), routeMatch = matches[matches.length - 1]
  return routeMatch ? routeMatch.params : {}
}
function useResolvedPath(to, { relative } = {}) {
  let { matches } = import_react.useContext(RouteContext),
    { pathname: locationPathname } = useLocation(),
    routePathnamesJson = JSON.stringify(getResolveToMatches(matches))
  return import_react.useMemo(
    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === `path`),
    [to, routePathnamesJson, locationPathname, relative],
  )
}
function useRoutesImpl(routes$2, locationArg, dataRouterState, future) {
  invariant$1(useInRouterContext(), `useRoutes() may be used only in the context of a <Router> component.`)
  let { navigator } = import_react.useContext(NavigationContext),
    { matches: parentMatches } = import_react.useContext(RouteContext),
    routeMatch = parentMatches[parentMatches.length - 1],
    parentParams = routeMatch ? routeMatch.params : {},
    parentPathname = routeMatch ? routeMatch.pathname : `/`,
    parentPathnameBase = routeMatch ? routeMatch.pathnameBase : `/`,
    parentRoute = routeMatch && routeMatch.route
  if (ENABLE_DEV_WARNINGS) {
    let parentPath = parentRoute && parentRoute.path || ``
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith(`*`) || parentPath.endsWith(`*?`),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${
        parentPath === `/` ? `*` : `${parentPath}/*`
      }">.`,
    )
  }
  let locationFromContext = useLocation(), location
  if (locationArg) {
    let parsedLocationArg = typeof locationArg == `string` ? parsePath(locationArg) : locationArg
    invariant$1(
      parentPathnameBase === `/` || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`,
    ), location = parsedLocationArg
  } else location = locationFromContext
  let pathname = location.pathname || `/`, remainingPathname = pathname
  if (parentPathnameBase !== `/`) {
    let parentSegments = parentPathnameBase.replace(/^\//, ``).split(`/`),
      segments = pathname.replace(/^\//, ``).split(`/`)
    remainingPathname = `/` + segments.slice(parentSegments.length).join(`/`)
  }
  let matches = matchRoutes(routes$2, { pathname: remainingPathname })
  ENABLE_DEV_WARNINGS
    && (warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `,
    ),
      warning(
        matches == null || matches[matches.length - 1].route.element !== void 0
          || matches[matches.length - 1].route.Component !== void 0
          || matches[matches.length - 1].route.lazy !== void 0,
        `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`,
      ))
  let renderedMatches = _renderMatches(
    matches && matches.map(match$13 =>
      Object.assign({}, match$13, {
        params: Object.assign({}, parentParams, match$13.params),
        pathname: joinPaths([
          parentPathnameBase,
          navigator.encodeLocation ? navigator.encodeLocation(match$13.pathname).pathname : match$13.pathname,
        ]),
        pathnameBase: match$13.pathnameBase === `/`
          ? parentPathnameBase
          : joinPaths([
            parentPathnameBase,
            navigator.encodeLocation ? navigator.encodeLocation(match$13.pathnameBase).pathname : match$13.pathnameBase,
          ]),
      })
    ),
    parentMatches,
    dataRouterState,
    future,
  )
  return locationArg && renderedMatches
    ? import_react.createElement(LocationContext.Provider, {
      value: {
        location: { pathname: `/`, search: ``, hash: ``, state: null, key: `default`, ...location },
        navigationType: `POP`,
      },
    }, renderedMatches)
    : renderedMatches
}
function DefaultErrorComponent() {
  let error = useRouteError(),
    message = isRouteErrorResponse(error)
      ? `${error.status} ${error.statusText}`
      : error instanceof Error
      ? error.message
      : JSON.stringify(error),
    stack = error instanceof Error ? error.stack : null,
    lightgrey = `rgba(200,200,200, 0.5)`,
    preStyles = { padding: `0.5rem`, backgroundColor: lightgrey },
    codeStyles = { padding: `2px 4px`, backgroundColor: lightgrey },
    devInfo = null
  return ENABLE_DEV_WARNINGS
    && (console.error(`Error handled by React Router default ErrorBoundary:`, error),
      devInfo = import_react.createElement(
        import_react.Fragment,
        null,
        import_react.createElement(`p`, null, ` Hey developer `),
        import_react.createElement(
          `p`,
          null,
          `You can provide a way better UX than this when your app throws errors by providing your own `,
          import_react.createElement(`code`, { style: codeStyles }, `ErrorBoundary`),
          ` or`,
          ` `,
          import_react.createElement(`code`, { style: codeStyles }, `errorElement`),
          ` prop on your route.`,
        ),
      )),
    import_react.createElement(
      import_react.Fragment,
      null,
      import_react.createElement(`h2`, null, `Unexpected Application Error!`),
      import_react.createElement(`h3`, { style: { fontStyle: `italic` } }, message),
      stack ? import_react.createElement(`pre`, { style: preStyles }, stack) : null,
      devInfo,
    )
}
var defaultErrorElement = import_react.createElement(DefaultErrorComponent, null),
  RenderErrorBoundary = class extends import_react.Component {
    constructor(props) {
      super(props), this.state = { location: props.location, revalidation: props.revalidation, error: props.error }
    }
    static getDerivedStateFromError(error) {
      return { error }
    }
    static getDerivedStateFromProps(props, state) {
      return state.location !== props.location || state.revalidation !== `idle` && props.revalidation === `idle`
        ? { error: props.error, location: props.location, revalidation: props.revalidation }
        : {
          error: props.error === void 0 ? state.error : props.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation,
        }
    }
    componentDidCatch(error, errorInfo) {
      console.error(`React Router caught the following error during render`, error, errorInfo)
    }
    render() {
      return this.state.error === void 0
        ? this.props.children
        : import_react.createElement(
          RouteContext.Provider,
          { value: this.props.routeContext },
          import_react.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component,
          }),
        )
    }
  }
function RenderedRoute({ routeContext, match: match$13, children: children$3 }) {
  let dataRouterContext = import_react.useContext(DataRouterContext)
  return dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext
    && (match$13.route.errorElement || match$13.route.ErrorBoundary)
    && (dataRouterContext.staticContext._deepestRenderedBoundaryId = match$13.route.id),
    import_react.createElement(RouteContext.Provider, { value: routeContext }, children$3)
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) return null
    if (dataRouterState.errors) matches = dataRouterState.matches
    else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches
    } else return null
  }
  let renderedMatches = matches, errors = dataRouterState?.errors
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m$12 => m$12.route.id && errors?.[m$12.route.id] !== void 0)
    invariant$1(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(`,`)}`,
    ), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1))
  }
  let renderFallback = !1, fallbackIndex = -1
  if (dataRouterState) {
    for (let i$14 = 0; i$14 < renderedMatches.length; i$14++) {
      let match$13 = renderedMatches[i$14]
      if (
        (match$13.route.HydrateFallback || match$13.route.hydrateFallbackElement) && (fallbackIndex = i$14),
          match$13.route.id
      ) {
        let { loaderData, errors: errors2 } = dataRouterState,
          needsToRunLoader = match$13.route.loader && !loaderData.hasOwnProperty(match$13.route.id)
            && (!errors2 || errors2[match$13.route.id] === void 0)
        if (match$13.route.lazy || needsToRunLoader) {
          renderFallback = !0,
            renderedMatches = fallbackIndex >= 0 ? renderedMatches.slice(0, fallbackIndex + 1) : [renderedMatches[0]]
          break
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match$13, index$4) => {
    let error, shouldRenderHydrateFallback = !1, errorElement = null, hydrateFallbackElement = null
    dataRouterState
      && (error = errors && match$13.route.id ? errors[match$13.route.id] : void 0,
        errorElement = match$13.route.errorElement || defaultErrorElement,
        renderFallback
        && (fallbackIndex < 0 && index$4 === 0
          ? (warningOnce(
            `route-fallback`,
            !1,
            'No `HydrateFallback` element provided to render during initial hydration',
          ),
            shouldRenderHydrateFallback = !0,
            hydrateFallbackElement = null)
          : fallbackIndex === index$4
            && (shouldRenderHydrateFallback = !0,
              hydrateFallbackElement = match$13.route.hydrateFallbackElement || null)))
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index$4 + 1)),
      getChildren = () => {
        let children$3
        return children$3 = error
          ? errorElement
          : shouldRenderHydrateFallback
          ? hydrateFallbackElement
          : match$13.route.Component
          ? import_react.createElement(match$13.route.Component, null)
          : match$13.route.element
          ? match$13.route.element
          : outlet,
          import_react.createElement(RenderedRoute, {
            match: match$13,
            routeContext: { outlet, matches: matches2, isDataRoute: dataRouterState != null },
            children: children$3,
          })
      }
    return dataRouterState && (match$13.route.ErrorBoundary || match$13.route.errorElement || index$4 === 0)
      ? import_react.createElement(RenderErrorBoundary, {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error,
        children: getChildren(),
        routeContext: { outlet: null, matches: matches2, isDataRoute: !0 },
      })
      : getChildren()
  }, null)
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function useDataRouterContext(hookName) {
  let ctx = import_react.useContext(DataRouterContext)
  return invariant$1(ctx, getDataRouterConsoleError(hookName)), ctx
}
function useDataRouterState(hookName) {
  let state = import_react.useContext(DataRouterStateContext)
  return invariant$1(state, getDataRouterConsoleError(hookName)), state
}
function useRouteContext(hookName) {
  let route$1 = import_react.useContext(RouteContext)
  return invariant$1(route$1, getDataRouterConsoleError(hookName)), route$1
}
function useCurrentRouteId(hookName) {
  let route$1 = useRouteContext(hookName), thisRoute = route$1.matches[route$1.matches.length - 1]
  return invariant$1(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique "id"`),
    thisRoute.route.id
}
function useRouteId() {
  return useCurrentRouteId(`useRouteId`)
}
function useNavigation() {
  let state = useDataRouterState(`useNavigation`)
  return state.navigation
}
function useMatches() {
  let { matches, loaderData } = useDataRouterState(`useMatches`)
  return import_react.useMemo(() => matches.map(m$12 => convertRouteMatchToUiMatch(m$12, loaderData)), [
    matches,
    loaderData,
  ])
}
function useRouteError() {
  let error = import_react.useContext(RouteErrorContext),
    state = useDataRouterState(`useRouteError`),
    routeId = useCurrentRouteId(`useRouteError`)
  return error === void 0 ? state.errors?.[routeId] : error
}
function useNavigateStable() {
  let { router: router$1 } = useDataRouterContext(`useNavigate`),
    id$2 = useCurrentRouteId(`useNavigate`),
    activeRef = import_react.useRef(!1)
  useIsomorphicLayoutEffect$1(() => {
    activeRef.current = !0
  })
  let navigate = import_react.useCallback(async (to, options$2 = {}) => {
    warning(activeRef.current, navigateEffectWarning),
      activeRef.current
      && (typeof to == `number`
        ? router$1.navigate(to)
        : await router$1.navigate(to, { fromRouteId: id$2, ...options$2 }))
  }, [router$1, id$2])
  return navigate
}
var alreadyWarned = {}
function warningOnce(key$1, cond, message) {
  !cond && !alreadyWarned[key$1] && (alreadyWarned[key$1] = !0, warning(!1, message))
}
var alreadyWarned2 = {}
function warnOnce(condition, message) {
  !condition && !alreadyWarned2[message] && (alreadyWarned2[message] = !0, console.warn(message))
}
function mapRouteProperties(route$1) {
  let updates = {
    hasErrorBoundary: route$1.hasErrorBoundary || route$1.ErrorBoundary != null || route$1.errorElement != null,
  }
  return route$1.Component
    && (ENABLE_DEV_WARNINGS && route$1.element
      && warning(!1, 'You should not include both `Component` and `element` on your route - `Component` will be used.'),
      Object.assign(updates, { element: import_react.createElement(route$1.Component), Component: void 0 })),
    route$1.HydrateFallback
    && (ENABLE_DEV_WARNINGS && route$1.hydrateFallbackElement
      && warning(
        !1,
        'You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.',
      ),
      Object.assign(updates, {
        hydrateFallbackElement: import_react.createElement(route$1.HydrateFallback),
        HydrateFallback: void 0,
      })),
    route$1.ErrorBoundary
    && (ENABLE_DEV_WARNINGS && route$1.errorElement
      && warning(
        !1,
        'You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.',
      ),
      Object.assign(updates, {
        errorElement: import_react.createElement(route$1.ErrorBoundary),
        ErrorBoundary: void 0,
      })),
    updates
}
var hydrationRouteProperties = [`HydrateFallback`, `hydrateFallbackElement`],
  Deferred = class {
    constructor() {
      this.status = `pending`,
        this.promise = new Promise((resolve, reject) => {
          this.resolve = value$2 => {
            this.status === `pending` && (this.status = `resolved`, resolve(value$2))
          },
            this.reject = reason => {
              this.status === `pending` && (this.status = `rejected`, reject(reason))
            }
        })
    }
  }
function RouterProvider({ router: router$1, flushSync: reactDomFlushSyncImpl }) {
  let [state, setStateImpl] = import_react.useState(router$1.state),
    [pendingState, setPendingState] = import_react.useState(),
    [vtContext, setVtContext] = import_react.useState({ isTransitioning: !1 }),
    [renderDfd, setRenderDfd] = import_react.useState(),
    [transition, setTransition] = import_react.useState(),
    [interruption$1, setInterruption] = import_react.useState(),
    fetcherData = import_react.useRef(new Map()),
    setState = import_react.useCallback((newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {
      newState.fetchers.forEach((fetcher, key$1) => {
        fetcher.data !== void 0 && fetcherData.current.set(key$1, fetcher.data)
      }),
        deletedFetchers.forEach(key$1 => fetcherData.current.delete(key$1)),
        warnOnce(
          flushSync === !1 || reactDomFlushSyncImpl != null,
          'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.',
        )
      let isViewTransitionAvailable = router$1.window != null && router$1.window.document != null
        && typeof router$1.window.document.startViewTransition == `function`
      if (
        warnOnce(
          viewTransitionOpts == null || isViewTransitionAvailable,
          'You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.',
        ), !viewTransitionOpts || !isViewTransitionAvailable
      ) {
        reactDomFlushSyncImpl && flushSync
          ? reactDomFlushSyncImpl(() => setStateImpl(newState))
          : import_react.startTransition(() => setStateImpl(newState))
        return
      }
      if (reactDomFlushSyncImpl && flushSync) {
        reactDomFlushSyncImpl(() => {
          transition && (renderDfd && renderDfd.resolve(), transition.skipTransition()),
            setVtContext({
              isTransitioning: !0,
              flushSync: !0,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation,
            })
        })
        let t$18 = router$1.window.document.startViewTransition(() => {
          reactDomFlushSyncImpl(() => setStateImpl(newState))
        })
        t$18.finished.finally(() => {
          reactDomFlushSyncImpl(() => {
            setRenderDfd(void 0), setTransition(void 0), setPendingState(void 0), setVtContext({ isTransitioning: !1 })
          })
        }), reactDomFlushSyncImpl(() => setTransition(t$18))
        return
      }
      transition
        ? (renderDfd && renderDfd.resolve(),
          transition.skipTransition(),
          setInterruption({
            state: newState,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation,
          }))
        : (setPendingState(newState),
          setVtContext({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation,
          }))
    }, [router$1.window, reactDomFlushSyncImpl, transition, renderDfd])
  import_react.useLayoutEffect(() => router$1.subscribe(setState), [router$1, setState]),
    import_react.useEffect(() => {
      vtContext.isTransitioning && !vtContext.flushSync && setRenderDfd(new Deferred())
    }, [vtContext]),
    import_react.useEffect(() => {
      if (renderDfd && pendingState && router$1.window) {
        let newState = pendingState,
          renderPromise = renderDfd.promise,
          transition2 = router$1.window.document.startViewTransition(async () => {
            import_react.startTransition(() => setStateImpl(newState)), await renderPromise
          })
        transition2.finished.finally(() => {
          setRenderDfd(void 0), setTransition(void 0), setPendingState(void 0), setVtContext({ isTransitioning: !1 })
        }), setTransition(transition2)
      }
    }, [pendingState, renderDfd, router$1.window]),
    import_react.useEffect(() => {
      renderDfd && pendingState && state.location.key === pendingState.location.key && renderDfd.resolve()
    }, [renderDfd, transition, state.location, pendingState]),
    import_react.useEffect(() => {
      !vtContext.isTransitioning && interruption$1
        && (setPendingState(interruption$1.state),
          setVtContext({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: interruption$1.currentLocation,
            nextLocation: interruption$1.nextLocation,
          }),
          setInterruption(void 0))
    }, [vtContext.isTransitioning, interruption$1])
  let navigator = import_react.useMemo(() => ({
      createHref: router$1.createHref,
      encodeLocation: router$1.encodeLocation,
      go: n$19 => router$1.navigate(n$19),
      push: (to, state2, opts) =>
        router$1.navigate(to, { state: state2, preventScrollReset: opts?.preventScrollReset }),
      replace: (to, state2, opts) =>
        router$1.navigate(to, { replace: !0, state: state2, preventScrollReset: opts?.preventScrollReset }),
    }), [router$1]),
    basename$1 = router$1.basename || `/`,
    dataRouterContext = import_react.useMemo(
      () => ({ router: router$1, navigator, static: !1, basename: basename$1 }),
      [router$1, navigator, basename$1],
    )
  return import_react.createElement(
    import_react.Fragment,
    null,
    import_react.createElement(
      DataRouterContext.Provider,
      { value: dataRouterContext },
      import_react.createElement(
        DataRouterStateContext.Provider,
        { value: state },
        import_react.createElement(
          FetchersContext.Provider,
          { value: fetcherData.current },
          import_react.createElement(
            ViewTransitionContext.Provider,
            { value: vtContext },
            import_react.createElement(
              Router,
              { basename: basename$1, location: state.location, navigationType: state.historyAction, navigator },
              import_react.createElement(MemoizedDataRoutes, {
                routes: router$1.routes,
                future: router$1.future,
                state,
              }),
            ),
          ),
        ),
      ),
    ),
    null,
  )
}
var MemoizedDataRoutes = import_react.memo(DataRoutes)
function DataRoutes({ routes: routes$2, future, state }) {
  return useRoutesImpl(routes$2, void 0, state, future)
}
function Outlet(props) {
  return useOutlet(props.context)
}
function Router(
  {
    basename: basenameProp = `/`,
    children: children$3 = null,
    location: locationProp,
    navigationType = `POP`,
    navigator,
    static: staticProp = !1,
  },
) {
  invariant$1(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`,
  )
  let basename$1 = basenameProp.replace(/^\/*/, `/`),
    navigationContext = import_react.useMemo(
      () => ({ basename: basename$1, navigator, static: staticProp, future: {} }),
      [basename$1, navigator, staticProp],
    )
  typeof locationProp == `string` && (locationProp = parsePath(locationProp))
  let { pathname = `/`, search: search$1 = ``, hash: hash$1 = ``, state = null, key: key$1 = `default` } = locationProp,
    locationContext = import_react.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename$1)
      return trailingPathname == null
        ? null
        : {
          location: { pathname: trailingPathname, search: search$1, hash: hash$1, state, key: key$1 },
          navigationType,
        }
    }, [basename$1, pathname, search$1, hash$1, state, key$1, navigationType])
  return warning(
    locationContext != null,
    `<Router basename="${basename$1}"> is not able to match the URL "${pathname}${search$1}${hash$1}" because it does not start with the basename, so the <Router> won't render anything.`,
  ),
    locationContext == null
      ? null
      : import_react.createElement(
        NavigationContext.Provider,
        { value: navigationContext },
        import_react.createElement(LocationContext.Provider, { children: children$3, value: locationContext }),
      )
}
var defaultMethod = `get`, defaultEncType = `application/x-www-form-urlencoded`
function isHtmlElement(object) {
  return object != null && typeof object.tagName == `string`
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === `button`
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === `form`
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === `input`
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (!target || target === `_self`) && !isModifiedEvent(event)
}
function createSearchParams(init = ``) {
  return new URLSearchParams(
    typeof init == `string` || Array.isArray(init) || init instanceof URLSearchParams
      ? init
      : Object.keys(init).reduce((memo2, key$1) => {
        let value$2 = init[key$1]
        return memo2.concat(Array.isArray(value$2) ? value$2.map(v$4 => [key$1, v$4]) : [[key$1, value$2]])
      }, []),
  )
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch)
  return defaultSearchParams && defaultSearchParams.forEach((_$1, key$1) => {
    searchParams.has(key$1) || defaultSearchParams.getAll(key$1).forEach(value$2 => {
      searchParams.append(key$1, value$2)
    })
  }),
    searchParams
}
var _formDataSupportsSubmitter = null
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(document.createElement(`form`), 0), _formDataSupportsSubmitter = !1
    } catch {
      _formDataSupportsSubmitter = !0
    }
  }
  return _formDataSupportsSubmitter
}
var supportedFormEncTypes = new Set([`application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`])
function getFormEncType(encType) {
  return encType != null && !supportedFormEncTypes.has(encType)
    ? (warning(
      !1,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`,
    ),
      null)
    : encType
}
function getFormSubmissionInfo(target, basename$1) {
  let method, action, encType, formData, body$2
  if (isFormElement(target)) {
    let attr = target.getAttribute(`action`)
    action = attr ? stripBasename(attr, basename$1) : null,
      method = target.getAttribute(`method`) || defaultMethod,
      encType = getFormEncType(target.getAttribute(`enctype`)) || defaultEncType,
      formData = new FormData(target)
  } else if (
    isButtonElement(target) || isInputElement(target) && (target.type === `submit` || target.type === `image`)
  ) {
    let form = target.form
    if (form == null) throw Error(`Cannot submit a <button> or <input type="submit"> without a <form>`)
    let attr = target.getAttribute(`formaction`) || form.getAttribute(`action`)
    if (
      action = attr ? stripBasename(attr, basename$1) : null,
        method = target.getAttribute(`formmethod`) || form.getAttribute(`method`) || defaultMethod,
        encType = getFormEncType(target.getAttribute(`formenctype`)) || getFormEncType(form.getAttribute(`enctype`))
          || defaultEncType,
        formData = new FormData(form, target),
        !isFormDataSubmitterSupported()
    ) {
      let { name, type: type$2, value: value$2 } = target
      if (type$2 === `image`) {
        let prefix$1 = name ? `${name}.` : ``
        formData.append(`${prefix$1}x`, `0`), formData.append(`${prefix$1}y`, `0`)
      } else name && formData.append(name, value$2)
    }
  } else if (isHtmlElement(target)) {
    throw Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`)
  } else method = defaultMethod, action = null, encType = defaultEncType, body$2 = target
  return formData && encType === `text/plain` && (body$2 = formData, formData = void 0),
    { action, method: method.toLowerCase(), encType, formData, body: body$2 }
}
var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(`\0`)
function invariant2(value$2, message) {
  if (value$2 === !1 || value$2 == null) throw Error(message)
}
var SingleFetchRedirectSymbol = Symbol(`SingleFetchRedirect`)
function singleFetchUrl(reqUrl, basename$1, extension$1) {
  let url = typeof reqUrl == `string`
    ? new URL(reqUrl, typeof window > `u` ? `server://singlefetch/` : window.location.origin)
    : reqUrl
  return url.pathname === `/`
    ? url.pathname = `_root.${extension$1}`
    : basename$1 && stripBasename(url.pathname, basename$1) === `/`
    ? url.pathname = `${basename$1.replace(/\/$/, ``)}/_root.${extension$1}`
    : url.pathname = `${url.pathname.replace(/\/$/, ``)}.${extension$1}`,
    url
}
async function loadRouteModule(route$1, routeModulesCache) {
  if (route$1.id in routeModulesCache) return routeModulesCache[route$1.id]
  try {
    let routeModule = await import(route$1.module)
    return routeModulesCache[route$1.id] = routeModule, routeModule
  } catch (error) {
    return console.error(`Error loading route module \`${route$1.module}\`, reloading page...`),
      console.error(error),
      window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
      window.location.reload(),
      new Promise(() => {})
  }
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page == `string`
}
function isHtmlLinkDescriptor(object) {
  return object == null
    ? !1
    : object.href == null
    ? object.rel === `preload` && typeof object.imageSrcSet == `string` && typeof object.imageSizes == `string`
    : typeof object.rel == `string` && typeof object.href == `string`
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(matches.map(async match$13 => {
    let route$1 = manifest.routes[match$13.route.id]
    if (route$1) {
      let mod = await loadRouteModule(route$1, routeModules)
      return mod.links ? mod.links() : []
    }
    return []
  }))
  return dedupeLinkDescriptors(
    links.flat(1).filter(isHtmlLinkDescriptor).filter(link$2 => link$2.rel === `stylesheet` || link$2.rel === `preload`)
      .map(link$2 =>
        link$2.rel === `stylesheet` ? { ...link$2, rel: `prefetch`, as: `style` } : { ...link$2, rel: `prefetch` }
      ),
  )
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match$13, index$4) =>
      currentMatches[index$4] ? match$13.route.id !== currentMatches[index$4].route.id : !0,
    matchPathChanged = (match$13, index$4) =>
      currentMatches[index$4].pathname !== match$13.pathname
      || currentMatches[index$4].route.path?.endsWith(`*`)
        && currentMatches[index$4].params[`*`] !== match$13.params[`*`]
  return mode === `assets`
    ? nextMatches.filter((match$13, index$4) => isNew(match$13, index$4) || matchPathChanged(match$13, index$4))
    : mode === `data`
    ? nextMatches.filter((match$13, index$4) => {
      let manifestRoute = manifest.routes[match$13.route.id]
      if (!manifestRoute || !manifestRoute.hasLoader) return !1
      if (isNew(match$13, index$4) || matchPathChanged(match$13, index$4)) return !0
      if (match$13.route.shouldRevalidate) {
        let routeChoice = match$13.route.shouldRevalidate({
          currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match$13.params,
          defaultShouldRevalidate: !0,
        })
        if (typeof routeChoice == `boolean`) return routeChoice
      }
      return !0
    })
    : []
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map(match$13 => {
      let route$1 = manifest.routes[match$13.route.id]
      if (!route$1) return []
      let hrefs = [route$1.module]
      return route$1.clientActionModule && (hrefs = hrefs.concat(route$1.clientActionModule)),
        route$1.clientLoaderModule && (hrefs = hrefs.concat(route$1.clientLoaderModule)),
        includeHydrateFallback && route$1.hydrateFallbackModule
        && (hrefs = hrefs.concat(route$1.hydrateFallbackModule)),
        route$1.imports && (hrefs = hrefs.concat(route$1.imports)),
        hrefs
    }).flat(1),
  )
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)]
}
function sortKeys(obj) {
  let sorted = {}, keys$6 = Object.keys(obj).sort()
  for (let key$1 of keys$6) sorted[key$1] = obj[key$1]
  return sorted
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set$6 = new Set(), preloadsSet = new Set(preloads)
  return descriptors.reduce((deduped, descriptor$2) => {
    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor$2) && descriptor$2.as === `script`
      && descriptor$2.href && preloadsSet.has(descriptor$2.href)
    if (alreadyModulePreload) return deduped
    let key$1 = JSON.stringify(sortKeys(descriptor$2))
    return set$6.has(key$1) || (set$6.add(key$1), deduped.push({ key: key$1, link: descriptor$2 })), deduped
  }, [])
}
function useDataRouterContext2() {
  let context$2 = import_react.useContext(DataRouterContext)
  return invariant2(context$2, `You must render this element inside a <DataRouterContext.Provider> element`), context$2
}
function useDataRouterStateContext() {
  let context$2 = import_react.useContext(DataRouterStateContext)
  return invariant2(context$2, `You must render this element inside a <DataRouterStateContext.Provider> element`),
    context$2
}
var FrameworkContext = import_react.createContext(void 0)
FrameworkContext.displayName = `FrameworkContext`
function useFrameworkContext() {
  let context$2 = import_react.useContext(FrameworkContext)
  return invariant2(context$2, `You must render this element inside a <HydratedRouter> element`), context$2
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = import_react.useContext(FrameworkContext),
    [maybePrefetch, setMaybePrefetch] = import_react.useState(!1),
    [shouldPrefetch, setShouldPrefetch] = import_react.useState(!1),
    { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps,
    ref = import_react.useRef(null)
  import_react.useEffect(() => {
    if (prefetch === `render` && setShouldPrefetch(!0), prefetch === `viewport`) {
      let callback = entries$2 => {
          entries$2.forEach(entry => {
            setShouldPrefetch(entry.isIntersecting)
          })
        },
        observer = new IntersectionObserver(callback, { threshold: .5 })
      return ref.current && observer.observe(ref.current), () => {
        observer.disconnect()
      }
    }
  }, [prefetch]),
    import_react.useEffect(() => {
      if (maybePrefetch) {
        let id$2 = setTimeout(() => {
          setShouldPrefetch(!0)
        }, 100)
        return () => {
          clearTimeout(id$2)
        }
      }
    }, [maybePrefetch])
  let setIntent = () => {
      setMaybePrefetch(!0)
    },
    cancelIntent = () => {
      setMaybePrefetch(!1), setShouldPrefetch(!1)
    }
  return frameworkContext
    ? prefetch === `intent`
      ? [shouldPrefetch, ref, {
        onFocus: composeEventHandlers$1(onFocus, setIntent),
        onBlur: composeEventHandlers$1(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers$1(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers$1(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers$1(onTouchStart, setIntent),
      }]
      : [shouldPrefetch, ref, {}]
    : [!1, ref, {}]
}
function composeEventHandlers$1(theirHandler, ourHandler) {
  return event => {
    theirHandler && theirHandler(event), event.defaultPrevented || ourHandler(event)
  }
}
function PrefetchPageLinks({ page, ...dataLinkProps }) {
  let { router: router$1 } = useDataRouterContext2(),
    matches = import_react.useMemo(() => matchRoutes(router$1.routes, page, router$1.basename), [
      router$1.routes,
      page,
      router$1.basename,
    ])
  return matches ? import_react.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps }) : null
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext(),
    [keyedPrefetchLinks, setKeyedPrefetchLinks] = import_react.useState([])
  return import_react.useEffect(() => {
    let interrupted$2 = !1
    return getKeyedPrefetchLinks(matches, manifest, routeModules).then(links => {
      interrupted$2 || setKeyedPrefetchLinks(links)
    }),
      () => {
        interrupted$2 = !0
      }
  }, [matches, manifest, routeModules]),
    keyedPrefetchLinks
}
function PrefetchPageLinksImpl({ page, matches: nextMatches, ...linkProps }) {
  let location = useLocation(),
    { manifest, routeModules } = useFrameworkContext(),
    { basename: basename$1 } = useDataRouterContext2(),
    { loaderData, matches } = useDataRouterStateContext(),
    newMatchesForData = import_react.useMemo(
      () => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, `data`),
      [page, nextMatches, matches, manifest, location],
    ),
    newMatchesForAssets = import_react.useMemo(
      () => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, `assets`),
      [page, nextMatches, matches, manifest, location],
    ),
    dataHrefs = import_react.useMemo(() => {
      if (page === location.pathname + location.search + location.hash) return []
      let routesParams = new Set(), foundOptOutRoute = !1
      if (
        nextMatches.forEach(m$12 => {
          let manifestRoute = manifest.routes[m$12.route.id]
          !manifestRoute || !manifestRoute.hasLoader
            || (!newMatchesForData.some(m2 => m2.route.id === m$12.route.id) && m$12.route.id in loaderData
                  && routeModules[m$12.route.id]?.shouldRevalidate || manifestRoute.hasClientLoader
              ? foundOptOutRoute = !0
              : routesParams.add(m$12.route.id))
        }), routesParams.size === 0
      ) return []
      let url = singleFetchUrl(page, basename$1, `data`)
      return foundOptOutRoute && routesParams.size > 0
        && url.searchParams.set(
          `_routes`,
          nextMatches.filter(m$12 => routesParams.has(m$12.route.id)).map(m$12 => m$12.route.id).join(`,`),
        ),
        [url.pathname + url.search]
    }, [basename$1, loaderData, location, manifest, newMatchesForData, nextMatches, page, routeModules]),
    moduleHrefs = import_react.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [
      newMatchesForAssets,
      manifest,
    ]),
    keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets)
  return import_react.createElement(
    import_react.Fragment,
    null,
    dataHrefs.map(href =>
      import_react.createElement(`link`, { key: href, rel: `prefetch`, as: `fetch`, href, ...linkProps })
    ),
    moduleHrefs.map(href =>
      import_react.createElement(`link`, { key: href, rel: `modulepreload`, href, ...linkProps })
    ),
    keyedPrefetchLinks.map(({ key: key$1, link: link$2 }) =>
      import_react.createElement(`link`, { key: key$1, ...link$2 })
    ),
  )
}
function mergeRefs(...refs) {
  return value$2 => {
    refs.forEach(ref => {
      typeof ref == `function` ? ref(value$2) : ref != null && (ref.current = value$2)
    })
  }
}
var isBrowser = typeof window < `u` && window.document !== void 0 && window.document.createElement !== void 0
try {
  isBrowser && (window.__reactRouterVersion = `7.7.0`)
} catch {}
function createBrowserRouter(routes$2, opts) {
  return createRouter({
    basename: opts?.basename,
    unstable_getContext: opts?.unstable_getContext,
    future: opts?.future,
    history: createBrowserHistory({ window: opts?.window }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes: routes$2,
    mapRouteProperties,
    hydrationRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window,
  }).initialize()
}
function parseHydrationData() {
  let state = window?.__staticRouterHydrationData
  return state && state.errors && (state = { ...state, errors: deserializeErrors(state.errors) }), state
}
function deserializeErrors(errors) {
  if (!errors) return null
  let entries$2 = Object.entries(errors), serialized = {}
  for (let [key$1, val] of entries$2) {
    if (val && val.__type === `RouteErrorResponse`) {
      serialized[key$1] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === !0)
    } else if (val && val.__type === `Error`) {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType]
        if (typeof ErrorConstructor == `function`) {
          try {
            let error = new ErrorConstructor(val.message)
            error.stack = ``, serialized[key$1] = error
          } catch {
          }
        }
      }
      if (serialized[key$1] == null) {
        let error = Error(val.message)
        error.stack = ``, serialized[key$1] = error
      }
    } else serialized[key$1] = val
  }
  return serialized
}
function HistoryRouter({ basename: basename$1, children: children$3, history }) {
  let [state, setStateImpl] = import_react.useState({ action: history.action, location: history.location }),
    setState = import_react.useCallback(newState => {
      import_react.startTransition(() => setStateImpl(newState))
    }, [setStateImpl])
  return import_react.useLayoutEffect(() => history.listen(setState), [history, setState]),
    import_react.createElement(Router, {
      basename: basename$1,
      children: children$3,
      location: state.location,
      navigationType: state.action,
      navigator: history,
    })
}
HistoryRouter.displayName = `unstable_HistoryRouter`
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Link = import_react.forwardRef(
    function(
      {
        onClick,
        discover = `render`,
        prefetch = `none`,
        relative,
        reloadDocument,
        replace: replace2,
        state,
        target,
        to,
        preventScrollReset,
        viewTransition,
        ...rest
      },
      forwardedRef,
    ) {
      let { basename: basename$1 } = import_react.useContext(NavigationContext),
        isAbsolute = typeof to == `string` && ABSOLUTE_URL_REGEX2.test(to),
        absoluteHref,
        isExternal = !1
      if (typeof to == `string` && isAbsolute && (absoluteHref = to, isBrowser)) {
        try {
          let currentUrl = new URL(window.location.href),
            targetUrl = to.startsWith(`//`) ? new URL(currentUrl.protocol + to) : new URL(to),
            path$1 = stripBasename(targetUrl.pathname, basename$1)
          targetUrl.origin === currentUrl.origin && path$1 != null
            ? to = path$1 + targetUrl.search + targetUrl.hash
            : isExternal = !0
        } catch {
          warning(
            !1,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`,
          )
        }
      }
      let href = useHref(to, { relative }),
        [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest),
        internalOnClick = useLinkClickHandler(to, {
          replace: replace2,
          state,
          target,
          preventScrollReset,
          relative,
          viewTransition,
        })
      function handleClick(event) {
        onClick && onClick(event), event.defaultPrevented || internalOnClick(event)
      }
      let link$2 = import_react.createElement(`a`, {
        ...rest,
        ...prefetchHandlers,
        href: absoluteHref || href,
        onClick: isExternal || reloadDocument ? onClick : handleClick,
        ref: mergeRefs(forwardedRef, prefetchRef),
        target,
        'data-discover': !isAbsolute && discover === `render` ? `true` : void 0,
      })
      return shouldPrefetch && !isAbsolute
        ? import_react.createElement(
          import_react.Fragment,
          null,
          link$2,
          import_react.createElement(PrefetchPageLinks, { page: href }),
        )
        : link$2
    },
  )
Link.displayName = `Link`
var NavLink = import_react.forwardRef(
  function(
    {
      'aria-current': ariaCurrentProp = `page`,
      caseSensitive = !1,
      className: classNameProp = ``,
      end: end$2 = !1,
      style: styleProp,
      to,
      viewTransition,
      children: children$3,
      ...rest
    },
    ref,
  ) {
    let path$1 = useResolvedPath(to, { relative: rest.relative }),
      location = useLocation(),
      routerState = import_react.useContext(DataRouterStateContext),
      { navigator, basename: basename$1 } = import_react.useContext(NavigationContext),
      isTransitioning = routerState != null && useViewTransitionState(path$1) && viewTransition === !0,
      toPathname = navigator.encodeLocation ? navigator.encodeLocation(path$1).pathname : path$1.pathname,
      locationPathname = location.pathname,
      nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location
        ? routerState.navigation.location.pathname
        : null
    caseSensitive
    || (locationPathname = locationPathname.toLowerCase(),
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null,
      toPathname = toPathname.toLowerCase()),
      nextLocationPathname && basename$1
      && (nextLocationPathname = stripBasename(nextLocationPathname, basename$1) || nextLocationPathname)
    let endSlashPosition = toPathname !== `/` && toPathname.endsWith(`/`) ? toPathname.length - 1 : toPathname.length,
      isActive$2 = locationPathname === toPathname
        || !end$2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === `/`,
      isPending = nextLocationPathname != null
        && (nextLocationPathname === toPathname
          || !end$2 && nextLocationPathname.startsWith(toPathname)
            && nextLocationPathname.charAt(toPathname.length) === `/`),
      renderProps = { isActive: isActive$2, isPending, isTransitioning },
      ariaCurrent = isActive$2 ? ariaCurrentProp : void 0,
      className
    className = typeof classNameProp == `function`
      ? classNameProp(renderProps)
      : [
        classNameProp,
        isActive$2 ? `active` : null,
        isPending ? `pending` : null,
        isTransitioning ? `transitioning` : null,
      ].filter(Boolean).join(` `)
    let style$1 = typeof styleProp == `function` ? styleProp(renderProps) : styleProp
    return import_react.createElement(Link, {
      ...rest,
      'aria-current': ariaCurrent,
      className,
      ref,
      style: style$1,
      to,
      viewTransition,
    }, typeof children$3 == `function` ? children$3(renderProps) : children$3)
  },
)
NavLink.displayName = `NavLink`
var Form = import_react.forwardRef(
  (
    {
      discover = `render`,
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace2,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition,
      ...props
    },
    forwardedRef,
  ) => {
    let submit = useSubmit(),
      formAction = useFormAction(action, { relative }),
      formMethod = method.toLowerCase() === `get` ? `get` : `post`,
      isAbsolute = typeof action == `string` && ABSOLUTE_URL_REGEX2.test(action),
      submitHandler = event => {
        if (onSubmit && onSubmit(event), event.defaultPrevented) return
        event.preventDefault()
        let submitter = event.nativeEvent.submitter, submitMethod = submitter?.getAttribute(`formmethod`) || method
        submit(submitter || event.currentTarget, {
          fetcherKey,
          method: submitMethod,
          navigate,
          replace: replace2,
          state,
          relative,
          preventScrollReset,
          viewTransition,
        })
      }
    return import_react.createElement(`form`, {
      ref: forwardedRef,
      method: formMethod,
      action: formAction,
      onSubmit: reloadDocument ? onSubmit : submitHandler,
      ...props,
      'data-discover': !isAbsolute && discover === `render` ? `true` : void 0,
    })
  },
)
Form.displayName = `Form`
function ScrollRestoration({ getKey, storageKey, ...props }) {
  let remixContext = import_react.useContext(FrameworkContext),
    { basename: basename$1 } = import_react.useContext(NavigationContext),
    location = useLocation(),
    matches = useMatches()
  useScrollRestoration({ getKey, storageKey })
  let ssrKey = import_react.useMemo(() => {
    if (!remixContext || !getKey) return null
    let userKey = getScrollRestorationKey(location, matches, basename$1, getKey)
    return userKey === location.key ? null : userKey
  }, [])
  if (!remixContext || remixContext.isSpaMode) return null
  let restoreScroll = ((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key$1 = Math.random().toString(32).slice(2)
      window.history.replaceState({ key: key$1 }, ``)
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || `{}`),
        storedY = positions[restoreKey || window.history.state.key]
      typeof storedY == `number` && window.scrollTo(0, storedY)
    } catch (error) {
      console.error(error), sessionStorage.removeItem(storageKey2)
    }
  }).toString()
  return import_react.createElement(`script`, {
    ...props,
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)}, ${
        JSON.stringify(ssrKey)
      })`,
    },
  })
}
ScrollRestoration.displayName = `ScrollRestoration`
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function useDataRouterContext3(hookName) {
  let ctx = import_react.useContext(DataRouterContext)
  return invariant$1(ctx, getDataRouterConsoleError2(hookName)), ctx
}
function useDataRouterState2(hookName) {
  let state = import_react.useContext(DataRouterStateContext)
  return invariant$1(state, getDataRouterConsoleError2(hookName)), state
}
function useLinkClickHandler(
  to,
  { target, replace: replaceProp, state, preventScrollReset, relative, viewTransition } = {},
) {
  let navigate = useNavigate(), location = useLocation(), path$1 = useResolvedPath(to, { relative })
  return import_react.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault()
      let replace2 = replaceProp === void 0 ? createPath(location) === createPath(path$1) : replaceProp
      navigate(to, { replace: replace2, state, preventScrollReset, relative, viewTransition })
    }
  }, [location, navigate, path$1, replaceProp, state, target, to, preventScrollReset, relative, viewTransition])
}
function useSearchParams(defaultInit) {
  warning(
    typeof URLSearchParams < `u`,
    'You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.',
  )
  let defaultSearchParamsRef = import_react.useRef(createSearchParams(defaultInit)),
    hasSetSearchParamsRef = import_react.useRef(!1),
    location = useLocation(),
    searchParams = import_react.useMemo(
      () =>
        getSearchParamsForLocation(
          location.search,
          hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current,
        ),
      [location.search],
    ),
    navigate = useNavigate(),
    setSearchParams = import_react.useCallback((nextInit, navigateOptions) => {
      let newSearchParams = createSearchParams(
        typeof nextInit == `function` ? nextInit(new URLSearchParams(searchParams)) : nextInit,
      )
      hasSetSearchParamsRef.current = !0, navigate(`?` + newSearchParams, navigateOptions)
    }, [navigate, searchParams])
  return [searchParams, setSearchParams]
}
var fetcherId = 0, getUniqueFetcherId = () => `__${String(++fetcherId)}__`
function useSubmit() {
  let { router: router$1 } = useDataRouterContext3(`useSubmit`),
    { basename: basename$1 } = import_react.useContext(NavigationContext),
    currentRouteId = useRouteId()
  return import_react.useCallback(async (target, options$2 = {}) => {
    let { action, method, encType, formData, body: body$2 } = getFormSubmissionInfo(target, basename$1)
    if (options$2.navigate === !1) {
      let key$1 = options$2.fetcherKey || getUniqueFetcherId()
      await router$1.fetch(key$1, currentRouteId, options$2.action || action, {
        preventScrollReset: options$2.preventScrollReset,
        formData,
        body: body$2,
        formMethod: options$2.method || method,
        formEncType: options$2.encType || encType,
        flushSync: options$2.flushSync,
      })
    } else {await router$1.navigate(options$2.action || action, {
        preventScrollReset: options$2.preventScrollReset,
        formData,
        body: body$2,
        formMethod: options$2.method || method,
        formEncType: options$2.encType || encType,
        replace: options$2.replace,
        state: options$2.state,
        fromRouteId: currentRouteId,
        flushSync: options$2.flushSync,
        viewTransition: options$2.viewTransition,
      })}
  }, [router$1, basename$1, currentRouteId])
}
function useFormAction(action, { relative } = {}) {
  let { basename: basename$1 } = import_react.useContext(NavigationContext),
    routeContext = import_react.useContext(RouteContext)
  invariant$1(routeContext, `useFormAction must be used inside a RouteContext`)
  let [match$13] = routeContext.matches.slice(-1),
    path$1 = { ...useResolvedPath(action || `.`, { relative }) },
    location = useLocation()
  if (action == null) {
    path$1.search = location.search
    let params = new URLSearchParams(path$1.search),
      indexValues = params.getAll(`index`),
      hasNakedIndexParam = indexValues.some(v$4 => v$4 === ``)
    if (hasNakedIndexParam) {
      params.delete(`index`), indexValues.filter(v$4 => v$4).forEach(v$4 => params.append(`index`, v$4))
      let qs = params.toString()
      path$1.search = qs ? `?${qs}` : ``
    }
  }
  return (!action || action === `.`) && match$13.route.index
    && (path$1.search = path$1.search ? path$1.search.replace(/^\?/, `?index&`) : `?index`),
    basename$1 !== `/`
    && (path$1.pathname = path$1.pathname === `/` ? basename$1 : joinPaths([basename$1, path$1.pathname])),
    createPath(path$1)
}
var SCROLL_RESTORATION_STORAGE_KEY = `react-router-scroll-positions`, savedScrollPositions = {}
function getScrollRestorationKey(location, matches, basename$1, getKey) {
  let key$1 = null
  return getKey
    && (key$1 = getKey(
      basename$1 === `/`
        ? location
        : { ...location, pathname: stripBasename(location.pathname, basename$1) || location.pathname },
      matches,
    )),
    key$1 ??= location.key,
    key$1
}
function useScrollRestoration({ getKey, storageKey } = {}) {
  let { router: router$1 } = useDataRouterContext3(`useScrollRestoration`),
    { restoreScrollPosition, preventScrollReset } = useDataRouterState2(`useScrollRestoration`),
    { basename: basename$1 } = import_react.useContext(NavigationContext),
    location = useLocation(),
    matches = useMatches(),
    navigation = useNavigation()
  import_react.useEffect(() => (window.history.scrollRestoration = `manual`, () => {
    window.history.scrollRestoration = `auto`
  }), []),
    usePageHide(import_react.useCallback(() => {
      if (navigation.state === `idle`) {
        let key$1 = getScrollRestorationKey(location, matches, basename$1, getKey)
        savedScrollPositions[key$1] = window.scrollY
      }
      try {
        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions))
      } catch (error) {
        warning(
          !1,
          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`,
        )
      }
      window.history.scrollRestoration = `auto`
    }, [navigation.state, getKey, basename$1, location, matches, storageKey])),
    typeof document < `u` && (import_react.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY)
        sessionPositions && (savedScrollPositions = JSON.parse(sessionPositions))
      } catch {}
    }, [storageKey]),
      import_react.useLayoutEffect(() => {
        let disableScrollRestoration = router$1?.enableScrollRestoration(
          savedScrollPositions,
          () => window.scrollY,
          getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename$1, getKey) : void 0,
        )
        return () => disableScrollRestoration && disableScrollRestoration()
      }, [router$1, basename$1, getKey]),
      import_react.useLayoutEffect(() => {
        if (restoreScrollPosition !== !1) {
          if (typeof restoreScrollPosition == `number`) {
            window.scrollTo(0, restoreScrollPosition)
            return
          }
          try {
            if (location.hash) {
              let el = document.getElementById(decodeURIComponent(location.hash.slice(1)))
              if (el) {
                el.scrollIntoView()
                return
              }
            }
          } catch {
            warning(!1, `"${location.hash.slice(1)}" is not a decodable element ID. The view will not scroll to it.`)
          }
          preventScrollReset !== !0 && window.scrollTo(0, 0)
        }
      }, [location, restoreScrollPosition, preventScrollReset]))
}
function usePageHide(callback, options$2) {
  let { capture: capture$1 } = options$2 || {}
  import_react.useEffect(() => {
    let opts = capture$1 == null ? void 0 : { capture: capture$1 }
    return window.addEventListener(`pagehide`, callback, opts), () => {
      window.removeEventListener(`pagehide`, callback, opts)
    }
  }, [callback, capture$1])
}
function useViewTransitionState(to, opts = {}) {
  let vtContext = import_react.useContext(ViewTransitionContext)
  invariant$1(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?",
  )
  let { basename: basename$1 } = useDataRouterContext3(`useViewTransitionState`),
    path$1 = useResolvedPath(to, { relative: opts.relative })
  if (!vtContext.isTransitioning) return !1
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename$1) || vtContext.currentLocation.pathname,
    nextPath = stripBasename(vtContext.nextLocation.pathname, basename$1) || vtContext.nextLocation.pathname
  return matchPath(path$1.pathname, nextPath) != null || matchPath(path$1.pathname, currentPath) != null
}
const templateConfig = {
    name: `My Developer Portal`,
    description: `Explore and integrate with our GraphQL API`,
    build: { architecture: `ssg`, base: `/` },
    server: { port: 3e3, routes: { assets: `/assets` } },
    templateVariables: { title: `My Developer Portal` },
    home: {
      enabled: !0,
      hero: {
        enabled: !0,
        title: `My Developer Portal`,
        tagline: `Explore and integrate with our GraphQL API`,
        layout: `asymmetric`,
      },
      socialProof: !1,
      socialMedia: !1,
      examples: { enabled: !0, maxExamples: 3, filter: { _tag: `DirectedFilterAllowAll` } },
      quickStart: !1,
      stats: !1,
      changelog: !1,
      resources: !1,
    },
    branding: { logoDesignedFor: `light` },
    ssr: { enabled: !0 },
    warnings: { interactiveWithoutSchema: { enabled: !0 } },
    paths: {
      project: {
        rootDir: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples`,
        relative: {
          build: {
            root: `build`,
            relative: { assets: { root: `assets`, relative: { schemas: `schemas` } }, serverEntrypoint: `app.js` },
          },
          pages: `pages`,
          public: { root: `public`, logo: `logo.svg` },
        },
        absolute: {
          build: {
            root: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/build`,
            assets: {
              root: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/build/assets`,
              schemas: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/build/assets/schemas`,
            },
            serverEntrypoint: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/build/app.js`,
          },
          pages: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/pages`,
          public: {
            root: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/public`,
            logo: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/public/logo.svg`,
          },
        },
      },
      framework: {
        name: `polen`,
        isRunningFromSource: !1,
        static: { source: `/Users/jasonkuhrt/projects/the-guild-org/polen/build`, build: `build` },
        rootDir: `/Users/jasonkuhrt/projects/the-guild-org/polen`,
        sourceExtension: `.js`,
        sourceDir: `/Users/jasonkuhrt/projects/the-guild-org/polen/build`,
        template: {
          absolute: {
            rootDir: `/Users/jasonkuhrt/projects/the-guild-org/polen/build/template`,
            server: {
              app: `/Users/jasonkuhrt/projects/the-guild-org/polen/build/template/server/app.js`,
              entrypoint: `/Users/jasonkuhrt/projects/the-guild-org/polen/build/template/server/main.js`,
            },
            client: { entrypoint: `/Users/jasonkuhrt/projects/the-guild-org/polen/build/template/entry.client.js` },
          },
          relative: {
            rootDir: `build/template`,
            server: { app: `build/template/server/app.js`, entrypoint: `build/template/server/main.js` },
            client: { entrypoint: `build/template/entry.client.js` },
          },
        },
        devAssets: {
          relative: `node_modules/.vite/polen-assets`,
          absolute: `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/node_modules/.vite/polen-assets`,
          schemas:
            `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/node_modules/.vite/polen-assets/schemas`,
        },
        generatedTypes: {
          relative: `node_modules/@types/polen-generated`,
          absolute:
            `/Users/jasonkuhrt/projects/the-guild-org/polen/src/api/examples/node_modules/@types/polen-generated`,
        },
      },
    },
    advanced: { isSelfContainedMode: !1, explorer: !1, debug: !1 },
    schema: { enabled: !1 },
    examples: { display: `all`, enabled: !1 },
  },
  isFunction$2 = input => typeof input == `function`,
  dual = function(arity, body$2) {
    if (typeof arity == `function`) {
      return function() {
        return arity(arguments) ? body$2.apply(this, arguments) : self$1 => body$2(self$1, ...arguments)
      }
    }
    switch (arity) {
      case 0:
      case 1:
        throw RangeError(`Invalid arity ${arity}`)
      case 2:
        return function(a$22, b$3) {
          return arguments.length >= 2 ? body$2(a$22, b$3) : function(self$1) {
            return body$2(self$1, a$22)
          }
        }
      case 3:
        return function(a$22, b$3, c$3) {
          return arguments.length >= 3 ? body$2(a$22, b$3, c$3) : function(self$1) {
            return body$2(self$1, a$22, b$3)
          }
        }
      case 4:
        return function(a$22, b$3, c$3, d$7) {
          return arguments.length >= 4 ? body$2(a$22, b$3, c$3, d$7) : function(self$1) {
            return body$2(self$1, a$22, b$3, c$3)
          }
        }
      case 5:
        return function(a$22, b$3, c$3, d$7, e$26) {
          return arguments.length >= 5 ? body$2(a$22, b$3, c$3, d$7, e$26) : function(self$1) {
            return body$2(self$1, a$22, b$3, c$3, d$7)
          }
        }
      default:
        return function() {
          if (arguments.length >= arity) return body$2.apply(this, arguments)
          let args$1 = arguments
          return function(self$1) {
            return body$2(self$1, ...args$1)
          }
        }
    }
  },
  identity = a$22 => a$22,
  constant = value$2 => () => value$2,
  constTrue = constant(!0),
  constFalse = constant(!1),
  constNull = constant(null),
  constUndefined = constant(void 0),
  constVoid = constUndefined
function pipe(a$22, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a$22
    case 2:
      return ab(a$22)
    case 3:
      return bc(ab(a$22))
    case 4:
      return cd(bc(ab(a$22)))
    case 5:
      return de(cd(bc(ab(a$22))))
    case 6:
      return ef(de(cd(bc(ab(a$22)))))
    case 7:
      return fg(ef(de(cd(bc(ab(a$22))))))
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a$22)))))))
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a$22))))))))
    default: {
      let ret = arguments[0]
      for (let i$14 = 1; i$14 < arguments.length; i$14++) ret = arguments[i$14](ret)
      return ret
    }
  }
}
const make$61 = isEquivalent => (self$1, that) => self$1 === that || isEquivalent(self$1, that),
  isStrictEquivalent = (x$2, y$3) => x$2 === y$3,
  strict = () => isStrictEquivalent,
  number$4 = strict(),
  boolean$3 = strict(),
  mapInput$1 = dual(2, (self$1, f$14) => make$61((x$2, y$3) => self$1(f$14(x$2), f$14(y$3)))),
  all$7 = collection =>
    make$61((x$2, y$3) => {
      let len = Math.min(x$2.length, y$3.length), collectionLength = 0
      for (let equivalence$22 of collection) {
        if (collectionLength >= len) break
        if (!equivalence$22(x$2[collectionLength], y$3[collectionLength])) return !1
        collectionLength++
      }
      return !0
    }),
  tuple$1 = (...elements) => all$7(elements),
  array$2 = item =>
    make$61((self$1, that) => {
      if (self$1.length !== that.length) return !1
      for (let i$14 = 0; i$14 < self$1.length; i$14++) {
        let isEq = item(self$1[i$14], that[i$14])
        if (!isEq) return !1
      }
      return !0
    }),
  struct$3 = fields => {
    let keys$6 = Object.keys(fields)
    return make$61((self$1, that) => {
      for (let key$1 of keys$6) if (!fields[key$1](self$1[key$1], that[key$1])) return !1
      return !0
    })
  },
  let_$2 = map$20 => dual(3, (self$1, name, f$14) => map$20(self$1, a$22 => ({ ...a$22, [name]: f$14(a$22) }))),
  bindTo$2 = map$20 => dual(2, (self$1, name) => map$20(self$1, a$22 => ({ [name]: a$22 }))),
  bind$2 = (map$20, flatMap$13) =>
    dual(3, (self$1, name, f$14) => flatMap$13(self$1, a$22 => map$20(f$14(a$22), b$3 => ({ ...a$22, [name]: b$3 })))),
  globalStoreId = `effect/GlobalValue`
let globalStore
const globalValue = (
    id$2,
    compute,
  ) => (globalStore || (globalThis[globalStoreId] ??= new Map(), globalStore = globalThis[globalStoreId]),
    globalStore.has(id$2) || globalStore.set(id$2, compute()),
    globalStore.get(id$2)),
  isString$1 = input => typeof input == `string`,
  isNumber$1 = input => typeof input == `number`,
  isBoolean$2 = input => typeof input == `boolean`,
  isBigInt = input => typeof input == `bigint`,
  isSymbol = input => typeof input == `symbol`,
  isFunction$1 = isFunction$2,
  isUndefined = input => input === void 0,
  isNull = input => input === null,
  isNever = _$1 => !1,
  isRecordOrArray = input => typeof input == `object` && !!input,
  isObject$4 = input => isRecordOrArray(input) || isFunction$1(input),
  hasProperty = dual(2, (self$1, property) => isObject$4(self$1) && property in self$1),
  isTagged = dual(2, (self$1, tag$3) => hasProperty(self$1, `_tag`) && self$1._tag === tag$3),
  isNullable = input => input == null,
  isNotNullable = input => input != null,
  isUint8Array$2 = input => input instanceof Uint8Array,
  isDate = input => input instanceof Date,
  isIterable = input => hasProperty(input, Symbol.iterator),
  isRecord$1 = input => isRecordOrArray(input) && !Array.isArray(input),
  isPromiseLike = input => hasProperty(input, `then`) && isFunction$1(input.then),
  isRegExp$1 = input => input instanceof RegExp,
  getBugErrorMessage = message =>
    `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`,
  GenKindTypeId = Symbol.for(`effect/Gen/GenKind`)
var GenKindImpl = class {
    value
    constructor(value$2) {
      this.value = value$2
    }
    get _F() {
      return identity
    }
    get _R() {
      return _$1 => _$1
    }
    get _O() {
      return _$1 => _$1
    }
    get _E() {
      return _$1 => _$1
    }
    [GenKindTypeId] = GenKindTypeId;
    [Symbol.iterator]() {
      return new SingleShotGen(this)
    }
  },
  SingleShotGen = class SingleShotGen {
    self
    called = !1
    constructor(self$1) {
      this.self = self$1
    }
    next(a$22) {
      return this.called ? { value: a$22, done: !0 } : (this.called = !0, { value: this.self, done: !1 })
    }
    return(a$22) {
      return { value: a$22, done: !0 }
    }
    throw(e$26) {
      throw e$26
    }
    [Symbol.iterator]() {
      return new SingleShotGen(this.self)
    }
  }
const defaultIncHi = 335903614,
  defaultIncLo = 4150755663,
  MUL_HI = 1481765933,
  MUL_LO = 1284865837,
  BIT_53 = 9007199254740992,
  BIT_27 = 134217728
var PCGRandom = class {
  _state
  constructor(seedHi, seedLo, incHi, incLo) {
    return isNullable(seedLo) && isNullable(seedHi)
      ? (seedLo = Math.random() * 4294967295 >>> 0, seedHi = 0)
      : isNullable(seedLo) && (seedLo = seedHi, seedHi = 0),
      isNullable(incLo) && isNullable(incHi)
        ? (incLo = this._state ? this._state[3] : defaultIncLo, incHi = this._state ? this._state[2] : defaultIncHi)
        : isNullable(incLo) && (incLo = incHi, incHi = 0),
      this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]),
      this._next(),
      add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0),
      this._next(),
      this
  }
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]]
  }
  setState(state) {
    this._state[0] = state[0], this._state[1] = state[1], this._state[2] = state[2], this._state[3] = state[3] | 1
  }
  integer(max$12) {
    return Math.round(this.number() * (2 ** 53 - 1)) % max$12
  }
  number() {
    let hi = (this._next() & 67108863) * 1, lo = (this._next() & 134217727) * 1
    return (hi * BIT_27 + lo) / BIT_53
  }
  _next() {
    let oldHi = this._state[0] >>> 0, oldLo = this._state[1] >>> 0
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO),
      add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3])
    let xsHi = oldHi >>> 18, xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0
    xsHi = (xsHi ^ oldHi) >>> 0, xsLo = (xsLo ^ oldLo) >>> 0
    let xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0, rot = oldHi >>> 27, rot2 = (-rot >>> 0 & 31) >>> 0
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0,
    c0 = (aLo & 65535) * (bLo >>> 16) >>> 0,
    lo = (aLo & 65535) * (bLo & 65535) >>> 0,
    hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0
  c0 = c0 << 16 >>> 0,
    lo = lo + c0 >>> 0,
    lo >>> 0 < c0 >>> 0 && (hi = hi + 1 >>> 0),
    c1 = c1 << 16 >>> 0,
    lo = lo + c1 >>> 0,
    lo >>> 0 < c1 >>> 0 && (hi = hi + 1 >>> 0),
    hi = hi + Math.imul(aLo, bHi) >>> 0,
    hi = hi + Math.imul(aHi, bLo) >>> 0,
    out[0] = hi,
    out[1] = lo
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0, lo = aLo + bLo >>> 0
  lo >>> 0 < aLo >>> 0 && (hi = hi + 1 | 0), out[0] = hi, out[1] = lo
}
const YieldWrapTypeId = Symbol.for(`effect/Utils/YieldWrap`)
var YieldWrap = class {
  #value
  constructor(value$2) {
    this.#value = value$2
  }
  [YieldWrapTypeId]() {
    return this.#value
  }
}
function yieldWrapGet(self$1) {
  if (typeof self$1 == `object` && self$1 && YieldWrapTypeId in self$1) return self$1[YieldWrapTypeId]()
  throw Error(getBugErrorMessage(`yieldWrapGet`))
}
const structuralRegionState = globalValue(`effect/Utils/isStructuralRegion`, () => ({ enabled: !1, tester: void 0 })),
  standard = { effect_internal_function: body$2 => body$2() },
  forced = {
    effect_internal_function: body$2 => {
      try {
        return body$2()
      } finally {
      }
    },
  },
  isNotOptimizedAway =
    standard.effect_internal_function(() => Error().stack)?.includes(`effect_internal_function`) === !0,
  internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function,
  genConstructor = function*() {}.constructor,
  randomHashCache = globalValue(Symbol.for(`effect/Hash/randomHashCache`), () => new WeakMap()),
  symbol$2 = Symbol.for(`effect/Hash`),
  hash = self$1 => {
    if (structuralRegionState.enabled === !0) return 0
    switch (typeof self$1) {
      case `number`:
        return number$3(self$1)
      case `bigint`:
        return string$4(self$1.toString(10))
      case `boolean`:
        return string$4(String(self$1))
      case `symbol`:
        return string$4(String(self$1))
      case `string`:
        return string$4(self$1)
      case `undefined`:
        return string$4(`undefined`)
      case `function`:
      case `object`:
        return self$1 === null
          ? string$4(`null`)
          : self$1 instanceof Date
          ? hash(self$1.toISOString())
          : self$1 instanceof URL
          ? hash(self$1.href)
          : isHash(self$1)
          ? self$1[symbol$2]()
          : random$2(self$1)
      default:
        throw Error(
          `BUG: unhandled typeof ${typeof self$1} - please report an issue at https://github.com/Effect-TS/effect/issues`,
        )
    }
  },
  random$2 = self$1 => (randomHashCache.has(self$1)
    || randomHashCache.set(self$1, number$3(Math.floor(Math.random() * (2 ** 53 - 1)))),
    randomHashCache.get(self$1)),
  combine$11 = b$3 => self$1 => self$1 * 53 ^ b$3,
  optimize = n$19 => n$19 & 3221225471 | n$19 >>> 1 & 1073741824,
  isHash = u$7 => hasProperty(u$7, symbol$2),
  number$3 = n$19 => {
    if (n$19 !== n$19 || n$19 === 1 / 0) return 0
    let h$2 = n$19 | 0
    for (h$2 !== n$19 && (h$2 ^= n$19 * 4294967295); n$19 > 4294967295;) h$2 ^= n$19 /= 4294967295
    return optimize(h$2)
  },
  string$4 = str => {
    let h$2 = 5381, i$14 = str.length
    for (; i$14;) h$2 = h$2 * 33 ^ str.charCodeAt(--i$14)
    return optimize(h$2)
  },
  structureKeys = (o$18, keys$6) => {
    let h$2 = 12289
    for (let i$14 = 0; i$14 < keys$6.length; i$14++) {
      h$2 ^= pipe(string$4(keys$6[i$14]), combine$11(hash(o$18[keys$6[i$14]])))
    }
    return optimize(h$2)
  },
  structure = o$18 => structureKeys(o$18, Object.keys(o$18)),
  array$1 = arr => {
    let h$2 = 6151
    for (let i$14 = 0; i$14 < arr.length; i$14++) h$2 = pipe(h$2, combine$11(hash(arr[i$14])))
    return optimize(h$2)
  },
  cached$2 = function() {
    if (arguments.length === 1) {
      let self$2 = arguments[0]
      return function(hash$2) {
        return Object.defineProperty(self$2, symbol$2, {
          value() {
            return hash$2
          },
          enumerable: !1,
        }),
          hash$2
      }
    }
    let self$1 = arguments[0], hash$1 = arguments[1]
    return Object.defineProperty(self$1, symbol$2, {
      value() {
        return hash$1
      },
      enumerable: !1,
    }),
      hash$1
  },
  symbol$1 = Symbol.for(`effect/Equal`)
function equals() {
  return arguments.length === 1 ? self$1 => compareBoth(self$1, arguments[0]) : compareBoth(arguments[0], arguments[1])
}
function compareBoth(self$1, that) {
  if (self$1 === that) return !0
  let selfType = typeof self$1
  if (selfType !== typeof that) return !1
  if (selfType === `object` || selfType === `function`) {
    if (self$1 !== null && that !== null) {
      if (isEqual(self$1) && isEqual(that)) {
        return hash(self$1) === hash(that) && self$1[symbol$1](that)
          ? !0
          : structuralRegionState.enabled && structuralRegionState.tester
          ? structuralRegionState.tester(self$1, that)
          : !1
      }
      if (self$1 instanceof Date && that instanceof Date) return self$1.toISOString() === that.toISOString()
      if (self$1 instanceof URL && that instanceof URL) return self$1.href === that.href
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self$1) && Array.isArray(that)) {
        return self$1.length === that.length && self$1.every((v$4, i$14) => compareBoth(v$4, that[i$14]))
      }
      if (Object.getPrototypeOf(self$1) === Object.prototype && Object.getPrototypeOf(self$1) === Object.prototype) {
        let keysSelf = Object.keys(self$1), keysThat = Object.keys(that)
        if (keysSelf.length === keysThat.length) {
          for (let key$1 of keysSelf) {
            if (!(key$1 in that && compareBoth(self$1[key$1], that[key$1]))) {
              return structuralRegionState.tester
                ? structuralRegionState.tester(self$1, that)
                : !1
            }
          }
          return !0
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self$1, that) : !1
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self$1, that) : !1
}
const isEqual = u$7 => hasProperty(u$7, symbol$1),
  equivalence$21 = () => equals,
  NodeInspectSymbol = Symbol.for(`nodejs.util.inspect.custom`),
  toJSON = x$2 => {
    try {
      if (hasProperty(x$2, `toJSON`) && isFunction$1(x$2.toJSON) && x$2.toJSON.length === 0) return x$2.toJSON()
      if (Array.isArray(x$2)) return x$2.map(toJSON)
    } catch {
      return {}
    }
    return redact(x$2)
  },
  format$1 = x$2 => JSON.stringify(x$2, null, 2),
  BaseProto = {
    toJSON() {
      return toJSON(this)
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    toString() {
      return format$1(this.toJSON())
    },
  }
var Class$5 = class {
  [NodeInspectSymbol]() {
    return this.toJSON()
  }
  toString() {
    return format$1(this.toJSON())
  }
}
const toStringUnknown = (u$7, whitespace$1 = 2) => {
    if (typeof u$7 == `string`) return u$7
    try {
      return typeof u$7 == `object` ? stringifyCircular(u$7, whitespace$1) : String(u$7)
    } catch {
      return String(u$7)
    }
  },
  stringifyCircular = (obj, whitespace$1) => {
    let cache = [],
      retVal = JSON.stringify(
        obj,
        (_key, value$2) =>
          typeof value$2 == `object` && value$2
            ? cache.includes(value$2)
              ? void 0
              : cache.push(value$2) && (redactableState.fiberRefs !== void 0 && isRedactable(value$2)
                ? value$2[symbolRedactable](redactableState.fiberRefs)
                : value$2)
            : value$2,
        whitespace$1,
      )
    return cache = void 0, retVal
  },
  symbolRedactable = Symbol.for(`effect/Inspectable/Redactable`),
  isRedactable = u$7 => typeof u$7 == `object` && !!u$7 && symbolRedactable in u$7,
  redactableState = globalValue(`effect/Inspectable/redactableState`, () => ({ fiberRefs: void 0 })),
  withRedactableContext = (context$2, f$14) => {
    let prev = redactableState.fiberRefs
    redactableState.fiberRefs = context$2
    try {
      return f$14()
    } finally {
      redactableState.fiberRefs = prev
    }
  },
  redact = u$7 =>
    isRedactable(u$7) && redactableState.fiberRefs !== void 0 ? u$7[symbolRedactable](redactableState.fiberRefs) : u$7,
  pipeArguments = (self$1, args$1) => {
    switch (args$1.length) {
      case 0:
        return self$1
      case 1:
        return args$1[0](self$1)
      case 2:
        return args$1[1](args$1[0](self$1))
      case 3:
        return args$1[2](args$1[1](args$1[0](self$1)))
      case 4:
        return args$1[3](args$1[2](args$1[1](args$1[0](self$1))))
      case 5:
        return args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self$1)))))
      case 6:
        return args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self$1))))))
      case 7:
        return args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self$1)))))))
      case 8:
        return args$1[7](args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self$1))))))))
      case 9:
        return args$1[8](args$1[7](args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self$1)))))))))
      default: {
        let ret = self$1
        for (let i$14 = 0, len = args$1.length; i$14 < len; i$14++) ret = args$1[i$14](ret)
        return ret
      }
    }
  },
  OP_ASYNC = `Async`,
  OP_COMMIT = `Commit`,
  OP_FAILURE = `Failure`,
  OP_ON_FAILURE = `OnFailure`,
  OP_ON_SUCCESS = `OnSuccess`,
  OP_ON_SUCCESS_AND_FAILURE = `OnSuccessAndFailure`,
  OP_SUCCESS = `Success`,
  OP_SYNC = `Sync`,
  OP_TAG = `Tag`,
  OP_UPDATE_RUNTIME_FLAGS = `UpdateRuntimeFlags`,
  OP_WHILE = `While`,
  OP_ITERATOR = `Iterator`,
  OP_WITH_RUNTIME = `WithRuntime`,
  OP_YIELD = `Yield`,
  OP_REVERT_FLAGS = `RevertFlags`
let moduleVersion = `3.17.0`
const getCurrentVersion = () => moduleVersion,
  EffectTypeId$3 = Symbol.for(`effect/Effect`),
  StreamTypeId$1 = Symbol.for(`effect/Stream`),
  SinkTypeId$1 = Symbol.for(`effect/Sink`),
  ChannelTypeId$1 = Symbol.for(`effect/Channel`),
  effectVariance = { _R: _$1 => _$1, _E: _$1 => _$1, _A: _$1 => _$1, _V: getCurrentVersion() },
  sinkVariance = { _A: _$1 => _$1, _In: _$1 => _$1, _L: _$1 => _$1, _E: _$1 => _$1, _R: _$1 => _$1 },
  channelVariance = {
    _Env: _$1 => _$1,
    _InErr: _$1 => _$1,
    _InElem: _$1 => _$1,
    _InDone: _$1 => _$1,
    _OutErr: _$1 => _$1,
    _OutElem: _$1 => _$1,
    _OutDone: _$1 => _$1,
  },
  EffectPrototype$1 = {
    [EffectTypeId$3]: effectVariance,
    [StreamTypeId$1]: effectVariance,
    [SinkTypeId$1]: sinkVariance,
    [ChannelTypeId$1]: channelVariance,
    [symbol$1](that) {
      return this === that
    },
    [symbol$2]() {
      return cached$2(this, random$2(this))
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this))
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  StructuralPrototype = {
    [symbol$2]() {
      return cached$2(this, structure(this))
    },
    [symbol$1](that) {
      let selfKeys = Object.keys(this), thatKeys = Object.keys(that)
      if (selfKeys.length !== thatKeys.length) return !1
      for (let key$1 of selfKeys) if (!(key$1 in that && equals(this[key$1], that[key$1]))) return !1
      return !0
    },
  },
  CommitPrototype$1 = { ...EffectPrototype$1, _op: OP_COMMIT },
  StructuralCommitPrototype$1 = { ...CommitPrototype$1, ...StructuralPrototype },
  Base$1 = function() {
    function Base$2() {}
    return Base$2.prototype = CommitPrototype$1, Base$2
  }(),
  StructuralBase$1 = function() {
    function Base$2() {}
    return Base$2.prototype = StructuralCommitPrototype$1, Base$2
  }(),
  TypeId$22 = Symbol.for(`effect/Option`),
  CommonProto$1 = {
    ...EffectPrototype$1,
    [TypeId$22]: { _A: _$1 => _$1 },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    toString() {
      return format$1(this.toJSON())
    },
  },
  SomeProto = Object.assign(Object.create(CommonProto$1), {
    _tag: `Some`,
    _op: `Some`,
    [symbol$1](that) {
      return isOption$1(that) && isSome$1(that) && equals(this.value, that.value)
    },
    [symbol$2]() {
      return cached$2(this, combine$11(hash(this._tag))(hash(this.value)))
    },
    toJSON() {
      return { _id: `Option`, _tag: this._tag, value: toJSON(this.value) }
    },
  }),
  NoneHash = hash(`None`),
  NoneProto = Object.assign(Object.create(CommonProto$1), {
    _tag: `None`,
    _op: `None`,
    [symbol$1](that) {
      return isOption$1(that) && isNone$3(that)
    },
    [symbol$2]() {
      return NoneHash
    },
    toJSON() {
      return { _id: `Option`, _tag: this._tag }
    },
  }),
  isOption$1 = input => hasProperty(input, TypeId$22),
  isNone$3 = fa => fa._tag === `None`,
  isSome$1 = fa => fa._tag === `Some`,
  none$8 = Object.create(NoneProto),
  some$5 = value$2 => {
    let a$22 = Object.create(SomeProto)
    return a$22.value = value$2, a$22
  },
  TypeId$21 = Symbol.for(`effect/Either`),
  CommonProto = {
    ...EffectPrototype$1,
    [TypeId$21]: { _R: _$1 => _$1 },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    toString() {
      return format$1(this.toJSON())
    },
  },
  RightProto = Object.assign(Object.create(CommonProto), {
    _tag: `Right`,
    _op: `Right`,
    [symbol$1](that) {
      return isEither$2(that) && isRight$1(that) && equals(this.right, that.right)
    },
    [symbol$2]() {
      return combine$11(hash(this._tag))(hash(this.right))
    },
    toJSON() {
      return { _id: `Either`, _tag: this._tag, right: toJSON(this.right) }
    },
  }),
  LeftProto = Object.assign(Object.create(CommonProto), {
    _tag: `Left`,
    _op: `Left`,
    [symbol$1](that) {
      return isEither$2(that) && isLeft$1(that) && equals(this.left, that.left)
    },
    [symbol$2]() {
      return combine$11(hash(this._tag))(hash(this.left))
    },
    toJSON() {
      return { _id: `Either`, _tag: this._tag, left: toJSON(this.left) }
    },
  }),
  isEither$2 = input => hasProperty(input, TypeId$21),
  isLeft$1 = ma => ma._tag === `Left`,
  isRight$1 = ma => ma._tag === `Right`,
  left$1 = left$2 => {
    let a$22 = Object.create(LeftProto)
    return a$22.left = left$2, a$22
  },
  right$1 = right$2 => {
    let a$22 = Object.create(RightProto)
    return a$22.right = right$2, a$22
  },
  getLeft$2 = self$1 => isRight$1(self$1) ? none$8 : some$5(self$1.left),
  getRight$2 = self$1 => isLeft$1(self$1) ? none$8 : some$5(self$1.right),
  fromOption$4 = dual(2, (self$1, onNone) => isNone$3(self$1) ? left$1(onNone()) : right$1(self$1.value)),
  TypeId$20 = TypeId$21,
  right = right$1,
  left = left$1,
  fromOption$3 = fromOption$4,
  try_$2 = evaluate$2 => {
    if (isFunction$1(evaluate$2)) {
      try {
        return right(evaluate$2())
      } catch (e$26) {
        return left(e$26)
      }
    } else {try {
        return right(evaluate$2.try())
      } catch (e$26) {
        return left(evaluate$2.catch(e$26))
      }}
  },
  isEither$1 = isEither$2,
  isLeft = isLeft$1,
  isRight = isRight$1,
  getRight$1 = getRight$2,
  getLeft$1 = getLeft$2,
  mapBoth$4 = dual(
    2,
    (self$1, { onLeft, onRight }) => isLeft(self$1) ? left(onLeft(self$1.left)) : right(onRight(self$1.right)),
  ),
  mapLeft = dual(2, (self$1, f$14) => isLeft(self$1) ? left(f$14(self$1.left)) : right(self$1.right)),
  map$19 = dual(2, (self$1, f$14) => isRight(self$1) ? right(f$14(self$1.right)) : left(self$1.left)),
  match$12 = dual(2, (self$1, { onLeft, onRight }) => isLeft(self$1) ? onLeft(self$1.left) : onRight(self$1.right)),
  merge$8 = match$12({ onLeft: identity, onRight: identity }),
  getOrThrowWith$1 = dual(2, (self$1, onLeft) => {
    if (isRight(self$1)) return self$1.right
    throw onLeft(self$1.left)
  }),
  getOrThrow$1 = getOrThrowWith$1(() => Error(`getOrThrow called on a Left`)),
  isNonEmptyArray$1 = self$1 => self$1.length > 0,
  make$60 = compare$2 => (self$1, that) => self$1 === that ? 0 : compare$2(self$1, that),
  string$3 = make$60((self$1, that) => self$1 < that ? -1 : 1),
  number$2 = make$60((self$1, that) => self$1 < that ? -1 : 1),
  boolean$2 = make$60((self$1, that) => self$1 < that ? -1 : 1),
  reverse$3 = O$1 => make$60((self$1, that) => O$1(that, self$1)),
  mapInput = dual(2, (self$1, f$14) => make$60((b1, b2) => self$1(f$14(b1), f$14(b2)))),
  all$6 = collection =>
    make$60((x$2, y$3) => {
      let len = Math.min(x$2.length, y$3.length), collectionLength = 0
      for (let O$1 of collection) {
        if (collectionLength >= len) break
        let o$18 = O$1(x$2[collectionLength], y$3[collectionLength])
        if (o$18 !== 0) return o$18
        collectionLength++
      }
      return 0
    }),
  tuple = (...elements) => all$6(elements),
  array = O$1 =>
    make$60((self$1, that) => {
      let aLen = self$1.length, bLen = that.length, len = Math.min(aLen, bLen)
      for (let i$14 = 0; i$14 < len; i$14++) {
        let o$18 = O$1(self$1[i$14], that[i$14])
        if (o$18 !== 0) return o$18
      }
      return number$2(aLen, bLen)
    }),
  struct$2 = fields => {
    let keys$6 = Object.keys(fields)
    return make$60((self$1, that) => {
      for (let key$1 of keys$6) {
        let o$18 = fields[key$1](self$1[key$1], that[key$1])
        if (o$18 !== 0) return o$18
      }
      return 0
    })
  },
  lessThan$12 = O$1 => dual(2, (self$1, that) => O$1(self$1, that) === -1),
  greaterThan$9 = O$1 => dual(2, (self$1, that) => O$1(self$1, that) === 1),
  min$9 = O$1 => dual(2, (self$1, that) => self$1 === that || O$1(self$1, that) < 1 ? self$1 : that),
  max$11 = O$1 => dual(2, (self$1, that) => self$1 === that || O$1(self$1, that) > -1 ? self$1 : that),
  none$7 = () => none$8,
  some$4 = some$5,
  isOption = isOption$1,
  isNone$2 = isNone$3,
  isSome = isSome$1,
  match$11 = dual(2, (self$1, { onNone, onSome }) => isNone$2(self$1) ? onNone() : onSome(self$1.value)),
  getRight = getRight$2,
  getLeft = getLeft$2,
  getOrElse$5 = dual(2, (self$1, onNone) => isNone$2(self$1) ? onNone() : self$1.value),
  orElse$7 = dual(2, (self$1, that) => isNone$2(self$1) ? that() : self$1),
  orElseSome = dual(2, (self$1, onNone) => isNone$2(self$1) ? some$4(onNone()) : self$1),
  fromNullable$2 = nullableValue => nullableValue == null ? none$7() : some$4(nullableValue),
  getOrNull = getOrElse$5(constNull),
  getOrUndefined = getOrElse$5(constUndefined),
  liftThrowable = f$14 => (...a$22) => {
    try {
      return some$4(f$14(...a$22))
    } catch {
      return none$7()
    }
  },
  getOrThrowWith = dual(2, (self$1, onNone) => {
    if (isSome(self$1)) return self$1.value
    throw onNone()
  }),
  getOrThrow = getOrThrowWith(() => Error(`getOrThrow called on a None`)),
  map$18 = dual(2, (self$1, f$14) => isNone$2(self$1) ? none$7() : some$4(f$14(self$1.value))),
  flatMap$12 = dual(2, (self$1, f$14) => isNone$2(self$1) ? none$7() : f$14(self$1.value)),
  flatMapNullable = dual(2, (self$1, f$14) => isNone$2(self$1) ? none$7() : fromNullable$2(f$14(self$1.value))),
  toArray$1 = self$1 => isNone$2(self$1) ? [] : [self$1.value],
  containsWith$2 = isEquivalent => dual(2, (self$1, a$22) => isNone$2(self$1) ? !1 : isEquivalent(self$1.value, a$22)),
  _equivalence$3 = equivalence$21(),
  contains$5 = containsWith$2(_equivalence$3),
  exists$3 = dual(2, (self$1, refinement) => isNone$2(self$1) ? !1 : refinement(self$1.value)),
  mergeWith = f$14 => (o1, o2) => isNone$2(o1) ? o2 : isNone$2(o2) ? o1 : some$4(f$14(o1.value, o2.value)),
  make$59 = (...elements) => elements,
  getEquivalence$4 = tuple$1,
  getOrder$4 = tuple,
  findFirst$8 = dual(2, (self$1, f$14) => {
    let i$14 = 0
    for (let a$22 of self$1) {
      let o$18 = f$14(a$22, i$14)
      if (isBoolean$2(o$18)) {
        if (o$18) return some$4(a$22)
        else if (isSome(o$18)) return o$18
      }
      i$14++
    }
    return none$7()
  }),
  collect = dual(2, (self$1, f$14) => {
    let out = []
    for (let key$1 of keys$5(self$1)) out.push(f$14(key$1, self$1[key$1]))
    return out
  }),
  toEntries = collect((key$1, value$2) => [key$1, value$2]),
  keys$5 = self$1 => Object.keys(self$1),
  allocate = n$19 => Array(n$19),
  makeBy = dual(2, (n$19, f$14) => {
    let max$12 = Math.max(1, Math.floor(n$19)), out = Array(max$12)
    for (let i$14 = 0; i$14 < max$12; i$14++) out[i$14] = f$14(i$14)
    return out
  }),
  fromIterable$10 = collection => Array.isArray(collection) ? collection : Array.from(collection),
  ensure = self$1 => Array.isArray(self$1) ? self$1 : [self$1],
  fromRecord = toEntries,
  fromOption$2 = toArray$1,
  matchLeft = dual(
    2,
    (self$1, { onEmpty, onNonEmpty }) =>
      isNonEmptyReadonlyArray(self$1) ? onNonEmpty(headNonEmpty$1(self$1), tailNonEmpty$1(self$1)) : onEmpty(),
  ),
  prepend$2 = dual(2, (self$1, head$5) => [head$5, ...self$1]),
  append$2 = dual(2, (self$1, last$3) => [...self$1, last$3]),
  appendAll$2 = dual(2, (self$1, that) => fromIterable$10(self$1).concat(fromIterable$10(that))),
  isArray$1 = Array.isArray,
  isEmptyArray = self$1 => self$1.length === 0,
  isEmptyReadonlyArray = isEmptyArray,
  isNonEmptyArray = isNonEmptyArray$1,
  isNonEmptyReadonlyArray = isNonEmptyArray$1,
  isOutOfBounds = (i$14, as$6) => i$14 < 0 || i$14 >= as$6.length,
  clamp$2 = (i$14, as$6) => Math.floor(Math.min(Math.max(0, i$14), as$6.length)),
  get$11 = dual(2, (self$1, index$4) => {
    let i$14 = Math.floor(index$4)
    return isOutOfBounds(i$14, self$1) ? none$7() : some$4(self$1[i$14])
  }),
  unsafeGet$5 = dual(2, (self$1, index$4) => {
    let i$14 = Math.floor(index$4)
    if (isOutOfBounds(i$14, self$1)) throw Error(`Index ${i$14} out of bounds`)
    return self$1[i$14]
  }),
  head$4 = get$11(0),
  headNonEmpty$1 = unsafeGet$5(0),
  last$2 = self$1 => isNonEmptyReadonlyArray(self$1) ? some$4(lastNonEmpty(self$1)) : none$7(),
  lastNonEmpty = self$1 => self$1[self$1.length - 1],
  tailNonEmpty$1 = self$1 => self$1.slice(1),
  spanIndex = (self$1, predicate) => {
    let i$14 = 0
    for (let a$22 of self$1) {
      if (!predicate(a$22, i$14)) break
      i$14++
    }
    return i$14
  },
  span = dual(2, (self$1, predicate) => splitAt(self$1, spanIndex(self$1, predicate))),
  drop$1 = dual(2, (self$1, n$19) => {
    let input = fromIterable$10(self$1)
    return input.slice(clamp$2(n$19, input), input.length)
  }),
  findFirstIndex$1 = dual(2, (self$1, predicate) => {
    let i$14 = 0
    for (let a$22 of self$1) {
      if (predicate(a$22, i$14)) return some$4(i$14)
      i$14++
    }
    return none$7()
  }),
  findLastIndex$1 = dual(2, (self$1, predicate) => {
    let input = fromIterable$10(self$1)
    for (let i$14 = input.length - 1; i$14 >= 0; i$14--) if (predicate(input[i$14], i$14)) return some$4(i$14)
    return none$7()
  }),
  findFirst$7 = findFirst$8,
  findLast$1 = dual(2, (self$1, f$14) => {
    let input = fromIterable$10(self$1)
    for (let i$14 = input.length - 1; i$14 >= 0; i$14--) {
      let a$22 = input[i$14], o$18 = f$14(a$22, i$14)
      if (isBoolean$2(o$18)) {
        if (o$18) return some$4(a$22)
        else if (isSome(o$18)) return o$18
      }
    }
    return none$7()
  }),
  reverse$2 = self$1 => Array.from(self$1).reverse(),
  sort = dual(2, (self$1, O$1) => {
    let out = Array.from(self$1)
    return out.sort(O$1), out
  }),
  zip$6 = dual(2, (self$1, that) => zipWith$5(self$1, that, make$59)),
  zipWith$5 = dual(3, (self$1, that, f$14) => {
    let as$6 = fromIterable$10(self$1), bs = fromIterable$10(that)
    if (isNonEmptyReadonlyArray(as$6) && isNonEmptyReadonlyArray(bs)) {
      let out = [f$14(headNonEmpty$1(as$6), headNonEmpty$1(bs))], len = Math.min(as$6.length, bs.length)
      for (let i$14 = 1; i$14 < len; i$14++) out[i$14] = f$14(as$6[i$14], bs[i$14])
      return out
    }
    return []
  }),
  containsWith$1 = isEquivalent =>
    dual(2, (self$1, a$22) => {
      for (let i$14 of self$1) if (isEquivalent(a$22, i$14)) return !0
      return !1
    }),
  _equivalence$2 = equivalence$21(),
  contains$4 = containsWith$1(_equivalence$2),
  splitAt = dual(2, (self$1, n$19) => {
    let input = Array.from(self$1), _n = Math.floor(n$19)
    return isNonEmptyReadonlyArray(input) ? _n >= 1 ? splitNonEmptyAt(input, _n) : [[], input] : [input, []]
  }),
  splitNonEmptyAt = dual(2, (self$1, n$19) => {
    let _n = Math.max(1, Math.floor(n$19))
    return _n >= self$1.length
      ? [copy$1(self$1), []]
      : [prepend$2(self$1.slice(1, _n), headNonEmpty$1(self$1)), self$1.slice(_n)]
  }),
  copy$1 = self$1 => self$1.slice(),
  unionWith = dual(3, (self$1, that, isEquivalent) => {
    let a$22 = fromIterable$10(self$1), b$3 = fromIterable$10(that)
    if (isNonEmptyReadonlyArray(a$22)) {
      if (isNonEmptyReadonlyArray(b$3)) {
        let dedupe$1 = dedupeWith(isEquivalent)
        return dedupe$1(appendAll$2(a$22, b$3))
      }
      return a$22
    }
    return b$3
  }),
  union$8 = dual(2, (self$1, that) => unionWith(self$1, that, _equivalence$2)),
  empty$35 = () => [],
  of$4 = a$22 => [a$22],
  map$17 = dual(2, (self$1, f$14) => self$1.map(f$14)),
  flatMap$11 = dual(2, (self$1, f$14) => {
    if (isEmptyReadonlyArray(self$1)) return []
    let out = []
    for (let i$14 = 0; i$14 < self$1.length; i$14++) {
      let inner = f$14(self$1[i$14], i$14)
      for (let j$1 = 0; j$1 < inner.length; j$1++) out.push(inner[j$1])
    }
    return out
  }),
  flatten$7 = flatMap$11(identity),
  filterMap$4 = dual(2, (self$1, f$14) => {
    let as$6 = fromIterable$10(self$1), out = []
    for (let i$14 = 0; i$14 < as$6.length; i$14++) {
      let o$18 = f$14(as$6[i$14], i$14)
      isSome(o$18) && out.push(o$18.value)
    }
    return out
  }),
  partitionMap$1 = dual(2, (self$1, f$14) => {
    let left$2 = [], right$2 = [], as$6 = fromIterable$10(self$1)
    for (let i$14 = 0; i$14 < as$6.length; i$14++) {
      let e$26 = f$14(as$6[i$14], i$14)
      isLeft(e$26) ? left$2.push(e$26.left) : right$2.push(e$26.right)
    }
    return [left$2, right$2]
  }),
  getSomes = filterMap$4(identity),
  partition$4 = dual(2, (self$1, predicate) => {
    let left$2 = [], right$2 = [], as$6 = fromIterable$10(self$1)
    for (let i$14 = 0; i$14 < as$6.length; i$14++) {
      predicate(as$6[i$14], i$14)
        ? right$2.push(as$6[i$14])
        : left$2.push(as$6[i$14])
    }
    return [left$2, right$2]
  }),
  reduce$12 = dual(
    3,
    (self$1, b$3, f$14) => fromIterable$10(self$1).reduce((b$4, a$22, i$14) => f$14(b$4, a$22, i$14), b$3),
  ),
  reduceRight$3 = dual(
    3,
    (self$1, b$3, f$14) => fromIterable$10(self$1).reduceRight((b$4, a$22, i$14) => f$14(b$4, a$22, i$14), b$3),
  ),
  unfold$1 = (b$3, f$14) => {
    let out = [], next = b$3, o$18
    for (; isSome(o$18 = f$14(next));) {
      let [a$22, b$4] = o$18.value
      out.push(a$22), next = b$4
    }
    return out
  },
  getOrder$3 = array,
  getEquivalence$3 = array$2,
  dedupeWith = dual(2, (self$1, isEquivalent) => {
    let input = fromIterable$10(self$1)
    if (isNonEmptyReadonlyArray(input)) {
      let out = [headNonEmpty$1(input)], rest = tailNonEmpty$1(input)
      for (let r$26 of rest) out.every(a$22 => !isEquivalent(r$26, a$22)) && out.push(r$26)
      return out
    }
    return []
  }),
  dedupe = self$1 => dedupeWith(self$1, equivalence$21()),
  join$6 = dual(2, (self$1, sep) => fromIterable$10(self$1).join(sep)),
  getKeysForIndexSignature = (input, parameter) => {
    switch (parameter._tag) {
      case `StringKeyword`:
      case `TemplateLiteral`:
        return Object.keys(input)
      case `SymbolKeyword`:
        return Object.getOwnPropertySymbols(input)
      case `Refinement`:
        return getKeysForIndexSignature(input, parameter.from)
    }
  },
  ownKeys = o$18 => Object.keys(o$18).concat(Object.getOwnPropertySymbols(o$18)),
  memoizeThunk = f$14 => {
    let done$8 = !1, a$22
    return () => done$8 ? a$22 : (a$22 = f$14(), done$8 = !0, a$22)
  },
  formatDate = date$1 => {
    try {
      return date$1.toISOString()
    } catch {
      return String(date$1)
    }
  },
  formatUnknown = (u$7, checkCircular = !0) => {
    if (Array.isArray(u$7)) return `[${u$7.map(i$14 => formatUnknown(i$14, checkCircular)).join(`,`)}]`
    if (isDate(u$7)) return formatDate(u$7)
    if (hasProperty(u$7, `toString`) && isFunction$1(u$7.toString) && u$7.toString !== Object.prototype.toString) {
      return u$7.toString()
    }
    if (isString$1(u$7)) return JSON.stringify(u$7)
    if (isNumber$1(u$7) || u$7 == null || isBoolean$2(u$7) || isSymbol(u$7)) return String(u$7)
    if (isBigInt(u$7)) return String(u$7) + `n`
    if (isIterable(u$7)) return `${u$7.constructor.name}(${formatUnknown(Array.from(u$7), checkCircular)})`
    try {
      checkCircular && JSON.stringify(u$7)
      let pojo = `{${
          ownKeys(u$7).map(k$1 =>
            `${isString$1(k$1) ? JSON.stringify(k$1) : String(k$1)}:${formatUnknown(u$7[k$1], !1)}`
          ).join(`,`)
        }}`,
        name = u$7.constructor.name
      return u$7.constructor === Object.prototype.constructor ? pojo : `${name}(${pojo})`
    } catch {
      return `<circular structure>`
    }
  },
  formatPropertyKey$1 = name => typeof name == `string` ? JSON.stringify(name) : String(name),
  isNonEmpty$5 = x$2 => Array.isArray(x$2),
  isSingle$1 = x$2 => !Array.isArray(x$2),
  formatPathKey = key$1 => `[${formatPropertyKey$1(key$1)}]`,
  formatPath = path$1 => isNonEmpty$5(path$1) ? path$1.map(formatPathKey).join(``) : formatPathKey(path$1),
  getErrorMessage = (reason, details, path$1, ast) => {
    let out = reason
    return path$1 && isNonEmptyReadonlyArray(path$1) && (out += `\nat path: ${formatPath(path$1)}`),
      details !== void 0 && (out += `\ndetails: ${details}`),
      ast && (out += `\nschema (${ast._tag}): ${ast}`),
      out
  },
  getUnsupportedSchemaErrorMessage = (details, path$1, ast) =>
    getErrorMessage(`Unsupported schema`, details, path$1, ast),
  getEquivalenceUnsupportedErrorMessage = (ast, path$1) =>
    getUnsupportedSchemaErrorMessage(`Cannot build an Equivalence`, path$1, ast),
  getSchemaExtendErrorMessage = (x$2, y$3, path$1) =>
    getErrorMessage(`Unsupported schema or overlapping types`, `cannot extend ${x$2} with ${y$3}`, path$1),
  getASTUnsupportedKeySchemaErrorMessage = ast => getErrorMessage(`Unsupported key schema`, void 0, void 0, ast),
  getASTUnsupportedLiteralErrorMessage = literal =>
    getErrorMessage(`Unsupported literal`, `literal value: ${formatUnknown(literal)}`),
  getASTDuplicateIndexSignatureErrorMessage = type$2 =>
    getErrorMessage(`Duplicate index signature`, `${type$2} index signature`),
  getASTIndexSignatureParameterErrorMessage = getErrorMessage(
    `Unsupported index signature parameter`,
    'An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types',
  ),
  getASTRequiredElementFollowinAnOptionalElementErrorMessage = getErrorMessage(
    `Invalid element`,
    `A required element cannot follow an optional element. ts(1257)`,
  ),
  getASTDuplicatePropertySignatureTransformationErrorMessage = key$1 =>
    getErrorMessage(`Duplicate property signature transformation`, `Duplicate key ${formatUnknown(key$1)}`),
  getASTDuplicatePropertySignatureErrorMessage = key$1 =>
    getErrorMessage(`Duplicate property signature`, `Duplicate key ${formatUnknown(key$1)}`),
  DateFromSelfSchemaId$1 = Symbol.for(`effect/SchemaId/DateFromSelf`),
  GreaterThanSchemaId$1 = Symbol.for(`effect/SchemaId/GreaterThan`),
  GreaterThanOrEqualToSchemaId$1 = Symbol.for(`effect/SchemaId/GreaterThanOrEqualTo`),
  LessThanSchemaId$1 = Symbol.for(`effect/SchemaId/LessThan`),
  LessThanOrEqualToSchemaId$1 = Symbol.for(`effect/SchemaId/LessThanOrEqualTo`),
  IntSchemaId$1 = Symbol.for(`effect/SchemaId/Int`),
  NonNaNSchemaId$1 = Symbol.for(`effect/SchemaId/NonNaN`),
  FiniteSchemaId$1 = Symbol.for(`effect/SchemaId/Finite`),
  JsonNumberSchemaId$1 = Symbol.for(`effect/SchemaId/JsonNumber`),
  BetweenSchemaId$1 = Symbol.for(`effect/SchemaId/Between`),
  GreaterThanBigintSchemaId = Symbol.for(`effect/SchemaId/GreaterThanBigint`),
  GreaterThanOrEqualToBigIntSchemaId$1 = Symbol.for(`effect/SchemaId/GreaterThanOrEqualToBigint`),
  LessThanBigIntSchemaId$1 = Symbol.for(`effect/SchemaId/LessThanBigint`),
  LessThanOrEqualToBigIntSchemaId$1 = Symbol.for(`effect/SchemaId/LessThanOrEqualToBigint`),
  BetweenBigintSchemaId = Symbol.for(`effect/SchemaId/BetweenBigint`),
  MinLengthSchemaId$1 = Symbol.for(`effect/SchemaId/MinLength`),
  MaxLengthSchemaId$1 = Symbol.for(`effect/SchemaId/MaxLength`),
  LengthSchemaId$1 = Symbol.for(`effect/SchemaId/Length`),
  MinItemsSchemaId$1 = Symbol.for(`effect/SchemaId/MinItems`),
  MaxItemsSchemaId$1 = Symbol.for(`effect/SchemaId/MaxItems`),
  ItemsCountSchemaId$1 = Symbol.for(`effect/SchemaId/ItemsCount`),
  isNumber$2 = isNumber$1,
  Equivalence$2 = number$4,
  Order$4 = number$2,
  isRegExp = isRegExp$1,
  escape = string$5 => string$5.replace(/[/\\^$*+?.()|[\]{}]/g, `\\$&`),
  BrandAnnotationId = Symbol.for(`effect/annotation/Brand`),
  SchemaIdAnnotationId = Symbol.for(`effect/annotation/SchemaId`),
  MessageAnnotationId = Symbol.for(`effect/annotation/Message`),
  MissingMessageAnnotationId = Symbol.for(`effect/annotation/MissingMessage`),
  IdentifierAnnotationId = Symbol.for(`effect/annotation/Identifier`),
  TitleAnnotationId = Symbol.for(`effect/annotation/Title`),
  AutoTitleAnnotationId = Symbol.for(`effect/annotation/AutoTitle`),
  DescriptionAnnotationId = Symbol.for(`effect/annotation/Description`),
  ExamplesAnnotationId = Symbol.for(`effect/annotation/Examples`),
  DefaultAnnotationId = Symbol.for(`effect/annotation/Default`),
  JSONSchemaAnnotationId = Symbol.for(`effect/annotation/JSONSchema`),
  ArbitraryAnnotationId = Symbol.for(`effect/annotation/Arbitrary`),
  PrettyAnnotationId = Symbol.for(`effect/annotation/Pretty`),
  EquivalenceAnnotationId = Symbol.for(`effect/annotation/Equivalence`),
  DocumentationAnnotationId = Symbol.for(`effect/annotation/Documentation`),
  ConcurrencyAnnotationId = Symbol.for(`effect/annotation/Concurrency`),
  BatchingAnnotationId = Symbol.for(`effect/annotation/Batching`),
  ParseIssueTitleAnnotationId = Symbol.for(`effect/annotation/ParseIssueTitle`),
  ParseOptionsAnnotationId = Symbol.for(`effect/annotation/ParseOptions`),
  DecodingFallbackAnnotationId = Symbol.for(`effect/annotation/DecodingFallback`),
  SurrogateAnnotationId = Symbol.for(`effect/annotation/Surrogate`),
  StableFilterAnnotationId = Symbol.for(`effect/annotation/StableFilter`),
  getAnnotation = dual(
    2,
    (annotated, key$1) =>
      Object.prototype.hasOwnProperty.call(annotated.annotations, key$1)
        ? some$4(annotated.annotations[key$1])
        : none$7(),
  ),
  getBrandAnnotation = getAnnotation(BrandAnnotationId),
  getMessageAnnotation = getAnnotation(MessageAnnotationId),
  getMissingMessageAnnotation = getAnnotation(MissingMessageAnnotationId),
  getTitleAnnotation = getAnnotation(TitleAnnotationId),
  getAutoTitleAnnotation = getAnnotation(AutoTitleAnnotationId),
  getIdentifierAnnotation = getAnnotation(IdentifierAnnotationId),
  getDescriptionAnnotation = getAnnotation(DescriptionAnnotationId),
  getConcurrencyAnnotation = getAnnotation(ConcurrencyAnnotationId),
  getBatchingAnnotation = getAnnotation(BatchingAnnotationId),
  getParseIssueTitleAnnotation$1 = getAnnotation(ParseIssueTitleAnnotationId),
  getParseOptionsAnnotation = getAnnotation(ParseOptionsAnnotationId),
  getDecodingFallbackAnnotation = getAnnotation(DecodingFallbackAnnotationId),
  getSurrogateAnnotation = getAnnotation(SurrogateAnnotationId),
  getStableFilterAnnotation = getAnnotation(StableFilterAnnotationId),
  hasStableFilter = annotated => exists$3(getStableFilterAnnotation(annotated), b$3 => b$3 === !0),
  JSONIdentifierAnnotationId = Symbol.for(`effect/annotation/JSONIdentifier`),
  getJSONIdentifierAnnotation = getAnnotation(JSONIdentifierAnnotationId),
  getJSONIdentifier = annotated =>
    orElse$7(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated))
var Declaration = class {
  typeParameters
  decodeUnknown
  encodeUnknown
  annotations
  _tag = `Declaration`
  constructor(typeParameters, decodeUnknown$2, encodeUnknown$2, annotations$2 = {}) {
    this.typeParameters = typeParameters,
      this.decodeUnknown = decodeUnknown$2,
      this.encodeUnknown = encodeUnknown$2,
      this.annotations = annotations$2
  }
  toString() {
    return getOrElse$5(getExpected(this), () => `<declaration schema>`)
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations),
    }
  }
}
const createASTGuard = tag$3 => ast => ast._tag === tag$3
var Literal$1 = class {
  literal
  annotations
  _tag = `Literal`
  constructor(literal, annotations$2 = {}) {
    this.literal = literal, this.annotations = annotations$2
  }
  toString() {
    return getOrElse$5(getExpected(this), () => formatUnknown(this.literal))
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations),
    }
  }
}
const isLiteral = createASTGuard(`Literal`), $null = new Literal$1(null)
var UniqueSymbol = class {
    symbol
    annotations
    _tag = `UniqueSymbol`
    constructor(symbol$3, annotations$2 = {}) {
      this.symbol = symbol$3, this.annotations = annotations$2
    }
    toString() {
      return getOrElse$5(getExpected(this), () => formatUnknown(this.symbol))
    }
    toJSON() {
      return { _tag: this._tag, symbol: String(this.symbol), annotations: toJSONAnnotations(this.annotations) }
    }
  },
  UndefinedKeyword = class {
    annotations
    _tag = `UndefinedKeyword`
    constructor(annotations$2 = {}) {
      this.annotations = annotations$2
    }
    toString() {
      return formatKeyword(this)
    }
    toJSON() {
      return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
    }
  }
const undefinedKeyword = new UndefinedKeyword({ [TitleAnnotationId]: `undefined` })
var VoidKeyword = class {
  annotations
  _tag = `VoidKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const voidKeyword = new VoidKeyword({ [TitleAnnotationId]: `void` })
var NeverKeyword = class {
  annotations
  _tag = `NeverKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const neverKeyword = new NeverKeyword({ [TitleAnnotationId]: `never` })
var UnknownKeyword = class {
  annotations
  _tag = `UnknownKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const unknownKeyword = new UnknownKeyword({ [TitleAnnotationId]: `unknown` })
var AnyKeyword = class {
  annotations
  _tag = `AnyKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const anyKeyword = new AnyKeyword({ [TitleAnnotationId]: `any` })
var StringKeyword = class {
  annotations
  _tag = `StringKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const stringKeyword = new StringKeyword({ [TitleAnnotationId]: `string`, [DescriptionAnnotationId]: `a string` }),
  isStringKeyword = createASTGuard(`StringKeyword`)
var NumberKeyword = class {
  annotations
  _tag = `NumberKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const numberKeyword = new NumberKeyword({ [TitleAnnotationId]: `number`, [DescriptionAnnotationId]: `a number` }),
  isNumberKeyword = createASTGuard(`NumberKeyword`)
var BooleanKeyword = class {
  annotations
  _tag = `BooleanKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const booleanKeyword = new BooleanKeyword({ [TitleAnnotationId]: `boolean`, [DescriptionAnnotationId]: `a boolean` }),
  isBooleanKeyword = createASTGuard(`BooleanKeyword`)
var BigIntKeyword = class {
  annotations
  _tag = `BigIntKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const bigIntKeyword = new BigIntKeyword({ [TitleAnnotationId]: `bigint`, [DescriptionAnnotationId]: `a bigint` })
var SymbolKeyword = class {
  annotations
  _tag = `SymbolKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const symbolKeyword = new SymbolKeyword({ [TitleAnnotationId]: `symbol`, [DescriptionAnnotationId]: `a symbol` }),
  isSymbolKeyword = createASTGuard(`SymbolKeyword`)
var ObjectKeyword = class {
  annotations
  _tag = `ObjectKeyword`
  constructor(annotations$2 = {}) {
    this.annotations = annotations$2
  }
  toString() {
    return formatKeyword(this)
  }
  toJSON() {
    return { _tag: this._tag, annotations: toJSONAnnotations(this.annotations) }
  }
}
const objectKeyword = new ObjectKeyword({
  [TitleAnnotationId]: `object`,
  [DescriptionAnnotationId]: 'an object in the TypeScript meaning, i.e. the `object` type',
})
var Enums$1 = class {
    enums
    annotations
    _tag = `Enums`
    constructor(enums, annotations$2 = {}) {
      this.enums = enums, this.annotations = annotations$2
    }
    toString() {
      return getOrElse$5(
        getExpected(this),
        () =>
          `<enum ${this.enums.length} value(s): ${
            this.enums.map(([_$1, value$2]) => JSON.stringify(value$2)).join(` | `)
          }>`,
      )
    }
    toJSON() {
      return { _tag: this._tag, enums: this.enums, annotations: toJSONAnnotations(this.annotations) }
    }
  },
  Type$2 = class {
    type
    annotations
    constructor(type$2, annotations$2 = {}) {
      this.type = type$2, this.annotations = annotations$2
    }
    toJSON() {
      return { type: this.type.toJSON(), annotations: toJSONAnnotations(this.annotations) }
    }
    toString() {
      return String(this.type)
    }
  },
  OptionalType = class extends Type$2 {
    isOptional
    constructor(type$2, isOptional, annotations$2 = {}) {
      super(type$2, annotations$2), this.isOptional = isOptional
    }
    toJSON() {
      return { type: this.type.toJSON(), isOptional: this.isOptional, annotations: toJSONAnnotations(this.annotations) }
    }
    toString() {
      return String(this.type) + (this.isOptional ? `?` : ``)
    }
  }
const getRestASTs = rest => rest.map(annotatedAST => annotatedAST.type)
var TupleType = class {
  elements
  rest
  isReadonly
  annotations
  _tag = `TupleType`
  constructor(elements, rest, isReadonly, annotations$2 = {}) {
    this.elements = elements, this.rest = rest, this.isReadonly = isReadonly, this.annotations = annotations$2
    let hasOptionalElement = !1, hasIllegalRequiredElement = !1
    for (let e$26 of elements) {
      if (e$26.isOptional) hasOptionalElement = !0
      else if (hasOptionalElement) {
        hasIllegalRequiredElement = !0
        break
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage)
    }
  }
  toString() {
    return getOrElse$5(getExpected(this), () => formatTuple(this))
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map(e$26 => e$26.toJSON()),
      rest: this.rest.map(ast => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations),
    }
  }
}
const formatTuple = ast => {
  let formattedElements = ast.elements.map(String).join(`, `)
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head$5, tail) => {
      let formattedHead = String(head$5),
        wrappedHead = formattedHead.includes(` | `) ? `(${formattedHead})` : formattedHead
      if (tail.length > 0) {
        let formattedTail = tail.map(String).join(`, `)
        return ast.elements.length > 0
          ? `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`
          : `readonly [...${wrappedHead}[], ${formattedTail}]`
      } else if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[]]`
      else return `ReadonlyArray<${formattedHead}>`
    },
  })
}
var PropertySignature = class extends OptionalType {
  name
  isReadonly
  constructor(name, type$2, isOptional, isReadonly, annotations$2) {
    super(type$2, isOptional, annotations$2), this.name = name, this.isReadonly = isReadonly
  }
  toString() {
    return (this.isReadonly ? `readonly ` : ``) + String(this.name) + (this.isOptional ? `?` : ``) + `: ` + this.type
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations),
    }
  }
}
const isParameter = ast => {
  switch (ast._tag) {
    case `StringKeyword`:
    case `SymbolKeyword`:
    case `TemplateLiteral`:
      return !0
    case `Refinement`:
      return isParameter(ast.from)
  }
  return !1
}
var IndexSignature = class {
    type
    isReadonly
    parameter
    constructor(parameter, type$2, isReadonly) {
      if (this.type = type$2, this.isReadonly = isReadonly, isParameter(parameter)) this.parameter = parameter
      else throw Error(getASTIndexSignatureParameterErrorMessage)
    }
    toString() {
      return (this.isReadonly ? `readonly ` : ``) + `[x: ${this.parameter}]: ${this.type}`
    }
    toJSON() {
      return { parameter: this.parameter.toJSON(), type: this.type.toJSON(), isReadonly: this.isReadonly }
    }
  },
  TypeLiteral = class {
    annotations
    _tag = `TypeLiteral`
    propertySignatures
    indexSignatures
    constructor(propertySignatures, indexSignatures, annotations$2 = {}) {
      this.annotations = annotations$2
      let keys$6 = {}
      for (let i$14 = 0; i$14 < propertySignatures.length; i$14++) {
        let name = propertySignatures[i$14].name
        if (Object.prototype.hasOwnProperty.call(keys$6, name)) {
          throw Error(getASTDuplicatePropertySignatureErrorMessage(name))
        }
        keys$6[name] = null
      }
      let parameters = { string: !1, symbol: !1 }
      for (let i$14 = 0; i$14 < indexSignatures.length; i$14++) {
        let encodedParameter = getEncodedParameter(indexSignatures[i$14].parameter)
        if (isStringKeyword(encodedParameter)) {
          if (parameters.string) throw Error(getASTDuplicateIndexSignatureErrorMessage(`string`))
          parameters.string = !0
        } else if (isSymbolKeyword(encodedParameter)) {
          if (parameters.symbol) throw Error(getASTDuplicateIndexSignatureErrorMessage(`symbol`))
          parameters.symbol = !0
        }
      }
      this.propertySignatures = propertySignatures, this.indexSignatures = indexSignatures
    }
    toString() {
      return getOrElse$5(getExpected(this), () => formatTypeLiteral(this))
    }
    toJSON() {
      return {
        _tag: this._tag,
        propertySignatures: this.propertySignatures.map(ps => ps.toJSON()),
        indexSignatures: this.indexSignatures.map(ps => ps.toJSON()),
        annotations: toJSONAnnotations(this.annotations),
      }
    }
  }
const formatIndexSignatures = iss => iss.map(String).join(`; `),
  formatTypeLiteral = ast => {
    if (ast.propertySignatures.length > 0) {
      let pss = ast.propertySignatures.map(String).join(`; `)
      return ast.indexSignatures.length > 0 ? `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }` : `{ ${pss} }`
    } else if (ast.indexSignatures.length > 0) return `{ ${formatIndexSignatures(ast.indexSignatures)} }`
    else return `{}`
  },
  isTypeLiteral = createASTGuard(`TypeLiteral`),
  sortCandidates = sort(mapInput(Order$4, ast => {
    switch (ast._tag) {
      case `AnyKeyword`:
        return 0
      case `UnknownKeyword`:
        return 1
      case `ObjectKeyword`:
        return 2
      case `StringKeyword`:
      case `NumberKeyword`:
      case `BooleanKeyword`:
      case `BigIntKeyword`:
      case `SymbolKeyword`:
        return 3
    }
    return 4
  })),
  literalMap = { string: `StringKeyword`, number: `NumberKeyword`, boolean: `BooleanKeyword`, bigint: `BigIntKeyword` },
  flatten$6 = candidates => flatMap$11(candidates, ast => isUnion(ast) ? flatten$6(ast.types) : [ast]),
  unify = candidates => {
    let cs = sortCandidates(candidates), out = [], uniques = {}, literals = []
    for (let ast of cs) {
      switch (ast._tag) {
        case `NeverKeyword`:
          break
        case `AnyKeyword`:
          return [anyKeyword]
        case `UnknownKeyword`:
          return [unknownKeyword]
        case `ObjectKeyword`:
        case `UndefinedKeyword`:
        case `VoidKeyword`:
        case `StringKeyword`:
        case `NumberKeyword`:
        case `BooleanKeyword`:
        case `BigIntKeyword`:
        case `SymbolKeyword`:
          uniques[ast._tag] || (uniques[ast._tag] = ast, out.push(ast))
          break
        case `Literal`: {
          let type$2 = typeof ast.literal
          switch (type$2) {
            case `string`:
            case `number`:
            case `bigint`:
            case `boolean`: {
              let _tag = literalMap[type$2]
              !uniques[_tag] && !literals.includes(ast.literal) && (literals.push(ast.literal), out.push(ast))
              break
            }
            case `object`:
              literals.includes(ast.literal) || (literals.push(ast.literal), out.push(ast))
              break
          }
          break
        }
        case `UniqueSymbol`:
          !uniques.SymbolKeyword && !literals.includes(ast.symbol) && (literals.push(ast.symbol), out.push(ast))
          break
        case `TupleType`:
          uniques.ObjectKeyword || out.push(ast)
          break
        case `TypeLiteral`:
          ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0
            ? uniques[`{}`] || (uniques[`{}`] = ast, out.push(ast))
            : uniques.ObjectKeyword || out.push(ast)
          break
        default:
          out.push(ast)
      }
    }
    return out
  }
var Union$1 = class Union$1 {
  types
  annotations
  static make = (types, annotations$2) =>
    isMembers(types) ? new Union$1(types, annotations$2) : types.length === 1 ? types[0] : neverKeyword
  static unify = (candidates, annotations$2) => Union$1.make(unify(flatten$6(candidates)), annotations$2)
  _tag = `Union`
  constructor(types, annotations$2 = {}) {
    this.types = types, this.annotations = annotations$2
  }
  toString() {
    return getOrElse$5(getExpected(this), () => this.types.map(String).join(` | `))
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations),
    }
  }
}
const mapMembers = (members, f$14) => members.map(f$14),
  isMembers = as$6 => as$6.length > 1,
  isUnion = createASTGuard(`Union`),
  toJSONMemoMap = globalValue(Symbol.for(`effect/Schema/AST/toJSONMemoMap`), () => new WeakMap())
var Suspend = class {
    f
    annotations
    _tag = `Suspend`
    constructor(f$14, annotations$2 = {}) {
      this.f = f$14, this.annotations = annotations$2, this.f = memoizeThunk(f$14)
    }
    toString() {
      return getExpected(this).pipe(
        orElse$7(() => flatMap$12(liftThrowable(this.f)(), ast => getExpected(ast))),
        getOrElse$5(() => `<suspended schema>`),
      )
    }
    toJSON() {
      let ast = this.f(), out = toJSONMemoMap.get(ast)
      return out
        || (toJSONMemoMap.set(ast, { _tag: this._tag }),
          out = { _tag: this._tag, ast: ast.toJSON(), annotations: toJSONAnnotations(this.annotations) },
          toJSONMemoMap.set(ast, out),
          out)
    }
  },
  Refinement$1 = class {
    from
    filter
    annotations
    _tag = `Refinement`
    constructor(from, filter$9, annotations$2 = {}) {
      this.from = from, this.filter = filter$9, this.annotations = annotations$2
    }
    toString() {
      return getIdentifierAnnotation(this).pipe(
        getOrElse$5(() =>
          match$11(getOrElseExpected(this), {
            onNone: () => `{ ${this.from} | filter }`,
            onSome: expected => isRefinement$1(this.from) ? String(this.from) + ` & ` + expected : expected,
          })
        ),
      )
    }
    toJSON() {
      return { _tag: this._tag, from: this.from.toJSON(), annotations: toJSONAnnotations(this.annotations) }
    }
  }
const isRefinement$1 = createASTGuard(`Refinement`), defaultParseOption = {}
var Transformation$1 = class {
  from
  to
  transformation
  annotations
  _tag = `Transformation`
  constructor(from, to, transformation, annotations$2 = {}) {
    this.from = from, this.to = to, this.transformation = transformation, this.annotations = annotations$2
  }
  toString() {
    return getOrElse$5(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`)
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations),
    }
  }
}
const isTransformation$1 = createASTGuard(`Transformation`)
var FinalTransformation = class {
  decode
  encode
  _tag = `FinalTransformation`
  constructor(decode$31, encode$29) {
    this.decode = decode$31, this.encode = encode$29
  }
}
const createTransformationGuard = tag$3 => ast => ast._tag === tag$3
var ComposeTransformation = class {
  _tag = `ComposeTransformation`
}
const composeTransformation = new ComposeTransformation()
var PropertySignatureTransformation$1 = class {
    from
    to
    decode
    encode
    constructor(from, to, decode$31, encode$29) {
      this.from = from, this.to = to, this.decode = decode$31, this.encode = encode$29
    }
  },
  TypeLiteralTransformation = class {
    propertySignatureTransformations
    _tag = `TypeLiteralTransformation`
    constructor(propertySignatureTransformations) {
      this.propertySignatureTransformations = propertySignatureTransformations
      let fromKeys = {}, toKeys = {}
      for (let pst of propertySignatureTransformations) {
        let from = pst.from
        if (fromKeys[from]) throw Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from))
        fromKeys[from] = !0
        let to = pst.to
        if (toKeys[to]) throw Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to))
        toKeys[to] = !0
      }
    }
  }
const isTypeLiteralTransformation = createTransformationGuard(`TypeLiteralTransformation`),
  annotations$1 = (ast, overrides) => {
    let d$7 = Object.getOwnPropertyDescriptors(ast),
      value$2 = { ...ast.annotations, ...overrides },
      surrogate = getSurrogateAnnotation(ast)
    return isSome(surrogate) && (value$2[SurrogateAnnotationId] = annotations$1(surrogate.value, overrides)),
      d$7.annotations.value = value$2,
      Object.create(Object.getPrototypeOf(ast), d$7)
  },
  STRING_KEYWORD_PATTERN = `[\\s\\S]*`,
  NUMBER_KEYWORD_PATTERN = `[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?`,
  getTemplateLiteralSpanTypePattern = (type$2, capture$1) => {
    switch (type$2._tag) {
      case `Literal`:
        return escape(String(type$2.literal))
      case `StringKeyword`:
        return STRING_KEYWORD_PATTERN
      case `NumberKeyword`:
        return NUMBER_KEYWORD_PATTERN
      case `TemplateLiteral`:
        return getTemplateLiteralPattern(type$2, capture$1, !1)
      case `Union`:
        return type$2.types.map(type$3 => getTemplateLiteralSpanTypePattern(type$3, capture$1)).join(`|`)
    }
  },
  handleTemplateLiteralSpanTypeParens = (type$2, s$14, capture$1, top) => {
    if (isUnion(type$2)) {
      if (capture$1 && !top) return `(?:${s$14})`
      else if (!capture$1 || !top) return s$14
    }
    return `(${s$14})`
  },
  getTemplateLiteralPattern = (ast, capture$1, top) => {
    let pattern$1 = ``
    if (ast.head !== ``) {
      let head$5 = escape(ast.head)
      pattern$1 += capture$1 && top ? `(${head$5})` : head$5
    }
    for (let span$1 of ast.spans) {
      let spanPattern = getTemplateLiteralSpanTypePattern(span$1.type, capture$1)
      if (
        pattern$1 += handleTemplateLiteralSpanTypeParens(span$1.type, spanPattern, capture$1, top),
          span$1.literal !== ``
      ) {
        let literal = escape(span$1.literal)
        pattern$1 += capture$1 && top ? `(${literal})` : literal
      }
    }
    return pattern$1
  },
  getTemplateLiteralRegExp = ast => RegExp(`^${getTemplateLiteralPattern(ast, !1, !0)}$`),
  record$1 = (key$1, value$2) => {
    let propertySignatures = [],
      indexSignatures = [],
      go$2 = key$2 => {
        switch (key$2._tag) {
          case `NeverKeyword`:
            break
          case `StringKeyword`:
          case `SymbolKeyword`:
          case `TemplateLiteral`:
          case `Refinement`:
            indexSignatures.push(new IndexSignature(key$2, value$2, !0))
            break
          case `Literal`:
            if (isString$1(key$2.literal) || isNumber$1(key$2.literal)) {
              propertySignatures.push(new PropertySignature(key$2.literal, value$2, !1, !0))
            } else throw Error(getASTUnsupportedLiteralErrorMessage(key$2.literal))
            break
          case `Enums`:
            for (let [_$1, name] of key$2.enums) propertySignatures.push(new PropertySignature(name, value$2, !1, !0))
            break
          case `UniqueSymbol`:
            propertySignatures.push(new PropertySignature(key$2.symbol, value$2, !1, !0))
            break
          case `Union`:
            key$2.types.forEach(go$2)
            break
          default:
            throw Error(getASTUnsupportedKeySchemaErrorMessage(key$2))
        }
      }
    return go$2(key$1), { propertySignatures, indexSignatures }
  },
  mutable$1 = ast => {
    switch (ast._tag) {
      case `TupleType`:
        return ast.isReadonly === !1 ? ast : new TupleType(ast.elements, ast.rest, !1, ast.annotations)
      case `TypeLiteral`: {
        let propertySignatures = changeMap(
            ast.propertySignatures,
            ps =>
              ps.isReadonly === !1 ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, !1, ps.annotations),
          ),
          indexSignatures = changeMap(
            ast.indexSignatures,
            is$29 => is$29.isReadonly === !1 ? is$29 : new IndexSignature(is$29.parameter, is$29.type, !1),
          )
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures
          ? ast
          : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations)
      }
      case `Union`: {
        let types = changeMap(ast.types, mutable$1)
        return types === ast.types ? ast : Union$1.make(types, ast.annotations)
      }
      case `Suspend`:
        return new Suspend(() => mutable$1(ast.f()), ast.annotations)
      case `Refinement`: {
        let from = mutable$1(ast.from)
        return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations)
      }
      case `Transformation`: {
        let from = mutable$1(ast.from), to = mutable$1(ast.to)
        return from === ast.from && to === ast.to
          ? ast
          : new Transformation$1(from, to, ast.transformation, ast.annotations)
      }
    }
    return ast
  },
  pickAnnotations = annotationIds => annotated => {
    let out
    for (let id$2 of annotationIds) {
      Object.prototype.hasOwnProperty.call(annotated.annotations, id$2)
        && (out === void 0 && (out = {}), out[id$2] = annotated.annotations[id$2])
    }
    return out
  },
  omitAnnotations = annotationIds => annotated => {
    let out = { ...annotated.annotations }
    for (let id$2 of annotationIds) delete out[id$2]
    return out
  },
  preserveTransformationAnnotations = pickAnnotations([
    ExamplesAnnotationId,
    DefaultAnnotationId,
    JSONSchemaAnnotationId,
    ArbitraryAnnotationId,
    PrettyAnnotationId,
    EquivalenceAnnotationId,
  ]),
  typeAST = ast => {
    switch (ast._tag) {
      case `Declaration`: {
        let typeParameters = changeMap(ast.typeParameters, typeAST)
        return typeParameters === ast.typeParameters
          ? ast
          : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations)
      }
      case `TupleType`: {
        let elements = changeMap(ast.elements, e$26 => {
            let type$2 = typeAST(e$26.type)
            return type$2 === e$26.type ? e$26 : new OptionalType(type$2, e$26.isOptional)
          }),
          restASTs = getRestASTs(ast.rest),
          rest = changeMap(restASTs, typeAST)
        return elements === ast.elements && rest === restASTs
          ? ast
          : new TupleType(elements, rest.map(type$2 => new Type$2(type$2)), ast.isReadonly, ast.annotations)
      }
      case `TypeLiteral`: {
        let propertySignatures = changeMap(ast.propertySignatures, p$25 => {
            let type$2 = typeAST(p$25.type)
            return type$2 === p$25.type
              ? p$25
              : new PropertySignature(p$25.name, type$2, p$25.isOptional, p$25.isReadonly)
          }),
          indexSignatures = changeMap(ast.indexSignatures, is$29 => {
            let type$2 = typeAST(is$29.type)
            return type$2 === is$29.type ? is$29 : new IndexSignature(is$29.parameter, type$2, is$29.isReadonly)
          })
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures
          ? ast
          : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations)
      }
      case `Union`: {
        let types = changeMap(ast.types, typeAST)
        return types === ast.types ? ast : Union$1.make(types, ast.annotations)
      }
      case `Suspend`:
        return new Suspend(() => typeAST(ast.f()), ast.annotations)
      case `Refinement`: {
        let from = typeAST(ast.from)
        return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations)
      }
      case `Transformation`: {
        let preserve = preserveTransformationAnnotations(ast)
        return typeAST(preserve === void 0 ? ast.to : annotations$1(ast.to, preserve))
      }
    }
    return ast
  },
  createJSONIdentifierAnnotation = annotated =>
    match$11(getJSONIdentifier(annotated), {
      onNone: () => void 0,
      onSome: identifier$1 => ({ [JSONIdentifierAnnotationId]: identifier$1 }),
    })
function changeMap(as$6, f$14) {
  let changed = !1, out = allocate(as$6.length)
  for (let i$14 = 0; i$14 < as$6.length; i$14++) {
    let a$22 = as$6[i$14], fa = f$14(a$22)
    fa !== a$22 && (changed = !0), out[i$14] = fa
  }
  return changed ? out : as$6
}
const getTransformationFrom = ast => {
    switch (ast._tag) {
      case `Transformation`:
        return ast.from
      case `Refinement`:
        return getTransformationFrom(ast.from)
      case `Suspend`:
        return getTransformationFrom(ast.f())
    }
  },
  encodedAST_ = (ast, isBound) => {
    switch (ast._tag) {
      case `Declaration`: {
        let typeParameters = changeMap(ast.typeParameters, ast$1 => encodedAST_(ast$1, isBound))
        return typeParameters === ast.typeParameters
          ? ast
          : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations)
      }
      case `TupleType`: {
        let elements = changeMap(ast.elements, e$26 => {
            let type$2 = encodedAST_(e$26.type, isBound)
            return type$2 === e$26.type ? e$26 : new OptionalType(type$2, e$26.isOptional)
          }),
          restASTs = getRestASTs(ast.rest),
          rest = changeMap(restASTs, ast$1 => encodedAST_(ast$1, isBound))
        return elements === ast.elements && rest === restASTs
          ? ast
          : new TupleType(
            elements,
            rest.map(ast$1 => new Type$2(ast$1)),
            ast.isReadonly,
            createJSONIdentifierAnnotation(ast),
          )
      }
      case `TypeLiteral`: {
        let propertySignatures = changeMap(ast.propertySignatures, ps => {
            let type$2 = encodedAST_(ps.type, isBound)
            return type$2 === ps.type ? ps : new PropertySignature(ps.name, type$2, ps.isOptional, ps.isReadonly)
          }),
          indexSignatures = changeMap(ast.indexSignatures, is$29 => {
            let type$2 = encodedAST_(is$29.type, isBound)
            return type$2 === is$29.type ? is$29 : new IndexSignature(is$29.parameter, type$2, is$29.isReadonly)
          })
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures
          ? ast
          : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast))
      }
      case `Union`: {
        let types = changeMap(ast.types, ast$1 => encodedAST_(ast$1, isBound))
        return types === ast.types ? ast : Union$1.make(types, createJSONIdentifierAnnotation(ast))
      }
      case `Suspend`:
        return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast))
      case `Refinement`: {
        let from = encodedAST_(ast.from, isBound)
        if (isBound) {
          if (from === ast.from) return ast
          if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
            return new Refinement$1(from, ast.filter, ast.annotations)
          }
        }
        let identifier$1 = createJSONIdentifierAnnotation(ast)
        return identifier$1 ? annotations$1(from, identifier$1) : from
      }
      case `Transformation`: {
        let identifier$1 = createJSONIdentifierAnnotation(ast)
        return encodedAST_(identifier$1 ? annotations$1(ast.from, identifier$1) : ast.from, isBound)
      }
    }
    return ast
  },
  encodedAST = ast => encodedAST_(ast, !1),
  toJSONAnnotations = annotations$2 => {
    let out = {}
    for (let k$1 of Object.getOwnPropertySymbols(annotations$2)) out[String(k$1)] = annotations$2[k$1]
    return out
  },
  getEncodedParameter = ast => {
    switch (ast._tag) {
      case `StringKeyword`:
      case `SymbolKeyword`:
      case `TemplateLiteral`:
        return ast
      case `Refinement`:
        return getEncodedParameter(ast.from)
    }
  },
  compose$1 = (ab, cd) => new Transformation$1(ab, cd, composeTransformation),
  formatKeyword = ast => getOrElse$5(getExpected(ast), () => ast._tag)
function getBrands(ast) {
  return match$11(getBrandAnnotation(ast), {
    onNone: () => ``,
    onSome: brands => brands.map(brand$1 => ` & Brand<${formatUnknown(brand$1)}>`).join(``),
  })
}
const getOrElseExpected = ast =>
    getTitleAnnotation(ast).pipe(
      orElse$7(() => getDescriptionAnnotation(ast)),
      orElse$7(() => getAutoTitleAnnotation(ast)),
      map$18(s$14 => s$14 + getBrands(ast)),
    ),
  getExpected = ast => orElse$7(getIdentifierAnnotation(ast), () => getOrElseExpected(ast)),
  isBoolean$1 = isBoolean$2,
  Equivalence$1 = boolean$3,
  Order$3 = boolean$2,
  not$2 = self$1 => !self$1,
  TagTypeId$1 = Symbol.for(`effect/Context/Tag`),
  ReferenceTypeId$1 = Symbol.for(`effect/Context/Reference`),
  STMSymbolKey = `effect/STM`,
  STMTypeId = Symbol.for(STMSymbolKey),
  TagProto = {
    ...EffectPrototype$1,
    _op: `Tag`,
    [STMTypeId]: effectVariance,
    [TagTypeId$1]: { _Service: _$1 => _$1, _Identifier: _$1 => _$1 },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `Tag`, key: this.key, stack: this.stack }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    of(self$1) {
      return self$1
    },
    context(self$1) {
      return make$58(this, self$1)
    },
  },
  ReferenceProto = { ...TagProto, [ReferenceTypeId$1]: ReferenceTypeId$1 },
  makeGenericTag = key$1 => {
    let limit = Error.stackTraceLimit
    Error.stackTraceLimit = 2
    let creationError = Error()
    Error.stackTraceLimit = limit
    let tag$3 = Object.create(TagProto)
    return Object.defineProperty(tag$3, `stack`, {
      get() {
        return creationError.stack
      },
    }),
      tag$3.key = key$1,
      tag$3
  },
  Tag$1 = id$2 => () => {
    let limit = Error.stackTraceLimit
    Error.stackTraceLimit = 2
    let creationError = Error()
    Error.stackTraceLimit = limit
    function TagClass() {}
    return Object.setPrototypeOf(TagClass, TagProto),
      TagClass.key = id$2,
      Object.defineProperty(TagClass, `stack`, {
        get() {
          return creationError.stack
        },
      }),
      TagClass
  },
  Reference$1 = () => (id$2, options$2) => {
    let limit = Error.stackTraceLimit
    Error.stackTraceLimit = 2
    let creationError = Error()
    Error.stackTraceLimit = limit
    function ReferenceClass() {}
    return Object.setPrototypeOf(ReferenceClass, ReferenceProto),
      ReferenceClass.key = id$2,
      ReferenceClass.defaultValue = options$2.defaultValue,
      Object.defineProperty(ReferenceClass, `stack`, {
        get() {
          return creationError.stack
        },
      }),
      ReferenceClass
  },
  TypeId$19 = Symbol.for(`effect/Context`),
  ContextProto = {
    [TypeId$19]: { _Services: _$1 => _$1 },
    [symbol$1](that) {
      if (isContext$1(that) && this.unsafeMap.size === that.unsafeMap.size) {
        for (let k$1 of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k$1) || !equals(this.unsafeMap.get(k$1), that.unsafeMap.get(k$1))) return !1
        }
        return !0
      }
      return !1
    },
    [symbol$2]() {
      return cached$2(this, number$3(this.unsafeMap.size))
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `Context`, services: Array.from(this.unsafeMap).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
  },
  makeContext = unsafeMap => {
    let context$2 = Object.create(ContextProto)
    return context$2.unsafeMap = unsafeMap, context$2
  },
  serviceNotFoundError = tag$3 => {
    let error = Error(`Service not found${tag$3.key ? `: ${String(tag$3.key)}` : ``}`)
    if (tag$3.stack) {
      let lines = tag$3.stack.split(`
`)
      if (lines.length > 2) {
        let afterAt = lines[2].match(/at (.*)/)
        afterAt && (error.message += ` (defined at ${afterAt[1]})`)
      }
    }
    if (error.stack) {
      let lines = error.stack.split(`
`)
      lines.splice(1, 3),
        error.stack = lines.join(`
`)
    }
    return error
  },
  isContext$1 = u$7 => hasProperty(u$7, TypeId$19),
  isTag$1 = u$7 => hasProperty(u$7, TagTypeId$1),
  isReference$1 = u$7 => hasProperty(u$7, ReferenceTypeId$1),
  _empty$9 = makeContext(new Map()),
  empty$34 = () => _empty$9,
  make$58 = (tag$3, service) => makeContext(new Map([[tag$3.key, service]])),
  add$4 = dual(3, (self$1, tag$3, service) => {
    let map$20 = new Map(self$1.unsafeMap)
    return map$20.set(tag$3.key, service), makeContext(map$20)
  }),
  defaultValueCache = globalValue(`effect/Context/defaultValueCache`, () => new Map()),
  getDefaultValue = tag$3 => {
    if (defaultValueCache.has(tag$3.key)) return defaultValueCache.get(tag$3.key)
    let value$2 = tag$3.defaultValue()
    return defaultValueCache.set(tag$3.key, value$2), value$2
  },
  unsafeGetReference = (self$1, tag$3) =>
    self$1.unsafeMap.has(tag$3.key) ? self$1.unsafeMap.get(tag$3.key) : getDefaultValue(tag$3),
  unsafeGet$4 = dual(2, (self$1, tag$3) => {
    if (!self$1.unsafeMap.has(tag$3.key)) {
      if (ReferenceTypeId$1 in tag$3) return getDefaultValue(tag$3)
      throw serviceNotFoundError(tag$3)
    }
    return self$1.unsafeMap.get(tag$3.key)
  }),
  get$10 = unsafeGet$4,
  getOrElse$4 = dual(
    3,
    (self$1, tag$3, orElse$8) =>
      self$1.unsafeMap.has(tag$3.key)
        ? self$1.unsafeMap.get(tag$3.key)
        : isReference$1(tag$3)
        ? getDefaultValue(tag$3)
        : orElse$8(),
  ),
  getOption$1 = dual(
    2,
    (self$1, tag$3) =>
      self$1.unsafeMap.has(tag$3.key)
        ? some$5(self$1.unsafeMap.get(tag$3.key))
        : isReference$1(tag$3)
        ? some$5(getDefaultValue(tag$3))
        : none$8,
  ),
  merge$7 = dual(2, (self$1, that) => {
    let map$20 = new Map(self$1.unsafeMap)
    for (let [tag$3, s$14] of that.unsafeMap) map$20.set(tag$3, s$14)
    return makeContext(map$20)
  }),
  mergeAll$4 = (...ctxs) => {
    let map$20 = new Map()
    for (let ctx of ctxs) for (let [tag$3, s$14] of ctx.unsafeMap) map$20.set(tag$3, s$14)
    return makeContext(map$20)
  },
  pick$2 = (...tags$2) => self$1 => {
    let tagSet = new Set(tags$2.map(_$1 => _$1.key)), newEnv = new Map()
    for (let [tag$3, s$14] of self$1.unsafeMap.entries()) tagSet.has(tag$3) && newEnv.set(tag$3, s$14)
    return makeContext(newEnv)
  },
  omit$2 = (...tags$2) => self$1 => {
    let newEnv = new Map(self$1.unsafeMap)
    for (let tag$3 of tags$2) newEnv.delete(tag$3.key)
    return makeContext(newEnv)
  },
  TagTypeId = TagTypeId$1,
  ReferenceTypeId = ReferenceTypeId$1,
  GenericTag = makeGenericTag,
  TypeId$18 = TypeId$19,
  unsafeMake$9 = makeContext,
  isContext = isContext$1,
  isTag = isTag$1,
  isReference = isReference$1,
  empty$33 = empty$34,
  make$57 = make$58,
  add$3 = add$4,
  get$9 = get$10,
  getOrElse$3 = getOrElse$4,
  unsafeGet$3 = unsafeGet$4,
  getOption = getOption$1,
  merge$6 = merge$7,
  mergeAll$3 = mergeAll$4,
  pick$1 = pick$2,
  omit$1 = omit$2,
  Tag = Tag$1,
  Reference = Reference$1,
  TypeId$17 = Symbol.for(`effect/Chunk`)
function copy(src, srcPos, dest, destPos, len) {
  for (let i$14 = srcPos; i$14 < Math.min(src.length, srcPos + len); i$14++) dest[destPos + i$14 - srcPos] = src[i$14]
  return dest
}
const emptyArray = [],
  getEquivalence$2 = isEquivalent =>
    make$61((self$1, that) =>
      self$1.length === that.length
      && toReadonlyArray(self$1).every((value$2, i$14) => isEquivalent(value$2, unsafeGet$2(that, i$14)))
    ),
  _equivalence$1 = getEquivalence$2(equals),
  ChunkProto = {
    [TypeId$17]: { _A: _$1 => _$1 },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `Chunk`, values: toReadonlyArray(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    [symbol$1](that) {
      return isChunk(that) && _equivalence$1(this, that)
    },
    [symbol$2]() {
      return cached$2(this, array$1(toReadonlyArray(this)))
    },
    [Symbol.iterator]() {
      switch (this.backing._tag) {
        case `IArray`:
          return this.backing.array[Symbol.iterator]()
        case `IEmpty`:
          return emptyArray[Symbol.iterator]()
        default:
          return toReadonlyArray(this)[Symbol.iterator]()
      }
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  makeChunk = backing => {
    let chunk$2 = Object.create(ChunkProto)
    switch (chunk$2.backing = backing, backing._tag) {
      case `IEmpty`:
        chunk$2.length = 0, chunk$2.depth = 0, chunk$2.left = chunk$2, chunk$2.right = chunk$2
        break
      case `IConcat`:
        chunk$2.length = backing.left.length + backing.right.length,
          chunk$2.depth = 1 + Math.max(backing.left.depth, backing.right.depth),
          chunk$2.left = backing.left,
          chunk$2.right = backing.right
        break
      case `IArray`:
        chunk$2.length = backing.array.length, chunk$2.depth = 0, chunk$2.left = _empty$8, chunk$2.right = _empty$8
        break
      case `ISingleton`:
        chunk$2.length = 1, chunk$2.depth = 0, chunk$2.left = _empty$8, chunk$2.right = _empty$8
        break
      case `ISlice`:
        chunk$2.length = backing.length,
          chunk$2.depth = backing.chunk.depth + 1,
          chunk$2.left = _empty$8,
          chunk$2.right = _empty$8
        break
    }
    return chunk$2
  },
  isChunk = u$7 => hasProperty(u$7, TypeId$17),
  _empty$8 = makeChunk({ _tag: `IEmpty` }),
  empty$32 = () => _empty$8,
  make$56 = (...as$6) => unsafeFromNonEmptyArray(as$6),
  of$3 = a$22 => makeChunk({ _tag: `ISingleton`, a: a$22 }),
  fromIterable$9 = self$1 => isChunk(self$1) ? self$1 : unsafeFromArray(fromIterable$10(self$1)),
  copyToArray = (self$1, array$3, initial) => {
    switch (self$1.backing._tag) {
      case `IArray`:
        copy(self$1.backing.array, 0, array$3, initial, self$1.length)
        break
      case `IConcat`:
        copyToArray(self$1.left, array$3, initial), copyToArray(self$1.right, array$3, initial + self$1.left.length)
        break
      case `ISingleton`:
        array$3[initial] = self$1.backing.a
        break
      case `ISlice`: {
        let i$14 = 0, j$1 = initial
        for (; i$14 < self$1.length;) array$3[j$1] = unsafeGet$2(self$1, i$14), i$14 += 1, j$1 += 1
        break
      }
    }
  },
  toReadonlyArray_ = self$1 => {
    switch (self$1.backing._tag) {
      case `IEmpty`:
        return emptyArray
      case `IArray`:
        return self$1.backing.array
      default: {
        let arr = Array(self$1.length)
        return copyToArray(self$1, arr, 0),
          self$1.backing = { _tag: `IArray`, array: arr },
          self$1.left = _empty$8,
          self$1.right = _empty$8,
          self$1.depth = 0,
          arr
      }
    }
  },
  toReadonlyArray = toReadonlyArray_,
  reverseChunk = self$1 => {
    switch (self$1.backing._tag) {
      case `IEmpty`:
      case `ISingleton`:
        return self$1
      case `IArray`:
        return makeChunk({ _tag: `IArray`, array: reverse$2(self$1.backing.array) })
      case `IConcat`:
        return makeChunk({
          _tag: `IConcat`,
          left: reverse$1(self$1.backing.right),
          right: reverse$1(self$1.backing.left),
        })
      case `ISlice`:
        return unsafeFromArray(reverse$2(toReadonlyArray(self$1)))
    }
  },
  reverse$1 = reverseChunk,
  get$8 = dual(
    2,
    (self$1, index$4) => index$4 < 0 || index$4 >= self$1.length ? none$7() : some$4(unsafeGet$2(self$1, index$4)),
  ),
  unsafeFromArray = self$1 =>
    self$1.length === 0
      ? empty$32()
      : self$1.length === 1
      ? of$3(self$1[0])
      : makeChunk({ _tag: `IArray`, array: self$1 }),
  unsafeFromNonEmptyArray = self$1 => unsafeFromArray(self$1),
  unsafeGet$2 = dual(2, (self$1, index$4) => {
    switch (self$1.backing._tag) {
      case `IEmpty`:
        throw Error(`Index out of bounds`)
      case `ISingleton`:
        if (index$4 !== 0) throw Error(`Index out of bounds`)
        return self$1.backing.a
      case `IArray`:
        if (index$4 >= self$1.length || index$4 < 0) throw Error(`Index out of bounds`)
        return self$1.backing.array[index$4]
      case `IConcat`:
        return index$4 < self$1.left.length
          ? unsafeGet$2(self$1.left, index$4)
          : unsafeGet$2(self$1.right, index$4 - self$1.left.length)
      case `ISlice`:
        return unsafeGet$2(self$1.backing.chunk, index$4 + self$1.backing.offset)
    }
  }),
  append$1 = dual(2, (self$1, a$22) => appendAll$1(self$1, of$3(a$22))),
  prepend$1 = dual(2, (self$1, elem) => appendAll$1(of$3(elem), self$1)),
  drop = dual(2, (self$1, n$19) => {
    if (n$19 <= 0) return self$1
    if (n$19 >= self$1.length) return _empty$8
    switch (self$1.backing._tag) {
      case `ISlice`:
        return makeChunk({
          _tag: `ISlice`,
          chunk: self$1.backing.chunk,
          offset: self$1.backing.offset + n$19,
          length: self$1.backing.length - n$19,
        })
      case `IConcat`:
        return n$19 > self$1.left.length
          ? drop(self$1.right, n$19 - self$1.left.length)
          : makeChunk({ _tag: `IConcat`, left: drop(self$1.left, n$19), right: self$1.right })
      default:
        return makeChunk({ _tag: `ISlice`, chunk: self$1, offset: n$19, length: self$1.length - n$19 })
    }
  }),
  appendAll$1 = dual(2, (self$1, that) => {
    if (self$1.backing._tag === `IEmpty`) return that
    if (that.backing._tag === `IEmpty`) return self$1
    let diff$10 = that.depth - self$1.depth
    if (Math.abs(diff$10) <= 1) return makeChunk({ _tag: `IConcat`, left: self$1, right: that })
    if (diff$10 < -1) {
      if (self$1.left.depth >= self$1.right.depth) {
        let nr = appendAll$1(self$1.right, that)
        return makeChunk({ _tag: `IConcat`, left: self$1.left, right: nr })
      } else {
        let nrr = appendAll$1(self$1.right.right, that)
        if (nrr.depth === self$1.depth - 3) {
          let nr = makeChunk({ _tag: `IConcat`, left: self$1.right.left, right: nrr })
          return makeChunk({ _tag: `IConcat`, left: self$1.left, right: nr })
        } else {
          let nl = makeChunk({ _tag: `IConcat`, left: self$1.left, right: self$1.right.left })
          return makeChunk({ _tag: `IConcat`, left: nl, right: nrr })
        }
      }
    } else if (that.right.depth >= that.left.depth) {
      let nl = appendAll$1(self$1, that.left)
      return makeChunk({ _tag: `IConcat`, left: nl, right: that.right })
    } else {
      let nll = appendAll$1(self$1, that.left.left)
      if (nll.depth === that.depth - 3) {
        let nl = makeChunk({ _tag: `IConcat`, left: nll, right: that.left.right })
        return makeChunk({ _tag: `IConcat`, left: nl, right: that.right })
      } else {
        let nr = makeChunk({ _tag: `IConcat`, left: that.left.right, right: that.right })
        return makeChunk({ _tag: `IConcat`, left: nll, right: nr })
      }
    }
  }),
  isEmpty$9 = self$1 => self$1.length === 0,
  isNonEmpty$4 = self$1 => self$1.length > 0,
  head$3 = get$8(0),
  unsafeHead = self$1 => unsafeGet$2(self$1, 0),
  headNonEmpty = unsafeHead,
  tailNonEmpty = self$1 => drop(self$1, 1),
  contains$3 = contains$4,
  containsWith = containsWith$1,
  findFirst$6 = findFirst$7,
  findFirstIndex = findFirstIndex$1,
  findLast = findLast$1,
  findLastIndex = findLastIndex$1,
  join$5 = join$6,
  reduce$11 = reduce$12,
  reduceRight$2 = reduceRight$3,
  TypeId$16 = Symbol.for(`effect/Duration`),
  bigint0$2 = BigInt(0),
  bigint24 = BigInt(24),
  bigint60 = BigInt(60),
  bigint1e3 = BigInt(1e3),
  bigint1e6 = BigInt(1e6),
  bigint1e9 = BigInt(1e9),
  DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/,
  decode$30 = input => {
    if (isDuration(input)) return input
    if (isNumber$1(input)) return millis(input)
    if (isBigInt(input)) return nanos(input)
    if (Array.isArray(input) && input.length === 2 && input.every(isNumber$1)) {
      return input[0] === -1 / 0 || input[1] === -1 / 0 || Number.isNaN(input[0]) || Number.isNaN(input[1])
        ? zero
        : input[0] === 1 / 0 || input[1] === 1 / 0
        ? infinity
        : nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])))
    }
    if (isString$1(input)) {
      let match$13 = DURATION_REGEX.exec(input)
      if (match$13) {
        let [_$1, valueStr, unit] = match$13, value$2 = Number(valueStr)
        switch (unit) {
          case `nano`:
          case `nanos`:
            return nanos(BigInt(valueStr))
          case `micro`:
          case `micros`:
            return micros(BigInt(valueStr))
          case `milli`:
          case `millis`:
            return millis(value$2)
          case `second`:
          case `seconds`:
            return seconds(value$2)
          case `minute`:
          case `minutes`:
            return minutes(value$2)
          case `hour`:
          case `hours`:
            return hours(value$2)
          case `day`:
          case `days`:
            return days(value$2)
          case `week`:
          case `weeks`:
            return weeks(value$2)
        }
      }
    }
    throw Error(`Invalid DurationInput`)
  },
  zeroValue = { _tag: `Millis`, millis: 0 },
  infinityValue = { _tag: `Infinity` },
  DurationProto = {
    [TypeId$16]: TypeId$16,
    [symbol$2]() {
      return cached$2(this, structure(this.value))
    },
    [symbol$1](that) {
      return isDuration(that) && equals$1(this, that)
    },
    toString() {
      return `Duration(${format$3(this)})`
    },
    toJSON() {
      switch (this.value._tag) {
        case `Millis`:
          return { _id: `Duration`, _tag: `Millis`, millis: this.value.millis }
        case `Nanos`:
          return { _id: `Duration`, _tag: `Nanos`, hrtime: toHrTime(this) }
        case `Infinity`:
          return { _id: `Duration`, _tag: `Infinity` }
      }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  make$55 = input => {
    let duration = Object.create(DurationProto)
    return isNumber$1(input)
      ? isNaN(input) || input <= 0
        ? duration.value = zeroValue
        : Number.isFinite(input)
        ? Number.isInteger(input)
          ? duration.value = { _tag: `Millis`, millis: input }
          : duration.value = { _tag: `Nanos`, nanos: BigInt(Math.round(input * 1e6)) }
        : duration.value = infinityValue
      : input <= bigint0$2
      ? duration.value = zeroValue
      : duration.value = { _tag: `Nanos`, nanos: input },
      duration
  },
  isDuration = u$7 => hasProperty(u$7, TypeId$16),
  isZero = self$1 => {
    switch (self$1.value._tag) {
      case `Millis`:
        return self$1.value.millis === 0
      case `Nanos`:
        return self$1.value.nanos === bigint0$2
      case `Infinity`:
        return !1
    }
  },
  zero = make$55(0),
  infinity = make$55(1 / 0),
  nanos = nanos$1 => make$55(nanos$1),
  micros = micros$1 => make$55(micros$1 * bigint1e3),
  millis = millis$1 => make$55(millis$1),
  seconds = seconds$1 => make$55(seconds$1 * 1e3),
  minutes = minutes$1 => make$55(minutes$1 * 6e4),
  hours = hours$1 => make$55(hours$1 * 36e5),
  days = days$1 => make$55(days$1 * 864e5),
  weeks = weeks$1 => make$55(weeks$1 * 6048e5),
  toMillis = self$1 => match$10(self$1, { onMillis: millis$1 => millis$1, onNanos: nanos$1 => Number(nanos$1) / 1e6 }),
  toSeconds = self$1 =>
    match$10(self$1, { onMillis: millis$1 => millis$1 / 1e3, onNanos: nanos$1 => Number(nanos$1) / 1e9 }),
  unsafeToNanos = self$1 => {
    let _self = decode$30(self$1)
    switch (_self.value._tag) {
      case `Infinity`:
        throw Error(`Cannot convert infinite duration to nanos`)
      case `Nanos`:
        return _self.value.nanos
      case `Millis`:
        return BigInt(Math.round(_self.value.millis * 1e6))
    }
  },
  toHrTime = self$1 => {
    let _self = decode$30(self$1)
    switch (_self.value._tag) {
      case `Infinity`:
        return [1 / 0, 0]
      case `Nanos`:
        return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)]
      case `Millis`:
        return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)]
    }
  },
  match$10 = dual(2, (self$1, options$2) => {
    let _self = decode$30(self$1)
    switch (_self.value._tag) {
      case `Nanos`:
        return options$2.onNanos(_self.value.nanos)
      case `Infinity`:
        return options$2.onMillis(1 / 0)
      case `Millis`:
        return options$2.onMillis(_self.value.millis)
    }
  }),
  matchWith = dual(3, (self$1, that, options$2) => {
    let _self = decode$30(self$1), _that = decode$30(that)
    if (_self.value._tag === `Infinity` || _that.value._tag === `Infinity`) {
      return options$2.onMillis(toMillis(_self), toMillis(_that))
    }
    if (_self.value._tag === `Nanos` || _that.value._tag === `Nanos`) {
      let selfNanos = _self.value._tag === `Nanos` ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6)),
        thatNanos = _that.value._tag === `Nanos` ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6))
      return options$2.onNanos(selfNanos, thatNanos)
    }
    return options$2.onMillis(_self.value.millis, _that.value.millis)
  }),
  Equivalence = (self$1, that) =>
    matchWith(self$1, that, {
      onMillis: (self$2, that$1) => self$2 === that$1,
      onNanos: (self$2, that$1) => self$2 === that$1,
    }),
  lessThanOrEqualTo = dual(
    2,
    (self$1, that) =>
      matchWith(self$1, that, {
        onMillis: (self$2, that$1) => self$2 <= that$1,
        onNanos: (self$2, that$1) => self$2 <= that$1,
      }),
  ),
  greaterThanOrEqualTo = dual(
    2,
    (self$1, that) =>
      matchWith(self$1, that, {
        onMillis: (self$2, that$1) => self$2 >= that$1,
        onNanos: (self$2, that$1) => self$2 >= that$1,
      }),
  ),
  equals$1 = dual(2, (self$1, that) => Equivalence(decode$30(self$1), decode$30(that))),
  parts = self$1 => {
    let duration = decode$30(self$1)
    if (duration.value._tag === `Infinity`) {
      return { days: 1 / 0, hours: 1 / 0, minutes: 1 / 0, seconds: 1 / 0, millis: 1 / 0, nanos: 1 / 0 }
    }
    let nanos$1 = unsafeToNanos(duration),
      ms = nanos$1 / bigint1e6,
      sec = ms / bigint1e3,
      min$10 = sec / bigint60,
      hr = min$10 / bigint60,
      days$1 = hr / bigint24
    return {
      days: Number(days$1),
      hours: Number(hr % bigint24),
      minutes: Number(min$10 % bigint60),
      seconds: Number(sec % bigint60),
      millis: Number(ms % bigint1e3),
      nanos: Number(nanos$1 % bigint1e6),
    }
  },
  format$3 = self$1 => {
    let duration = decode$30(self$1)
    if (duration.value._tag === `Infinity`) return `Infinity`
    if (isZero(duration)) return `0`
    let fragments = parts(duration), pieces = []
    return fragments.days !== 0 && pieces.push(`${fragments.days}d`),
      fragments.hours !== 0 && pieces.push(`${fragments.hours}h`),
      fragments.minutes !== 0 && pieces.push(`${fragments.minutes}m`),
      fragments.seconds !== 0 && pieces.push(`${fragments.seconds}s`),
      fragments.millis !== 0 && pieces.push(`${fragments.millis}ms`),
      fragments.nanos !== 0 && pieces.push(`${fragments.nanos}ns`),
      pieces.join(` `)
  },
  SIZE = 5,
  BUCKET_SIZE = 2 ** SIZE,
  MASK = BUCKET_SIZE - 1,
  MAX_INDEX_NODE = BUCKET_SIZE / 2,
  MIN_ARRAY_NODE = BUCKET_SIZE / 4
function popcount(x$2) {
  return x$2 -= x$2 >> 1 & 1431655765,
    x$2 = (x$2 & 858993459) + (x$2 >> 2 & 858993459),
    x$2 = x$2 + (x$2 >> 4) & 252645135,
    x$2 += x$2 >> 8,
    x$2 += x$2 >> 16,
    x$2 & 127
}
function hashFragment(shift$4, h$2) {
  return h$2 >>> shift$4 & MASK
}
function toBitmap(x$2) {
  return 1 << x$2
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1)
}
const make$54 = (value$2, previous$2) => ({ value: value$2, previous: previous$2 })
function arrayUpdate(mutate$4, at$2, v$4, arr) {
  let out = arr
  if (!mutate$4) {
    let len = arr.length
    out = Array(len)
    for (let i$14 = 0; i$14 < len; ++i$14) out[i$14] = arr[i$14]
  }
  return out[at$2] = v$4, out
}
function arraySpliceOut(mutate$4, at$2, arr) {
  let newLen = arr.length - 1, i$14 = 0, g$3 = 0, out = arr
  if (mutate$4) i$14 = g$3 = at$2
  else for (out = Array(newLen); i$14 < at$2;) out[g$3++] = arr[i$14++]
  for (++i$14; i$14 <= newLen;) out[g$3++] = arr[i$14++]
  return mutate$4 && (out.length = newLen), out
}
function arraySpliceIn(mutate$4, at$2, v$4, arr) {
  let len = arr.length
  if (mutate$4) {
    let i$15 = len
    for (; i$15 >= at$2;) arr[i$15--] = arr[i$15]
    return arr[at$2] = v$4, arr
  }
  let i$14 = 0, g$3 = 0, out = Array(len + 1)
  for (; i$14 < at$2;) out[g$3++] = arr[i$14++]
  for (out[at$2] = v$4; i$14 < len;) out[++g$3] = arr[i$14++]
  return out
}
var EmptyNode = class EmptyNode {
  _tag = `EmptyNode`
  modify(edit, _shift, f$14, hash$1, key$1, size$14) {
    let v$4 = f$14(none$7())
    return isNone$2(v$4) ? new EmptyNode() : (++size$14.value, new LeafNode(edit, hash$1, key$1, v$4))
  }
}
function isEmptyNode(a$22) {
  return isTagged(a$22, `EmptyNode`)
}
function isLeafNode(node$1) {
  return isEmptyNode(node$1) || node$1._tag === `LeafNode` || node$1._tag === `CollisionNode`
}
function canEditNode(node$1, edit) {
  return isEmptyNode(node$1) ? !1 : edit === node$1.edit
}
var LeafNode = class LeafNode {
    edit
    hash
    key
    value
    _tag = `LeafNode`
    constructor(edit, hash$1, key$1, value$2) {
      this.edit = edit, this.hash = hash$1, this.key = key$1, this.value = value$2
    }
    modify(edit, shift$4, f$14, hash$1, key$1, size$14) {
      if (equals(key$1, this.key)) {
        let v$5 = f$14(this.value)
        return v$5 === this.value
          ? this
          : isNone$2(v$5)
          ? (--size$14.value, new EmptyNode())
          : canEditNode(this, edit)
          ? (this.value = v$5, this)
          : new LeafNode(edit, hash$1, key$1, v$5)
      }
      let v$4 = f$14(none$7())
      return isNone$2(v$4)
        ? this
        : (++size$14.value, mergeLeaves(edit, shift$4, this.hash, this, hash$1, new LeafNode(edit, hash$1, key$1, v$4)))
    }
  },
  CollisionNode = class CollisionNode {
    edit
    hash
    children
    _tag = `CollisionNode`
    constructor(edit, hash$1, children$3) {
      this.edit = edit, this.hash = hash$1, this.children = children$3
    }
    modify(edit, shift$4, f$14, hash$1, key$1, size$14) {
      if (hash$1 === this.hash) {
        let canEdit = canEditNode(this, edit),
          list$3 = this.updateCollisionList(canEdit, edit, this.hash, this.children, f$14, key$1, size$14)
        return list$3 === this.children
          ? this
          : list$3.length > 1
          ? new CollisionNode(edit, this.hash, list$3)
          : list$3[0]
      }
      let v$4 = f$14(none$7())
      return isNone$2(v$4)
        ? this
        : (++size$14.value, mergeLeaves(edit, shift$4, this.hash, this, hash$1, new LeafNode(edit, hash$1, key$1, v$4)))
    }
    updateCollisionList(mutate$4, edit, hash$1, list$3, f$14, key$1, size$14) {
      let len = list$3.length
      for (let i$14 = 0; i$14 < len; ++i$14) {
        let child = list$3[i$14]
        if (`key` in child && equals(key$1, child.key)) {
          let value$2 = child.value, newValue$1 = f$14(value$2)
          return newValue$1 === value$2
            ? list$3
            : isNone$2(newValue$1)
            ? (--size$14.value, arraySpliceOut(mutate$4, i$14, list$3))
            : arrayUpdate(mutate$4, i$14, new LeafNode(edit, hash$1, key$1, newValue$1), list$3)
        }
      }
      let newValue = f$14(none$7())
      return isNone$2(newValue)
        ? list$3
        : (++size$14.value, arrayUpdate(mutate$4, len, new LeafNode(edit, hash$1, key$1, newValue), list$3))
    }
  },
  IndexedNode = class IndexedNode {
    edit
    mask
    children
    _tag = `IndexedNode`
    constructor(edit, mask, children$3) {
      this.edit = edit, this.mask = mask, this.children = children$3
    }
    modify(edit, shift$4, f$14, hash$1, key$1, size$14) {
      let mask = this.mask,
        children$3 = this.children,
        frag = hashFragment(shift$4, hash$1),
        bit = toBitmap(frag),
        indx = fromBitmap(mask, bit),
        exists$4 = mask & bit,
        canEdit = canEditNode(this, edit)
      if (!exists$4) {
        let _newChild = new EmptyNode().modify(edit, shift$4 + SIZE, f$14, hash$1, key$1, size$14)
        return _newChild
          ? children$3.length >= MAX_INDEX_NODE
            ? expand(edit, frag, _newChild, mask, children$3)
            : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children$3))
          : this
      }
      let current = children$3[indx], child = current.modify(edit, shift$4 + SIZE, f$14, hash$1, key$1, size$14)
      if (current === child) return this
      let bitmap = mask, newChildren
      if (isEmptyNode(child)) {
        if (bitmap &= ~bit, !bitmap) return new EmptyNode()
        if (children$3.length <= 2 && isLeafNode(children$3[indx ^ 1])) return children$3[indx ^ 1]
        newChildren = arraySpliceOut(canEdit, indx, children$3)
      } else newChildren = arrayUpdate(canEdit, indx, child, children$3)
      return canEdit
        ? (this.mask = bitmap, this.children = newChildren, this)
        : new IndexedNode(edit, bitmap, newChildren)
    }
  },
  ArrayNode = class ArrayNode {
    edit
    size
    children
    _tag = `ArrayNode`
    constructor(edit, size$14, children$3) {
      this.edit = edit, this.size = size$14, this.children = children$3
    }
    modify(edit, shift$4, f$14, hash$1, key$1, size$14) {
      let count$2 = this.size,
        children$3 = this.children,
        frag = hashFragment(shift$4, hash$1),
        child = children$3[frag],
        newChild = (child || new EmptyNode()).modify(edit, shift$4 + SIZE, f$14, hash$1, key$1, size$14)
      if (child === newChild) return this
      let canEdit = canEditNode(this, edit), newChildren
      if (isEmptyNode(child) && !isEmptyNode(newChild)) {
        ;++count$2, newChildren = arrayUpdate(canEdit, frag, newChild, children$3)
      } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
        if (--count$2, count$2 <= MIN_ARRAY_NODE) return pack(edit, count$2, frag, children$3)
        newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children$3)
      } else newChildren = arrayUpdate(canEdit, frag, newChild, children$3)
      return canEdit
        ? (this.size = count$2, this.children = newChildren, this)
        : new ArrayNode(edit, count$2, newChildren)
    }
  }
function pack(edit, count$2, removed, elements) {
  let children$3 = Array(count$2 - 1), g$3 = 0, bitmap = 0
  for (let i$14 = 0, len = elements.length; i$14 < len; ++i$14) {
    if (i$14 !== removed) {
      let elem = elements[i$14]
      elem && !isEmptyNode(elem) && (children$3[g$3++] = elem, bitmap |= 1 << i$14)
    }
  }
  return new IndexedNode(edit, bitmap, children$3)
}
function expand(edit, frag, child, bitmap, subNodes) {
  let arr = [], bit = bitmap, count$2 = 0
  for (let i$14 = 0; bit; ++i$14) bit & 1 && (arr[i$14] = subNodes[count$2++]), bit >>>= 1
  return arr[frag] = child, new ArrayNode(edit, count$2 + 1, arr)
}
function mergeLeavesInner(edit, shift$4, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1])
  let subH1 = hashFragment(shift$4, h1), subH2 = hashFragment(shift$4, h2)
  if (subH1 === subH2) return child => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child])
  {
    let children$3 = subH1 < subH2 ? [n1, n2] : [n2, n1]
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children$3)
  }
}
function mergeLeaves(edit, shift$4, h1, n1, h2, n2) {
  let stack, currentShift = shift$4
  for (;;) {
    let res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2)
    if (typeof res == `function`) stack = make$54(res, stack), currentShift += SIZE
    else {
      let final = res
      for (; stack != null;) final = stack.value(final), stack = stack.previous
      return final
    }
  }
}
const HashMapSymbolKey = `effect/HashMap`,
  HashMapTypeId = Symbol.for(HashMapSymbolKey),
  HashMapProto = {
    [HashMapTypeId]: HashMapTypeId,
    [Symbol.iterator]() {
      return new HashMapIterator(this, (k$1, v$4) => [k$1, v$4])
    },
    [symbol$2]() {
      let hash$1 = hash(HashMapSymbolKey)
      for (let item of this) hash$1 ^= pipe(hash(item[0]), combine$11(hash(item[1])))
      return cached$2(this, hash$1)
    },
    [symbol$1](that) {
      if (isHashMap$1(that)) {
        if (that._size !== this._size) return !1
        for (let item of this) {
          let elem = pipe(that, getHash$1(item[0], hash(item[0])))
          if (isNone$2(elem) || !equals(item[1], elem.value)) return !1
        }
        return !0
      }
      return !1
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `HashMap`, values: Array.from(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  makeImpl$2 = (editable, edit, root$5, size$14) => {
    let map$20 = Object.create(HashMapProto)
    return map$20._editable = editable, map$20._edit = edit, map$20._root = root$5, map$20._size = size$14, map$20
  }
var HashMapIterator = class HashMapIterator {
  map
  f
  v
  constructor(map$20, f$14) {
    this.map = map$20, this.f = f$14, this.v = visitLazy(this.map._root, this.f, void 0)
  }
  next() {
    if (isNone$2(this.v)) return { done: !0, value: void 0 }
    let v0 = this.v.value
    return this.v = applyCont(v0.cont), { done: !1, value: v0.value }
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f)
  }
}
const applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none$7(),
  visitLazy = (node$1, f$14, cont = void 0) => {
    switch (node$1._tag) {
      case `LeafNode`:
        return isSome(node$1.value) ? some$4({ value: f$14(node$1.key, node$1.value.value), cont }) : applyCont(cont)
      case `CollisionNode`:
      case `ArrayNode`:
      case `IndexedNode`: {
        let children$3 = node$1.children
        return visitLazyChildren(children$3.length, children$3, 0, f$14, cont)
      }
      default:
        return applyCont(cont)
    }
  },
  visitLazyChildren = (len, children$3, i$14, f$14, cont) => {
    for (; i$14 < len;) {
      let child = children$3[i$14++]
      if (child && !isEmptyNode(child)) return visitLazy(child, f$14, [len, children$3, i$14, f$14, cont])
    }
    return applyCont(cont)
  },
  _empty$7 = makeImpl$2(!1, 0, new EmptyNode(), 0),
  empty$31 = () => _empty$7,
  make$53 = (...entries$2) => fromIterable$8(entries$2),
  fromIterable$8 = entries$2 => {
    let map$20 = beginMutation$3(empty$31())
    for (let entry of entries$2) set$5(map$20, entry[0], entry[1])
    return endMutation$3(map$20)
  },
  isHashMap$1 = u$7 => hasProperty(u$7, HashMapTypeId),
  isEmpty$8 = self$1 => self$1 && isEmptyNode(self$1._root),
  get$7 = dual(2, (self$1, key$1) => getHash$1(self$1, key$1, hash(key$1))),
  getHash$1 = dual(3, (self$1, key$1, hash$1) => {
    let node$1 = self$1._root, shift$4 = 0
    for (;;) {
      switch (node$1._tag) {
        case `LeafNode`:
          return equals(key$1, node$1.key) ? node$1.value : none$7()
        case `CollisionNode`:
          if (hash$1 === node$1.hash) {
            let children$3 = node$1.children
            for (let i$14 = 0, len = children$3.length; i$14 < len; ++i$14) {
              let child = children$3[i$14]
              if (`key` in child && equals(key$1, child.key)) return child.value
            }
          }
          return none$7()
        case `IndexedNode`: {
          let frag = hashFragment(shift$4, hash$1), bit = toBitmap(frag)
          if (node$1.mask & bit) {
            node$1 = node$1.children[fromBitmap(node$1.mask, bit)], shift$4 += SIZE
            break
          }
          return none$7()
        }
        case `ArrayNode`:
          if (node$1 = node$1.children[hashFragment(shift$4, hash$1)], node$1) {
            shift$4 += SIZE
            break
          }
          return none$7()
        default:
          return none$7()
      }
    }
  }),
  unsafeGet$1 = dual(2, (self$1, key$1) => {
    let element$2 = getHash$1(self$1, key$1, hash(key$1))
    if (isNone$2(element$2)) throw Error(`Expected map to contain key`)
    return element$2.value
  }),
  has$6 = dual(2, (self$1, key$1) => isSome(getHash$1(self$1, key$1, hash(key$1)))),
  hasHash$1 = dual(3, (self$1, key$1, hash$1) => isSome(getHash$1(self$1, key$1, hash$1))),
  hasBy$1 = dual(2, (self$1, predicate) => isSome(findFirst$5(self$1, predicate))),
  set$5 = dual(3, (self$1, key$1, value$2) => modifyAt$1(self$1, key$1, () => some$4(value$2))),
  setTree = dual(
    3,
    (self$1, newRoot, newSize) =>
      self$1._editable
        ? (self$1._root = newRoot, self$1._size = newSize, self$1)
        : newRoot === self$1._root
        ? self$1
        : makeImpl$2(self$1._editable, self$1._edit, newRoot, newSize),
  ),
  keys$4 = self$1 => new HashMapIterator(self$1, key$1 => key$1),
  values$5 = self$1 => new HashMapIterator(self$1, (_$1, value$2) => value$2),
  entries$1 = self$1 => new HashMapIterator(self$1, (key$1, value$2) => [key$1, value$2]),
  size$13 = self$1 => self$1._size,
  countBy$1 = dual(2, (self$1, f$14) => {
    let count$2 = 0
    for (let [k$1, a$22] of self$1) f$14(a$22, k$1) && count$2++
    return count$2
  }),
  beginMutation$3 = self$1 => makeImpl$2(!0, self$1._edit + 1, self$1._root, self$1._size),
  endMutation$3 = self$1 => (self$1._editable = !1, self$1),
  mutate$3 = dual(2, (self$1, f$14) => {
    let transient = beginMutation$3(self$1)
    return f$14(transient), endMutation$3(transient)
  }),
  modifyAt$1 = dual(3, (self$1, key$1, f$14) => modifyHash$1(self$1, key$1, hash(key$1), f$14)),
  modifyHash$1 = dual(4, (self$1, key$1, hash$1, f$14) => {
    let size$14 = { value: self$1._size },
      newRoot = self$1._root.modify(self$1._editable ? self$1._edit : NaN, 0, f$14, hash$1, key$1, size$14)
    return pipe(self$1, setTree(newRoot, size$14.value))
  }),
  modify$3 = dual(3, (self$1, key$1, f$14) => modifyAt$1(self$1, key$1, map$18(f$14))),
  union$7 = dual(2, (self$1, that) => {
    let result = beginMutation$3(self$1)
    return forEach$8(that, (v$4, k$1) => set$5(result, k$1, v$4)), endMutation$3(result)
  }),
  remove$6 = dual(2, (self$1, key$1) => modifyAt$1(self$1, key$1, none$7)),
  removeMany$1 = dual(2, (self$1, keys$6) =>
    mutate$3(self$1, map$20 => {
      for (let key$1 of keys$6) remove$6(key$1)(map$20)
    })),
  map$16 = dual(
    2,
    (self$1, f$14) =>
      reduce$10(self$1, empty$31(), (map$20, value$2, key$1) => set$5(map$20, key$1, f$14(value$2, key$1))),
  ),
  flatMap$10 = dual(
    2,
    (self$1, f$14) =>
      reduce$10(
        self$1,
        empty$31(),
        (zero$1, value$2, key$1) =>
          mutate$3(
            zero$1,
            map$20 => forEach$8(f$14(value$2, key$1), (value$3, key$2) => set$5(map$20, key$2, value$3)),
          ),
      ),
  ),
  forEach$8 = dual(2, (self$1, f$14) => reduce$10(self$1, void 0, (_$1, value$2, key$1) => f$14(value$2, key$1))),
  reduce$10 = dual(3, (self$1, zero$1, f$14) => {
    let root$5 = self$1._root
    if (root$5._tag === `LeafNode`) return isSome(root$5.value) ? f$14(zero$1, root$5.value.value, root$5.key) : zero$1
    if (root$5._tag === `EmptyNode`) return zero$1
    let toVisit = [root$5.children], children$3
    for (; children$3 = toVisit.pop();) {
      for (let i$14 = 0, len = children$3.length; i$14 < len;) {
        let child = children$3[i$14++]
        child && !isEmptyNode(child) && (child._tag === `LeafNode`
          ? isSome(child.value) && (zero$1 = f$14(zero$1, child.value.value, child.key))
          : toVisit.push(child.children))
      }
    }
    return zero$1
  }),
  filter$8 = dual(2, (self$1, f$14) =>
    mutate$3(empty$31(), map$20 => {
      for (let [k$1, a$22] of self$1) f$14(a$22, k$1) && set$5(map$20, k$1, a$22)
    })),
  compact$1 = self$1 => filterMap$3(self$1, identity),
  filterMap$3 = dual(2, (self$1, f$14) =>
    mutate$3(empty$31(), map$20 => {
      for (let [k$1, a$22] of self$1) {
        let option$5 = f$14(a$22, k$1)
        isSome(option$5) && set$5(map$20, k$1, option$5.value)
      }
    })),
  findFirst$5 = dual(2, (self$1, predicate) => {
    for (let ka of self$1) if (predicate(ka[1], ka[0])) return some$4(ka)
    return none$7()
  }),
  some$3 = dual(2, (self$1, predicate) => {
    for (let ka of self$1) if (predicate(ka[1], ka[0])) return !0
    return !1
  }),
  every$5 = dual(2, (self$1, predicate) => !some$3(self$1, (a$22, k$1) => !predicate(a$22, k$1))),
  HashSetSymbolKey = `effect/HashSet`,
  HashSetTypeId = Symbol.for(HashSetSymbolKey),
  HashSetProto = {
    [HashSetTypeId]: HashSetTypeId,
    [Symbol.iterator]() {
      return keys$4(this._keyMap)
    },
    [symbol$2]() {
      return cached$2(this, combine$11(hash(this._keyMap))(hash(HashSetSymbolKey)))
    },
    [symbol$1](that) {
      return isHashSet$1(that)
        ? size$13(this._keyMap) === size$13(that._keyMap) && equals(this._keyMap, that._keyMap)
        : !1
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `HashSet`, values: Array.from(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  makeImpl$1 = keyMap$1 => {
    let set$6 = Object.create(HashSetProto)
    return set$6._keyMap = keyMap$1, set$6
  },
  isHashSet$1 = u$7 => hasProperty(u$7, HashSetTypeId),
  _empty$6 = makeImpl$1(empty$31()),
  empty$30 = () => _empty$6,
  fromIterable$7 = elements => {
    let set$6 = beginMutation$2(empty$30())
    for (let value$2 of elements) add$2(set$6, value$2)
    return endMutation$2(set$6)
  },
  make$52 = (...elements) => {
    let set$6 = beginMutation$2(empty$30())
    for (let value$2 of elements) add$2(set$6, value$2)
    return endMutation$2(set$6)
  },
  has$5 = dual(2, (self$1, value$2) => has$6(self$1._keyMap, value$2)),
  some$2 = dual(2, (self$1, f$14) => {
    let found = !1
    for (let value$2 of self$1) if (found = f$14(value$2), found) break
    return found
  }),
  every$4 = dual(2, (self$1, refinement) => !some$2(self$1, a$22 => !refinement(a$22))),
  isSubset$1 = dual(2, (self$1, that) => every$4(self$1, value$2 => has$5(that, value$2))),
  values$4 = self$1 => keys$4(self$1._keyMap),
  size$12 = self$1 => size$13(self$1._keyMap),
  beginMutation$2 = self$1 => makeImpl$1(beginMutation$3(self$1._keyMap)),
  endMutation$2 = self$1 => (self$1._keyMap._editable = !1, self$1),
  mutate$2 = dual(2, (self$1, f$14) => {
    let transient = beginMutation$2(self$1)
    return f$14(transient), endMutation$2(transient)
  }),
  add$2 = dual(
    2,
    (self$1, value$2) =>
      self$1._keyMap._editable
        ? (set$5(value$2, !0)(self$1._keyMap), self$1)
        : makeImpl$1(set$5(value$2, !0)(self$1._keyMap)),
  ),
  remove$5 = dual(
    2,
    (self$1, value$2) =>
      self$1._keyMap._editable
        ? (remove$6(value$2)(self$1._keyMap), self$1)
        : makeImpl$1(remove$6(value$2)(self$1._keyMap)),
  ),
  difference$1 = dual(2, (self$1, that) =>
    mutate$2(self$1, set$6 => {
      for (let value$2 of that) remove$5(set$6, value$2)
    })),
  intersection$1 = dual(2, (self$1, that) =>
    mutate$2(empty$30(), set$6 => {
      for (let value$2 of that) has$5(value$2)(self$1) && add$2(value$2)(set$6)
    })),
  union$6 = dual(2, (self$1, that) =>
    mutate$2(empty$30(), set$6 => {
      forEach$7(self$1, value$2 => add$2(set$6, value$2))
      for (let value$2 of that) add$2(set$6, value$2)
    })),
  toggle$1 = dual(2, (self$1, value$2) => has$5(self$1, value$2) ? remove$5(self$1, value$2) : add$2(self$1, value$2)),
  map$15 = dual(2, (self$1, f$14) =>
    mutate$2(empty$30(), set$6 => {
      forEach$7(self$1, a$22 => {
        let b$3 = f$14(a$22)
        has$5(set$6, b$3) || add$2(set$6, b$3)
      })
    })),
  flatMap$9 = dual(2, (self$1, f$14) =>
    mutate$2(empty$30(), set$6 => {
      forEach$7(self$1, a$22 => {
        for (let b$3 of f$14(a$22)) has$5(set$6, b$3) || add$2(set$6, b$3)
      })
    })),
  forEach$7 = dual(2, (self$1, f$14) => forEach$8(self$1._keyMap, (_$1, k$1) => f$14(k$1))),
  reduce$9 = dual(3, (self$1, zero$1, f$14) => reduce$10(self$1._keyMap, zero$1, (z$1, _$1, a$22) => f$14(z$1, a$22))),
  filter$7 = dual(2, (self$1, f$14) =>
    mutate$2(empty$30(), set$6 => {
      let iterator = values$4(self$1), next
      for (; !(next = iterator.next()).done;) {
        let value$2 = next.value
        f$14(value$2) && add$2(set$6, value$2)
      }
    })),
  partition$3 = dual(2, (self$1, predicate) => {
    let iterator = values$4(self$1), next, right$2 = beginMutation$2(empty$30()), left$2 = beginMutation$2(empty$30())
    for (; !(next = iterator.next()).done;) {
      let value$2 = next.value
      predicate(value$2) ? add$2(right$2, value$2) : add$2(left$2, value$2)
    }
    return [endMutation$2(left$2), endMutation$2(right$2)]
  }),
  TypeId$15 = HashSetTypeId,
  isHashSet = isHashSet$1,
  empty$29 = empty$30,
  fromIterable$6 = fromIterable$7,
  make$51 = make$52,
  has$4 = has$5,
  some$1 = some$2,
  every$3 = every$4,
  isSubset = isSubset$1,
  values$3 = values$4,
  toValues = self$1 => Array.from(values$3(self$1)),
  size$11 = size$12,
  beginMutation$1 = beginMutation$2,
  endMutation$1 = endMutation$2,
  mutate$1 = mutate$2,
  add$1 = add$2,
  remove$4 = remove$5,
  difference = difference$1,
  intersection = intersection$1,
  union$5 = union$6,
  toggle = toggle$1,
  map$14 = map$15,
  flatMap$8 = flatMap$9,
  forEach$6 = forEach$7,
  reduce$8 = reduce$9,
  filter$6 = filter$7,
  partition$2 = partition$3,
  TypeId$14 = Symbol.for(`effect/MutableRef`),
  MutableRefProto = {
    [TypeId$14]: TypeId$14,
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `MutableRef`, current: toJSON(this.current) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  make$50 = value$2 => {
    let ref = Object.create(MutableRefProto)
    return ref.current = value$2, ref
  },
  compareAndSet = dual(
    3,
    (self$1, oldValue, newValue) => equals(oldValue, self$1.current) ? (self$1.current = newValue, !0) : !1,
  ),
  get$6 = self$1 => self$1.current,
  set$4 = dual(2, (self$1, value$2) => (self$1.current = value$2, self$1)),
  FiberIdSymbolKey = `effect/FiberId`,
  FiberIdTypeId$1 = Symbol.for(FiberIdSymbolKey),
  OP_NONE = `None`,
  OP_RUNTIME = `Runtime`,
  OP_COMPOSITE = `Composite`,
  emptyHash = string$4(`${FiberIdSymbolKey}-${OP_NONE}`)
var None$2 = class {
    [FiberIdTypeId$1] = FiberIdTypeId$1
    _tag = OP_NONE
    id = -1
    startTimeMillis = -1;
    [symbol$2]() {
      return emptyHash
    }
    [symbol$1](that) {
      return isFiberId$1(that) && that._tag === OP_NONE
    }
    toString() {
      return format$1(this.toJSON())
    }
    toJSON() {
      return { _id: `FiberId`, _tag: this._tag }
    }
    [NodeInspectSymbol]() {
      return this.toJSON()
    }
  },
  Runtime = class {
    id
    startTimeMillis;
    [FiberIdTypeId$1] = FiberIdTypeId$1
    _tag = OP_RUNTIME
    constructor(id$2, startTimeMillis) {
      this.id = id$2, this.startTimeMillis = startTimeMillis
    }
    [symbol$2]() {
      return cached$2(this, string$4(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`))
    }
    [symbol$1](that) {
      return isFiberId$1(that) && that._tag === OP_RUNTIME && this.id === that.id
        && this.startTimeMillis === that.startTimeMillis
    }
    toString() {
      return format$1(this.toJSON())
    }
    toJSON() {
      return { _id: `FiberId`, _tag: this._tag, id: this.id, startTimeMillis: this.startTimeMillis }
    }
    [NodeInspectSymbol]() {
      return this.toJSON()
    }
  },
  Composite$1 = class {
    left
    right;
    [FiberIdTypeId$1] = FiberIdTypeId$1
    _tag = OP_COMPOSITE
    constructor(left$2, right$2) {
      this.left = left$2, this.right = right$2
    }
    _hash;
    [symbol$2]() {
      return pipe(
        string$4(`${FiberIdSymbolKey}-${this._tag}`),
        combine$11(hash(this.left)),
        combine$11(hash(this.right)),
        cached$2(this),
      )
    }
    [symbol$1](that) {
      return isFiberId$1(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left)
        && equals(this.right, that.right)
    }
    toString() {
      return format$1(this.toJSON())
    }
    toJSON() {
      return { _id: `FiberId`, _tag: this._tag, left: toJSON(this.left), right: toJSON(this.right) }
    }
    [NodeInspectSymbol]() {
      return this.toJSON()
    }
  }
const none$1 = new None$2(),
  runtime$3 = (id$2, startTimeMillis) => new Runtime(id$2, startTimeMillis),
  composite$1 = (left$2, right$2) => new Composite$1(left$2, right$2),
  isFiberId$1 = self$1 => hasProperty(self$1, FiberIdTypeId$1),
  isNone$1 = self$1 => self$1._tag === OP_NONE || pipe(toSet$3(self$1), every$3(id$2 => isNone$1(id$2))),
  isRuntime$1 = self$1 => self$1._tag === OP_RUNTIME,
  isComposite$2 = self$1 => self$1._tag === OP_COMPOSITE,
  combine$10 = dual(
    2,
    (self$1, that) => self$1._tag === OP_NONE ? that : that._tag === OP_NONE ? self$1 : new Composite$1(self$1, that),
  ),
  combineAll$1 = fiberIds => pipe(fiberIds, reduce$8(none$1, (a$22, b$3) => combine$10(b$3)(a$22))),
  getOrElse$2 = dual(2, (self$1, that) => isNone$1(self$1) ? that : self$1),
  ids$1 = self$1 => {
    switch (self$1._tag) {
      case OP_NONE:
        return empty$29()
      case OP_RUNTIME:
        return make$51(self$1.id)
      case OP_COMPOSITE:
        return pipe(ids$1(self$1.left), union$5(ids$1(self$1.right)))
    }
  },
  _fiberCounter = globalValue(Symbol.for(`effect/Fiber/Id/_fiberCounter`), () => make$50(0)),
  make$49 = (id$2, startTimeSeconds) => new Runtime(id$2, startTimeSeconds),
  threadName$1 = self$1 => {
    let identifiers = Array.from(ids$1(self$1)).map(n$19 => `#${n$19}`).join(`,`)
    return identifiers
  },
  toOption$1 = self$1 => {
    let fiberIds = toSet$3(self$1)
    if (size$11(fiberIds) === 0) return none$7()
    let first$2 = !0, acc
    for (let fiberId$2 of fiberIds) first$2 ? (acc = fiberId$2, first$2 = !1) : acc = pipe(acc, combine$10(fiberId$2))
    return some$4(acc)
  },
  toSet$3 = self$1 => {
    switch (self$1._tag) {
      case OP_NONE:
        return empty$29()
      case OP_RUNTIME:
        return make$51(self$1)
      case OP_COMPOSITE:
        return pipe(toSet$3(self$1.left), union$5(toSet$3(self$1.right)))
    }
  },
  unsafeMake$8 = () => {
    let id$2 = get$6(_fiberCounter)
    return pipe(_fiberCounter, set$4(id$2 + 1)), new Runtime(id$2, Date.now())
  },
  FiberIdTypeId = FiberIdTypeId$1,
  none$6 = none$1,
  runtime$2 = runtime$3,
  composite = composite$1,
  isFiberId = isFiberId$1,
  isNone = isNone$1,
  isRuntime = isRuntime$1,
  isComposite$1 = isComposite$2,
  combine$9 = combine$10,
  combineAll = combineAll$1,
  getOrElse$1 = getOrElse$2,
  ids = ids$1,
  make$48 = make$49,
  threadName = threadName$1,
  toOption = toOption$1,
  toSet$2 = toSet$3,
  unsafeMake$7 = unsafeMake$8
function keySet$1(self$1) {
  return makeImpl$1(self$1)
}
const TypeId$13 = HashMapTypeId,
  isHashMap = isHashMap$1,
  empty$28 = empty$31,
  make$47 = make$53,
  fromIterable$5 = fromIterable$8,
  isEmpty$7 = isEmpty$8,
  get$5 = get$7,
  getHash = getHash$1,
  unsafeGet = unsafeGet$1,
  has$3 = has$6,
  hasHash = hasHash$1,
  hasBy = hasBy$1,
  set$3 = set$5,
  keys$3 = keys$4,
  keySet = keySet$1,
  values$2 = values$5,
  entries = entries$1,
  size$10 = size$13,
  countBy = countBy$1,
  beginMutation = beginMutation$3,
  endMutation = endMutation$3,
  mutate = mutate$3,
  modifyAt = modifyAt$1,
  modifyHash = modifyHash$1,
  modify$2 = modify$3,
  union$4 = union$7,
  remove$3 = remove$6,
  removeMany = removeMany$1,
  map$13 = map$16,
  flatMap$7 = flatMap$10,
  forEach$5 = forEach$8,
  reduce$7 = reduce$10,
  filter$5 = filter$8,
  compact = compact$1,
  filterMap$2 = filterMap$3,
  findFirst$4 = findFirst$5,
  some = some$3,
  every$2 = every$5,
  TypeId$12 = Symbol.for(`effect/List`),
  toArray = self$1 => fromIterable$10(self$1),
  getEquivalence$1 = isEquivalent => mapInput$1(getEquivalence$3(isEquivalent), toArray),
  _equivalence = getEquivalence$1(equals),
  ConsProto = {
    [TypeId$12]: TypeId$12,
    _tag: `Cons`,
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `List`, _tag: `Cons`, values: toArray(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    [symbol$1](that) {
      return isList(that) && this._tag === that._tag && _equivalence(this, that)
    },
    [symbol$2]() {
      return cached$2(this, array$1(toArray(this)))
    },
    [Symbol.iterator]() {
      let done$8 = !1, self$1 = this
      return {
        next() {
          if (done$8) return this.return()
          if (self$1._tag === `Nil`) return done$8 = !0, this.return()
          let value$2 = self$1.head
          return self$1 = self$1.tail, { done: done$8, value: value$2 }
        },
        return(value$2) {
          return done$8 ||= !0, { done: !0, value: value$2 }
        },
      }
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  makeCons = (head$5, tail) => {
    let cons$1 = Object.create(ConsProto)
    return cons$1.head = head$5, cons$1.tail = tail, cons$1
  },
  NilHash = string$4(`Nil`),
  NilProto = {
    [TypeId$12]: TypeId$12,
    _tag: `Nil`,
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `List`, _tag: `Nil` }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    [symbol$2]() {
      return NilHash
    },
    [symbol$1](that) {
      return isList(that) && this._tag === that._tag
    },
    [Symbol.iterator]() {
      return {
        next() {
          return { done: !0, value: void 0 }
        },
      }
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  _Nil = Object.create(NilProto),
  isList = u$7 => hasProperty(u$7, TypeId$12),
  isNil = self$1 => self$1._tag === `Nil`,
  isCons = self$1 => self$1._tag === `Cons`,
  nil = () => _Nil,
  cons = (head$5, tail) => makeCons(head$5, tail),
  empty$27 = nil,
  of$2 = value$2 => makeCons(value$2, _Nil),
  appendAll = dual(2, (self$1, that) => prependAll(that, self$1)),
  prepend = dual(2, (self$1, element$2) => cons(element$2, self$1)),
  prependAll = dual(2, (self$1, prefix$1) => {
    if (isNil(self$1)) return prefix$1
    if (isNil(prefix$1)) return self$1
    {
      let result = makeCons(prefix$1.head, self$1), curr = result, that = prefix$1.tail
      for (; !isNil(that);) {
        let temp = makeCons(that.head, self$1)
        curr.tail = temp, curr = temp, that = that.tail
      }
      return result
    }
  }),
  reduce$6 = dual(3, (self$1, zero$1, f$14) => {
    let acc = zero$1, these = self$1
    for (; !isNil(these);) acc = f$14(acc, these.head), these = these.tail
    return acc
  }),
  reverse = self$1 => {
    let result = empty$27(), these = self$1
    for (; !isNil(these);) result = prepend(result, these.head), these = these.tail
    return result
  },
  ArrayProto = Object.assign(Object.create(Array.prototype), {
    [symbol$2]() {
      return cached$2(this, array$1(this))
    },
    [symbol$1](that) {
      return Array.isArray(that) && this.length === that.length
        ? this.every((v$4, i$14) => equals(v$4, that[i$14]))
        : !1
    },
  }),
  Structural$1 = function() {
    function Structural$2(args$1) {
      args$1 && Object.assign(this, args$1)
    }
    return Structural$2.prototype = StructuralPrototype, Structural$2
  }(),
  struct$1 = as$6 => Object.assign(Object.create(StructuralPrototype), as$6),
  ChunkPatchTypeId$1 = Symbol.for(`effect/DifferChunkPatch`)
function variance$7(a$22) {
  return a$22
}
const PatchProto$5 = { ...Structural$1.prototype, [ChunkPatchTypeId$1]: { _Value: variance$7, _Patch: variance$7 } },
  EmptyProto$5 = Object.assign(Object.create(PatchProto$5), { _tag: `Empty` }),
  _empty$5 = Object.create(EmptyProto$5),
  empty$26 = () => _empty$5,
  AndThenProto$5 = Object.assign(Object.create(PatchProto$5), { _tag: `AndThen` }),
  makeAndThen$5 = (first$2, second) => {
    let o$18 = Object.create(AndThenProto$5)
    return o$18.first = first$2, o$18.second = second, o$18
  },
  AppendProto$1 = Object.assign(Object.create(PatchProto$5), { _tag: `Append` }),
  makeAppend$1 = values$6 => {
    let o$18 = Object.create(AppendProto$1)
    return o$18.values = values$6, o$18
  },
  SliceProto$1 = Object.assign(Object.create(PatchProto$5), { _tag: `Slice` }),
  makeSlice$1 = (from, until) => {
    let o$18 = Object.create(SliceProto$1)
    return o$18.from = from, o$18.until = until, o$18
  },
  UpdateProto$2 = Object.assign(Object.create(PatchProto$5), { _tag: `Update` }),
  makeUpdate$2 = (index$4, patch$12) => {
    let o$18 = Object.create(UpdateProto$2)
    return o$18.index = index$4, o$18.patch = patch$12, o$18
  },
  diff$9 = options$2 => {
    let i$14 = 0, patch$12 = empty$26()
    for (; i$14 < options$2.oldValue.length && i$14 < options$2.newValue.length;) {
      let oldElement = unsafeGet$2(i$14)(options$2.oldValue),
        newElement = unsafeGet$2(i$14)(options$2.newValue),
        valuePatch = options$2.differ.diff(oldElement, newElement)
      equals(valuePatch, options$2.differ.empty)
      || (patch$12 = pipe(patch$12, combine$8(makeUpdate$2(i$14, valuePatch)))), i$14 += 1
    }
    return i$14 < options$2.oldValue.length && (patch$12 = pipe(patch$12, combine$8(makeSlice$1(0, i$14)))),
      i$14 < options$2.newValue.length
      && (patch$12 = pipe(patch$12, combine$8(makeAppend$1(drop(i$14)(options$2.newValue))))),
      patch$12
  },
  combine$8 = dual(2, (self$1, that) => makeAndThen$5(self$1, that)),
  patch$11 = dual(3, (self$1, oldValue, differ$2) => {
    if (self$1._tag === `Empty`) return oldValue
    let chunk$2 = oldValue, patches = of$3(self$1)
    for (; isNonEmpty$4(patches);) {
      let head$5 = headNonEmpty(patches), tail = tailNonEmpty(patches)
      switch (head$5._tag) {
        case `Empty`:
          patches = tail
          break
        case `AndThen`:
          patches = prepend$1(head$5.first)(prepend$1(head$5.second)(tail))
          break
        case `Append`:
          chunk$2 = appendAll$1(head$5.values)(chunk$2), patches = tail
          break
        case `Slice`: {
          let array$3 = toReadonlyArray(chunk$2)
          chunk$2 = unsafeFromArray(array$3.slice(head$5.from, head$5.until)), patches = tail
          break
        }
        case `Update`: {
          let array$3 = toReadonlyArray(chunk$2)
          array$3[head$5.index] = differ$2.patch(head$5.patch, array$3[head$5.index]),
            chunk$2 = unsafeFromArray(array$3),
            patches = tail
          break
        }
      }
    }
    return chunk$2
  }),
  ContextPatchTypeId$1 = Symbol.for(`effect/DifferContextPatch`)
function variance$6(a$22) {
  return a$22
}
const PatchProto$4 = { ...Structural$1.prototype, [ContextPatchTypeId$1]: { _Value: variance$6, _Patch: variance$6 } },
  EmptyProto$4 = Object.assign(Object.create(PatchProto$4), { _tag: `Empty` }),
  _empty$4 = Object.create(EmptyProto$4),
  empty$25 = () => _empty$4,
  AndThenProto$4 = Object.assign(Object.create(PatchProto$4), { _tag: `AndThen` }),
  makeAndThen$4 = (first$2, second) => {
    let o$18 = Object.create(AndThenProto$4)
    return o$18.first = first$2, o$18.second = second, o$18
  },
  AddServiceProto = Object.assign(Object.create(PatchProto$4), { _tag: `AddService` }),
  makeAddService = (key$1, service) => {
    let o$18 = Object.create(AddServiceProto)
    return o$18.key = key$1, o$18.service = service, o$18
  },
  RemoveServiceProto = Object.assign(Object.create(PatchProto$4), { _tag: `RemoveService` }),
  makeRemoveService = key$1 => {
    let o$18 = Object.create(RemoveServiceProto)
    return o$18.key = key$1, o$18
  },
  UpdateServiceProto = Object.assign(Object.create(PatchProto$4), { _tag: `UpdateService` }),
  makeUpdateService = (key$1, update$5) => {
    let o$18 = Object.create(UpdateServiceProto)
    return o$18.key = key$1, o$18.update = update$5, o$18
  },
  diff$8 = (oldValue, newValue) => {
    let missingServices = new Map(oldValue.unsafeMap), patch$12 = empty$25()
    for (let [tag$3, newService] of newValue.unsafeMap.entries()) {
      if (missingServices.has(tag$3)) {
        let old = missingServices.get(tag$3)
        missingServices.delete(tag$3),
          equals(old, newService) || (patch$12 = combine$7(makeUpdateService(tag$3, () => newService))(patch$12))
      } else missingServices.delete(tag$3), patch$12 = combine$7(makeAddService(tag$3, newService))(patch$12)
    }
    for (let [tag$3] of missingServices.entries()) patch$12 = combine$7(makeRemoveService(tag$3))(patch$12)
    return patch$12
  },
  combine$7 = dual(2, (self$1, that) => makeAndThen$4(self$1, that)),
  patch$10 = dual(2, (self$1, context$2) => {
    if (self$1._tag === `Empty`) return context$2
    let wasServiceUpdated = !1, patches = of$3(self$1), updatedContext = new Map(context$2.unsafeMap)
    for (; isNonEmpty$4(patches);) {
      let head$5 = headNonEmpty(patches), tail = tailNonEmpty(patches)
      switch (head$5._tag) {
        case `Empty`:
          patches = tail
          break
        case `AddService`:
          updatedContext.set(head$5.key, head$5.service), patches = tail
          break
        case `AndThen`:
          patches = prepend$1(prepend$1(tail, head$5.second), head$5.first)
          break
        case `RemoveService`:
          updatedContext.delete(head$5.key), patches = tail
          break
        case `UpdateService`:
          updatedContext.set(head$5.key, head$5.update(updatedContext.get(head$5.key))),
            wasServiceUpdated = !0,
            patches = tail
          break
      }
    }
    if (!wasServiceUpdated) return makeContext(updatedContext)
    let map$20 = new Map()
    for (let [tag$3] of context$2.unsafeMap) {
      updatedContext.has(tag$3) && (map$20.set(tag$3, updatedContext.get(tag$3)), updatedContext.delete(tag$3))
    }
    for (let [tag$3, s$14] of updatedContext) map$20.set(tag$3, s$14)
    return makeContext(map$20)
  }),
  HashMapPatchTypeId$1 = Symbol.for(`effect/DifferHashMapPatch`)
function variance$5(a$22) {
  return a$22
}
const PatchProto$3 = {
    ...Structural$1.prototype,
    [HashMapPatchTypeId$1]: { _Value: variance$5, _Key: variance$5, _Patch: variance$5 },
  },
  EmptyProto$3 = Object.assign(Object.create(PatchProto$3), { _tag: `Empty` }),
  _empty$3 = Object.create(EmptyProto$3),
  empty$24 = () => _empty$3,
  AndThenProto$3 = Object.assign(Object.create(PatchProto$3), { _tag: `AndThen` }),
  makeAndThen$3 = (first$2, second) => {
    let o$18 = Object.create(AndThenProto$3)
    return o$18.first = first$2, o$18.second = second, o$18
  },
  AddProto$1 = Object.assign(Object.create(PatchProto$3), { _tag: `Add` }),
  makeAdd$1 = (key$1, value$2) => {
    let o$18 = Object.create(AddProto$1)
    return o$18.key = key$1, o$18.value = value$2, o$18
  },
  RemoveProto$1 = Object.assign(Object.create(PatchProto$3), { _tag: `Remove` }),
  makeRemove$1 = key$1 => {
    let o$18 = Object.create(RemoveProto$1)
    return o$18.key = key$1, o$18
  },
  UpdateProto$1 = Object.assign(Object.create(PatchProto$3), { _tag: `Update` }),
  makeUpdate$1 = (key$1, patch$12) => {
    let o$18 = Object.create(UpdateProto$1)
    return o$18.key = key$1, o$18.patch = patch$12, o$18
  },
  diff$7 = options$2 => {
    let [removed, patch$12] = reduce$7([options$2.oldValue, empty$24()], ([map$20, patch$13], newValue, key$1) => {
      let option$5 = get$5(key$1)(map$20)
      switch (option$5._tag) {
        case `Some`: {
          let valuePatch = options$2.differ.diff(option$5.value, newValue)
          return equals(valuePatch, options$2.differ.empty)
            ? [remove$3(key$1)(map$20), patch$13]
            : [remove$3(key$1)(map$20), combine$6(makeUpdate$1(key$1, valuePatch))(patch$13)]
        }
        case `None`:
          return [map$20, combine$6(makeAdd$1(key$1, newValue))(patch$13)]
      }
    })(options$2.newValue)
    return reduce$7(patch$12, (patch$13, _$1, key$1) => combine$6(makeRemove$1(key$1))(patch$13))(removed)
  },
  combine$6 = dual(2, (self$1, that) => makeAndThen$3(self$1, that)),
  patch$9 = dual(3, (self$1, oldValue, differ$2) => {
    if (self$1._tag === `Empty`) return oldValue
    let map$20 = oldValue, patches = of$3(self$1)
    for (; isNonEmpty$4(patches);) {
      let head$5 = headNonEmpty(patches), tail = tailNonEmpty(patches)
      switch (head$5._tag) {
        case `Empty`:
          patches = tail
          break
        case `AndThen`:
          patches = prepend$1(head$5.first)(prepend$1(head$5.second)(tail))
          break
        case `Add`:
          map$20 = set$3(head$5.key, head$5.value)(map$20), patches = tail
          break
        case `Remove`:
          map$20 = remove$3(head$5.key)(map$20), patches = tail
          break
        case `Update`: {
          let option$5 = get$5(head$5.key)(map$20)
          option$5._tag === `Some`
          && (map$20 = set$3(head$5.key, differ$2.patch(head$5.patch, option$5.value))(map$20)), patches = tail
          break
        }
      }
    }
    return map$20
  }),
  HashSetPatchTypeId$1 = Symbol.for(`effect/DifferHashSetPatch`)
function variance$4(a$22) {
  return a$22
}
const PatchProto$2 = {
    ...Structural$1.prototype,
    [HashSetPatchTypeId$1]: { _Value: variance$4, _Key: variance$4, _Patch: variance$4 },
  },
  EmptyProto$2 = Object.assign(Object.create(PatchProto$2), { _tag: `Empty` }),
  _empty$2 = Object.create(EmptyProto$2),
  empty$23 = () => _empty$2,
  AndThenProto$2 = Object.assign(Object.create(PatchProto$2), { _tag: `AndThen` }),
  makeAndThen$2 = (first$2, second) => {
    let o$18 = Object.create(AndThenProto$2)
    return o$18.first = first$2, o$18.second = second, o$18
  },
  AddProto = Object.assign(Object.create(PatchProto$2), { _tag: `Add` }),
  makeAdd = value$2 => {
    let o$18 = Object.create(AddProto)
    return o$18.value = value$2, o$18
  },
  RemoveProto = Object.assign(Object.create(PatchProto$2), { _tag: `Remove` }),
  makeRemove = value$2 => {
    let o$18 = Object.create(RemoveProto)
    return o$18.value = value$2, o$18
  },
  diff$6 = (oldValue, newValue) => {
    let [removed, patch$12] = reduce$8(
      [oldValue, empty$23()],
      ([set$6, patch$13], value$2) =>
        has$4(value$2)(set$6) ? [remove$4(value$2)(set$6), patch$13] : [set$6, combine$5(makeAdd(value$2))(patch$13)],
    )(newValue)
    return reduce$8(patch$12, (patch$13, value$2) => combine$5(makeRemove(value$2))(patch$13))(removed)
  },
  combine$5 = dual(2, (self$1, that) => makeAndThen$2(self$1, that)),
  patch$8 = dual(2, (self$1, oldValue) => {
    if (self$1._tag === `Empty`) return oldValue
    let set$6 = oldValue, patches = of$3(self$1)
    for (; isNonEmpty$4(patches);) {
      let head$5 = headNonEmpty(patches), tail = tailNonEmpty(patches)
      switch (head$5._tag) {
        case `Empty`:
          patches = tail
          break
        case `AndThen`:
          patches = prepend$1(head$5.first)(prepend$1(head$5.second)(tail))
          break
        case `Add`:
          set$6 = add$1(head$5.value)(set$6), patches = tail
          break
        case `Remove`:
          set$6 = remove$4(head$5.value)(set$6), patches = tail
      }
    }
    return set$6
  }),
  OrPatchTypeId$1 = Symbol.for(`effect/DifferOrPatch`)
function variance$3(a$22) {
  return a$22
}
const PatchProto$1 = {
    ...Structural$1.prototype,
    [OrPatchTypeId$1]: { _Value: variance$3, _Key: variance$3, _Patch: variance$3 },
  },
  EmptyProto$1 = Object.assign(Object.create(PatchProto$1), { _tag: `Empty` }),
  _empty$1 = Object.create(EmptyProto$1),
  empty$22 = () => _empty$1,
  AndThenProto$1 = Object.assign(Object.create(PatchProto$1), { _tag: `AndThen` }),
  makeAndThen$1 = (first$2, second) => {
    let o$18 = Object.create(AndThenProto$1)
    return o$18.first = first$2, o$18.second = second, o$18
  },
  SetLeftProto = Object.assign(Object.create(PatchProto$1), { _tag: `SetLeft` }),
  makeSetLeft = value$2 => {
    let o$18 = Object.create(SetLeftProto)
    return o$18.value = value$2, o$18
  },
  SetRightProto = Object.assign(Object.create(PatchProto$1), { _tag: `SetRight` }),
  makeSetRight = value$2 => {
    let o$18 = Object.create(SetRightProto)
    return o$18.value = value$2, o$18
  },
  UpdateLeftProto = Object.assign(Object.create(PatchProto$1), { _tag: `UpdateLeft` }),
  makeUpdateLeft = patch$12 => {
    let o$18 = Object.create(UpdateLeftProto)
    return o$18.patch = patch$12, o$18
  },
  UpdateRightProto = Object.assign(Object.create(PatchProto$1), { _tag: `UpdateRight` }),
  makeUpdateRight = patch$12 => {
    let o$18 = Object.create(UpdateRightProto)
    return o$18.patch = patch$12, o$18
  },
  diff$5 = options$2 => {
    switch (options$2.oldValue._tag) {
      case `Left`:
        switch (options$2.newValue._tag) {
          case `Left`: {
            let valuePatch = options$2.left.diff(options$2.oldValue.left, options$2.newValue.left)
            return equals(valuePatch, options$2.left.empty) ? empty$22() : makeUpdateLeft(valuePatch)
          }
          case `Right`:
            return makeSetRight(options$2.newValue.right)
        }
      case `Right`:
        switch (options$2.newValue._tag) {
          case `Left`:
            return makeSetLeft(options$2.newValue.left)
          case `Right`: {
            let valuePatch = options$2.right.diff(options$2.oldValue.right, options$2.newValue.right)
            return equals(valuePatch, options$2.right.empty) ? empty$22() : makeUpdateRight(valuePatch)
          }
        }
    }
  },
  combine$4 = dual(2, (self$1, that) => makeAndThen$1(self$1, that)),
  patch$7 = dual(2, (self$1, { left: left$2, oldValue, right: right$2 }) => {
    if (self$1._tag === `Empty`) return oldValue
    let patches = of$3(self$1), result = oldValue
    for (; isNonEmpty$4(patches);) {
      let head$5 = headNonEmpty(patches), tail = tailNonEmpty(patches)
      switch (head$5._tag) {
        case `Empty`:
          patches = tail
          break
        case `AndThen`:
          patches = prepend$1(head$5.first)(prepend$1(head$5.second)(tail))
          break
        case `UpdateLeft`:
          result._tag === `Left` && (result = left(left$2.patch(head$5.patch, result.left))), patches = tail
          break
        case `UpdateRight`:
          result._tag === `Right` && (result = right(right$2.patch(head$5.patch, result.right))), patches = tail
          break
        case `SetLeft`:
          result = left(head$5.value), patches = tail
          break
        case `SetRight`:
          result = right(head$5.value), patches = tail
          break
      }
    }
    return result
  }),
  ReadonlyArrayPatchTypeId$1 = Symbol.for(`effect/DifferReadonlyArrayPatch`)
function variance$2(a$22) {
  return a$22
}
const PatchProto = {
    ...Structural$1.prototype,
    [ReadonlyArrayPatchTypeId$1]: { _Value: variance$2, _Patch: variance$2 },
  },
  EmptyProto = Object.assign(Object.create(PatchProto), { _tag: `Empty` }),
  _empty = Object.create(EmptyProto),
  empty$21 = () => _empty,
  AndThenProto = Object.assign(Object.create(PatchProto), { _tag: `AndThen` }),
  makeAndThen = (first$2, second) => {
    let o$18 = Object.create(AndThenProto)
    return o$18.first = first$2, o$18.second = second, o$18
  },
  AppendProto = Object.assign(Object.create(PatchProto), { _tag: `Append` }),
  makeAppend = values$6 => {
    let o$18 = Object.create(AppendProto)
    return o$18.values = values$6, o$18
  },
  SliceProto = Object.assign(Object.create(PatchProto), { _tag: `Slice` }),
  makeSlice = (from, until) => {
    let o$18 = Object.create(SliceProto)
    return o$18.from = from, o$18.until = until, o$18
  },
  UpdateProto = Object.assign(Object.create(PatchProto), { _tag: `Update` }),
  makeUpdate = (index$4, patch$12) => {
    let o$18 = Object.create(UpdateProto)
    return o$18.index = index$4, o$18.patch = patch$12, o$18
  },
  diff$4 = options$2 => {
    let i$14 = 0, patch$12 = empty$21()
    for (; i$14 < options$2.oldValue.length && i$14 < options$2.newValue.length;) {
      let oldElement = options$2.oldValue[i$14],
        newElement = options$2.newValue[i$14],
        valuePatch = options$2.differ.diff(oldElement, newElement)
      equals(valuePatch, options$2.differ.empty) || (patch$12 = combine$3(patch$12, makeUpdate(i$14, valuePatch))),
        i$14 += 1
    }
    return i$14 < options$2.oldValue.length && (patch$12 = combine$3(patch$12, makeSlice(0, i$14))),
      i$14 < options$2.newValue.length
      && (patch$12 = combine$3(patch$12, makeAppend(drop$1(i$14)(options$2.newValue)))),
      patch$12
  },
  combine$3 = dual(2, (self$1, that) => makeAndThen(self$1, that)),
  patch$6 = dual(3, (self$1, oldValue, differ$2) => {
    if (self$1._tag === `Empty`) return oldValue
    let readonlyArray$2 = oldValue.slice(), patches = of$4(self$1)
    for (; isNonEmptyArray(patches);) {
      let head$5 = headNonEmpty$1(patches), tail = tailNonEmpty$1(patches)
      switch (head$5._tag) {
        case `Empty`:
          patches = tail
          break
        case `AndThen`:
          tail.unshift(head$5.first, head$5.second), patches = tail
          break
        case `Append`:
          for (let value$2 of head$5.values) readonlyArray$2.push(value$2)
          patches = tail
          break
        case `Slice`:
          readonlyArray$2 = readonlyArray$2.slice(head$5.from, head$5.until), patches = tail
          break
        case `Update`:
          readonlyArray$2[head$5.index] = differ$2.patch(head$5.patch, readonlyArray$2[head$5.index]), patches = tail
          break
      }
    }
    return readonlyArray$2
  }),
  DifferTypeId = Symbol.for(`effect/Differ`),
  DifferProto = {
    [DifferTypeId]: { _P: identity, _V: identity },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  make$46 = params => {
    let differ$2 = Object.create(DifferProto)
    return differ$2.empty = params.empty,
      differ$2.diff = params.diff,
      differ$2.combine = params.combine,
      differ$2.patch = params.patch,
      differ$2
  },
  environment$1 = () =>
    make$46({
      empty: empty$25(),
      combine: (first$2, second) => combine$7(second)(first$2),
      diff: (oldValue, newValue) => diff$8(oldValue, newValue),
      patch: (patch$12, oldValue) => patch$10(oldValue)(patch$12),
    }),
  chunk$1 = differ$2 =>
    make$46({
      empty: empty$26(),
      combine: (first$2, second) => combine$8(second)(first$2),
      diff: (oldValue, newValue) => diff$9({ oldValue, newValue, differ: differ$2 }),
      patch: (patch$12, oldValue) => patch$11(oldValue, differ$2)(patch$12),
    }),
  hashMap$1 = differ$2 =>
    make$46({
      empty: empty$24(),
      combine: (first$2, second) => combine$6(second)(first$2),
      diff: (oldValue, newValue) => diff$7({ oldValue, newValue, differ: differ$2 }),
      patch: (patch$12, oldValue) => patch$9(oldValue, differ$2)(patch$12),
    }),
  hashSet$1 = () =>
    make$46({
      empty: empty$23(),
      combine: (first$2, second) => combine$5(second)(first$2),
      diff: (oldValue, newValue) => diff$6(oldValue, newValue),
      patch: (patch$12, oldValue) => patch$8(oldValue)(patch$12),
    }),
  orElseEither$3 = dual(
    2,
    (self$1, that) =>
      make$46({
        empty: empty$22(),
        combine: (first$2, second) => combine$4(first$2, second),
        diff: (oldValue, newValue) => diff$5({ oldValue, newValue, left: self$1, right: that }),
        patch: (patch$12, oldValue) => patch$7(patch$12, { oldValue, left: self$1, right: that }),
      }),
  ),
  readonlyArray$1 = differ$2 =>
    make$46({
      empty: empty$21(),
      combine: (first$2, second) => combine$3(first$2, second),
      diff: (oldValue, newValue) => diff$4({ oldValue, newValue, differ: differ$2 }),
      patch: (patch$12, oldValue) => patch$6(patch$12, oldValue, differ$2),
    }),
  transform$2 = dual(
    2,
    (self$1, { toNew, toOld }) =>
      make$46({
        empty: self$1.empty,
        combine: (first$2, second) => self$1.combine(first$2, second),
        diff: (oldValue, newValue) => self$1.diff(toOld(oldValue), toOld(newValue)),
        patch: (patch$12, oldValue) => toNew(self$1.patch(patch$12, toOld(oldValue))),
      }),
  ),
  update$4 = () => updateWith$1((_$1, a$22) => a$22),
  updateWith$1 = f$14 =>
    make$46({
      empty: identity,
      combine: (first$2, second) =>
        first$2 === identity ? second : second === identity ? first$2 : a$22 => second(first$2(a$22)),
      diff: (oldValue, newValue) => equals(oldValue, newValue) ? identity : constant(newValue),
      patch: (patch$12, oldValue) => f$14(oldValue, patch$12(oldValue)),
    }),
  zip$5 = dual(2, (self$1, that) =>
    make$46({
      empty: [self$1.empty, that.empty],
      combine: (first$2, second) => [self$1.combine(first$2[0], second[0]), that.combine(first$2[1], second[1])],
      diff: (oldValue, newValue) => [self$1.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
      patch: (patch$12, oldValue) => [self$1.patch(patch$12[0], oldValue[0]), that.patch(patch$12[1], oldValue[1])],
    })),
  BIT_MASK = 255,
  BIT_SHIFT = 8,
  active = patch$12 => patch$12 & BIT_MASK,
  enabled = patch$12 => patch$12 >> BIT_SHIFT & BIT_MASK,
  make$45 = (active$1, enabled$1) => (active$1 & BIT_MASK) + ((enabled$1 & active$1 & BIT_MASK) << BIT_SHIFT),
  empty$20 = make$45(0, 0),
  enable$2 = flag => make$45(flag, flag),
  disable$3 = flag => make$45(flag, 0),
  isEmpty$6 = patch$12 => patch$12 === 0,
  isActive$1 = dual(2, (self$1, flag) => (active(self$1) & flag) !== 0),
  isEnabled$2 = dual(2, (self$1, flag) => (enabled(self$1) & flag) !== 0),
  isDisabled$1 = dual(2, (self$1, flag) => (active(self$1) & flag) !== 0 && (enabled(self$1) & flag) === 0),
  exclude$1 = dual(2, (self$1, flag) => make$45(active(self$1) & ~flag, enabled(self$1))),
  both$1 = dual(2, (self$1, that) => make$45(active(self$1) | active(that), enabled(self$1) & enabled(that))),
  either$5 = dual(2, (self$1, that) => make$45(active(self$1) | active(that), enabled(self$1) | enabled(that))),
  andThen$5 = dual(2, (self$1, that) => self$1 | that),
  inverse$1 = patch$12 => make$45(enabled(patch$12), invert(active(patch$12))),
  invert = n$19 => ~n$19 >>> 0 & BIT_MASK,
  None$1 = 0,
  Interruption = 1,
  OpSupervision = 2,
  RuntimeMetrics = 4,
  WindDown = 16,
  CooperativeYielding = 32,
  allFlags = [None$1, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding],
  print$1 = flag => {
    switch (flag) {
      case CooperativeYielding:
        return `CooperativeYielding`
      case WindDown:
        return `WindDown`
      case RuntimeMetrics:
        return `RuntimeMetrics`
      case OpSupervision:
        return `OpSupervision`
      case Interruption:
        return `Interruption`
      case None$1:
        return `None`
    }
  },
  cooperativeYielding = self$1 => isEnabled$1(self$1, CooperativeYielding),
  disable$2 = dual(2, (self$1, flag) => self$1 & ~flag),
  enable$1 = dual(2, (self$1, flag) => self$1 | flag),
  interruptible$3 = self$1 => interruption(self$1) && !windDown(self$1),
  interruption = self$1 => isEnabled$1(self$1, Interruption),
  isEnabled$1 = dual(2, (self$1, flag) => (self$1 & flag) !== 0),
  make$44 = (...flags) => flags.reduce((a$22, b$3) => a$22 | b$3, 0),
  none$5 = make$44(None$1),
  runtimeMetrics = self$1 => isEnabled$1(self$1, RuntimeMetrics),
  toSet$1 = self$1 => new Set(allFlags.filter(flag => isEnabled$1(self$1, flag))),
  windDown = self$1 => isEnabled$1(self$1, WindDown),
  enabledSet$1 = self$1 => toSet$1(active(self$1) & enabled(self$1)),
  disabledSet$1 = self$1 => toSet$1(active(self$1) & ~enabled(self$1)),
  diff$3 = dual(2, (self$1, that) => make$45(self$1 ^ that, that)),
  patch$5 = dual(
    2,
    (self$1, patch$12) =>
      self$1 & (invert(active(patch$12)) | enabled(patch$12)) | active(patch$12) & enabled(patch$12),
  ),
  renderPatch = self$1 => {
    let enabled$1 = Array.from(enabledSet$1(self$1)).map(flag => print$1(flag)).join(`, `),
      disabled = Array.from(disabledSet$1(self$1)).map(flag => print$1(flag)).join(`, `)
    return `RuntimeFlagsPatch(enabled = (${enabled$1}), disabled = (${disabled}))`
  },
  differ$1 = make$46({
    empty: empty$20,
    diff: (oldValue, newValue) => diff$3(oldValue, newValue),
    combine: (first$2, second) => andThen$5(second)(first$2),
    patch: (_patch, oldValue) => patch$5(oldValue, _patch),
  }),
  empty$19 = empty$20,
  make$43 = make$45,
  enable = enable$2,
  disable$1 = disable$3,
  isEmpty$5 = isEmpty$6,
  isActive = isActive$1,
  isEnabled = isEnabled$2,
  isDisabled = isDisabled$1,
  includes = isActive$1,
  andThen$4 = andThen$5,
  both = both$1,
  either$4 = either$5,
  exclude = exclude$1,
  inverse = inverse$1,
  enabledSet = enabledSet$1,
  disabledSet = disabledSet$1,
  render$2 = renderPatch,
  empty$18 = { _tag: `Empty` },
  par = (self$1, that) => ({ _tag: `Par`, left: self$1, right: that }),
  seq = (self$1, that) => ({ _tag: `Seq`, left: self$1, right: that }),
  single = (dataSource, blockedRequest) => ({ _tag: `Single`, dataSource, blockedRequest }),
  flatten$5 = self$1 => {
    let current = of$2(self$1), updated = empty$27()
    for (;;) {
      let [parallel$4, sequential$4] = reduce$6(
        current,
        [parallelCollectionEmpty(), empty$27()],
        ([parallel$5, sequential$5], blockedRequest) => {
          let [par$1, seq$1] = step$2(blockedRequest)
          return [parallelCollectionCombine(parallel$5, par$1), appendAll(sequential$5, seq$1)]
        },
      )
      if (updated = merge$5(updated, parallel$4), isNil(sequential$4)) return reverse(updated)
      current = sequential$4
    }
    throw Error(`BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues`)
  },
  step$2 = requests => {
    let current = requests, parallel$4 = parallelCollectionEmpty(), stack = empty$27(), sequential$4 = empty$27()
    for (;;) {
      switch (current._tag) {
        case `Empty`:
          if (isNil(stack)) return [parallel$4, sequential$4]
          current = stack.head, stack = stack.tail
          break
        case `Par`:
          stack = cons(current.right, stack), current = current.left
          break
        case `Seq`: {
          let left$2 = current.left, right$2 = current.right
          switch (left$2._tag) {
            case `Empty`:
              current = right$2
              break
            case `Par`: {
              let l$9 = left$2.left, r$26 = left$2.right
              current = par(seq(l$9, right$2), seq(r$26, right$2))
              break
            }
            case `Seq`: {
              let l$9 = left$2.left, r$26 = left$2.right
              current = seq(l$9, seq(r$26, right$2))
              break
            }
            case `Single`:
              current = left$2, sequential$4 = cons(right$2, sequential$4)
              break
          }
          break
        }
        case `Single`:
          if (parallel$4 = parallelCollectionAdd(parallel$4, current), isNil(stack)) return [parallel$4, sequential$4]
          current = stack.head, stack = stack.tail
          break
      }
    }
    throw Error(`BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues`)
  },
  merge$5 = (sequential$4, parallel$4) => {
    if (isNil(sequential$4)) return of$2(parallelCollectionToSequentialCollection(parallel$4))
    if (parallelCollectionIsEmpty(parallel$4)) return sequential$4
    let seqHeadKeys = sequentialCollectionKeys(sequential$4.head), parKeys = parallelCollectionKeys(parallel$4)
    return seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])
      ? cons(
        sequentialCollectionCombine(sequential$4.head, parallelCollectionToSequentialCollection(parallel$4)),
        sequential$4.tail,
      )
      : cons(parallelCollectionToSequentialCollection(parallel$4), sequential$4)
  },
  EntryTypeId = Symbol.for(`effect/RequestBlock/Entry`)
var EntryImpl = class {
  request
  result
  listeners
  ownerId
  state;
  [EntryTypeId] = blockedRequestVariance
  constructor(request$1, result, listeners, ownerId, state) {
    this.request = request$1,
      this.result = result,
      this.listeners = listeners,
      this.ownerId = ownerId,
      this.state = state
  }
}
const blockedRequestVariance = { _R: _$1 => _$1 },
  isEntry$1 = u$7 => hasProperty(u$7, EntryTypeId),
  makeEntry$1 = options$2 =>
    new EntryImpl(options$2.request, options$2.result, options$2.listeners, options$2.ownerId, options$2.state),
  RequestBlockParallelTypeId = Symbol.for(`effect/RequestBlock/RequestBlockParallel`),
  parallelVariance = { _R: _$1 => _$1 }
var ParallelImpl = class {
  map;
  [RequestBlockParallelTypeId] = parallelVariance
  constructor(map$20) {
    this.map = map$20
  }
}
const parallelCollectionEmpty = () => new ParallelImpl(empty$28()),
  parallelCollectionAdd = (self$1, blockedRequest) =>
    new ParallelImpl(
      modifyAt(self$1.map, blockedRequest.dataSource, _$1 =>
        orElseSome(map$18(_$1, append$1(blockedRequest.blockedRequest)), () =>
          of$3(blockedRequest.blockedRequest))),
    ),
  parallelCollectionCombine = (self$1, that) =>
    new ParallelImpl(
      reduce$7(self$1.map, that.map, (map$20, value$2, key$1) =>
        set$3(
          map$20,
          key$1,
          match$11(get$5(map$20, key$1), { onNone: () => value$2, onSome: other => appendAll$1(value$2, other) }),
        )),
    ),
  parallelCollectionIsEmpty = self$1 => isEmpty$7(self$1.map),
  parallelCollectionKeys = self$1 => Array.from(keys$3(self$1.map)),
  parallelCollectionToSequentialCollection = self$1 => sequentialCollectionMake(map$13(self$1.map, x$2 => of$3(x$2))),
  SequentialCollectionTypeId = Symbol.for(`effect/RequestBlock/RequestBlockSequential`),
  sequentialVariance = { _R: _$1 => _$1 }
var SequentialImpl = class {
  map;
  [SequentialCollectionTypeId] = sequentialVariance
  constructor(map$20) {
    this.map = map$20
  }
}
const sequentialCollectionMake = map$20 => new SequentialImpl(map$20),
  sequentialCollectionCombine = (self$1, that) =>
    new SequentialImpl(
      reduce$7(that.map, self$1.map, (map$20, value$2, key$1) =>
        set$3(
          map$20,
          key$1,
          match$11(get$5(map$20, key$1), { onNone: () => empty$32(), onSome: a$22 => appendAll$1(a$22, value$2) }),
        )),
    ),
  sequentialCollectionKeys = self$1 => Array.from(keys$3(self$1.map)),
  sequentialCollectionToChunk = self$1 => Array.from(self$1.map),
  OP_DIE = `Die`,
  OP_EMPTY$2 = `Empty`,
  OP_FAIL$1 = `Fail`,
  OP_INTERRUPT = `Interrupt`,
  OP_PARALLEL$1 = `Parallel`,
  OP_SEQUENTIAL$1 = `Sequential`,
  CauseSymbolKey = `effect/Cause`,
  CauseTypeId$1 = Symbol.for(CauseSymbolKey),
  variance$1 = { _E: _$1 => _$1 },
  proto$2 = {
    [CauseTypeId$1]: variance$1,
    [symbol$2]() {
      return pipe(hash(CauseSymbolKey), combine$11(hash(flattenCause(this))), cached$2(this))
    },
    [symbol$1](that) {
      return isCause$1(that) && causeEquals(this, that)
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
    toJSON() {
      switch (this._tag) {
        case `Empty`:
          return { _id: `Cause`, _tag: this._tag }
        case `Die`:
          return { _id: `Cause`, _tag: this._tag, defect: toJSON(this.defect) }
        case `Interrupt`:
          return { _id: `Cause`, _tag: this._tag, fiberId: this.fiberId.toJSON() }
        case `Fail`:
          return { _id: `Cause`, _tag: this._tag, failure: toJSON(this.error) }
        case `Sequential`:
        case `Parallel`:
          return { _id: `Cause`, _tag: this._tag, left: toJSON(this.left), right: toJSON(this.right) }
      }
    },
    toString() {
      return pretty$3(this)
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
  },
  empty$17 = (() => {
    let o$18 = Object.create(proto$2)
    return o$18._tag = OP_EMPTY$2, o$18
  })(),
  fail$10 = error => {
    let o$18 = Object.create(proto$2)
    return o$18._tag = OP_FAIL$1, o$18.error = error, o$18
  },
  die$5 = defect => {
    let o$18 = Object.create(proto$2)
    return o$18._tag = OP_DIE, o$18.defect = defect, o$18
  },
  interrupt$6 = fiberId$2 => {
    let o$18 = Object.create(proto$2)
    return o$18._tag = OP_INTERRUPT, o$18.fiberId = fiberId$2, o$18
  },
  parallel$3 = (left$2, right$2) => {
    let o$18 = Object.create(proto$2)
    return o$18._tag = OP_PARALLEL$1, o$18.left = left$2, o$18.right = right$2, o$18
  },
  sequential$3 = (left$2, right$2) => {
    let o$18 = Object.create(proto$2)
    return o$18._tag = OP_SEQUENTIAL$1, o$18.left = left$2, o$18.right = right$2, o$18
  },
  isCause$1 = u$7 => hasProperty(u$7, CauseTypeId$1),
  isEmptyType$1 = self$1 => self$1._tag === OP_EMPTY$2,
  isFailType$1 = self$1 => self$1._tag === OP_FAIL$1,
  isDieType$1 = self$1 => self$1._tag === OP_DIE,
  isInterruptType$1 = self$1 => self$1._tag === OP_INTERRUPT,
  isSequentialType$1 = self$1 => self$1._tag === OP_SEQUENTIAL$1,
  isParallelType$1 = self$1 => self$1._tag === OP_PARALLEL$1,
  size$9 = self$1 => reduceWithContext$1(self$1, void 0, SizeCauseReducer),
  isEmpty$4 = self$1 =>
    self$1._tag === OP_EMPTY$2 ? !0 : reduce$5(self$1, !0, (acc, cause$2) => {
      switch (cause$2._tag) {
        case OP_EMPTY$2:
          return some$4(acc)
        case OP_DIE:
        case OP_FAIL$1:
        case OP_INTERRUPT:
          return some$4(!1)
        default:
          return none$7()
      }
    }),
  isFailure$4 = self$1 => isSome(failureOption$1(self$1)),
  isDie$1 = self$1 => isSome(dieOption$1(self$1)),
  isInterrupted$2 = self$1 => isSome(interruptOption$1(self$1)),
  isInterruptedOnly$1 = self$1 => reduceWithContext$1(void 0, IsInterruptedOnlyCauseReducer)(self$1),
  failures$1 = self$1 =>
    reverse$1(
      reduce$5(self$1, empty$32(), (list$3, cause$2) =>
        cause$2._tag === OP_FAIL$1 ? some$4(pipe(list$3, prepend$1(cause$2.error))) : none$7()),
    ),
  defects$1 = self$1 =>
    reverse$1(
      reduce$5(self$1, empty$32(), (list$3, cause$2) =>
        cause$2._tag === OP_DIE ? some$4(pipe(list$3, prepend$1(cause$2.defect))) : none$7()),
    ),
  interruptors$1 = self$1 =>
    reduce$5(
      self$1,
      empty$29(),
      (set$6, cause$2) => cause$2._tag === OP_INTERRUPT ? some$4(pipe(set$6, add$1(cause$2.fiberId))) : none$7(),
    ),
  failureOption$1 = self$1 => find$2(self$1, cause$2 => cause$2._tag === OP_FAIL$1 ? some$4(cause$2.error) : none$7()),
  failureOrCause$1 = self$1 => {
    let option$5 = failureOption$1(self$1)
    switch (option$5._tag) {
      case `None`:
        return right(self$1)
      case `Some`:
        return left(option$5.value)
    }
  },
  dieOption$1 = self$1 => find$2(self$1, cause$2 => cause$2._tag === OP_DIE ? some$4(cause$2.defect) : none$7()),
  flipCauseOption$1 = self$1 =>
    match$9(self$1, {
      onEmpty: some$4(empty$17),
      onFail: map$18(fail$10),
      onDie: defect => some$4(die$5(defect)),
      onInterrupt: fiberId$2 => some$4(interrupt$6(fiberId$2)),
      onSequential: mergeWith(sequential$3),
      onParallel: mergeWith(parallel$3),
    }),
  interruptOption$1 = self$1 =>
    find$2(self$1, cause$2 => cause$2._tag === OP_INTERRUPT ? some$4(cause$2.fiberId) : none$7()),
  keepDefects$1 = self$1 =>
    match$9(self$1, {
      onEmpty: none$7(),
      onFail: () => none$7(),
      onDie: defect => some$4(die$5(defect)),
      onInterrupt: () => none$7(),
      onSequential: mergeWith(sequential$3),
      onParallel: mergeWith(parallel$3),
    }),
  keepDefectsAndElectFailures = self$1 =>
    match$9(self$1, {
      onEmpty: none$7(),
      onFail: failure => some$4(die$5(failure)),
      onDie: defect => some$4(die$5(defect)),
      onInterrupt: () => none$7(),
      onSequential: mergeWith(sequential$3),
      onParallel: mergeWith(parallel$3),
    }),
  linearize$1 = self$1 =>
    match$9(self$1, {
      onEmpty: empty$29(),
      onFail: error => make$51(fail$10(error)),
      onDie: defect => make$51(die$5(defect)),
      onInterrupt: fiberId$2 => make$51(interrupt$6(fiberId$2)),
      onSequential: (leftSet, rightSet) =>
        flatMap$8(leftSet, leftCause => map$14(rightSet, rightCause => sequential$3(leftCause, rightCause))),
      onParallel: (leftSet, rightSet) =>
        flatMap$8(leftSet, leftCause => map$14(rightSet, rightCause => parallel$3(leftCause, rightCause))),
    }),
  stripFailures$1 = self$1 =>
    match$9(self$1, {
      onEmpty: empty$17,
      onFail: () => empty$17,
      onDie: die$5,
      onInterrupt: interrupt$6,
      onSequential: sequential$3,
      onParallel: parallel$3,
    }),
  electFailures = self$1 =>
    match$9(self$1, {
      onEmpty: empty$17,
      onFail: die$5,
      onDie: die$5,
      onInterrupt: interrupt$6,
      onSequential: sequential$3,
      onParallel: parallel$3,
    }),
  stripSomeDefects$1 = dual(2, (self$1, pf) =>
    match$9(self$1, {
      onEmpty: some$4(empty$17),
      onFail: error => some$4(fail$10(error)),
      onDie: defect => {
        let option$5 = pf(defect)
        return isSome(option$5) ? none$7() : some$4(die$5(defect))
      },
      onInterrupt: fiberId$2 => some$4(interrupt$6(fiberId$2)),
      onSequential: mergeWith(sequential$3),
      onParallel: mergeWith(parallel$3),
    })),
  as$5 = dual(2, (self$1, error) => map$12(self$1, () => error)),
  map$12 = dual(2, (self$1, f$14) => flatMap$6(self$1, e$26 => fail$10(f$14(e$26)))),
  flatMap$6 = dual(
    2,
    (self$1, f$14) =>
      match$9(self$1, {
        onEmpty: empty$17,
        onFail: error => f$14(error),
        onDie: defect => die$5(defect),
        onInterrupt: fiberId$2 => interrupt$6(fiberId$2),
        onSequential: (left$2, right$2) => sequential$3(left$2, right$2),
        onParallel: (left$2, right$2) => parallel$3(left$2, right$2),
      }),
  ),
  flatten$4 = self$1 => flatMap$6(self$1, identity),
  andThen$3 = dual(2, (self$1, f$14) => isFunction$1(f$14) ? flatMap$6(self$1, f$14) : flatMap$6(self$1, () => f$14)),
  contains$2 = dual(
    2,
    (self$1, that) =>
      that._tag === OP_EMPTY$2 || self$1 === that
        ? !0
        : reduce$5(self$1, !1, (accumulator, cause$2) => some$4(accumulator || causeEquals(cause$2, that))),
  ),
  causeEquals = (left$2, right$2) => {
    let leftStack = of$3(left$2), rightStack = of$3(right$2)
    for (; isNonEmpty$4(leftStack) && isNonEmpty$4(rightStack);) {
      let [leftParallel, leftSequential] = pipe(
          headNonEmpty(leftStack),
          reduce$5([empty$29(), empty$32()], ([parallel$4, sequential$4], cause$2) => {
            let [par$1, seq$1] = evaluateCause(cause$2)
            return some$4([pipe(parallel$4, union$5(par$1)), pipe(sequential$4, appendAll$1(seq$1))])
          }),
        ),
        [rightParallel, rightSequential] = pipe(
          headNonEmpty(rightStack),
          reduce$5([empty$29(), empty$32()], ([parallel$4, sequential$4], cause$2) => {
            let [par$1, seq$1] = evaluateCause(cause$2)
            return some$4([pipe(parallel$4, union$5(par$1)), pipe(sequential$4, appendAll$1(seq$1))])
          }),
        )
      if (!equals(leftParallel, rightParallel)) return !1
      leftStack = leftSequential, rightStack = rightSequential
    }
    return !0
  },
  flattenCause = cause$2 => flattenCauseLoop(of$3(cause$2), empty$32()),
  flattenCauseLoop = (causes, flattened) => {
    for (;;) {
      let [parallel$4, sequential$4] = pipe(
          causes,
          reduce$12([empty$29(), empty$32()], ([parallel$5, sequential$5], cause$2) => {
            let [par$1, seq$1] = evaluateCause(cause$2)
            return [pipe(parallel$5, union$5(par$1)), pipe(sequential$5, appendAll$1(seq$1))]
          }),
        ),
        updated = size$11(parallel$4) > 0 ? pipe(flattened, prepend$1(parallel$4)) : flattened
      if (isEmpty$9(sequential$4)) return reverse$1(updated)
      causes = sequential$4, flattened = updated
    }
    throw Error(getBugErrorMessage(`Cause.flattenCauseLoop`))
  },
  find$2 = dual(2, (self$1, pf) => {
    let stack = [self$1]
    for (; stack.length > 0;) {
      let item = stack.pop(), option$5 = pf(item)
      switch (option$5._tag) {
        case `None`:
          switch (item._tag) {
            case OP_SEQUENTIAL$1:
            case OP_PARALLEL$1:
              stack.push(item.right), stack.push(item.left)
              break
          }
          break
        case `Some`:
          return option$5
      }
    }
    return none$7()
  }),
  filter$4 = dual(2, (self$1, predicate) => reduceWithContext$1(self$1, void 0, FilterCauseReducer(predicate))),
  evaluateCause = self$1 => {
    let cause$2 = self$1, stack = [], _parallel = empty$29(), _sequential = empty$32()
    for (; cause$2 !== void 0;) {
      switch (cause$2._tag) {
        case OP_EMPTY$2:
          if (stack.length === 0) return [_parallel, _sequential]
          cause$2 = stack.pop()
          break
        case OP_FAIL$1:
          if (_parallel = add$1(_parallel, make$56(cause$2._tag, cause$2.error)), stack.length === 0) {
            return [_parallel, _sequential]
          }
          cause$2 = stack.pop()
          break
        case OP_DIE:
          if (_parallel = add$1(_parallel, make$56(cause$2._tag, cause$2.defect)), stack.length === 0) {
            return [_parallel, _sequential]
          }
          cause$2 = stack.pop()
          break
        case OP_INTERRUPT:
          if (_parallel = add$1(_parallel, make$56(cause$2._tag, cause$2.fiberId)), stack.length === 0) {
            return [_parallel, _sequential]
          }
          cause$2 = stack.pop()
          break
        case OP_SEQUENTIAL$1:
          switch (cause$2.left._tag) {
            case OP_EMPTY$2:
              cause$2 = cause$2.right
              break
            case OP_SEQUENTIAL$1:
              cause$2 = sequential$3(cause$2.left.left, sequential$3(cause$2.left.right, cause$2.right))
              break
            case OP_PARALLEL$1:
              cause$2 = parallel$3(
                sequential$3(cause$2.left.left, cause$2.right),
                sequential$3(cause$2.left.right, cause$2.right),
              )
              break
            default:
              _sequential = prepend$1(_sequential, cause$2.right), cause$2 = cause$2.left
              break
          }
          break
        case OP_PARALLEL$1:
          stack.push(cause$2.right), cause$2 = cause$2.left
          break
      }
    }
    throw Error(getBugErrorMessage(`Cause.evaluateCauseLoop`))
  },
  SizeCauseReducer = {
    emptyCase: () => 0,
    failCase: () => 1,
    dieCase: () => 1,
    interruptCase: () => 1,
    sequentialCase: (_$1, left$2, right$2) => left$2 + right$2,
    parallelCase: (_$1, left$2, right$2) => left$2 + right$2,
  },
  IsInterruptedOnlyCauseReducer = {
    emptyCase: constTrue,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: constTrue,
    sequentialCase: (_$1, left$2, right$2) => left$2 && right$2,
    parallelCase: (_$1, left$2, right$2) => left$2 && right$2,
  },
  FilterCauseReducer = predicate => ({
    emptyCase: () => empty$17,
    failCase: (_$1, error) => fail$10(error),
    dieCase: (_$1, defect) => die$5(defect),
    interruptCase: (_$1, fiberId$2) => interrupt$6(fiberId$2),
    sequentialCase: (_$1, left$2, right$2) =>
      predicate(left$2)
        ? predicate(right$2) ? sequential$3(left$2, right$2) : left$2
        : predicate(right$2)
        ? right$2
        : empty$17,
    parallelCase: (_$1, left$2, right$2) =>
      predicate(left$2)
        ? predicate(right$2) ? parallel$3(left$2, right$2) : left$2
        : predicate(right$2)
        ? right$2
        : empty$17,
  }),
  OP_SEQUENTIAL_CASE = `SequentialCase`,
  OP_PARALLEL_CASE = `ParallelCase`,
  match$9 = dual(
    2,
    (self$1, { onDie, onEmpty, onFail, onInterrupt: onInterrupt$2, onParallel, onSequential }) =>
      reduceWithContext$1(self$1, void 0, {
        emptyCase: () => onEmpty,
        failCase: (_$1, error) => onFail(error),
        dieCase: (_$1, defect) => onDie(defect),
        interruptCase: (_$1, fiberId$2) => onInterrupt$2(fiberId$2),
        sequentialCase: (_$1, left$2, right$2) => onSequential(left$2, right$2),
        parallelCase: (_$1, left$2, right$2) => onParallel(left$2, right$2),
      }),
  ),
  reduce$5 = dual(3, (self$1, zero$1, pf) => {
    let accumulator = zero$1, cause$2 = self$1, causes = []
    for (; cause$2 !== void 0;) {
      let option$5 = pf(accumulator, cause$2)
      switch (accumulator = isSome(option$5) ? option$5.value : accumulator, cause$2._tag) {
        case OP_SEQUENTIAL$1:
          causes.push(cause$2.right), cause$2 = cause$2.left
          break
        case OP_PARALLEL$1:
          causes.push(cause$2.right), cause$2 = cause$2.left
          break
        default:
          cause$2 = void 0
          break
      }
      cause$2 === void 0 && causes.length > 0 && (cause$2 = causes.pop())
    }
    return accumulator
  }),
  reduceWithContext$1 = dual(3, (self$1, context$2, reducer) => {
    let input = [self$1], output = []
    for (; input.length > 0;) {
      let cause$2 = input.pop()
      switch (cause$2._tag) {
        case OP_EMPTY$2:
          output.push(right(reducer.emptyCase(context$2)))
          break
        case OP_FAIL$1:
          output.push(right(reducer.failCase(context$2, cause$2.error)))
          break
        case OP_DIE:
          output.push(right(reducer.dieCase(context$2, cause$2.defect)))
          break
        case OP_INTERRUPT:
          output.push(right(reducer.interruptCase(context$2, cause$2.fiberId)))
          break
        case OP_SEQUENTIAL$1:
          input.push(cause$2.right), input.push(cause$2.left), output.push(left({ _tag: OP_SEQUENTIAL_CASE }))
          break
        case OP_PARALLEL$1:
          input.push(cause$2.right), input.push(cause$2.left), output.push(left({ _tag: OP_PARALLEL_CASE }))
          break
      }
    }
    let accumulator = []
    for (; output.length > 0;) {
      let either$6 = output.pop()
      switch (either$6._tag) {
        case `Left`:
          switch (either$6.left._tag) {
            case OP_SEQUENTIAL_CASE: {
              let left$2 = accumulator.pop(),
                right$2 = accumulator.pop(),
                value$2 = reducer.sequentialCase(context$2, left$2, right$2)
              accumulator.push(value$2)
              break
            }
            case OP_PARALLEL_CASE: {
              let left$2 = accumulator.pop(),
                right$2 = accumulator.pop(),
                value$2 = reducer.parallelCase(context$2, left$2, right$2)
              accumulator.push(value$2)
              break
            }
          }
          break
        case `Right`:
          accumulator.push(either$6.right)
          break
      }
    }
    if (accumulator.length === 0) {
      throw Error(`BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues`)
    }
    return accumulator.pop()
  }),
  pretty$3 = (cause$2, options$2) =>
    isInterruptedOnly$1(cause$2)
      ? `All fibers interrupted without errors.`
      : prettyErrors$1(cause$2).map(function(e$26) {
        return options$2?.renderErrorCause !== !0 || e$26.cause === void 0
          ? e$26.stack
          : `${e$26.stack} {\n${renderErrorCause(e$26.cause, `  `)}\n}`
      }).join(`
`),
  renderErrorCause = (cause$2, prefix$1) => {
    let lines = cause$2.stack.split(`
`),
      stack = `${prefix$1}[cause]: ${lines[0]}`
    for (let i$14 = 1, len = lines.length; i$14 < len; i$14++) stack += `\n${prefix$1}${lines[i$14]}`
    return cause$2.cause && (stack += ` {\n${renderErrorCause(cause$2.cause, `${prefix$1}  `)}\n${prefix$1}}`), stack
  }
var PrettyError = class PrettyError extends globalThis.Error {
  span = void 0
  constructor(originalError$1) {
    let originalErrorIsObject = typeof originalError$1 == `object` && !!originalError$1,
      prevLimit = Error.stackTraceLimit
    Error.stackTraceLimit = 1,
      super(
        prettyErrorMessage(originalError$1),
        originalErrorIsObject && `cause` in originalError$1 && originalError$1.cause !== void 0
          ? { cause: new PrettyError(originalError$1.cause) }
          : void 0,
      ),
      this.message === `` && (this.message = `An error has occurred`),
      Error.stackTraceLimit = prevLimit,
      this.name = originalError$1 instanceof Error ? originalError$1.name : `Error`,
      originalErrorIsObject
      && (spanSymbol in originalError$1 && (this.span = originalError$1[spanSymbol]),
        Object.keys(originalError$1).forEach(key$1 => {
          key$1 in this || (this[key$1] = originalError$1[key$1])
        })),
      this.stack = prettyErrorStack(
        `${this.name}: ${this.message}`,
        originalError$1 instanceof Error && originalError$1.stack ? originalError$1.stack : ``,
        this.span,
      )
  }
}
const prettyErrorMessage = u$7 => {
    if (typeof u$7 == `string`) return u$7
    if (typeof u$7 == `object` && u$7 && u$7 instanceof Error) return u$7.message
    try {
      if (
        hasProperty(u$7, `toString`) && isFunction$1(u$7.toString) && u$7.toString !== Object.prototype.toString
        && u$7.toString !== globalThis.Array.prototype.toString
      ) return u$7.toString()
    } catch {}
    return stringifyCircular(u$7)
  },
  locationRegex = /\((.*)\)/g,
  spanToTrace = globalValue(`effect/Tracer/spanToTrace`, () => new WeakMap()),
  prettyErrorStack = (message, stack, span$1) => {
    let out = [message],
      lines = stack.startsWith(message)
        ? stack.slice(message.length).split(`
`)
        : stack.split(`
`)
    for (let i$14 = 1; i$14 < lines.length; i$14++) {
      if (lines[i$14].includes(` at new BaseEffectError`) || lines[i$14].includes(` at new YieldableError`)) {
        i$14++
        continue
      }
      if (lines[i$14].includes(`Generator.next`) || lines[i$14].includes(`effect_internal_function`)) break
      out.push(
        lines[i$14].replace(/at .*effect_instruction_i.*\((.*)\)/, `at $1`).replace(
          /EffectPrimitive\.\w+/,
          `<anonymous>`,
        ),
      )
    }
    if (span$1) {
      let current = span$1, i$14 = 0
      for (; current && current._tag === `Span` && i$14 < 10;) {
        let stackFn = spanToTrace.get(current)
        if (typeof stackFn == `function`) {
          let stack$1 = stackFn()
          if (typeof stack$1 == `string`) {
            let locationMatchAll = stack$1.matchAll(locationRegex), match$13 = !1
            for (let [, location] of locationMatchAll) match$13 = !0, out.push(`    at ${current.name} (${location})`)
            match$13 || out.push(`    at ${current.name} (${stack$1.replace(/^at /, ``)})`)
          } else out.push(`    at ${current.name}`)
        } else out.push(`    at ${current.name}`)
        current = getOrUndefined(current.parent), i$14++
      }
    }
    return out.join(`
`)
  },
  spanSymbol = Symbol.for(`effect/SpanAnnotation`),
  prettyErrors$1 = cause$2 =>
    reduceWithContext$1(cause$2, void 0, {
      emptyCase: () => [],
      dieCase: (_$1, unknownError) => [new PrettyError(unknownError)],
      failCase: (_$1, error) => [new PrettyError(error)],
      interruptCase: () => [],
      parallelCase: (_$1, l$9, r$26) => [...l$9, ...r$26],
      sequentialCase: (_$1, l$9, r$26) => [...l$9, ...r$26],
    }),
  OP_STATE_PENDING = `Pending`,
  OP_STATE_DONE = `Done`,
  DeferredSymbolKey = `effect/Deferred`,
  DeferredTypeId$1 = Symbol.for(DeferredSymbolKey),
  deferredVariance = { _E: _$1 => _$1, _A: _$1 => _$1 },
  pending$1 = joiners => ({ _tag: OP_STATE_PENDING, joiners }),
  done$7 = effect => ({ _tag: OP_STATE_DONE, effect })
var SingleShotGen$1 = class SingleShotGen$1 {
  self
  called = !1
  constructor(self$1) {
    this.self = self$1
  }
  next(a$22) {
    return this.called ? { value: a$22, done: !0 } : (this.called = !0, { value: this.self, done: !1 })
  }
  return(a$22) {
    return { value: a$22, done: !0 }
  }
  throw(e$26) {
    throw e$26
  }
  [Symbol.iterator]() {
    return new SingleShotGen$1(this.self)
  }
}
const blocked$1 = (blockedRequests, _continue$2) => {
    let effect = new EffectPrimitive(`Blocked`)
    return effect.effect_instruction_i0 = blockedRequests, effect.effect_instruction_i1 = _continue$2, effect
  },
  runRequestBlock$1 = blockedRequests => {
    let effect = new EffectPrimitive(`RunBlocked`)
    return effect.effect_instruction_i0 = blockedRequests, effect
  },
  EffectTypeId$2 = Symbol.for(`effect/Effect`)
var RevertFlags = class {
    patch
    op
    _op = OP_REVERT_FLAGS
    constructor(patch$12, op) {
      this.patch = patch$12, this.op = op
    }
  },
  EffectPrimitive = class {
    _op
    effect_instruction_i0 = void 0
    effect_instruction_i1 = void 0
    effect_instruction_i2 = void 0
    trace = void 0;
    [EffectTypeId$2] = effectVariance
    constructor(_op) {
      this._op = _op
    }
    [symbol$1](that) {
      return this === that
    }
    [symbol$2]() {
      return cached$2(this, random$2(this))
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
    toJSON() {
      return {
        _id: `Effect`,
        _op: this._op,
        effect_instruction_i0: toJSON(this.effect_instruction_i0),
        effect_instruction_i1: toJSON(this.effect_instruction_i1),
        effect_instruction_i2: toJSON(this.effect_instruction_i2),
      }
    }
    toString() {
      return format$1(this.toJSON())
    }
    [NodeInspectSymbol]() {
      return this.toJSON()
    }
    [Symbol.iterator]() {
      return new SingleShotGen$1(new YieldWrap(this))
    }
  },
  EffectPrimitiveFailure = class {
    _op
    effect_instruction_i0 = void 0
    effect_instruction_i1 = void 0
    effect_instruction_i2 = void 0
    trace = void 0;
    [EffectTypeId$2] = effectVariance
    constructor(_op) {
      this._op = _op, this._tag = _op
    }
    [symbol$1](that) {
      return exitIsExit(that) && that._op === `Failure`
        && equals(this.effect_instruction_i0, that.effect_instruction_i0)
    }
    [symbol$2]() {
      return pipe(string$4(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this))
    }
    get cause() {
      return this.effect_instruction_i0
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
    toJSON() {
      return { _id: `Exit`, _tag: this._op, cause: this.cause.toJSON() }
    }
    toString() {
      return format$1(this.toJSON())
    }
    [NodeInspectSymbol]() {
      return this.toJSON()
    }
    [Symbol.iterator]() {
      return new SingleShotGen$1(new YieldWrap(this))
    }
  },
  EffectPrimitiveSuccess = class {
    _op
    effect_instruction_i0 = void 0
    effect_instruction_i1 = void 0
    effect_instruction_i2 = void 0
    trace = void 0;
    [EffectTypeId$2] = effectVariance
    constructor(_op) {
      this._op = _op, this._tag = _op
    }
    [symbol$1](that) {
      return exitIsExit(that) && that._op === `Success`
        && equals(this.effect_instruction_i0, that.effect_instruction_i0)
    }
    [symbol$2]() {
      return pipe(string$4(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this))
    }
    get value() {
      return this.effect_instruction_i0
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
    toJSON() {
      return { _id: `Exit`, _tag: this._op, value: toJSON(this.value) }
    }
    toString() {
      return format$1(this.toJSON())
    }
    [NodeInspectSymbol]() {
      return this.toJSON()
    }
    [Symbol.iterator]() {
      return new SingleShotGen$1(new YieldWrap(this))
    }
  }
const isEffect$1 = u$7 => hasProperty(u$7, EffectTypeId$2),
  withFiberRuntime$1 = withRuntime => {
    let effect = new EffectPrimitive(OP_WITH_RUNTIME)
    return effect.effect_instruction_i0 = withRuntime, effect
  },
  acquireUseRelease$1 = dual(
    3,
    (acquire, use$2, release) =>
      uninterruptibleMask$2(restore =>
        flatMap$5(acquire, a$22 =>
          flatMap$5(
            exit$4(suspend$4(() => restore(use$2(a$22)))),
            exit$5 =>
              suspend$4(() => release(a$22, exit$5)).pipe(matchCauseEffect$2({
                onFailure: cause$2 => {
                  switch (exit$5._tag) {
                    case OP_FAILURE:
                      return failCause$8(sequential$3(exit$5.effect_instruction_i0, cause$2))
                    case OP_SUCCESS:
                      return failCause$8(cause$2)
                  }
                },
                onSuccess: () => exit$5,
              })),
          ))
      ),
  ),
  as$4 = dual(2, (self$1, value$2) => flatMap$5(self$1, () => succeed$9(value$2))),
  asVoid$3 = self$1 => as$4(self$1, void 0),
  custom$1 = function() {
    let wrapper = new EffectPrimitive(OP_COMMIT)
    switch (arguments.length) {
      case 2:
        wrapper.effect_instruction_i0 = arguments[0], wrapper.commit = arguments[1]
        break
      case 3:
        wrapper.effect_instruction_i0 = arguments[0],
          wrapper.effect_instruction_i1 = arguments[1],
          wrapper.commit = arguments[2]
        break
      case 4:
        wrapper.effect_instruction_i0 = arguments[0],
          wrapper.effect_instruction_i1 = arguments[1],
          wrapper.effect_instruction_i2 = arguments[2],
          wrapper.commit = arguments[3]
        break
      default:
        throw Error(getBugErrorMessage(`you're not supposed to end up here`))
    }
    return wrapper
  },
  unsafeAsync = (register, blockingOn = none$6) => {
    let effect = new EffectPrimitive(OP_ASYNC), cancelerRef
    return effect.effect_instruction_i0 = resume$1 => {
      cancelerRef = register(resume$1)
    },
      effect.effect_instruction_i1 = blockingOn,
      onInterrupt$1(effect, _$1 => isEffect$1(cancelerRef) ? cancelerRef : void_$4)
  },
  asyncInterrupt = (register, blockingOn = none$6) => suspend$4(() => unsafeAsync(register, blockingOn)),
  async_ = (resume$1, blockingOn = none$6) =>
    custom$1(resume$1, function() {
      let backingResume, pendingEffect
      function proxyResume(effect$1) {
        backingResume ? backingResume(effect$1) : pendingEffect === void 0 && (pendingEffect = effect$1)
      }
      let effect = new EffectPrimitive(OP_ASYNC)
      effect.effect_instruction_i0 = resume$2 => {
        backingResume = resume$2, pendingEffect && resume$2(pendingEffect)
      }, effect.effect_instruction_i1 = blockingOn
      let cancelerRef, controllerRef
      return this.effect_instruction_i0.length === 1
        ? cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume))
        : (controllerRef = new AbortController(),
          cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal))),
        cancelerRef || controllerRef
          ? onInterrupt$1(effect, _$1 => (controllerRef && controllerRef.abort(), cancelerRef ?? void_$4))
          : effect
    }),
  catchAllCause$1 = dual(2, (self$1, f$14) => {
    let effect = new EffectPrimitive(OP_ON_FAILURE)
    return effect.effect_instruction_i0 = self$1, effect.effect_instruction_i1 = f$14, effect
  }),
  catchAll$1 = dual(2, (self$1, f$14) => matchEffect$2(self$1, { onFailure: f$14, onSuccess: succeed$9 })),
  catchIf$1 = dual(3, (self$1, predicate, f$14) =>
    catchAllCause$1(self$1, cause$2 => {
      let either$6 = failureOrCause$1(cause$2)
      switch (either$6._tag) {
        case `Left`:
          return predicate(either$6.left) ? f$14(either$6.left) : failCause$8(cause$2)
        case `Right`:
          return failCause$8(either$6.right)
      }
    })),
  catchSome$1 = dual(2, (self$1, pf) =>
    catchAllCause$1(self$1, cause$2 => {
      let either$6 = failureOrCause$1(cause$2)
      switch (either$6._tag) {
        case `Left`:
          return pipe(pf(either$6.left), getOrElse$5(() => failCause$8(cause$2)))
        case `Right`:
          return failCause$8(either$6.right)
      }
    })),
  checkInterruptible$1 = f$14 => withFiberRuntime$1((_$1, status$2) => f$14(interruption(status$2.runtimeFlags))),
  originalSymbol = Symbol.for(`effect/OriginalAnnotation`),
  originalInstance = obj => hasProperty(obj, originalSymbol) ? obj[originalSymbol] : obj,
  capture = (obj, span$1) =>
    isSome(span$1)
      ? new Proxy(obj, {
        has(target, p$25) {
          return p$25 === spanSymbol || p$25 === originalSymbol || p$25 in target
        },
        get(target, p$25) {
          return p$25 === spanSymbol ? span$1.value : p$25 === originalSymbol ? obj : target[p$25]
        },
      })
      : obj,
  die$4 = defect =>
    isObject$4(defect) && !(spanSymbol in defect)
      ? withFiberRuntime$1(fiber => failCause$8(die$5(capture(defect, currentSpanFromFiber(fiber)))))
      : failCause$8(die$5(defect)),
  dieMessage$1 = message => failCauseSync$2(() => die$5(new RuntimeException$1(message))),
  dieSync$2 = evaluate$2 => flatMap$5(sync$3(evaluate$2), die$4),
  either$3 = self$1 =>
    matchEffect$2(self$1, { onFailure: e$26 => succeed$9(left(e$26)), onSuccess: a$22 => succeed$9(right(a$22)) }),
  exit$4 = self$1 => matchCause$2(self$1, { onFailure: exitFailCause$1, onSuccess: exitSucceed$1 }),
  fail$9 = error =>
    isObject$4(error) && !(spanSymbol in error)
      ? withFiberRuntime$1(fiber => failCause$8(fail$10(capture(error, currentSpanFromFiber(fiber)))))
      : failCause$8(fail$10(error)),
  failSync$2 = evaluate$2 => flatMap$5(sync$3(evaluate$2), fail$9),
  failCause$8 = cause$2 => {
    let effect = new EffectPrimitiveFailure(OP_FAILURE)
    return effect.effect_instruction_i0 = cause$2, effect
  },
  failCauseSync$2 = evaluate$2 => flatMap$5(sync$3(evaluate$2), failCause$8),
  fiberId$1 = withFiberRuntime$1(state => succeed$9(state.id())),
  fiberIdWith$1 = f$14 => withFiberRuntime$1(state => f$14(state.id())),
  flatMap$5 = dual(2, (self$1, f$14) => {
    let effect = new EffectPrimitive(OP_ON_SUCCESS)
    return effect.effect_instruction_i0 = self$1, effect.effect_instruction_i1 = f$14, effect
  }),
  andThen$2 = dual(2, (self$1, f$14) =>
    flatMap$5(self$1, a$22 => {
      let b$3 = typeof f$14 == `function` ? f$14(a$22) : f$14
      return isEffect$1(b$3) ? b$3 : isPromiseLike(b$3)
        ? unsafeAsync(resume$1 => {
          b$3.then(
            a$23 => resume$1(succeed$9(a$23)),
            e$26 => resume$1(fail$9(new UnknownException$1(e$26, `An unknown error occurred in Effect.andThen`))),
          )
        })
        : succeed$9(b$3)
    })),
  step$1 = self$1 => {
    let effect = new EffectPrimitive(`OnStep`)
    return effect.effect_instruction_i0 = self$1, effect
  },
  flatten$3 = self$1 => flatMap$5(self$1, identity),
  flip$4 = self$1 => matchEffect$2(self$1, { onFailure: succeed$9, onSuccess: fail$9 }),
  matchCause$2 = dual(
    2,
    (self$1, options$2) =>
      matchCauseEffect$2(self$1, {
        onFailure: cause$2 => succeed$9(options$2.onFailure(cause$2)),
        onSuccess: a$22 => succeed$9(options$2.onSuccess(a$22)),
      }),
  ),
  matchCauseEffect$2 = dual(2, (self$1, options$2) => {
    let effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE)
    return effect.effect_instruction_i0 = self$1,
      effect.effect_instruction_i1 = options$2.onFailure,
      effect.effect_instruction_i2 = options$2.onSuccess,
      effect
  }),
  matchEffect$2 = dual(2, (self$1, options$2) =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 => {
        let defects$2 = defects$1(cause$2)
        if (defects$2.length > 0) return failCause$8(electFailures(cause$2))
        let failures$2 = failures$1(cause$2)
        return failures$2.length > 0 ? options$2.onFailure(unsafeHead(failures$2)) : failCause$8(cause$2)
      },
      onSuccess: options$2.onSuccess,
    })),
  forEachSequential = dual(2, (self$1, f$14) =>
    suspend$4(() => {
      let arr = fromIterable$10(self$1), ret = allocate(arr.length), i$14 = 0
      return as$4(
        whileLoop$2({
          while: () => i$14 < arr.length,
          body: () => f$14(arr[i$14], i$14),
          step: b$3 => {
            ret[i$14++] = b$3
          },
        }),
        ret,
      )
    })),
  forEachSequentialDiscard = dual(2, (self$1, f$14) =>
    suspend$4(() => {
      let arr = fromIterable$10(self$1), i$14 = 0
      return whileLoop$2({
        while: () => i$14 < arr.length,
        body: () => f$14(arr[i$14], i$14),
        step: () => {
          i$14++
        },
      })
    })),
  if_$1 = dual(
    args$1 => typeof args$1[0] == `boolean` || isEffect$1(args$1[0]),
    (self$1, options$2) =>
      isEffect$1(self$1)
        ? flatMap$5(self$1, b$3 => b$3 ? options$2.onTrue() : options$2.onFalse())
        : self$1
        ? options$2.onTrue()
        : options$2.onFalse(),
  ),
  interrupt$5 = flatMap$5(fiberId$1, fiberId$2 => interruptWith$2(fiberId$2)),
  interruptWith$2 = fiberId$2 => failCause$8(interrupt$6(fiberId$2)),
  interruptible$2 = self$1 => {
    let effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS)
    return effect.effect_instruction_i0 = enable(Interruption), effect.effect_instruction_i1 = () => self$1, effect
  },
  interruptibleMask$1 = f$14 =>
    custom$1(f$14, function() {
      let effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS)
      return effect.effect_instruction_i0 = enable(Interruption),
        effect.effect_instruction_i1 = oldFlags =>
          interruption(oldFlags)
            ? internalCall(() => this.effect_instruction_i0(interruptible$2))
            : internalCall(() => this.effect_instruction_i0(uninterruptible$1)),
        effect
    }),
  intoDeferred$1 = dual(
    2,
    (self$1, deferred) =>
      uninterruptibleMask$2(restore => flatMap$5(exit$4(restore(self$1)), exit$5 => deferredDone(deferred, exit$5))),
  ),
  map$11 = dual(2, (self$1, f$14) => flatMap$5(self$1, a$22 => sync$3(() => f$14(a$22)))),
  mapBoth$3 = dual(
    2,
    (self$1, options$2) =>
      matchEffect$2(self$1, {
        onFailure: e$26 => failSync$2(() => options$2.onFailure(e$26)),
        onSuccess: a$22 => sync$3(() => options$2.onSuccess(a$22)),
      }),
  ),
  mapError$3 = dual(2, (self$1, f$14) =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 => {
        let either$6 = failureOrCause$1(cause$2)
        switch (either$6._tag) {
          case `Left`:
            return failSync$2(() => f$14(either$6.left))
          case `Right`:
            return failCause$8(either$6.right)
        }
      },
      onSuccess: succeed$9,
    })),
  onError$1 = dual(
    2,
    (self$1, cleanup) =>
      onExit$2(self$1, exit$5 => exitIsSuccess(exit$5) ? void_$4 : cleanup(exit$5.effect_instruction_i0)),
  ),
  onExit$2 = dual(2, (self$1, cleanup) =>
    uninterruptibleMask$2(restore =>
      matchCauseEffect$2(restore(self$1), {
        onFailure: cause1 => {
          let result = exitFailCause$1(cause1)
          return matchCauseEffect$2(cleanup(result), {
            onFailure: cause2 => exitFailCause$1(sequential$3(cause1, cause2)),
            onSuccess: () => result,
          })
        },
        onSuccess: success => {
          let result = exitSucceed$1(success)
          return zipRight$3(cleanup(result), result)
        },
      })
    )),
  onInterrupt$1 = dual(
    2,
    (self$1, cleanup) =>
      onExit$2(
        self$1,
        exitMatch({
          onFailure: cause$2 => isInterruptedOnly$1(cause$2) ? asVoid$3(cleanup(interruptors$1(cause$2))) : void_$4,
          onSuccess: () => void_$4,
        }),
      ),
  ),
  orElse$6 = dual(2, (self$1, that) => attemptOrElse(self$1, that, succeed$9)),
  orDie$1 = self$1 => orDieWith$1(self$1, identity),
  orDieWith$1 = dual(
    2,
    (self$1, f$14) => matchEffect$2(self$1, { onFailure: e$26 => die$4(f$14(e$26)), onSuccess: succeed$9 }),
  ),
  partitionMap = partitionMap$1,
  runtimeFlags = withFiberRuntime$1((_$1, status$2) => succeed$9(status$2.runtimeFlags)),
  succeed$9 = value$2 => {
    let effect = new EffectPrimitiveSuccess(OP_SUCCESS)
    return effect.effect_instruction_i0 = value$2, effect
  },
  suspend$4 = evaluate$2 => {
    let effect = new EffectPrimitive(OP_COMMIT)
    return effect.commit = evaluate$2, effect
  },
  sync$3 = thunk => {
    let effect = new EffectPrimitive(OP_SYNC)
    return effect.effect_instruction_i0 = thunk, effect
  },
  tap$1 = dual(
    args$1 => args$1.length === 3 || args$1.length === 2 && !(isObject$4(args$1[1]) && `onlyEffect` in args$1[1]),
    (self$1, f$14) =>
      flatMap$5(self$1, a$22 => {
        let b$3 = typeof f$14 == `function` ? f$14(a$22) : f$14
        return isEffect$1(b$3) ? as$4(b$3, a$22) : isPromiseLike(b$3)
          ? unsafeAsync(resume$1 => {
            b$3.then(
              _$1 => resume$1(succeed$9(a$22)),
              e$26 => resume$1(fail$9(new UnknownException$1(e$26, `An unknown error occurred in Effect.tap`))),
            )
          })
          : succeed$9(a$22)
      }),
  ),
  transplant$1 = f$14 =>
    withFiberRuntime$1(state => {
      let scopeOverride = state.getFiberRef(currentForkScopeOverride),
        scope$2 = pipe(scopeOverride, getOrElse$5(() => state.scope()))
      return f$14(fiberRefLocally(currentForkScopeOverride, some$4(scope$2)))
    }),
  attemptOrElse = dual(3, (self$1, that, onSuccess) =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 => {
        let defects$2 = defects$1(cause$2)
        return defects$2.length > 0 ? failCause$8(getOrThrow(keepDefectsAndElectFailures(cause$2))) : that()
      },
      onSuccess,
    })),
  uninterruptible$1 = self$1 => {
    let effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS)
    return effect.effect_instruction_i0 = disable$1(Interruption), effect.effect_instruction_i1 = () => self$1, effect
  },
  uninterruptibleMask$2 = f$14 =>
    custom$1(f$14, function() {
      let effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS)
      return effect.effect_instruction_i0 = disable$1(Interruption),
        effect.effect_instruction_i1 = oldFlags =>
          interruption(oldFlags)
            ? internalCall(() => this.effect_instruction_i0(interruptible$2))
            : internalCall(() => this.effect_instruction_i0(uninterruptible$1)),
        effect
    }),
  void_$4 = succeed$9(void 0),
  updateRuntimeFlags = patch$12 => {
    let effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS)
    return effect.effect_instruction_i0 = patch$12, effect.effect_instruction_i1 = void 0, effect
  },
  whenEffect$1 = dual(
    2,
    (self$1, condition) => flatMap$5(condition, b$3 => b$3 ? pipe(self$1, map$11(some$4)) : succeed$9(none$7())),
  ),
  whileLoop$2 = options$2 => {
    let effect = new EffectPrimitive(OP_WHILE)
    return effect.effect_instruction_i0 = options$2.while,
      effect.effect_instruction_i1 = options$2.body,
      effect.effect_instruction_i2 = options$2.step,
      effect
  },
  fromIterator = iterator =>
    suspend$4(() => {
      let effect = new EffectPrimitive(OP_ITERATOR)
      return effect.effect_instruction_i0 = iterator(), effect
    }),
  gen$1 = function() {
    let f$14 = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0])
    return fromIterator(() => f$14(pipe))
  },
  fnUntraced$1 = (body$2, ...pipeables) =>
    Object.defineProperty(
      pipeables.length === 0
        ? function(...args$1) {
          return fromIterator(() => body$2.apply(this, args$1))
        }
        : function(...args$1) {
          let effect = fromIterator(() => body$2.apply(this, args$1))
          for (let x$2 of pipeables) effect = x$2(effect, ...args$1)
          return effect
        },
      `length`,
      { value: body$2.length, configurable: !0 },
    ),
  withConcurrency$1 = dual(2, (self$1, concurrency) => fiberRefLocally(self$1, currentConcurrency, concurrency)),
  withRequestBatching$1 = dual(
    2,
    (self$1, requestBatching) => fiberRefLocally(self$1, currentRequestBatching, requestBatching),
  ),
  withRuntimeFlags = dual(2, (self$1, update$5) => {
    let effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS)
    return effect.effect_instruction_i0 = update$5, effect.effect_instruction_i1 = () => self$1, effect
  }),
  withTracerEnabled$1 = dual(2, (effect, enabled$1) => fiberRefLocally(effect, currentTracerEnabled, enabled$1)),
  withTracerTiming$1 = dual(2, (effect, enabled$1) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled$1)),
  yieldNow$3 = options$2 => {
    let effect = new EffectPrimitive(OP_YIELD)
    return options$2?.priority === void 0 ? effect : withSchedulingPriority$1(effect, options$2.priority)
  },
  zip$4 = dual(2, (self$1, that) => flatMap$5(self$1, a$22 => map$11(that, b$3 => [a$22, b$3]))),
  zipLeft$3 = dual(2, (self$1, that) => flatMap$5(self$1, a$22 => as$4(that, a$22))),
  zipRight$3 = dual(2, (self$1, that) => flatMap$5(self$1, () => that)),
  zipWith$4 = dual(3, (self$1, that, f$14) => flatMap$5(self$1, a$22 => map$11(that, b$3 => f$14(a$22, b$3)))),
  never$4 = asyncInterrupt(() => {
    let interval = setInterval(() => {}, 2 ** 31 - 1)
    return sync$3(() => clearInterval(interval))
  }),
  interruptFiber = self$1 => flatMap$5(fiberId$1, fiberId$2 => pipe(self$1, interruptAsFiber(fiberId$2))),
  interruptAsFiber = dual(2, (self$1, fiberId$2) => flatMap$5(self$1.interruptAsFork(fiberId$2), () => self$1.await)),
  logLevelAll = {
    _tag: `All`,
    syslog: 0,
    label: `ALL`,
    ordinal: -(2 ** 53 - 1),
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  logLevelFatal = {
    _tag: `Fatal`,
    syslog: 2,
    label: `FATAL`,
    ordinal: 5e4,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  logLevelError = {
    _tag: `Error`,
    syslog: 3,
    label: `ERROR`,
    ordinal: 4e4,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  logLevelWarning = {
    _tag: `Warning`,
    syslog: 4,
    label: `WARN`,
    ordinal: 3e4,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  logLevelInfo = {
    _tag: `Info`,
    syslog: 6,
    label: `INFO`,
    ordinal: 2e4,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  logLevelDebug = {
    _tag: `Debug`,
    syslog: 7,
    label: `DEBUG`,
    ordinal: 1e4,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  logLevelTrace = {
    _tag: `Trace`,
    syslog: 7,
    label: `TRACE`,
    ordinal: 0,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  logLevelNone = {
    _tag: `None`,
    syslog: 7,
    label: `OFF`,
    ordinal: 2 ** 53 - 1,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  allLogLevels = [
    logLevelAll,
    logLevelTrace,
    logLevelDebug,
    logLevelInfo,
    logLevelWarning,
    logLevelError,
    logLevelFatal,
    logLevelNone,
  ],
  FiberRefSymbolKey = `effect/FiberRef`,
  FiberRefTypeId = Symbol.for(FiberRefSymbolKey),
  fiberRefVariance = { _A: _$1 => _$1 },
  fiberRefGet = self$1 => withFiberRuntime$1(fiber => exitSucceed$1(fiber.getFiberRef(self$1))),
  fiberRefGetWith = dual(2, (self$1, f$14) => flatMap$5(fiberRefGet(self$1), f$14)),
  fiberRefSet = dual(2, (self$1, value$2) => fiberRefModify(self$1, () => [void 0, value$2])),
  fiberRefModify = dual(2, (self$1, f$14) =>
    withFiberRuntime$1(state => {
      let [b$3, a$22] = f$14(state.getFiberRef(self$1))
      return state.setFiberRef(self$1, a$22), succeed$9(b$3)
    })),
  RequestResolverSymbolKey = `effect/RequestResolver`,
  RequestResolverTypeId = Symbol.for(RequestResolverSymbolKey),
  requestResolverVariance = { _A: _$1 => _$1, _R: _$1 => _$1 }
var RequestResolverImpl = class RequestResolverImpl {
  runAll
  target;
  [RequestResolverTypeId] = requestResolverVariance
  constructor(runAll, target) {
    this.runAll = runAll, this.target = target
  }
  [symbol$2]() {
    return cached$2(this, this.target ? hash(this.target) : random$2(this))
  }
  [symbol$1](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that
  }
  identified(...ids$2) {
    return new RequestResolverImpl(this.runAll, fromIterable$9(ids$2))
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const isRequestResolver = u$7 => hasProperty(u$7, RequestResolverTypeId),
  fiberRefLocally = dual(
    3,
    (use$2, self$1, value$2) =>
      acquireUseRelease$1(
        zipLeft$3(fiberRefGet(self$1), fiberRefSet(self$1, value$2)),
        () => use$2,
        oldValue => fiberRefSet(self$1, oldValue),
      ),
  ),
  fiberRefLocallyWith = dual(
    3,
    (use$2, self$1, f$14) => fiberRefGetWith(self$1, a$22 => fiberRefLocally(use$2, self$1, f$14(a$22))),
  ),
  fiberRefUnsafeMake = (initial, options$2) =>
    fiberRefUnsafeMakePatch(initial, { differ: update$4(), fork: options$2?.fork ?? identity, join: options$2?.join }),
  fiberRefUnsafeMakeHashSet = initial => {
    let differ$2 = hashSet$1()
    return fiberRefUnsafeMakePatch(initial, { differ: differ$2, fork: differ$2.empty })
  },
  fiberRefUnsafeMakeReadonlyArray = initial => {
    let differ$2 = readonlyArray$1(update$4())
    return fiberRefUnsafeMakePatch(initial, { differ: differ$2, fork: differ$2.empty })
  },
  fiberRefUnsafeMakeContext = initial => {
    let differ$2 = environment$1()
    return fiberRefUnsafeMakePatch(initial, { differ: differ$2, fork: differ$2.empty })
  },
  fiberRefUnsafeMakePatch = (initial, options$2) => {
    let _fiberRef = {
      ...CommitPrototype$1,
      [FiberRefTypeId]: fiberRefVariance,
      initial,
      commit() {
        return fiberRefGet(this)
      },
      diff: (oldValue, newValue) => options$2.differ.diff(oldValue, newValue),
      combine: (first$2, second) => options$2.differ.combine(first$2, second),
      patch: patch$12 => oldValue => options$2.differ.patch(patch$12, oldValue),
      fork: options$2.fork,
      join: options$2.join ?? ((_$1, n$19) => n$19),
    }
    return _fiberRef
  },
  fiberRefUnsafeMakeRuntimeFlags = initial =>
    fiberRefUnsafeMakePatch(initial, { differ: differ$1, fork: differ$1.empty }),
  currentContext = globalValue(
    Symbol.for(`effect/FiberRef/currentContext`),
    () => fiberRefUnsafeMakeContext(empty$33()),
  ),
  currentSchedulingPriority = globalValue(
    Symbol.for(`effect/FiberRef/currentSchedulingPriority`),
    () => fiberRefUnsafeMake(0),
  ),
  currentMaxOpsBeforeYield = globalValue(
    Symbol.for(`effect/FiberRef/currentMaxOpsBeforeYield`),
    () => fiberRefUnsafeMake(2048),
  ),
  currentLogAnnotations = globalValue(
    Symbol.for(`effect/FiberRef/currentLogAnnotation`),
    () => fiberRefUnsafeMake(empty$28()),
  ),
  currentLogLevel = globalValue(Symbol.for(`effect/FiberRef/currentLogLevel`), () => fiberRefUnsafeMake(logLevelInfo)),
  currentLogSpan = globalValue(Symbol.for(`effect/FiberRef/currentLogSpan`), () => fiberRefUnsafeMake(empty$27())),
  withSchedulingPriority$1 = dual(
    2,
    (self$1, scheduler) => fiberRefLocally(self$1, currentSchedulingPriority, scheduler),
  ),
  withMaxOpsBeforeYield$1 = dual(
    2,
    (self$1, scheduler) => fiberRefLocally(self$1, currentMaxOpsBeforeYield, scheduler),
  ),
  currentConcurrency = globalValue(
    Symbol.for(`effect/FiberRef/currentConcurrency`),
    () => fiberRefUnsafeMake(`unbounded`),
  ),
  currentRequestBatching = globalValue(
    Symbol.for(`effect/FiberRef/currentRequestBatching`),
    () => fiberRefUnsafeMake(!0),
  ),
  currentUnhandledErrorLogLevel = globalValue(
    Symbol.for(`effect/FiberRef/currentUnhandledErrorLogLevel`),
    () => fiberRefUnsafeMake(some$4(logLevelDebug)),
  ),
  currentVersionMismatchErrorLogLevel = globalValue(
    Symbol.for(`effect/FiberRef/versionMismatchErrorLogLevel`),
    () => fiberRefUnsafeMake(some$4(logLevelWarning)),
  ),
  withUnhandledErrorLogLevel$1 = dual(
    2,
    (self$1, level) => fiberRefLocally(self$1, currentUnhandledErrorLogLevel, level),
  ),
  currentMetricLabels = globalValue(
    Symbol.for(`effect/FiberRef/currentMetricLabels`),
    () => fiberRefUnsafeMakeReadonlyArray(empty$35()),
  ),
  metricLabels$1 = fiberRefGet(currentMetricLabels),
  currentForkScopeOverride = globalValue(
    Symbol.for(`effect/FiberRef/currentForkScopeOverride`),
    () => fiberRefUnsafeMake(none$7(), { fork: () => none$7(), join: (parent, _$1) => parent }),
  ),
  currentInterruptedCause = globalValue(
    Symbol.for(`effect/FiberRef/currentInterruptedCause`),
    () => fiberRefUnsafeMake(empty$17, { fork: () => empty$17, join: (parent, _$1) => parent }),
  ),
  currentTracerEnabled = globalValue(Symbol.for(`effect/FiberRef/currentTracerEnabled`), () => fiberRefUnsafeMake(!0)),
  currentTracerTimingEnabled = globalValue(
    Symbol.for(`effect/FiberRef/currentTracerTiming`),
    () => fiberRefUnsafeMake(!0),
  ),
  currentTracerSpanAnnotations = globalValue(
    Symbol.for(`effect/FiberRef/currentTracerSpanAnnotations`),
    () => fiberRefUnsafeMake(empty$28()),
  ),
  currentTracerSpanLinks = globalValue(
    Symbol.for(`effect/FiberRef/currentTracerSpanLinks`),
    () => fiberRefUnsafeMake(empty$32()),
  ),
  ScopeTypeId$1 = Symbol.for(`effect/Scope`),
  CloseableScopeTypeId$1 = Symbol.for(`effect/CloseableScope`),
  scopeAddFinalizer = (self$1, finalizer) => self$1.addFinalizer(() => asVoid$3(finalizer)),
  scopeAddFinalizerExit = (self$1, finalizer) => self$1.addFinalizer(finalizer),
  scopeClose = (self$1, exit$5) => self$1.close(exit$5),
  scopeFork = (self$1, strategy) => self$1.fork(strategy),
  causeSquash = self$1 => causeSquashWith(identity)(self$1),
  causeSquashWith = dual(2, (self$1, f$14) => {
    let option$5 = pipe(self$1, failureOption$1, map$18(f$14))
    switch (option$5._tag) {
      case `None`:
        return pipe(
          defects$1(self$1),
          head$3,
          match$11({
            onNone: () => {
              let interrupts = fromIterable$10(interruptors$1(self$1)).flatMap(fiberId$2 =>
                fromIterable$10(ids(fiberId$2)).map(id$2 => `#${id$2}`)
              )
              return new InterruptedException$1(interrupts ? `Interrupted by fibers: ${interrupts.join(`, `)}` : void 0)
            },
            onSome: identity,
          }),
        )
      case `Some`:
        return option$5.value
    }
  }),
  YieldableError$1 = function() {
    class YieldableError$2 extends globalThis.Error {
      commit() {
        return fail$9(this)
      }
      toJSON() {
        let obj = { ...this }
        return this.message && (obj.message = this.message), this.cause && (obj.cause = this.cause), obj
      }
      [NodeInspectSymbol]() {
        return this.toString === globalThis.Error.prototype.toString
          ? `Bun` in globalThis ? pretty$3(fail$10(this), { renderErrorCause: !0 }) : this
          : this.stack
          ? `${this.toString()}\n${
            this.stack.split(`
`).slice(1).join(`
`)
          }`
          : this.toString()
      }
    }
    return Object.assign(YieldableError$2.prototype, StructuralCommitPrototype$1), YieldableError$2
  }(),
  makeException = (proto$3, tag$3) => {
    class Base$2 extends YieldableError$1 {
      _tag = tag$3
    }
    return Object.assign(Base$2.prototype, proto$3), Base$2.prototype.name = tag$3, Base$2
  },
  RuntimeExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/RuntimeException`),
  RuntimeException$1 = makeException({ [RuntimeExceptionTypeId$1]: RuntimeExceptionTypeId$1 }, `RuntimeException`),
  isRuntimeException$1 = u$7 => hasProperty(u$7, RuntimeExceptionTypeId$1),
  InterruptedExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/InterruptedException`),
  InterruptedException$1 = makeException(
    { [InterruptedExceptionTypeId$1]: InterruptedExceptionTypeId$1 },
    `InterruptedException`,
  ),
  isInterruptedException$1 = u$7 => hasProperty(u$7, InterruptedExceptionTypeId$1),
  IllegalArgumentExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/IllegalArgument`),
  IllegalArgumentException$1 = makeException(
    { [IllegalArgumentExceptionTypeId$1]: IllegalArgumentExceptionTypeId$1 },
    `IllegalArgumentException`,
  ),
  isIllegalArgumentException$1 = u$7 => hasProperty(u$7, IllegalArgumentExceptionTypeId$1),
  NoSuchElementExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/NoSuchElement`),
  NoSuchElementException$1 = makeException(
    { [NoSuchElementExceptionTypeId$1]: NoSuchElementExceptionTypeId$1 },
    `NoSuchElementException`,
  ),
  isNoSuchElementException$1 = u$7 => hasProperty(u$7, NoSuchElementExceptionTypeId$1),
  InvalidPubSubCapacityExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/InvalidPubSubCapacityException`),
  InvalidPubSubCapacityException = makeException({
    [InvalidPubSubCapacityExceptionTypeId$1]: InvalidPubSubCapacityExceptionTypeId$1,
  }, `InvalidPubSubCapacityException`),
  ExceededCapacityExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/ExceededCapacityException`),
  ExceededCapacityException$1 = makeException({
    [ExceededCapacityExceptionTypeId$1]: ExceededCapacityExceptionTypeId$1,
  }, `ExceededCapacityException`),
  isExceededCapacityException$1 = u$7 => hasProperty(u$7, ExceededCapacityExceptionTypeId$1),
  TimeoutExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/Timeout`),
  TimeoutException$1 = makeException({ [TimeoutExceptionTypeId$1]: TimeoutExceptionTypeId$1 }, `TimeoutException`),
  timeoutExceptionFromDuration = duration =>
    new TimeoutException$1(`Operation timed out after '${format$3(duration)}'`),
  isTimeoutException$1 = u$7 => hasProperty(u$7, TimeoutExceptionTypeId$1),
  UnknownExceptionTypeId$1 = Symbol.for(`effect/Cause/errors/UnknownException`),
  UnknownException$1 = function() {
    class UnknownException$2 extends YieldableError$1 {
      _tag = `UnknownException`
      error
      constructor(cause$2, message) {
        super(message ?? `An unknown error occurred`, { cause: cause$2 }), this.error = cause$2
      }
    }
    return Object.assign(UnknownException$2.prototype, {
      [UnknownExceptionTypeId$1]: UnknownExceptionTypeId$1,
      name: `UnknownException`,
    }),
      UnknownException$2
  }(),
  isUnknownException$1 = u$7 => hasProperty(u$7, UnknownExceptionTypeId$1),
  exitIsExit = u$7 => isEffect$1(u$7) && `_tag` in u$7 && (u$7._tag === `Success` || u$7._tag === `Failure`),
  exitIsFailure = self$1 => self$1._tag === `Failure`,
  exitIsSuccess = self$1 => self$1._tag === `Success`,
  exitIsInterrupted = self$1 => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return isInterrupted$2(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return !1
    }
  },
  exitAs = dual(2, (self$1, value$2) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return exitFailCause$1(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return exitSucceed$1(value$2)
    }
  }),
  exitAsVoid = self$1 => exitAs(self$1, void 0),
  exitCauseOption = self$1 => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return some$4(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return none$7()
    }
  },
  exitCollectAll = (exits, options$2) => exitCollectAllInternal(exits, options$2?.parallel ? parallel$3 : sequential$3),
  exitDie$1 = defect => exitFailCause$1(die$5(defect)),
  exitExists = dual(2, (self$1, refinement) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return !1
      case OP_SUCCESS:
        return refinement(self$1.effect_instruction_i0)
    }
  }),
  exitFail = error => exitFailCause$1(fail$10(error)),
  exitFailCause$1 = cause$2 => {
    let effect = new EffectPrimitiveFailure(OP_FAILURE)
    return effect.effect_instruction_i0 = cause$2, effect
  },
  exitFlatMap = dual(2, (self$1, f$14) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return exitFailCause$1(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return f$14(self$1.effect_instruction_i0)
    }
  }),
  exitFlatMapEffect = dual(2, (self$1, f$14) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return succeed$9(exitFailCause$1(self$1.effect_instruction_i0))
      case OP_SUCCESS:
        return f$14(self$1.effect_instruction_i0)
    }
  }),
  exitFlatten = self$1 => pipe(self$1, exitFlatMap(identity)),
  exitForEachEffect = dual(2, (self$1, f$14) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return succeed$9(exitFailCause$1(self$1.effect_instruction_i0))
      case OP_SUCCESS:
        return exit$4(f$14(self$1.effect_instruction_i0))
    }
  }),
  exitFromEither = either$6 => {
    switch (either$6._tag) {
      case `Left`:
        return exitFail(either$6.left)
      case `Right`:
        return exitSucceed$1(either$6.right)
    }
  },
  exitFromOption = option$5 => {
    switch (option$5._tag) {
      case `None`:
        return exitFail(void 0)
      case `Some`:
        return exitSucceed$1(option$5.value)
    }
  },
  exitGetOrElse = dual(2, (self$1, orElse$8) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return orElse$8(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return self$1.effect_instruction_i0
    }
  }),
  exitInterrupt$1 = fiberId$2 => exitFailCause$1(interrupt$6(fiberId$2)),
  exitMap = dual(2, (self$1, f$14) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return exitFailCause$1(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return exitSucceed$1(f$14(self$1.effect_instruction_i0))
    }
  }),
  exitMapBoth = dual(2, (self$1, { onFailure, onSuccess }) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return exitFailCause$1(pipe(self$1.effect_instruction_i0, map$12(onFailure)))
      case OP_SUCCESS:
        return exitSucceed$1(onSuccess(self$1.effect_instruction_i0))
    }
  }),
  exitMapError = dual(2, (self$1, f$14) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return exitFailCause$1(pipe(self$1.effect_instruction_i0, map$12(f$14)))
      case OP_SUCCESS:
        return exitSucceed$1(self$1.effect_instruction_i0)
    }
  }),
  exitMapErrorCause = dual(2, (self$1, f$14) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return exitFailCause$1(f$14(self$1.effect_instruction_i0))
      case OP_SUCCESS:
        return exitSucceed$1(self$1.effect_instruction_i0)
    }
  }),
  exitMatch = dual(2, (self$1, { onFailure, onSuccess }) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return onFailure(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return onSuccess(self$1.effect_instruction_i0)
    }
  }),
  exitMatchEffect = dual(2, (self$1, { onFailure, onSuccess }) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        return onFailure(self$1.effect_instruction_i0)
      case OP_SUCCESS:
        return onSuccess(self$1.effect_instruction_i0)
    }
  }),
  exitSucceed$1 = value$2 => {
    let effect = new EffectPrimitiveSuccess(OP_SUCCESS)
    return effect.effect_instruction_i0 = value$2, effect
  },
  exitVoid$1 = exitSucceed$1(void 0),
  exitZip = dual(
    2,
    (self$1, that) => exitZipWith(self$1, that, { onSuccess: (a$22, a2) => [a$22, a2], onFailure: sequential$3 }),
  ),
  exitZipLeft = dual(
    2,
    (self$1, that) => exitZipWith(self$1, that, { onSuccess: (a$22, _$1) => a$22, onFailure: sequential$3 }),
  ),
  exitZipRight = dual(
    2,
    (self$1, that) => exitZipWith(self$1, that, { onSuccess: (_$1, a2) => a2, onFailure: sequential$3 }),
  ),
  exitZipPar = dual(
    2,
    (self$1, that) => exitZipWith(self$1, that, { onSuccess: (a$22, a2) => [a$22, a2], onFailure: parallel$3 }),
  ),
  exitZipParLeft = dual(
    2,
    (self$1, that) => exitZipWith(self$1, that, { onSuccess: (a$22, _$1) => a$22, onFailure: parallel$3 }),
  ),
  exitZipParRight = dual(
    2,
    (self$1, that) => exitZipWith(self$1, that, { onSuccess: (_$1, a2) => a2, onFailure: parallel$3 }),
  ),
  exitZipWith = dual(3, (self$1, that, { onFailure, onSuccess }) => {
    switch (self$1._tag) {
      case OP_FAILURE:
        switch (that._tag) {
          case OP_SUCCESS:
            return exitFailCause$1(self$1.effect_instruction_i0)
          case OP_FAILURE:
            return exitFailCause$1(onFailure(self$1.effect_instruction_i0, that.effect_instruction_i0))
        }
      case OP_SUCCESS:
        switch (that._tag) {
          case OP_SUCCESS:
            return exitSucceed$1(onSuccess(self$1.effect_instruction_i0, that.effect_instruction_i0))
          case OP_FAILURE:
            return exitFailCause$1(that.effect_instruction_i0)
        }
    }
  }),
  exitCollectAllInternal = (exits, combineCauses) => {
    let list$3 = fromIterable$9(exits)
    return isNonEmpty$4(list$3)
      ? pipe(
        tailNonEmpty(list$3),
        reduce$12(pipe(headNonEmpty(list$3), exitMap(of$3)), (accumulator, current) =>
          pipe(
            accumulator,
            exitZipWith(current, {
              onSuccess: (list$4, value$2) => pipe(list$4, prepend$1(value$2)),
              onFailure: combineCauses,
            }),
          )),
        exitMap(reverse$1),
        exitMap(chunk$2 => toReadonlyArray(chunk$2)),
        some$4,
      )
      : none$7()
  },
  deferredUnsafeMake = fiberId$2 => {
    let _deferred = {
      ...CommitPrototype$1,
      [DeferredTypeId$1]: deferredVariance,
      state: make$50(pending$1([])),
      commit() {
        return deferredAwait(this)
      },
      blockingOn: fiberId$2,
    }
    return _deferred
  },
  deferredMake = () => flatMap$5(fiberId$1, id$2 => deferredMakeAs(id$2)),
  deferredMakeAs = fiberId$2 => sync$3(() => deferredUnsafeMake(fiberId$2)),
  deferredAwait = self$1 =>
    asyncInterrupt(resume$1 => {
      let state = get$6(self$1.state)
      switch (state._tag) {
        case OP_STATE_DONE:
          return resume$1(state.effect)
        case OP_STATE_PENDING:
          return state.joiners.push(resume$1), deferredInterruptJoiner(self$1, resume$1)
      }
    }, self$1.blockingOn),
  deferredComplete = dual(2, (self$1, effect) => intoDeferred$1(effect, self$1)),
  deferredCompleteWith = dual(2, (self$1, effect) =>
    sync$3(() => {
      let state = get$6(self$1.state)
      switch (state._tag) {
        case OP_STATE_DONE:
          return !1
        case OP_STATE_PENDING:
          set$4(self$1.state, done$7(effect))
          for (let i$14 = 0, len = state.joiners.length; i$14 < len; i$14++) state.joiners[i$14](effect)
          return !0
      }
    })),
  deferredDone = dual(2, (self$1, exit$5) => deferredCompleteWith(self$1, exit$5)),
  deferredFail = dual(2, (self$1, error) => deferredCompleteWith(self$1, fail$9(error))),
  deferredFailSync = dual(2, (self$1, evaluate$2) => deferredCompleteWith(self$1, failSync$2(evaluate$2))),
  deferredFailCause = dual(2, (self$1, cause$2) => deferredCompleteWith(self$1, failCause$8(cause$2))),
  deferredFailCauseSync = dual(2, (self$1, evaluate$2) => deferredCompleteWith(self$1, failCauseSync$2(evaluate$2))),
  deferredDie = dual(2, (self$1, defect) => deferredCompleteWith(self$1, die$4(defect))),
  deferredDieSync = dual(2, (self$1, evaluate$2) => deferredCompleteWith(self$1, dieSync$2(evaluate$2))),
  deferredInterrupt = self$1 =>
    flatMap$5(fiberId$1, fiberId$2 => deferredCompleteWith(self$1, interruptWith$2(fiberId$2))),
  deferredInterruptWith = dual(2, (self$1, fiberId$2) => deferredCompleteWith(self$1, interruptWith$2(fiberId$2))),
  deferredIsDone = self$1 => sync$3(() => get$6(self$1.state)._tag === OP_STATE_DONE),
  deferredPoll = self$1 =>
    sync$3(() => {
      let state = get$6(self$1.state)
      switch (state._tag) {
        case OP_STATE_DONE:
          return some$4(state.effect)
        case OP_STATE_PENDING:
          return none$7()
      }
    }),
  deferredSucceed = dual(2, (self$1, value$2) => deferredCompleteWith(self$1, succeed$9(value$2))),
  deferredSync = dual(2, (self$1, evaluate$2) => deferredCompleteWith(self$1, sync$3(evaluate$2))),
  deferredUnsafeDone = (self$1, effect) => {
    let state = get$6(self$1.state)
    if (state._tag === OP_STATE_PENDING) {
      set$4(self$1.state, done$7(effect))
      for (let i$14 = 0, len = state.joiners.length; i$14 < len; i$14++) state.joiners[i$14](effect)
    }
  },
  deferredInterruptJoiner = (self$1, joiner) =>
    sync$3(() => {
      let state = get$6(self$1.state)
      if (state._tag === OP_STATE_PENDING) {
        let index$4 = state.joiners.indexOf(joiner)
        index$4 >= 0 && state.joiners.splice(index$4, 1)
      }
    }),
  constContext = withFiberRuntime$1(fiber => exitSucceed$1(fiber.currentContext)),
  context$1 = () => constContext,
  contextWithEffect$1 = f$14 => flatMap$5(context$1(), f$14),
  provideContext$1 = dual(2, (self$1, context$2) => fiberRefLocally(currentContext, context$2)(self$1)),
  provideSomeContext = dual(
    2,
    (self$1, context$2) => fiberRefLocallyWith(currentContext, parent => merge$6(parent, context$2))(self$1),
  ),
  mapInputContext$1 = dual(
    2,
    (self$1, f$14) => contextWithEffect$1(context$2 => provideContext$1(self$1, f$14(context$2))),
  ),
  filterEffectOrElse$1 = dual(
    2,
    (self$1, options$2) =>
      flatMap$5(
        self$1,
        a$22 => flatMap$5(options$2.predicate(a$22), pass => pass ? succeed$9(a$22) : options$2.orElse(a$22)),
      ),
  ),
  filterEffectOrFail$1 = dual(
    2,
    (self$1, options$2) =>
      filterEffectOrElse$1(self$1, {
        predicate: options$2.predicate,
        orElse: a$22 => fail$9(options$2.orFailWith(a$22)),
      }),
  ),
  currentSpanFromFiber = fiber => {
    let span$1 = fiber.currentSpan
    return span$1 !== void 0 && span$1._tag === `Span` ? some$4(span$1) : none$7()
  },
  NoopSpanProto = {
    _tag: `Span`,
    spanId: `noop`,
    traceId: `noop`,
    sampled: !1,
    status: { _tag: `Ended`, startTime: BigInt(0), endTime: BigInt(0), exit: exitVoid$1 },
    attributes: new Map(),
    links: [],
    kind: `internal`,
    attribute() {},
    event() {},
    end() {},
    addLinks() {},
  },
  noopSpan = options$2 => Object.assign(Object.create(NoopSpanProto), options$2),
  DeferredTypeId = DeferredTypeId$1,
  make$42 = deferredMake,
  makeAs = deferredMakeAs,
  _await$2 = deferredAwait,
  complete$3 = deferredComplete,
  completeWith = deferredCompleteWith,
  done$6 = deferredDone,
  fail$8 = deferredFail,
  failSync$1 = deferredFailSync,
  failCause$7 = deferredFailCause,
  failCauseSync$1 = deferredFailCauseSync,
  die$3 = deferredDie,
  dieSync$1 = deferredDieSync,
  interrupt$4 = deferredInterrupt,
  interruptWith$1 = deferredInterruptWith,
  isDone$4 = deferredIsDone,
  poll$3 = deferredPoll,
  succeed$8 = deferredSucceed,
  sync$2 = deferredSync,
  unsafeMake$6 = deferredUnsafeMake,
  unsafeDone = deferredUnsafeDone,
  isExit = exitIsExit,
  isFailure$3 = exitIsFailure,
  isSuccess$2 = exitIsSuccess,
  isInterrupted$1 = exitIsInterrupted,
  as$3 = exitAs,
  asVoid$2 = exitAsVoid,
  causeOption = exitCauseOption,
  all$5 = exitCollectAll,
  die$2 = exitDie$1,
  exists$2 = exitExists,
  fail$7 = exitFail,
  failCause$6 = exitFailCause$1,
  flatMap$4 = exitFlatMap,
  flatMapEffect = exitFlatMapEffect,
  flatten$2 = exitFlatten,
  forEachEffect = exitForEachEffect,
  fromEither = exitFromEither,
  fromOption$1 = exitFromOption,
  getOrElse = exitGetOrElse,
  interrupt$3 = exitInterrupt$1,
  map$10 = exitMap,
  mapBoth$2 = exitMapBoth,
  mapError$2 = exitMapError,
  mapErrorCause$2 = exitMapErrorCause,
  match$8 = exitMatch,
  matchEffect$1 = exitMatchEffect,
  succeed$7 = exitSucceed$1,
  void_$3 = exitVoid$1,
  zip$3 = exitZip,
  zipLeft$2 = exitZipLeft,
  zipRight$2 = exitZipRight,
  zipPar = exitZipPar,
  zipParLeft = exitZipParLeft,
  zipParRight = exitZipParRight,
  zipWith$3 = exitZipWith,
  TypeId$11 = Symbol.for(`effect/MutableHashMap`),
  MutableHashMapProto = {
    [TypeId$11]: TypeId$11,
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this)
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `MutableHashMap`, values: Array.from(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  }
var MutableHashMapIterator = class MutableHashMapIterator {
    self
    referentialIterator
    bucketIterator
    constructor(self$1) {
      this.self = self$1, this.referentialIterator = self$1.referential[Symbol.iterator]()
    }
    next() {
      if (this.bucketIterator !== void 0) return this.bucketIterator.next()
      let result = this.referentialIterator.next()
      return result.done ? (this.bucketIterator = new BucketIterator(this.self.buckets.values()), this.next()) : result
    }
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this.self)
    }
  },
  BucketIterator = class {
    backing
    constructor(backing) {
      this.backing = backing
    }
    currentBucket
    next() {
      if (this.currentBucket === void 0) {
        let result$1 = this.backing.next()
        if (result$1.done) return result$1
        this.currentBucket = result$1.value[Symbol.iterator]()
      }
      let result = this.currentBucket.next()
      return result.done ? (this.currentBucket = void 0, this.next()) : result
    }
  }
const empty$16 = () => {
    let self$1 = Object.create(MutableHashMapProto)
    return self$1.referential = new Map(), self$1.buckets = new Map(), self$1.bucketsSize = 0, self$1
  },
  get$4 = dual(2, (self$1, key$1) => {
    if (isEqual(key$1) === !1) return self$1.referential.has(key$1) ? some$4(self$1.referential.get(key$1)) : none$7()
    let hash$1 = key$1[symbol$2](), bucket = self$1.buckets.get(hash$1)
    return bucket === void 0 ? none$7() : getFromBucket(self$1, bucket, key$1)
  }),
  getFromBucket = (self$1, bucket, key$1, remove$7 = !1) => {
    for (let i$14 = 0, len = bucket.length; i$14 < len; i$14++) {
      if (key$1[symbol$1](bucket[i$14][0])) {
        let value$2 = bucket[i$14][1]
        return remove$7 && (bucket.splice(i$14, 1), self$1.bucketsSize--), some$4(value$2)
      }
    }
    return none$7()
  },
  has$2 = dual(2, (self$1, key$1) => isSome(get$4(self$1, key$1))),
  set$2 = dual(3, (self$1, key$1, value$2) => {
    if (isEqual(key$1) === !1) return self$1.referential.set(key$1, value$2), self$1
    let hash$1 = key$1[symbol$2](), bucket = self$1.buckets.get(hash$1)
    return bucket === void 0
      ? (self$1.buckets.set(hash$1, [[key$1, value$2]]), self$1.bucketsSize++, self$1)
      : (removeFromBucket(self$1, bucket, key$1), bucket.push([key$1, value$2]), self$1.bucketsSize++, self$1)
  }),
  removeFromBucket = (self$1, bucket, key$1) => {
    for (let i$14 = 0, len = bucket.length; i$14 < len; i$14++) {
      if (key$1[symbol$1](bucket[i$14][0])) {
        bucket.splice(i$14, 1), self$1.bucketsSize--
        return
      }
    }
  },
  remove$2 = dual(2, (self$1, key$1) => {
    if (isEqual(key$1) === !1) return self$1.referential.delete(key$1), self$1
    let hash$1 = key$1[symbol$2](), bucket = self$1.buckets.get(hash$1)
    return bucket === void 0
      ? self$1
      : (removeFromBucket(self$1, bucket, key$1), bucket.length === 0 && self$1.buckets.delete(hash$1), self$1)
  }),
  size$8 = self$1 => self$1.referential.size + self$1.bucketsSize,
  TypeId$10 = Symbol.for(`effect/MutableList`),
  MutableListProto = {
    [TypeId$10]: TypeId$10,
    [Symbol.iterator]() {
      let done$8 = !1, head$5 = this.head
      return {
        next() {
          if (done$8) return this.return()
          if (head$5 == null) return done$8 = !0, this.return()
          let value$2 = head$5.value
          return head$5 = head$5.next, { done: done$8, value: value$2 }
        },
        return(value$2) {
          return done$8 ||= !0, { done: !0, value: value$2 }
        },
      }
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `MutableList`, values: Array.from(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  makeNode = value$2 => ({ value: value$2, removed: !1, prev: void 0, next: void 0 }),
  empty$15 = () => {
    let list$3 = Object.create(MutableListProto)
    return list$3.head = void 0, list$3.tail = void 0, list$3._length = 0, list$3
  },
  isEmpty$3 = self$1 => length(self$1) === 0,
  length = self$1 => self$1._length,
  append = dual(2, (self$1, value$2) => {
    let node$1 = makeNode(value$2)
    return self$1.head === void 0 && (self$1.head = node$1),
      self$1.tail === void 0
        ? self$1.tail = node$1
        : (self$1.tail.next = node$1, node$1.prev = self$1.tail, self$1.tail = node$1),
      self$1._length += 1,
      self$1
  }),
  shift$3 = self$1 => {
    let head$5 = self$1.head
    if (head$5 !== void 0) return remove$1(self$1, head$5), head$5.value
  },
  remove$1 = (self$1, node$1) => {
    node$1.removed || (node$1.removed = !0,
      node$1.prev !== void 0 && node$1.next !== void 0
        ? (node$1.prev.next = node$1.next, node$1.next.prev = node$1.prev)
        : node$1.prev === void 0
        ? node$1.next === void 0
          ? (self$1.tail = void 0, self$1.head = void 0)
          : (self$1.head = node$1.next, node$1.next.prev = void 0)
        : (self$1.tail = node$1.prev, node$1.prev.next = void 0),
      self$1._length > 0 && --self$1._length)
  },
  TypeId$9 = Symbol.for(`effect/MutableQueue`),
  EmptyMutableQueue = Symbol.for(`effect/mutable/MutableQueue/Empty`),
  MutableQueueProto = {
    [TypeId$9]: TypeId$9,
    [Symbol.iterator]() {
      return Array.from(this.queue)[Symbol.iterator]()
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `MutableQueue`, values: Array.from(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  make$41 = capacity => {
    let queue = Object.create(MutableQueueProto)
    return queue.queue = empty$15(), queue.capacity = capacity, queue
  },
  unbounded = () => make$41(void 0),
  offer = dual(2, (self$1, value$2) => {
    let queueLength = length(self$1.queue)
    return self$1.capacity !== void 0 && queueLength === self$1.capacity ? !1 : (append(value$2)(self$1.queue), !0)
  }),
  poll$2 = dual(2, (self$1, def) => isEmpty$3(self$1.queue) ? def : shift$3(self$1.queue)),
  ClockSymbolKey = `effect/Clock`,
  ClockTypeId$1 = Symbol.for(ClockSymbolKey),
  clockTag = GenericTag(`effect/Clock`),
  MAX_TIMER_MILLIS = 2 ** 31 - 1,
  globalClockScheduler = {
    unsafeSchedule(task, duration) {
      let millis$1 = toMillis(duration)
      if (millis$1 > MAX_TIMER_MILLIS) return constFalse
      let completed = !1,
        handle$2 = setTimeout(() => {
          completed = !0, task()
        }, millis$1)
      return () => (clearTimeout(handle$2), !completed)
    },
  },
  performanceNowNanos = function() {
    let bigint1e6$1 = BigInt(1e6)
    if (typeof performance > `u`) return () => BigInt(Date.now()) * bigint1e6$1
    let origin
    return () => (origin === void 0
      && (origin = BigInt(Date.now()) * bigint1e6$1 - BigInt(Math.round(performance.now() * 1e6))),
      origin + BigInt(Math.round(performance.now() * 1e6)))
  }(),
  processOrPerformanceNow = function() {
    let processHrtime = typeof process == `object` && `hrtime` in process && typeof process.hrtime.bigint == `function`
      ? process.hrtime
      : void 0
    if (!processHrtime) return performanceNowNanos
    let origin = performanceNowNanos() - processHrtime.bigint()
    return () => origin + processHrtime.bigint()
  }()
var ClockImpl = class {
  [ClockTypeId$1] = ClockTypeId$1
  unsafeCurrentTimeMillis() {
    return Date.now()
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow()
  }
  currentTimeMillis = sync$3(() => this.unsafeCurrentTimeMillis())
  currentTimeNanos = sync$3(() => this.unsafeCurrentTimeNanos())
  scheduler() {
    return succeed$9(globalClockScheduler)
  }
  sleep(duration) {
    return async_(resume$1 => {
      let canceler = globalClockScheduler.unsafeSchedule(() => resume$1(void_$4), duration)
      return asVoid$3(sync$3(canceler))
    })
  }
}
const make$40 = () => new ClockImpl(),
  OP_AND = `And`,
  OP_OR = `Or`,
  OP_INVALID_DATA = `InvalidData`,
  OP_MISSING_DATA = `MissingData`,
  OP_SOURCE_UNAVAILABLE = `SourceUnavailable`,
  OP_UNSUPPORTED = `Unsupported`,
  ConfigErrorSymbolKey = `effect/ConfigError`,
  ConfigErrorTypeId = Symbol.for(ConfigErrorSymbolKey),
  proto$1 = { _tag: `ConfigError`, [ConfigErrorTypeId]: ConfigErrorTypeId },
  And = (self$1, that) => {
    let error = Object.create(proto$1)
    return error._op = OP_AND,
      error.left = self$1,
      error.right = that,
      Object.defineProperty(error, `toString`, {
        enumerable: !1,
        value() {
          return `${this.left} and ${this.right}`
        },
      }),
      Object.defineProperty(error, `message`, {
        enumerable: !1,
        get() {
          return this.toString()
        },
      }),
      error
  },
  Or = (self$1, that) => {
    let error = Object.create(proto$1)
    return error._op = OP_OR,
      error.left = self$1,
      error.right = that,
      Object.defineProperty(error, `toString`, {
        enumerable: !1,
        value() {
          return `${this.left} or ${this.right}`
        },
      }),
      Object.defineProperty(error, `message`, {
        enumerable: !1,
        get() {
          return this.toString()
        },
      }),
      error
  },
  InvalidData = (path$1, message, options$2 = { pathDelim: `.` }) => {
    let error = Object.create(proto$1)
    return error._op = OP_INVALID_DATA,
      error.path = path$1,
      error.message = message,
      Object.defineProperty(error, `toString`, {
        enumerable: !1,
        value() {
          let path$2 = pipe(this.path, join$6(options$2.pathDelim))
          return `(Invalid data at ${path$2}: "${this.message}")`
        },
      }),
      error
  },
  MissingData = (path$1, message, options$2 = { pathDelim: `.` }) => {
    let error = Object.create(proto$1)
    return error._op = OP_MISSING_DATA,
      error.path = path$1,
      error.message = message,
      Object.defineProperty(error, `toString`, {
        enumerable: !1,
        value() {
          let path$2 = pipe(this.path, join$6(options$2.pathDelim))
          return `(Missing data at ${path$2}: "${this.message}")`
        },
      }),
      error
  },
  SourceUnavailable = (path$1, message, cause$2, options$2 = { pathDelim: `.` }) => {
    let error = Object.create(proto$1)
    return error._op = OP_SOURCE_UNAVAILABLE,
      error.path = path$1,
      error.message = message,
      error.cause = cause$2,
      Object.defineProperty(error, `toString`, {
        enumerable: !1,
        value() {
          let path$2 = pipe(this.path, join$6(options$2.pathDelim))
          return `(Source unavailable at ${path$2}: "${this.message}")`
        },
      }),
      error
  },
  Unsupported = (path$1, message, options$2 = { pathDelim: `.` }) => {
    let error = Object.create(proto$1)
    return error._op = OP_UNSUPPORTED,
      error.path = path$1,
      error.message = message,
      Object.defineProperty(error, `toString`, {
        enumerable: !1,
        value() {
          let path$2 = pipe(this.path, join$6(options$2.pathDelim))
          return `(Unsupported operation at ${path$2}: "${this.message}")`
        },
      }),
      error
  },
  prefixed = dual(2, (self$1, prefix$1) => {
    switch (self$1._op) {
      case OP_AND:
        return And(prefixed(self$1.left, prefix$1), prefixed(self$1.right, prefix$1))
      case OP_OR:
        return Or(prefixed(self$1.left, prefix$1), prefixed(self$1.right, prefix$1))
      case OP_INVALID_DATA:
        return InvalidData([...prefix$1, ...self$1.path], self$1.message)
      case OP_MISSING_DATA:
        return MissingData([...prefix$1, ...self$1.path], self$1.message)
      case OP_SOURCE_UNAVAILABLE:
        return SourceUnavailable([...prefix$1, ...self$1.path], self$1.message, self$1.cause)
      case OP_UNSUPPORTED:
        return Unsupported([...prefix$1, ...self$1.path], self$1.message)
    }
  }),
  empty$14 = { _tag: `Empty` },
  patch$4 = dual(2, (path$1, patch$12) => {
    let input = of$2(patch$12), output = path$1
    for (; isCons(input);) {
      let patch$13 = input.head
      switch (patch$13._tag) {
        case `Empty`:
          input = input.tail
          break
        case `AndThen`:
          input = cons(patch$13.first, cons(patch$13.second, input.tail))
          break
        case `MapName`:
          output = map$17(output, patch$13.f), input = input.tail
          break
        case `Nested`:
          output = prepend$2(output, patch$13.name), input = input.tail
          break
        case `Unnested`: {
          let containsName = pipe(head$4(output), contains$5(patch$13.name))
          if (containsName) output = tailNonEmpty$1(output), input = input.tail
          else return left(MissingData(output, `Expected ${patch$13.name} to be in path in ConfigProvider#unnested`))
          break
        }
      }
    }
    return right(output)
  }),
  OP_CONSTANT = `Constant`,
  OP_FAIL = `Fail`,
  OP_FALLBACK = `Fallback`,
  OP_DESCRIBED = `Described`,
  OP_LAZY = `Lazy`,
  OP_MAP_OR_FAIL = `MapOrFail`,
  OP_NESTED = `Nested`,
  OP_PRIMITIVE = `Primitive`,
  OP_SEQUENCE = `Sequence`,
  OP_HASHMAP = `HashMap`,
  OP_ZIP_WITH$1 = `ZipWith`,
  concat = (l$9, r$26) => [...l$9, ...r$26],
  ConfigProviderSymbolKey = `effect/ConfigProvider`,
  ConfigProviderTypeId = Symbol.for(ConfigProviderSymbolKey),
  configProviderTag = GenericTag(`effect/ConfigProvider`),
  FlatConfigProviderSymbolKey = `effect/ConfigProviderFlat`,
  FlatConfigProviderTypeId = Symbol.for(FlatConfigProviderSymbolKey),
  make$39 = options$2 => ({
    [ConfigProviderTypeId]: ConfigProviderTypeId,
    pipe() {
      return pipeArguments(this, arguments)
    },
    ...options$2,
  }),
  makeFlat = options$2 => ({
    [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
    patch: options$2.patch,
    load: (path$1, config, split = !0) => options$2.load(path$1, config, split),
    enumerateChildren: options$2.enumerateChildren,
  }),
  fromFlat = flat =>
    make$39({
      load: config =>
        flatMap$5(fromFlatLoop(flat, empty$35(), config, !1), chunk$2 =>
          match$11(head$4(chunk$2), {
            onNone: () => fail$9(MissingData(empty$35(), `Expected a single value having structure: ${config}`)),
            onSome: succeed$9,
          })),
      flattened: flat,
    }),
  fromEnv = options$2 => {
    let { pathDelim, seqDelim } = Object.assign({}, { pathDelim: `_`, seqDelim: `,` }, options$2),
      makePathString = path$1 => pipe(path$1, join$6(pathDelim)),
      unmakePathString = pathString => pathString.split(pathDelim),
      getEnv = () => (typeof process < `u` && `env` in process, {}),
      load = (path$1, primitive, split = !0) => {
        let pathString = makePathString(path$1),
          current = getEnv(),
          valueOpt = pathString in current ? some$4(current[pathString]) : none$7()
        return pipe(
          valueOpt,
          mapError$3(() => MissingData(path$1, `Expected ${pathString} to exist in the process context`)),
          flatMap$5(value$2 => parsePrimitive(value$2, path$1, primitive, seqDelim, split)),
        )
      },
      enumerateChildren = path$1 =>
        sync$3(() => {
          let current = getEnv(),
            keys$6 = Object.keys(current),
            keyPaths = keys$6.map(value$2 => unmakePathString(value$2.toUpperCase())),
            filteredKeyPaths = keyPaths.filter(keyPath => {
              for (let i$14 = 0; i$14 < path$1.length; i$14++) {
                let pathComponent = pipe(path$1, unsafeGet$5(i$14)), currentElement = keyPath[i$14]
                if (currentElement === void 0 || pathComponent !== currentElement) return !1
              }
              return !0
            }).flatMap(keyPath => keyPath.slice(path$1.length, path$1.length + 1))
          return fromIterable$6(filteredKeyPaths)
        })
    return fromFlat(makeFlat({ load, enumerateChildren, patch: empty$14 }))
  },
  extend$3 = (leftDef, rightDef, left$2, right$2) => {
    let leftPad = unfold$1(
        left$2.length,
        index$4 => index$4 >= right$2.length ? none$7() : some$4([leftDef(index$4), index$4 + 1]),
      ),
      rightPad = unfold$1(
        right$2.length,
        index$4 => index$4 >= left$2.length ? none$7() : some$4([rightDef(index$4), index$4 + 1]),
      ),
      leftExtension = concat(left$2, leftPad),
      rightExtension = concat(right$2, rightPad)
    return [leftExtension, rightExtension]
  },
  appendConfigPath = (path$1, config) => {
    let op = config
    if (op._tag === `Nested`) {
      let out = path$1.slice()
      for (; op._tag === `Nested`;) out.push(op.name), op = op.config
      return out
    }
    return path$1
  },
  fromFlatLoop = (flat, prefix$1, config, split) => {
    let op = config
    switch (op._tag) {
      case OP_CONSTANT:
        return succeed$9(of$4(op.value))
      case OP_DESCRIBED:
        return suspend$4(() => fromFlatLoop(flat, prefix$1, op.config, split))
      case OP_FAIL:
        return fail$9(MissingData(prefix$1, op.message))
      case OP_FALLBACK:
        return pipe(
          suspend$4(() => fromFlatLoop(flat, prefix$1, op.first, split)),
          catchAll$1(error1 =>
            op.condition(error1)
              ? pipe(fromFlatLoop(flat, prefix$1, op.second, split), catchAll$1(error2 => fail$9(Or(error1, error2))))
              : fail$9(error1)
          ),
        )
      case OP_LAZY:
        return suspend$4(() => fromFlatLoop(flat, prefix$1, op.config(), split))
      case OP_MAP_OR_FAIL:
        return suspend$4(() =>
          pipe(
            fromFlatLoop(flat, prefix$1, op.original, split),
            flatMap$5(forEachSequential(a$22 =>
              pipe(op.mapOrFail(a$22), mapError$3(prefixed(appendConfigPath(prefix$1, op.original))))
            )),
          )
        )
      case OP_NESTED:
        return suspend$4(() => fromFlatLoop(flat, concat(prefix$1, of$4(op.name)), op.config, split))
      case OP_PRIMITIVE:
        return pipe(
          patch$4(prefix$1, flat.patch),
          flatMap$5(prefix$2 =>
            pipe(
              flat.load(prefix$2, op, split),
              flatMap$5(values$6 => {
                if (values$6.length === 0) {
                  let name = pipe(last$2(prefix$2), getOrElse$5(() => `<n/a>`))
                  return fail$9(MissingData([], `Expected ${op.description} with name ${name}`))
                }
                return succeed$9(values$6)
              }),
            )
          ),
        )
      case OP_SEQUENCE:
        return pipe(
          patch$4(prefix$1, flat.patch),
          flatMap$5(patchedPrefix =>
            pipe(
              flat.enumerateChildren(patchedPrefix),
              flatMap$5(indicesFrom),
              flatMap$5(indices =>
                indices.length === 0
                  ? suspend$4(() => map$11(fromFlatLoop(flat, prefix$1, op.config, !0), of$4))
                  : pipe(
                    forEachSequential(
                      indices,
                      index$4 => fromFlatLoop(flat, append$2(prefix$1, `[${index$4}]`), op.config, !0),
                    ),
                    map$11(chunkChunk => {
                      let flattened = flatten$7(chunkChunk)
                      return flattened.length === 0 ? of$4(empty$35()) : of$4(flattened)
                    }),
                  )
              ),
            )
          ),
        )
      case OP_HASHMAP:
        return suspend$4(() =>
          pipe(
            patch$4(prefix$1, flat.patch),
            flatMap$5(prefix$2 =>
              pipe(
                flat.enumerateChildren(prefix$2),
                flatMap$5(keys$6 =>
                  pipe(
                    keys$6,
                    forEachSequential(key$1 =>
                      fromFlatLoop(flat, concat(prefix$2, of$4(key$1)), op.valueConfig, split)
                    ),
                    map$11(matrix =>
                      matrix.length === 0
                        ? of$4(empty$28())
                        : pipe(
                          transpose(matrix),
                          map$17(values$6 => fromIterable$5(zip$6(fromIterable$10(keys$6), values$6))),
                        )
                    ),
                  )
                ),
              )
            ),
          )
        )
      case OP_ZIP_WITH$1:
        return suspend$4(() =>
          pipe(
            fromFlatLoop(flat, prefix$1, op.left, split),
            either$3,
            flatMap$5(left$2 =>
              pipe(
                fromFlatLoop(flat, prefix$1, op.right, split),
                either$3,
                flatMap$5(right$2 => {
                  if (isLeft(left$2) && isLeft(right$2)) return fail$9(And(left$2.left, right$2.left))
                  if (isLeft(left$2) && isRight(right$2)) return fail$9(left$2.left)
                  if (isRight(left$2) && isLeft(right$2)) return fail$9(right$2.left)
                  if (isRight(left$2) && isRight(right$2)) {
                    let path$1 = pipe(prefix$1, join$6(`.`)),
                      fail$11 = fromFlatLoopFail(prefix$1, path$1),
                      [lefts, rights] = extend$3(
                        fail$11,
                        fail$11,
                        pipe(left$2.right, map$17(right)),
                        pipe(right$2.right, map$17(right)),
                      )
                    return pipe(
                      lefts,
                      zip$6(rights),
                      forEachSequential(([left$3, right$3]) =>
                        pipe(zip$4(left$3, right$3), map$11(([left$4, right$4]) => op.zip(left$4, right$4)))
                      ),
                    )
                  }
                  throw Error(
                    `BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues`,
                  )
                }),
              )
            ),
          )
        )
    }
  },
  fromFlatLoopFail = (prefix$1, path$1) => index$4 =>
    left(MissingData(prefix$1, `The element at index ${index$4} in a sequence at path "${path$1}" was missing`)),
  splitPathString = (text$6, delim) => {
    let split = text$6.split(RegExp(`\\s*${escape(delim)}\\s*`))
    return split
  },
  parsePrimitive = (text$6, path$1, primitive, delimiter, split) =>
    split
      ? pipe(
        splitPathString(text$6, delimiter),
        forEachSequential(char => primitive.parse(char.trim())),
        mapError$3(prefixed(path$1)),
      )
      : pipe(primitive.parse(text$6), mapBoth$3({ onFailure: prefixed(path$1), onSuccess: of$4 })),
  transpose = array$3 => Object.keys(array$3[0]).map(column => array$3.map(row => row[column])),
  indicesFrom = quotedIndices =>
    pipe(
      forEachSequential(quotedIndices, parseQuotedIndex),
      mapBoth$3({ onFailure: () => empty$35(), onSuccess: sort(Order$4) }),
      either$3,
      map$11(merge$8),
    ),
  QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/,
  parseQuotedIndex = str => {
    let match$13 = str.match(QUOTED_INDEX_REGEX)
    if (match$13 !== null) {
      let matchedIndex = match$13[2]
      return pipe(
        matchedIndex !== void 0 && matchedIndex.length > 0 ? some$4(matchedIndex) : none$7(),
        flatMap$12(parseInteger),
      )
    }
    return none$7()
  },
  parseInteger = str => {
    let parsedIndex = Number.parseInt(str)
    return Number.isNaN(parsedIndex) ? none$7() : some$4(parsedIndex)
  },
  TypeId$8 = Symbol.for(`effect/Console`),
  consoleTag = GenericTag(`effect/Console`),
  defaultConsole = {
    [TypeId$8]: TypeId$8,
    assert(condition, ...args$1) {
      return sync$3(() => {
        console.assert(condition, ...args$1)
      })
    },
    clear: sync$3(() => {
      console.clear()
    }),
    count(label) {
      return sync$3(() => {
        console.count(label)
      })
    },
    countReset(label) {
      return sync$3(() => {
        console.countReset(label)
      })
    },
    debug(...args$1) {
      return sync$3(() => {
        console.debug(...args$1)
      })
    },
    dir(item, options$2) {
      return sync$3(() => {
        console.dir(item, options$2)
      })
    },
    dirxml(...args$1) {
      return sync$3(() => {
        console.dirxml(...args$1)
      })
    },
    error(...args$1) {
      return sync$3(() => {
        console.error(...args$1)
      })
    },
    group(options$2) {
      return options$2?.collapsed
        ? sync$3(() => console.groupCollapsed(options$2?.label))
        : sync$3(() => console.group(options$2?.label))
    },
    groupEnd: sync$3(() => {
      console.groupEnd()
    }),
    info(...args$1) {
      return sync$3(() => {
        console.info(...args$1)
      })
    },
    log(...args$1) {
      return sync$3(() => {
        console.log(...args$1)
      })
    },
    table(tabularData, properties) {
      return sync$3(() => {
        console.table(tabularData, properties)
      })
    },
    time(label) {
      return sync$3(() => console.time(label))
    },
    timeEnd(label) {
      return sync$3(() => console.timeEnd(label))
    },
    timeLog(label, ...args$1) {
      return sync$3(() => {
        console.timeLog(label, ...args$1)
      })
    },
    trace(...args$1) {
      return sync$3(() => {
        console.trace(...args$1)
      })
    },
    warn(...args$1) {
      return sync$3(() => {
        console.warn(...args$1)
      })
    },
    unsafe: console,
  },
  RandomSymbolKey = `effect/Random`,
  RandomTypeId = Symbol.for(RandomSymbolKey),
  randomTag = GenericTag(`effect/Random`)
var RandomImpl = class {
  seed;
  [RandomTypeId] = RandomTypeId
  PRNG
  constructor(seed) {
    this.seed = seed, this.PRNG = new PCGRandom(seed)
  }
  get next() {
    return sync$3(() => this.PRNG.number())
  }
  get nextBoolean() {
    return map$11(this.next, n$19 => n$19 > .5)
  }
  get nextInt() {
    return sync$3(() => this.PRNG.integer(2 ** 53 - 1))
  }
  nextRange(min$10, max$12) {
    return map$11(this.next, n$19 => (max$12 - min$10) * n$19 + min$10)
  }
  nextIntBetween(min$10, max$12) {
    return sync$3(() => this.PRNG.integer(max$12 - min$10) + min$10)
  }
  shuffle(elements) {
    return shuffleWith(elements, n$19 => this.nextIntBetween(0, n$19))
  }
}
const shuffleWith = (elements, nextIntBounded) =>
    suspend$4(() =>
      pipe(
        sync$3(() => Array.from(elements)),
        flatMap$5(buffer => {
          let numbers = []
          for (let i$14 = buffer.length; i$14 >= 2; --i$14) numbers.push(i$14)
          return pipe(
            numbers,
            forEachSequentialDiscard(n$19 => pipe(nextIntBounded(n$19), map$11(k$1 => swap$1(buffer, n$19 - 1, k$1)))),
            as$4(fromIterable$9(buffer)),
          )
        }),
      )
    ),
  swap$1 = (buffer, index1, index2) => {
    let tmp = buffer[index1]
    return buffer[index1] = buffer[index2], buffer[index2] = tmp, buffer
  },
  make$38 = seed => new RandomImpl(hash(seed))
var FixedRandomImpl = class {
  values;
  [RandomTypeId] = RandomTypeId
  index = 0
  constructor(values$6) {
    if (this.values = values$6, values$6.length === 0) throw Error(`Requires at least one value`)
  }
  getNextValue() {
    let value$2 = this.values[this.index]
    return this.index = (this.index + 1) % this.values.length, value$2
  }
  get next() {
    return sync$3(() => {
      let value$2 = this.getNextValue()
      return typeof value$2 == `number` ? Math.max(0, Math.min(1, value$2)) : hash(value$2) / 2147483647
    })
  }
  get nextBoolean() {
    return sync$3(() => {
      let value$2 = this.getNextValue()
      return typeof value$2 == `boolean` ? value$2 : hash(value$2) % 2 == 0
    })
  }
  get nextInt() {
    return sync$3(() => {
      let value$2 = this.getNextValue()
      return typeof value$2 == `number` && Number.isFinite(value$2) ? Math.round(value$2) : Math.abs(hash(value$2))
    })
  }
  nextRange(min$10, max$12) {
    return map$11(this.next, n$19 => (max$12 - min$10) * n$19 + min$10)
  }
  nextIntBetween(min$10, max$12) {
    return sync$3(() => {
      let value$2 = this.getNextValue()
      if (typeof value$2 == `number` && Number.isFinite(value$2)) {
        return Math.max(min$10, Math.min(max$12 - 1, Math.round(value$2)))
      }
      let hash$1 = Math.abs(hash(value$2))
      return min$10 + hash$1 % (max$12 - min$10)
    })
  }
  shuffle(elements) {
    return shuffleWith(elements, n$19 => this.nextIntBetween(0, n$19))
  }
}
const TracerTypeId$1 = Symbol.for(`effect/Tracer`),
  make$37 = options$2 => ({ [TracerTypeId$1]: TracerTypeId$1, ...options$2 }),
  tracerTag = GenericTag(`effect/Tracer`),
  spanTag = GenericTag(`effect/ParentSpan`),
  randomHexString = function() {
    let characters$1 = `abcdef0123456789`, charactersLength = 16
    return function(length$1) {
      let result = ``
      for (let i$14 = 0; i$14 < length$1; i$14++) {
        result += characters$1.charAt(Math.floor(Math.random() * charactersLength))
      }
      return result
    }
  }()
var NativeSpan = class {
  name
  parent
  context
  startTime
  kind
  _tag = `Span`
  spanId
  traceId = `native`
  sampled = !0
  status
  attributes
  events = []
  links
  constructor(name, parent, context$2, links, startTime$1, kind) {
    this.name = name,
      this.parent = parent,
      this.context = context$2,
      this.startTime = startTime$1,
      this.kind = kind,
      this.status = { _tag: `Started`, startTime: startTime$1 },
      this.attributes = new Map(),
      this.traceId = parent._tag === `Some` ? parent.value.traceId : randomHexString(32),
      this.spanId = randomHexString(16),
      this.links = Array.from(links)
  }
  end(endTime, exit$5) {
    this.status = { _tag: `Ended`, endTime, exit: exit$5, startTime: this.status.startTime }
  }
  attribute(key$1, value$2) {
    this.attributes.set(key$1, value$2)
  }
  event(name, startTime$1, attributes) {
    this.events.push([name, startTime$1, attributes ?? {}])
  }
  addLinks(links) {
    this.links.push(...links)
  }
}
const nativeTracer = make$37({
    span: (name, parent, context$2, links, startTime$1, kind) =>
      new NativeSpan(name, parent, context$2, links, startTime$1, kind),
    context: f$14 => f$14(),
  }),
  externalSpan$1 = options$2 => ({
    _tag: `ExternalSpan`,
    spanId: options$2.spanId,
    traceId: options$2.traceId,
    sampled: options$2.sampled ?? !0,
    context: options$2.context ?? empty$33(),
  }),
  addSpanStackTrace = options$2 => {
    if (
      options$2?.captureStackTrace === !1
      || options$2?.captureStackTrace !== void 0 && typeof options$2.captureStackTrace != `boolean`
    ) return options$2
    let limit = Error.stackTraceLimit
    Error.stackTraceLimit = 3
    let traceError = Error()
    Error.stackTraceLimit = limit
    let cache = !1
    return {
      ...options$2,
      captureStackTrace: () => {
        if (cache !== !1) return cache
        if (traceError.stack !== void 0) {
          let stack = traceError.stack.split(`
`)
          if (stack[3] !== void 0) return cache = stack[3].trim(), cache
        }
      },
    }
  },
  DisablePropagation$1 = Reference()(`effect/Tracer/DisablePropagation`, { defaultValue: constFalse }),
  liveServices = pipe(
    empty$33(),
    add$3(clockTag, make$40()),
    add$3(consoleTag, defaultConsole),
    add$3(randomTag, make$38(Math.random())),
    add$3(configProviderTag, fromEnv()),
    add$3(tracerTag, nativeTracer),
  ),
  currentServices = globalValue(
    Symbol.for(`effect/DefaultServices/currentServices`),
    () => fiberRefUnsafeMakeContext(liveServices),
  ),
  sleep$3 = duration => {
    let decodedDuration = decode$30(duration)
    return clockWith$3(clock$2 => clock$2.sleep(decodedDuration))
  },
  defaultServicesWith = f$14 => withFiberRuntime$1(fiber => f$14(fiber.currentDefaultServices)),
  clockWith$3 = f$14 => defaultServicesWith(services => f$14(services.unsafeMap.get(clockTag.key))),
  currentTimeMillis$1 = clockWith$3(clock$2 => clock$2.currentTimeMillis),
  currentTimeNanos$1 = clockWith$3(clock$2 => clock$2.currentTimeNanos),
  withClock$1 = dual(2, (effect, c$3) => fiberRefLocallyWith(currentServices, add$3(clockTag, c$3))(effect)),
  withConfigProvider$1 = dual(
    2,
    (self$1, provider) => fiberRefLocallyWith(currentServices, add$3(configProviderTag, provider))(self$1),
  ),
  configProviderWith$1 = f$14 => defaultServicesWith(services => f$14(services.unsafeMap.get(configProviderTag.key))),
  randomWith$1 = f$14 => defaultServicesWith(services => f$14(services.unsafeMap.get(randomTag.key))),
  withRandom$1 = dual(2, (effect, value$2) => fiberRefLocallyWith(currentServices, add$3(randomTag, value$2))(effect)),
  tracerWith$3 = f$14 => defaultServicesWith(services => f$14(services.unsafeMap.get(tracerTag.key))),
  withTracer$1 = dual(2, (effect, value$2) => fiberRefLocallyWith(currentServices, add$3(tracerTag, value$2))(effect)),
  ClockTypeId = ClockTypeId$1,
  make$36 = make$40,
  sleep$2 = sleep$3,
  currentTimeMillis = currentTimeMillis$1,
  currentTimeNanos = currentTimeNanos$1,
  clockWith$2 = clockWith$3,
  Clock = clockTag
function unsafeMake$5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals)
}
function empty$13() {
  return unsafeMake$5(new Map())
}
const FiberRefsSym$1 = Symbol.for(`effect/FiberRefs`)
var FiberRefsImpl = class {
  locals;
  [FiberRefsSym$1] = FiberRefsSym$1
  constructor(locals) {
    this.locals = locals
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const findAncestor = (_ref, _parentStack, _childStack, _childModified = !1) => {
    let ref = _ref, parentStack = _parentStack, childStack = _childStack, childModified = _childModified, ret
    for (; ret === void 0;) {
      if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
        let parentFiberId = headNonEmpty$1(parentStack)[0],
          parentAncestors = tailNonEmpty$1(parentStack),
          childFiberId = headNonEmpty$1(childStack)[0],
          childRefValue = headNonEmpty$1(childStack)[1],
          childAncestors = tailNonEmpty$1(childStack)
        parentFiberId.startTimeMillis < childFiberId.startTimeMillis
          ? (childStack = childAncestors, childModified = !0)
          : parentFiberId.startTimeMillis > childFiberId.startTimeMillis
          ? parentStack = parentAncestors
          : parentFiberId.id < childFiberId.id
          ? (childStack = childAncestors, childModified = !0)
          : parentFiberId.id > childFiberId.id
          ? parentStack = parentAncestors
          : ret = [childRefValue, childModified]
      } else ret = [ref.initial, !0]
    }
    return ret
  },
  joinAs$1 = dual(3, (self$1, fiberId$2, that) => {
    let parentFiberRefs = new Map(self$1.locals)
    return that.locals.forEach((childStack, fiberRef) => {
      let childValue = childStack[0][1]
      if (!childStack[0][0][symbol$1](fiberId$2)) {
        if (!parentFiberRefs.has(fiberRef)) {
          if (equals(childValue, fiberRef.initial)) return
          parentFiberRefs.set(fiberRef, [[fiberId$2, fiberRef.join(fiberRef.initial, childValue)]])
          return
        }
        let parentStack = parentFiberRefs.get(fiberRef),
          [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack)
        if (wasModified) {
          let patch$12 = fiberRef.diff(ancestor, childValue),
            oldValue = parentStack[0][1],
            newValue = fiberRef.join(oldValue, fiberRef.patch(patch$12)(oldValue))
          if (!equals(oldValue, newValue)) {
            let newStack, parentFiberId = parentStack[0][0]
            newStack = parentFiberId[symbol$1](fiberId$2)
              ? [[parentFiberId, newValue], ...parentStack.slice(1)]
              : [[fiberId$2, newValue], ...parentStack], parentFiberRefs.set(fiberRef, newStack)
          }
        }
      }
    }),
      new FiberRefsImpl(parentFiberRefs)
  }),
  forkAs$1 = dual(2, (self$1, childId) => {
    let map$20 = new Map()
    return unsafeForkAs(self$1, map$20, childId), new FiberRefsImpl(map$20)
  }),
  unsafeForkAs = (self$1, map$20, fiberId$2) => {
    self$1.locals.forEach((stack, fiberRef) => {
      let oldValue = stack[0][1], newValue = fiberRef.patch(fiberRef.fork)(oldValue)
      equals(oldValue, newValue) ? map$20.set(fiberRef, stack) : map$20.set(fiberRef, [[fiberId$2, newValue], ...stack])
    })
  },
  fiberRefs$2 = self$1 => fromIterable$6(self$1.locals.keys()),
  setAll$1 = self$1 =>
    forEachSequentialDiscard(fiberRefs$2(self$1), fiberRef => fiberRefSet(fiberRef, getOrDefault$1(self$1, fiberRef))),
  delete_$1 = dual(2, (self$1, fiberRef) => {
    let locals = new Map(self$1.locals)
    return locals.delete(fiberRef), new FiberRefsImpl(locals)
  }),
  get$3 = dual(
    2,
    (self$1, fiberRef) =>
      self$1.locals.has(fiberRef) ? some$4(headNonEmpty$1(self$1.locals.get(fiberRef))[1]) : none$7(),
  ),
  getOrDefault$1 = dual(2, (self$1, fiberRef) => pipe(get$3(self$1, fiberRef), getOrElse$5(() => fiberRef.initial))),
  updateAs$1 = dual(2, (self$1, { fiberId: fiberId$2, fiberRef, value: value$2 }) => {
    if (self$1.locals.size === 0) return new FiberRefsImpl(new Map([[fiberRef, [[fiberId$2, value$2]]]]))
    let locals = new Map(self$1.locals)
    return unsafeUpdateAs(locals, fiberId$2, fiberRef, value$2), new FiberRefsImpl(locals)
  }),
  unsafeUpdateAs = (locals, fiberId$2, fiberRef, value$2) => {
    let oldStack = locals.get(fiberRef) ?? [], newStack
    if (isNonEmptyReadonlyArray(oldStack)) {
      let [currentId, currentValue] = headNonEmpty$1(oldStack)
      if (currentId[symbol$1](fiberId$2)) {
        if (equals(currentValue, value$2)) return
        newStack = [[fiberId$2, value$2], ...oldStack.slice(1)]
      } else newStack = [[fiberId$2, value$2], ...oldStack]
    } else newStack = [[fiberId$2, value$2]]
    locals.set(fiberRef, newStack)
  },
  updateManyAs$1 = dual(2, (self$1, { entries: entries$2, forkAs: forkAs$2 }) => {
    if (self$1.locals.size === 0) return new FiberRefsImpl(new Map(entries$2))
    let locals = new Map(self$1.locals)
    return forkAs$2 !== void 0 && unsafeForkAs(self$1, locals, forkAs$2),
      entries$2.forEach(([fiberRef, values$6]) => {
        values$6.length === 1
          ? unsafeUpdateAs(locals, values$6[0][0], fiberRef, values$6[0][1])
          : values$6.forEach(([fiberId$2, value$2]) => {
            unsafeUpdateAs(locals, fiberId$2, fiberRef, value$2)
          })
      }),
      new FiberRefsImpl(locals)
  }),
  FiberRefsSym = FiberRefsSym$1,
  delete_ = delete_$1,
  fiberRefs$1 = fiberRefs$2,
  forkAs = forkAs$1,
  get$2 = get$3,
  getOrDefault = getOrDefault$1,
  joinAs = joinAs$1,
  setAll = setAll$1,
  updateAs = updateAs$1,
  updateManyAs = updateManyAs$1,
  unsafeMake$4 = unsafeMake$5,
  empty$12 = empty$13,
  All = logLevelAll,
  Fatal = logLevelFatal,
  Error$2 = logLevelError,
  Warning = logLevelWarning,
  Info$1 = logLevelInfo,
  Debug = logLevelDebug,
  Trace = logLevelTrace,
  None = logLevelNone,
  allLevels = allLogLevels,
  Order$2 = pipe(Order$4, mapInput(level => level.ordinal)),
  greaterThan$8 = greaterThan$9(Order$2),
  fromLiteral = literal => {
    switch (literal) {
      case `All`:
        return All
      case `Debug`:
        return Debug
      case `Error`:
        return Error$2
      case `Fatal`:
        return Fatal
      case `Info`:
        return Info$1
      case `Trace`:
        return Trace
      case `None`:
        return None
      case `Warning`:
        return Warning
    }
  },
  make$35 = (label, startTime$1) => ({ label, startTime: startTime$1 }),
  formatLabel = key$1 => key$1.replace(/[\s="]/g, `_`),
  render$1 = now$1 => self$1 => {
    let label = formatLabel(self$1.label)
    return `${label}=${now$1 - self$1.startTime}ms`
  },
  make$34 = make$35,
  render = render$1,
  EffectTypeId$1 = EffectTypeId$3,
  StreamTypeId = StreamTypeId$1,
  SinkTypeId = SinkTypeId$1,
  ChannelTypeId = ChannelTypeId$1,
  EffectPrototype = EffectPrototype$1,
  CommitPrototype = CommitPrototype$1,
  StructuralCommitPrototype = StructuralCommitPrototype$1,
  Base = Base$1,
  StructuralBase = StructuralBase$1
var Class$4 = class extends Base {}
const TypeId$7 = Symbol.for(`effect/Readable`),
  Proto = {
    [TypeId$7]: TypeId$7,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  RefTypeId$1 = Symbol.for(`effect/Ref`),
  refVariance = { _A: _$1 => _$1 }
var RefImpl = class extends Class$4 {
  ref
  commit() {
    return this.get
  }
  [RefTypeId$1] = refVariance;
  [TypeId$7] = TypeId$7
  constructor(ref) {
    super(), this.ref = ref, this.get = sync$3(() => get$6(this.ref))
  }
  get modify(f$14) {
    return sync$3(() => {
      let current = get$6(this.ref), [b$3, a$22] = f$14(current)
      return current !== a$22 && set$4(a$22)(this.ref), b$3
    })
  }
}
const unsafeMake$3 = value$2 => new RefImpl(make$50(value$2)),
  make$33 = value$2 => sync$3(() => unsafeMake$3(value$2)),
  get$1 = self$1 => self$1.get,
  set$1 = dual(2, (self$1, value$2) => self$1.modify(() => [void 0, value$2])),
  getAndSet$1 = dual(2, (self$1, value$2) => self$1.modify(a$22 => [a$22, value$2])),
  getAndUpdate$1 = dual(2, (self$1, f$14) => self$1.modify(a$22 => [a$22, f$14(a$22)])),
  getAndUpdateSome$1 = dual(2, (self$1, pf) =>
    self$1.modify(value$2 => {
      let option$5 = pf(value$2)
      switch (option$5._tag) {
        case `None`:
          return [value$2, value$2]
        case `Some`:
          return [value$2, option$5.value]
      }
    })),
  setAndGet$1 = dual(2, (self$1, value$2) => self$1.modify(() => [value$2, value$2])),
  modify$1 = dual(2, (self$1, f$14) => self$1.modify(f$14)),
  modifySome$1 = dual(3, (self$1, fallback, pf) =>
    self$1.modify(value$2 => {
      let option$5 = pf(value$2)
      switch (option$5._tag) {
        case `None`:
          return [fallback, value$2]
        case `Some`:
          return option$5.value
      }
    })),
  update$3 = dual(2, (self$1, f$14) => self$1.modify(a$22 => [void 0, f$14(a$22)])),
  updateAndGet$1 = dual(2, (self$1, f$14) =>
    self$1.modify(a$22 => {
      let result = f$14(a$22)
      return [result, result]
    })),
  updateSome$1 = dual(
    2,
    (self$1, f$14) => self$1.modify(a$22 => [void 0, match$11(f$14(a$22), { onNone: () => a$22, onSome: b$3 => b$3 })]),
  ),
  updateSomeAndGet$1 = dual(2, (self$1, pf) =>
    self$1.modify(value$2 => {
      let option$5 = pf(value$2)
      switch (option$5._tag) {
        case `None`:
          return [value$2, value$2]
        case `Some`:
          return [option$5.value, option$5.value]
      }
    })),
  RefTypeId = RefTypeId$1,
  make$32 = make$33,
  get = get$1,
  getAndSet = getAndSet$1,
  getAndUpdate = getAndUpdate$1,
  getAndUpdateSome = getAndUpdateSome$1,
  modify = modify$1,
  modifySome = modifySome$1,
  set = set$1,
  setAndGet = setAndGet$1,
  update$2 = update$3,
  updateAndGet = updateAndGet$1,
  updateSome = updateSome$1,
  updateSomeAndGet = updateSomeAndGet$1,
  unsafeMake$2 = unsafeMake$3,
  TracerTypeId = TracerTypeId$1,
  ParentSpan = spanTag,
  Tracer = tracerTag,
  make$31 = make$37,
  externalSpan = externalSpan$1,
  tracerWith$2 = tracerWith$3,
  DisablePropagation = DisablePropagation$1,
  OP_EMPTY$1 = `Empty`,
  OP_ADD = `Add`,
  OP_REMOVE = `Remove`,
  OP_UPDATE = `Update`,
  OP_AND_THEN$1 = `AndThen`,
  empty$11 = { _tag: OP_EMPTY$1 },
  diff$2 = (oldValue, newValue) => {
    let missingLocals = new Map(oldValue.locals), patch$12 = empty$11
    for (let [fiberRef, pairs] of newValue.locals.entries()) {
      let newValue$1 = headNonEmpty$1(pairs)[1], old = missingLocals.get(fiberRef)
      if (old !== void 0) {
        let oldValue$1 = headNonEmpty$1(old)[1]
        equals(oldValue$1, newValue$1)
          || (patch$12 = combine$2({ _tag: OP_UPDATE, fiberRef, patch: fiberRef.diff(oldValue$1, newValue$1) })(
            patch$12,
          ))
      } else patch$12 = combine$2({ _tag: OP_ADD, fiberRef, value: newValue$1 })(patch$12)
      missingLocals.delete(fiberRef)
    }
    for (let [fiberRef] of missingLocals.entries()) patch$12 = combine$2({ _tag: OP_REMOVE, fiberRef })(patch$12)
    return patch$12
  },
  combine$2 = dual(2, (self$1, that) => ({ _tag: OP_AND_THEN$1, first: self$1, second: that })),
  patch$3 = dual(3, (self$1, fiberId$2, oldValue) => {
    let fiberRefs$3 = oldValue, patches = of$4(self$1)
    for (; isNonEmptyReadonlyArray(patches);) {
      let head$5 = headNonEmpty$1(patches), tail = tailNonEmpty$1(patches)
      switch (head$5._tag) {
        case OP_EMPTY$1:
          patches = tail
          break
        case OP_ADD:
          fiberRefs$3 = updateAs$1(fiberRefs$3, { fiberId: fiberId$2, fiberRef: head$5.fiberRef, value: head$5.value }),
            patches = tail
          break
        case OP_REMOVE:
          fiberRefs$3 = delete_$1(fiberRefs$3, head$5.fiberRef), patches = tail
          break
        case OP_UPDATE: {
          let value$2 = getOrDefault$1(fiberRefs$3, head$5.fiberRef)
          fiberRefs$3 = updateAs$1(fiberRefs$3, {
            fiberId: fiberId$2,
            fiberRef: head$5.fiberRef,
            value: head$5.fiberRef.patch(head$5.patch)(value$2),
          }), patches = tail
          break
        }
        case OP_AND_THEN$1:
          patches = prepend$2(head$5.first)(prepend$2(head$5.second)(tail))
          break
      }
    }
    return fiberRefs$3
  }),
  MetricLabelSymbolKey = `effect/MetricLabel`,
  MetricLabelTypeId = Symbol.for(MetricLabelSymbolKey)
var MetricLabelImpl = class {
  key
  value;
  [MetricLabelTypeId] = MetricLabelTypeId
  _hash
  constructor(key$1, value$2) {
    this.key = key$1, this.value = value$2, this._hash = string$4(MetricLabelSymbolKey + this.key + this.value)
  }
  [symbol$2]() {
    return this._hash
  }
  [symbol$1](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const make$30 = (key$1, value$2) => new MetricLabelImpl(key$1, value$2),
  isMetricLabel = u$7 => hasProperty(u$7, MetricLabelTypeId),
  annotateLogs$1 = dual(args$1 => isEffect$1(args$1[0]), function() {
    let args$1 = arguments
    return fiberRefLocallyWith(
      args$1[0],
      currentLogAnnotations,
      typeof args$1[1] == `string`
        ? set$3(args$1[1], args$1[2])
        : annotations$2 =>
          Object.entries(args$1[1]).reduce((acc, [key$1, value$2]) => set$3(acc, key$1, value$2), annotations$2),
    )
  }),
  asSome$1 = self$1 => map$11(self$1, some$4),
  asSomeError$1 = self$1 => mapError$3(self$1, some$4),
  try_$1 = arg => {
    let evaluate$2, onFailure
    return typeof arg == `function` ? evaluate$2 = arg : (evaluate$2 = arg.try, onFailure = arg.catch),
      suspend$4(() => {
        try {
          return succeed$9(internalCall(evaluate$2))
        } catch (error) {
          return fail$9(
            onFailure
              ? internalCall(() => onFailure(error))
              : new UnknownException$1(error, `An unknown error occurred in Effect.try`),
          )
        }
      })
  },
  _catch$1 = dual(
    3,
    (self$1, tag$3, options$2) =>
      catchAll$1(
        self$1,
        e$26 =>
          hasProperty(e$26, tag$3) && e$26[tag$3] === options$2.failure ? options$2.onFailure(e$26) : fail$9(e$26),
      ),
  ),
  catchAllDefect$1 = dual(2, (self$1, f$14) =>
    catchAllCause$1(self$1, cause$2 => {
      let option$5 = find$2(cause$2, _$1 => isDieType$1(_$1) ? some$4(_$1) : none$7())
      switch (option$5._tag) {
        case `None`:
          return failCause$8(cause$2)
        case `Some`:
          return f$14(option$5.value.defect)
      }
    })),
  catchSomeCause$1 = dual(2, (self$1, f$14) =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 => {
        let option$5 = f$14(cause$2)
        switch (option$5._tag) {
          case `None`:
            return failCause$8(cause$2)
          case `Some`:
            return option$5.value
        }
      },
      onSuccess: succeed$9,
    })),
  catchSomeDefect$1 = dual(2, (self$1, pf) =>
    catchAllCause$1(self$1, cause$2 => {
      let option$5 = find$2(cause$2, _$1 => isDieType$1(_$1) ? some$4(_$1) : none$7())
      switch (option$5._tag) {
        case `None`:
          return failCause$8(cause$2)
        case `Some`: {
          let optionEffect = pf(option$5.value.defect)
          return optionEffect._tag === `Some` ? optionEffect.value : failCause$8(cause$2)
        }
      }
    })),
  catchTag$1 = dual(args$1 => isEffect$1(args$1[0]), (self$1, ...args$1) => {
    let f$14 = args$1[args$1.length - 1], predicate
    return predicate = args$1.length === 2 ? isTagged(args$1[0]) : e$26 => {
      let tag$3 = hasProperty(e$26, `_tag`) ? e$26._tag : void 0
      if (!tag$3) return !1
      for (let i$14 = 0; i$14 < args$1.length - 1; i$14++) if (args$1[i$14] === tag$3) return !0
      return !1
    },
      catchIf$1(self$1, predicate, f$14)
  }),
  catchTags$1 = dual(2, (self$1, cases) => {
    let keys$6
    return catchIf$1(
      self$1,
      e$26 => (keys$6 ??= Object.keys(cases),
        hasProperty(e$26, `_tag`) && isString$1(e$26._tag) && keys$6.includes(e$26._tag)),
      e$26 => cases[e$26._tag](e$26),
    )
  }),
  cause$1 = self$1 => matchCause$2(self$1, { onFailure: identity, onSuccess: () => empty$17 }),
  clockWith$1 = clockWith$2,
  clock$1 = clockWith$1(succeed$9),
  delay$1 = dual(2, (self$1, duration) => zipRight$3(sleep$2(duration), self$1)),
  descriptorWith$1 = f$14 =>
    withFiberRuntime$1((state, status$2) =>
      f$14({
        id: state.id(),
        status: status$2,
        interruptors: interruptors$1(state.getFiberRef(currentInterruptedCause)),
      })
    ),
  allowInterrupt$1 = descriptorWith$1(descriptor$2 => size$11(descriptor$2.interruptors) > 0 ? interrupt$5 : void_$4),
  descriptor$1 = descriptorWith$1(succeed$9),
  diffFiberRefs$1 = self$1 => summarized$1(self$1, fiberRefs, diff$2),
  diffFiberRefsAndRuntimeFlags = self$1 =>
    summarized$1(
      self$1,
      zip$4(fiberRefs, runtimeFlags),
      ([refs, flags], [refsNew, flagsNew]) => [diff$2(refs, refsNew), diff$3(flags, flagsNew)],
    ),
  Do$1 = succeed$9({}),
  bind$1 = bind$2(map$11, flatMap$5),
  bindTo$1 = bindTo$2(map$11),
  let_$1 = let_$2(map$11),
  dropUntil$1 = dual(2, (elements, predicate) =>
    suspend$4(() => {
      let iterator = elements[Symbol.iterator](), builder = [], next, dropping = succeed$9(!1), i$14 = 0
      for (; (next = iterator.next()) && !next.done;) {
        let a$22 = next.value, index$4 = i$14++
        dropping = flatMap$5(dropping, bool => bool ? (builder.push(a$22), succeed$9(!0)) : predicate(a$22, index$4))
      }
      return map$11(dropping, () => builder)
    })),
  dropWhile$1 = dual(2, (elements, predicate) =>
    suspend$4(() => {
      let iterator = elements[Symbol.iterator](), builder = [], next, dropping = succeed$9(!0), i$14 = 0
      for (; (next = iterator.next()) && !next.done;) {
        let a$22 = next.value, index$4 = i$14++
        dropping = flatMap$5(dropping, d$7 =>
          map$11(d$7 ? predicate(a$22, index$4) : succeed$9(!1), b$3 => (b$3 || builder.push(a$22), b$3)))
      }
      return map$11(dropping, () =>
        builder)
    })),
  contextWith$1 = f$14 => map$11(context$1(), f$14),
  eventually$1 = self$1 => orElse$6(self$1, () => flatMap$5(yieldNow$3(), () => eventually$1(self$1))),
  filterMap$1 = dual(2, (elements, pf) => map$11(forEachSequential(elements, identity), filterMap$4(pf))),
  filterOrDie$1 = dual(
    3,
    (self$1, predicate, orDieWith$2) => filterOrElse$1(self$1, predicate, a$22 => dieSync$2(() => orDieWith$2(a$22))),
  ),
  filterOrDieMessage$1 = dual(
    3,
    (self$1, predicate, message) => filterOrElse$1(self$1, predicate, () => dieMessage$1(message)),
  ),
  filterOrElse$1 = dual(
    3,
    (self$1, predicate, orElse$8) => flatMap$5(self$1, a$22 => predicate(a$22) ? succeed$9(a$22) : orElse$8(a$22)),
  ),
  liftPredicate$1 = dual(
    3,
    (self$1, predicate, orFailWith) =>
      suspend$4(() => predicate(self$1) ? succeed$9(self$1) : fail$9(orFailWith(self$1))),
  ),
  filterOrFail$1 = dual(
    args$1 => isEffect$1(args$1[0]),
    (self$1, predicate, orFailWith) =>
      filterOrElse$1(
        self$1,
        predicate,
        a$22 => orFailWith === void 0 ? fail$9(new NoSuchElementException$1()) : failSync$2(() => orFailWith(a$22)),
      ),
  ),
  findFirst$3 = dual(2, (elements, predicate) =>
    suspend$4(() => {
      let iterator = elements[Symbol.iterator](), next = iterator.next()
      return next.done ? succeed$9(none$7()) : findLoop(iterator, 0, predicate, next.value)
    })),
  findLoop = (iterator, index$4, f$14, value$2) =>
    flatMap$5(f$14(value$2, index$4), result => {
      if (result) return succeed$9(some$4(value$2))
      let next = iterator.next()
      return next.done ? succeed$9(none$7()) : findLoop(iterator, index$4 + 1, f$14, next.value)
    }),
  firstSuccessOf$1 = effects =>
    suspend$4(() => {
      let list$3 = fromIterable$9(effects)
      return isNonEmpty$4(list$3)
        ? pipe(
          tailNonEmpty(list$3),
          reduce$12(headNonEmpty(list$3), (left$2, right$2) => orElse$6(left$2, () => right$2)),
        )
        : dieSync$2(() => new IllegalArgumentException$1(`Received an empty collection of effects`))
    }),
  flipWith$1 = dual(2, (self$1, f$14) => flip$4(f$14(flip$4(self$1)))),
  match$7 = dual(
    2,
    (self$1, options$2) =>
      matchEffect$2(self$1, {
        onFailure: e$26 => succeed$9(options$2.onFailure(e$26)),
        onSuccess: a$22 => succeed$9(options$2.onSuccess(a$22)),
      }),
  ),
  every$1 = dual(2, (elements, predicate) => suspend$4(() => forAllLoop(elements[Symbol.iterator](), 0, predicate))),
  forAllLoop = (iterator, index$4, f$14) => {
    let next = iterator.next()
    return next.done
      ? succeed$9(!0)
      : flatMap$5(f$14(next.value, index$4), b$3 => b$3 ? forAllLoop(iterator, index$4 + 1, f$14) : succeed$9(b$3))
  },
  forever$2 = self$1 => {
    let loop$2 = flatMap$5(flatMap$5(self$1, () => yieldNow$3()), () => loop$2)
    return loop$2
  },
  fiberRefs = withFiberRuntime$1(state => succeed$9(state.getFiberRefs())),
  head$2 = self$1 =>
    flatMap$5(self$1, as$6 => {
      let iterator = as$6[Symbol.iterator](), next = iterator.next()
      return next.done ? fail$9(new NoSuchElementException$1()) : succeed$9(next.value)
    }),
  ignore$2 = self$1 => match$7(self$1, { onFailure: constVoid, onSuccess: constVoid }),
  ignoreLogged$1 = self$1 =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 =>
        logDebug$1(cause$2, `An error was silently ignored because it is not anticipated to be useful`),
      onSuccess: () => void_$4,
    }),
  inheritFiberRefs$1 = childFiberRefs =>
    updateFiberRefs$1((parentFiberId, parentFiberRefs) => joinAs(parentFiberRefs, parentFiberId, childFiberRefs)),
  isFailure$2 = self$1 => match$7(self$1, { onFailure: constTrue, onSuccess: constFalse }),
  isSuccess$1 = self$1 => match$7(self$1, { onFailure: constFalse, onSuccess: constTrue }),
  iterate$1 = (initial, options$2) =>
    suspend$4(() =>
      options$2.while(initial) ? flatMap$5(options$2.body(initial), z2 => iterate$1(z2, options$2)) : succeed$9(initial)
    ),
  logWithLevel = level => (...message) => {
    let levelOption = fromNullable$2(level), cause$2
    for (let i$14 = 0, len = message.length; i$14 < len; i$14++) {
      let msg = message[i$14]
      isCause$1(msg)
        && (cause$2 = cause$2 === void 0 ? msg : sequential$3(cause$2, msg),
          message = [...message.slice(0, i$14), ...message.slice(i$14 + 1)],
          i$14--)
    }
    return cause$2 === void 0 && (cause$2 = empty$17),
      withFiberRuntime$1(fiberState => (fiberState.log(message, cause$2, levelOption), void_$4))
  },
  log$1 = logWithLevel(),
  logTrace$1 = logWithLevel(Trace),
  logDebug$1 = logWithLevel(Debug),
  logInfo$1 = logWithLevel(Info$1),
  logWarning$1 = logWithLevel(Warning),
  logError$1 = logWithLevel(Error$2),
  logFatal$1 = logWithLevel(Fatal),
  withLogSpan$1 = dual(
    2,
    (effect, label) =>
      flatMap$5(
        currentTimeMillis,
        now$1 => fiberRefLocallyWith(effect, currentLogSpan, prepend(make$34(label, now$1))),
      ),
  ),
  logAnnotations$1 = fiberRefGet(currentLogAnnotations),
  loop$1 = (initial, options$2) =>
    options$2.discard
      ? loopDiscard(initial, options$2.while, options$2.step, options$2.body)
      : map$11(loopInternal(initial, options$2.while, options$2.step, options$2.body), fromIterable$10),
  loopInternal = (initial, cont, inc, body$2) =>
    suspend$4(() =>
      cont(initial)
        ? flatMap$5(body$2(initial), a$22 => map$11(loopInternal(inc(initial), cont, inc, body$2), prepend(a$22)))
        : sync$3(() => empty$27())
    ),
  loopDiscard = (initial, cont, inc, body$2) =>
    suspend$4(() =>
      cont(initial) ? flatMap$5(body$2(initial), () => loopDiscard(inc(initial), cont, inc, body$2)) : void_$4
    ),
  mapAccum$1 = dual(3, (elements, initial, f$14) =>
    suspend$4(() => {
      let iterator = elements[Symbol.iterator](), builder = [], result = succeed$9(initial), next, i$14 = 0
      for (; !(next = iterator.next()).done;) {
        let index$4 = i$14++, value$2 = next.value
        result = flatMap$5(result, state =>
          map$11(f$14(state, value$2, index$4), ([z$1, b$3]) => (builder.push(b$3), z$1)))
      }
      return map$11(result, z$1 => [z$1, builder])
    })),
  mapErrorCause$1 = dual(
    2,
    (self$1, f$14) =>
      matchCauseEffect$2(self$1, { onFailure: c$3 => failCauseSync$2(() => f$14(c$3)), onSuccess: succeed$9 }),
  ),
  memoize = self$1 =>
    pipe(
      deferredMake(),
      flatMap$5(deferred =>
        pipe(
          diffFiberRefsAndRuntimeFlags(self$1),
          intoDeferred$1(deferred),
          once$2,
          map$11(complete$4 =>
            zipRight$3(
              complete$4,
              pipe(
                deferredAwait(deferred),
                flatMap$5(([patch$12, a$22]) =>
                  as$4(zip$4(patchFiberRefs$1(patch$12[0]), updateRuntimeFlags(patch$12[1])), a$22)
                ),
              ),
            )
          ),
        )
      ),
    ),
  merge$4 = self$1 => matchEffect$2(self$1, { onFailure: e$26 => succeed$9(e$26), onSuccess: succeed$9 }),
  negate$1 = self$1 => map$11(self$1, b$3 => !b$3),
  none$4 = self$1 =>
    flatMap$5(self$1, option$5 => {
      switch (option$5._tag) {
        case `None`:
          return void_$4
        case `Some`:
          return fail$9(new NoSuchElementException$1())
      }
    }),
  once$2 = self$1 => map$11(make$32(!0), ref => asVoid$3(whenEffect$1(self$1, getAndSet(ref, !1)))),
  option$4 = self$1 =>
    matchEffect$2(self$1, { onFailure: () => succeed$9(none$7()), onSuccess: a$22 => succeed$9(some$4(a$22)) }),
  orElseFail$1 = dual(2, (self$1, evaluate$2) => orElse$6(self$1, () => failSync$2(evaluate$2))),
  orElseSucceed$1 = dual(2, (self$1, evaluate$2) => orElse$6(self$1, () => sync$3(evaluate$2))),
  parallelErrors$1 = self$1 =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 => {
        let errors = fromIterable$10(failures$1(cause$2))
        return errors.length === 0 ? failCause$8(cause$2) : fail$9(errors)
      },
      onSuccess: succeed$9,
    }),
  patchFiberRefs$1 = patch$12 =>
    updateFiberRefs$1((fiberId$2, fiberRefs$3) => pipe(patch$12, patch$3(fiberId$2, fiberRefs$3))),
  promise$1 = evaluate$2 =>
    evaluate$2.length >= 1
      ? async_((resolve, signal) => {
        try {
          evaluate$2(signal).then(a$22 => resolve(exitSucceed$1(a$22)), e$26 => resolve(exitDie$1(e$26)))
        } catch (e$26) {
          resolve(exitDie$1(e$26))
        }
      })
      : async_(resolve => {
        try {
          evaluate$2().then(a$22 => resolve(exitSucceed$1(a$22)), e$26 => resolve(exitDie$1(e$26)))
        } catch (e$26) {
          resolve(exitDie$1(e$26))
        }
      }),
  provideService$1 = dual(
    3,
    (self$1, tag$3, service) => contextWithEffect$1(env$1 => provideContext$1(self$1, add$3(env$1, tag$3, service))),
  ),
  provideServiceEffect$1 = dual(
    3,
    (self$1, tag$3, effect) =>
      contextWithEffect$1(env$1 =>
        flatMap$5(effect, service => provideContext$1(self$1, pipe(env$1, add$3(tag$3, service))))
      ),
  ),
  random$1 = randomWith$1(succeed$9),
  reduce$4 = dual(
    3,
    (elements, zero$1, f$14) =>
      fromIterable$10(elements).reduce(
        (acc, el, i$14) => flatMap$5(acc, a$22 => f$14(a$22, el, i$14)),
        succeed$9(zero$1),
      ),
  ),
  reduceRight$1 = dual(
    3,
    (elements, zero$1, f$14) =>
      fromIterable$10(elements).reduceRight(
        (acc, el, i$14) => flatMap$5(acc, a$22 => f$14(el, a$22, i$14)),
        succeed$9(zero$1),
      ),
  ),
  reduceWhile$1 = dual(
    3,
    (elements, zero$1, options$2) =>
      flatMap$5(
        sync$3(() => elements[Symbol.iterator]()),
        iterator => reduceWhileLoop(iterator, 0, zero$1, options$2.while, options$2.body),
      ),
  ),
  reduceWhileLoop = (iterator, index$4, state, predicate, f$14) => {
    let next = iterator.next()
    return !next.done && predicate(state)
      ? flatMap$5(
        f$14(state, next.value, index$4),
        nextState => reduceWhileLoop(iterator, index$4 + 1, nextState, predicate, f$14),
      )
      : succeed$9(state)
  },
  repeatN$1 = dual(2, (self$1, n$19) => suspend$4(() => repeatNLoop(self$1, n$19))),
  repeatNLoop = (self$1, n$19) =>
    flatMap$5(self$1, a$22 => n$19 <= 0 ? succeed$9(a$22) : zipRight$3(yieldNow$3(), repeatNLoop(self$1, n$19 - 1))),
  sandbox$1 = self$1 => matchCauseEffect$2(self$1, { onFailure: fail$9, onSuccess: succeed$9 }),
  setFiberRefs$1 = fiberRefs$3 => suspend$4(() => setAll(fiberRefs$3)),
  sleep$1 = sleep$2,
  succeedNone$1 = succeed$9(none$7()),
  succeedSome$1 = value$2 => succeed$9(some$4(value$2)),
  summarized$1 = dual(
    3,
    (self$1, summary$2, f$14) =>
      flatMap$5(
        summary$2,
        start$2 => flatMap$5(self$1, value$2 => map$11(summary$2, end$2 => [f$14(start$2, end$2), value$2])),
      ),
  ),
  tagMetrics$1 = dual(args$1 => isEffect$1(args$1[0]), function() {
    return labelMetrics$1(
      arguments[0],
      typeof arguments[1] == `string`
        ? [make$30(arguments[1], arguments[2])]
        : Object.entries(arguments[1]).map(([k$1, v$4]) => make$30(k$1, v$4)),
    )
  }),
  labelMetrics$1 = dual(
    2,
    (self$1, labels) => fiberRefLocallyWith(self$1, currentMetricLabels, old => union$8(old, labels)),
  ),
  takeUntil$1 = dual(2, (elements, predicate) =>
    suspend$4(() => {
      let iterator = elements[Symbol.iterator](), builder = [], next, effect = succeed$9(!1), i$14 = 0
      for (; (next = iterator.next()) && !next.done;) {
        let a$22 = next.value, index$4 = i$14++
        effect = flatMap$5(effect, bool => bool ? succeed$9(!0) : (builder.push(a$22), predicate(a$22, index$4)))
      }
      return map$11(effect, () => builder)
    })),
  takeWhile$1 = dual(2, (elements, predicate) =>
    suspend$4(() => {
      let iterator = elements[Symbol.iterator](), builder = [], next, taking = succeed$9(!0), i$14 = 0
      for (; (next = iterator.next()) && !next.done;) {
        let a$22 = next.value, index$4 = i$14++
        taking = flatMap$5(taking, taking$1 =>
          pipe(taking$1 ? predicate(a$22, index$4) : succeed$9(!1), map$11(bool => (bool && builder.push(a$22), bool))))
      }
      return map$11(taking, () =>
        builder)
    })),
  tapBoth$1 = dual(2, (self$1, { onFailure, onSuccess }) =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 => {
        let either$6 = failureOrCause$1(cause$2)
        switch (either$6._tag) {
          case `Left`:
            return zipRight$3(onFailure(either$6.left), failCause$8(cause$2))
          case `Right`:
            return failCause$8(cause$2)
        }
      },
      onSuccess: a$22 => as$4(onSuccess(a$22), a$22),
    })),
  tapDefect$1 = dual(
    2,
    (self$1, f$14) =>
      catchAllCause$1(self$1, cause$2 =>
        match$11(keepDefects$1(cause$2), {
          onNone: () => failCause$8(cause$2),
          onSome: a$22 => zipRight$3(f$14(a$22), failCause$8(cause$2)),
        })),
  ),
  tapError$1 = dual(2, (self$1, f$14) =>
    matchCauseEffect$2(self$1, {
      onFailure: cause$2 => {
        let either$6 = failureOrCause$1(cause$2)
        switch (either$6._tag) {
          case `Left`:
            return zipRight$3(f$14(either$6.left), failCause$8(cause$2))
          case `Right`:
            return failCause$8(cause$2)
        }
      },
      onSuccess: succeed$9,
    })),
  tapErrorTag$1 = dual(
    3,
    (self$1, k$1, f$14) => tapError$1(self$1, e$26 => isTagged(e$26, k$1) ? f$14(e$26) : void_$4),
  ),
  tapErrorCause$1 = dual(
    2,
    (self$1, f$14) =>
      matchCauseEffect$2(self$1, {
        onFailure: cause$2 => zipRight$3(f$14(cause$2), failCause$8(cause$2)),
        onSuccess: succeed$9,
      }),
  ),
  timed$1 = self$1 => timedWith$1(self$1, currentTimeNanos),
  timedWith$1 = dual(2, (self$1, nanos$1) => summarized$1(self$1, nanos$1, (start$2, end$2) => nanos(end$2 - start$2))),
  tracerWith$1 = tracerWith$2,
  tracer$1 = tracerWith$1(succeed$9),
  tryPromise$1 = arg => {
    let evaluate$2, catcher
    typeof arg == `function` ? evaluate$2 = arg : (evaluate$2 = arg.try, catcher = arg.catch)
    let fail$11 = e$26 =>
      catcher
        ? failSync$2(() => catcher(e$26))
        : fail$9(new UnknownException$1(e$26, `An unknown error occurred in Effect.tryPromise`))
    return evaluate$2.length >= 1
      ? async_((resolve, signal) => {
        try {
          evaluate$2(signal).then(a$22 => resolve(exitSucceed$1(a$22)), e$26 => resolve(fail$11(e$26)))
        } catch (e$26) {
          resolve(fail$11(e$26))
        }
      })
      : async_(resolve => {
        try {
          evaluate$2().then(a$22 => resolve(exitSucceed$1(a$22)), e$26 => resolve(fail$11(e$26)))
        } catch (e$26) {
          resolve(fail$11(e$26))
        }
      })
  },
  tryMap$1 = dual(
    2,
    (self$1, options$2) =>
      flatMap$5(self$1, a$22 => try_$1({ try: () => options$2.try(a$22), catch: options$2.catch })),
  ),
  tryMapPromise$1 = dual(
    2,
    (self$1, options$2) =>
      flatMap$5(self$1, a$22 =>
        tryPromise$1({
          try: options$2.try.length >= 1
            ? signal => options$2.try(a$22, signal)
            : () => options$2.try(a$22),
          catch: options$2.catch,
        })),
  ),
  unless$1 = dual(2, (self$1, condition) => suspend$4(() => condition() ? succeedNone$1 : asSome$1(self$1))),
  unlessEffect$1 = dual(2, (self$1, condition) => flatMap$5(condition, b$3 => b$3 ? succeedNone$1 : asSome$1(self$1))),
  unsandbox$1 = self$1 => mapErrorCause$1(self$1, flatten$4),
  updateFiberRefs$1 = f$14 =>
    withFiberRuntime$1(state => (state.setFiberRefs(f$14(state.id(), state.getFiberRefs())), void_$4)),
  updateService$1 = dual(
    3,
    (self$1, tag$3, f$14) =>
      mapInputContext$1(self$1, context$2 => add$3(context$2, tag$3, f$14(unsafeGet$3(context$2, tag$3)))),
  ),
  when$3 = dual(2, (self$1, condition) => suspend$4(() => condition() ? map$11(self$1, some$4) : succeed$9(none$7()))),
  whenFiberRef$1 = dual(
    3,
    (self$1, fiberRef, predicate) =>
      flatMap$5(
        fiberRefGet(fiberRef),
        s$14 => predicate(s$14) ? map$11(self$1, a$22 => [s$14, some$4(a$22)]) : succeed$9([s$14, none$7()]),
      ),
  ),
  whenRef$1 = dual(
    3,
    (self$1, ref, predicate) =>
      flatMap$5(
        get(ref),
        s$14 => predicate(s$14) ? map$11(self$1, a$22 => [s$14, some$4(a$22)]) : succeed$9([s$14, none$7()]),
      ),
  ),
  withMetric$1 = dual(2, (self$1, metric) => metric(self$1)),
  serviceFunctionEffect$1 = (getService, f$14) => (...args$1) => flatMap$5(getService, a$22 => f$14(a$22)(...args$1)),
  serviceFunction$1 = (getService, f$14) => (...args$1) => map$11(getService, a$22 => f$14(a$22)(...args$1)),
  serviceFunctions$1 = getService =>
    new Proxy({}, {
      get(_target, prop, _receiver) {
        return (...args$1) => flatMap$5(getService, s$14 => s$14[prop](...args$1))
      },
    }),
  serviceConstants$1 = getService =>
    new Proxy({}, {
      get(_target, prop, _receiver) {
        return flatMap$5(getService, s$14 => isEffect$1(s$14[prop]) ? s$14[prop] : succeed$9(s$14[prop]))
      },
    }),
  serviceMembers$1 = getService => ({
    functions: serviceFunctions$1(getService),
    constants: serviceConstants$1(getService),
  }),
  serviceOption$1 = tag$3 => map$11(context$1(), getOption(tag$3)),
  serviceOptional$1 = tag$3 => flatMap$5(context$1(), getOption(tag$3)),
  annotateCurrentSpan$1 = function() {
    let args$1 = arguments
    return ignore$2(flatMap$5(currentSpan$1, span$1 =>
      sync$3(() => {
        if (typeof args$1[0] == `string`) span$1.attribute(args$1[0], args$1[1])
        else for (let key$1 in args$1[0]) span$1.attribute(key$1, args$1[0][key$1])
      })))
  },
  linkSpanCurrent$1 = function() {
    let args$1 = arguments,
      links = Array.isArray(args$1[0])
        ? args$1[0]
        : [{ _tag: `SpanLink`, span: args$1[0], attributes: args$1[1] ?? {} }]
    return ignore$2(flatMap$5(currentSpan$1, span$1 => sync$3(() => span$1.addLinks(links))))
  },
  annotateSpans$1 = dual(args$1 => isEffect$1(args$1[0]), function() {
    let args$1 = arguments
    return fiberRefLocallyWith(
      args$1[0],
      currentTracerSpanAnnotations,
      typeof args$1[1] == `string`
        ? set$3(args$1[1], args$1[2])
        : annotations$2 =>
          Object.entries(args$1[1]).reduce((acc, [key$1, value$2]) => set$3(acc, key$1, value$2), annotations$2),
    )
  }),
  currentParentSpan$1 = serviceOptional$1(spanTag),
  currentSpan$1 = flatMap$5(context$1(), context$2 => {
    let span$1 = context$2.unsafeMap.get(spanTag.key)
    return span$1 !== void 0 && span$1._tag === `Span` ? succeed$9(span$1) : fail$9(new NoSuchElementException$1())
  }),
  linkSpans$1 = dual(
    args$1 => isEffect$1(args$1[0]),
    (self$1, span$1, attributes) =>
      fiberRefLocallyWith(
        self$1,
        currentTracerSpanLinks,
        append$1({ _tag: `SpanLink`, span: span$1, attributes: attributes ?? {} }),
      ),
  ),
  bigint0$1 = BigInt(0),
  filterDisablePropagation = flatMap$12(span$1 =>
    get$9(span$1.context, DisablePropagation$1)
      ? span$1._tag === `Span` ? filterDisablePropagation(span$1.parent) : none$7()
      : some$4(span$1)
  ),
  unsafeMakeSpan = (fiber, name, options$2) => {
    let disablePropagation = !fiber.getFiberRef(currentTracerEnabled)
        || options$2.context && get$9(options$2.context, DisablePropagation$1),
      context$2 = fiber.getFiberRef(currentContext),
      parent = options$2.parent
        ? some$4(options$2.parent)
        : options$2.root
        ? none$7()
        : filterDisablePropagation(getOption(context$2, spanTag)),
      span$1
    if (disablePropagation) {
      span$1 = noopSpan({ name, parent, context: add$3(options$2.context ?? empty$33(), DisablePropagation$1, !0) })
    } else {
      let services = fiber.getFiberRef(currentServices),
        tracer$2 = get$9(services, tracerTag),
        clock$2 = get$9(services, Clock),
        timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled),
        fiberRefs$3 = fiber.getFiberRefs(),
        annotationsFromEnv = get$2(fiberRefs$3, currentTracerSpanAnnotations),
        linksFromEnv = get$2(fiberRefs$3, currentTracerSpanLinks),
        links = linksFromEnv._tag === `Some`
          ? options$2.links === void 0
            ? toReadonlyArray(linksFromEnv.value)
            : [...toReadonlyArray(linksFromEnv.value), ...options$2.links ?? []]
          : options$2.links ?? empty$35()
      span$1 = tracer$2.span(
        name,
        parent,
        options$2.context ?? empty$33(),
        links,
        timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1,
        options$2.kind ?? `internal`,
      ),
        annotationsFromEnv._tag === `Some`
        && forEach$5(annotationsFromEnv.value, (value$2, key$1) => span$1.attribute(key$1, value$2)),
        options$2.attributes !== void 0
        && Object.entries(options$2.attributes).forEach(([k$1, v$4]) => span$1.attribute(k$1, v$4))
    }
    return typeof options$2.captureStackTrace == `function` && spanToTrace.set(span$1, options$2.captureStackTrace),
      span$1
  },
  makeSpan$1 = (
    name,
    options$2,
  ) => (options$2 = addSpanStackTrace(options$2),
    withFiberRuntime$1(fiber => succeed$9(unsafeMakeSpan(fiber, name, options$2)))),
  spanAnnotations$1 = fiberRefGet(currentTracerSpanAnnotations),
  spanLinks$1 = fiberRefGet(currentTracerSpanLinks),
  endSpan = (span$1, exit$5, clock$2, timingEnabled) =>
    sync$3(() => {
      span$1.status._tag !== `Ended`
        && (exitIsFailure(exit$5) && spanToTrace.has(span$1)
          && span$1.attribute(`code.stacktrace`, spanToTrace.get(span$1)()),
          span$1.end(timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1, exit$5))
    }),
  useSpan$1 = (name, ...args$1) => {
    let options$2 = addSpanStackTrace(args$1.length === 1 ? void 0 : args$1[0]), evaluate$2 = args$1[args$1.length - 1]
    return withFiberRuntime$1(fiber => {
      let span$1 = unsafeMakeSpan(fiber, name, options$2),
        timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled),
        clock$2 = get$9(fiber.getFiberRef(currentServices), clockTag)
      return onExit$2(evaluate$2(span$1), exit$5 => endSpan(span$1, exit$5, clock$2, timingEnabled))
    })
  },
  withParentSpan$1 = dual(2, (self$1, span$1) => provideService$1(self$1, spanTag, span$1)),
  withSpan$1 = function() {
    let dataFirst = typeof arguments[0] != `string`,
      name = dataFirst ? arguments[1] : arguments[0],
      options$2 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])
    if (dataFirst) {
      let self$1 = arguments[0]
      return useSpan$1(name, options$2, span$1 => withParentSpan$1(self$1, span$1))
    }
    return self$1 => useSpan$1(name, options$2, span$1 => withParentSpan$1(self$1, span$1))
  },
  functionWithSpan$1 = options$2 =>
    function() {
      let captureStackTrace$1 = options$2.captureStackTrace ?? !1
      if (options$2.captureStackTrace !== !1) {
        let limit = Error.stackTraceLimit
        Error.stackTraceLimit = 2
        let error = Error()
        Error.stackTraceLimit = limit
        let cache = !1
        captureStackTrace$1 = () => {
          if (cache !== !1) return cache
          if (error.stack) {
            let stack = error.stack.trim().split(`
`)
            return cache = stack.slice(2).join(`
`).trim(),
              cache
          }
        }
      }
      return suspend$4(() => {
        let opts = typeof options$2.options == `function` ? options$2.options.apply(null, arguments) : options$2.options
        return withSpan$1(suspend$4(() => internalCall(() => options$2.body.apply(this, arguments))), opts.name, {
          ...opts,
          captureStackTrace: captureStackTrace$1,
        })
      })
    },
  fromNullable$1 = value$2 => value$2 == null ? fail$9(new NoSuchElementException$1()) : succeed$9(value$2),
  optionFromOptional$1 = self$1 =>
    catchAll$1(map$11(self$1, some$4), error => isNoSuchElementException$1(error) ? succeedNone$1 : fail$9(error)),
  OP_SEQUENTIAL = `Sequential`,
  OP_PARALLEL = `Parallel`,
  OP_PARALLEL_N = `ParallelN`,
  sequential$2 = { _tag: OP_SEQUENTIAL },
  parallel$2 = { _tag: OP_PARALLEL },
  parallelN$1 = parallelism => ({ _tag: OP_PARALLEL_N, parallelism }),
  isSequential$1 = self$1 => self$1._tag === OP_SEQUENTIAL,
  isParallel$1 = self$1 => self$1._tag === OP_PARALLEL,
  isParallelN$1 = self$1 => self$1._tag === OP_PARALLEL_N,
  match$6 = dual(2, (self$1, options$2) => {
    switch (self$1._tag) {
      case OP_SEQUENTIAL:
        return options$2.onSequential()
      case OP_PARALLEL:
        return options$2.onParallel()
      case OP_PARALLEL_N:
        return options$2.onParallelN(self$1.parallelism)
    }
  }),
  sequential$1 = sequential$2,
  parallel$1 = parallel$2,
  parallelN = parallelN$1,
  isSequential = isSequential$1,
  isParallel = isParallel$1,
  isParallelN = isParallelN$1,
  match$5 = match$6,
  empty$10 = empty$11,
  diff$1 = diff$2,
  combine$1 = combine$2,
  patch$2 = patch$3,
  FiberStatusSymbolKey = `effect/FiberStatus`,
  FiberStatusTypeId$1 = Symbol.for(FiberStatusSymbolKey),
  OP_DONE$1 = `Done`,
  OP_RUNNING = `Running`,
  OP_SUSPENDED = `Suspended`,
  DoneHash = string$4(`${FiberStatusSymbolKey}-${OP_DONE$1}`)
var Done = class {
    [FiberStatusTypeId$1] = FiberStatusTypeId$1
    _tag = OP_DONE$1;
    [symbol$2]() {
      return DoneHash
    }
    [symbol$1](that) {
      return isFiberStatus$1(that) && that._tag === OP_DONE$1
    }
  },
  Running = class {
    runtimeFlags;
    [FiberStatusTypeId$1] = FiberStatusTypeId$1
    _tag = OP_RUNNING
    constructor(runtimeFlags$1) {
      this.runtimeFlags = runtimeFlags$1
    }
    [symbol$2]() {
      return pipe(
        hash(FiberStatusSymbolKey),
        combine$11(hash(this._tag)),
        combine$11(hash(this.runtimeFlags)),
        cached$2(this),
      )
    }
    [symbol$1](that) {
      return isFiberStatus$1(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags
    }
  },
  Suspended = class {
    runtimeFlags
    blockingOn;
    [FiberStatusTypeId$1] = FiberStatusTypeId$1
    _tag = OP_SUSPENDED
    constructor(runtimeFlags$1, blockingOn) {
      this.runtimeFlags = runtimeFlags$1, this.blockingOn = blockingOn
    }
    [symbol$2]() {
      return pipe(
        hash(FiberStatusSymbolKey),
        combine$11(hash(this._tag)),
        combine$11(hash(this.runtimeFlags)),
        combine$11(hash(this.blockingOn)),
        cached$2(this),
      )
    }
    [symbol$1](that) {
      return isFiberStatus$1(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags
        && equals(this.blockingOn, that.blockingOn)
    }
  }
const done$5 = new Done(),
  running$1 = runtimeFlags$1 => new Running(runtimeFlags$1),
  suspended$1 = (runtimeFlags$1, blockingOn) => new Suspended(runtimeFlags$1, blockingOn),
  isFiberStatus$1 = u$7 => hasProperty(u$7, FiberStatusTypeId$1),
  isDone$3 = self$1 => self$1._tag === OP_DONE$1,
  isRunning$1 = self$1 => self$1._tag === OP_RUNNING,
  isSuspended$1 = self$1 => self$1._tag === OP_SUSPENDED,
  FiberStatusTypeId = FiberStatusTypeId$1,
  done$4 = done$5,
  running = running$1,
  suspended = suspended$1,
  isFiberStatus = isFiberStatus$1,
  isDone$2 = isDone$3,
  isRunning = isRunning$1,
  isSuspended = isSuspended$1,
  TypeId$6 = Symbol.for(`effect/Micro`),
  MicroExitTypeId = Symbol.for(`effect/Micro/MicroExit`),
  MicroCauseTypeId = Symbol.for(`effect/Micro/MicroCause`),
  microCauseVariance = { _E: identity }
var MicroCauseImpl = class extends globalThis.Error {
    _tag
    traces;
    [MicroCauseTypeId]
    constructor(_tag, originalError$1, traces) {
      let causeName = `MicroCause.${_tag}`, name, message, stack
      if (originalError$1 instanceof globalThis.Error) {
        name = `(${causeName}) ${originalError$1.name}`, message = originalError$1.message
        let messageLines = message.split(`
`).length
        stack = originalError$1.stack
          ? `(${causeName}) ${
            originalError$1.stack.split(`
`).slice(
              0,
              messageLines + 3,
            ).join(`
`)
          }`
          : `${name}: ${message}`
      } else name = causeName, message = toStringUnknown(originalError$1, 0), stack = `${name}: ${message}`
      traces.length > 0 && (stack += `\n    ${
        traces.join(`
    `)
      }`),
        super(message),
        this._tag = _tag,
        this.traces = traces,
        this[MicroCauseTypeId] = microCauseVariance,
        this.name = name,
        this.stack = stack
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
    toString() {
      return this.stack
    }
    [NodeInspectSymbol]() {
      return this.stack
    }
  },
  Die = class extends MicroCauseImpl {
    defect
    constructor(defect, traces = []) {
      super(`Die`, defect, traces), this.defect = defect
    }
  }
const causeDie = (defect, traces = []) => new Die(defect, traces)
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super(`Interrupt`, `interrupted`, traces)
  }
}
const causeInterrupt = (traces = []) => new Interrupt(traces),
  causeIsInterrupt = self$1 => self$1._tag === `Interrupt`,
  MicroFiberTypeId = Symbol.for(`effect/Micro/MicroFiber`),
  fiberVariance$1 = { _A: identity, _E: identity }
var MicroFiberImpl = class {
  context
  interruptible;
  [MicroFiberTypeId]
  _stack = []
  _observers = []
  _exit
  _children
  currentOpCount = 0
  constructor(context$2, interruptible$4 = !0) {
    this.context = context$2, this.interruptible = interruptible$4, this[MicroFiberTypeId] = fiberVariance$1
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref)
  }
  addObserver(cb) {
    return this._exit ? (cb(this._exit), constVoid) : (this._observers.push(cb), () => {
      let index$4 = this._observers.indexOf(cb)
      index$4 >= 0 && this._observers.splice(index$4, 1)
    })
  }
  _interrupted = !1
  unsafeInterrupt() {
    this._exit || (this._interrupted = !0, this.interruptible && this.evaluate(exitInterrupt))
  }
  unsafePoll() {
    return this._exit
  }
  evaluate(effect) {
    if (this._exit) return
    if (this._yielded !== void 0) {
      let yielded = this._yielded
      this._yielded = void 0, yielded()
    }
    let exit$5 = this.runLoop(effect)
    if (exit$5 === Yield) return
    let interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this)
    if (interruptChildren !== void 0) return this.evaluate(flatMap$3(interruptChildren, () => exit$5))
    this._exit = exit$5
    for (let i$14 = 0; i$14 < this._observers.length; i$14++) this._observers[i$14](exit$5)
    this._observers.length = 0
  }
  runLoop(effect) {
    let yielding = !1, current = effect
    this.currentOpCount = 0
    try {
      for (;;) {
        if (this.currentOpCount++, !yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = !0
          let prev = current
          current = flatMap$3(yieldNow$2, () => prev)
        }
        if (current = current[evaluate$1](this), current === Yield) {
          let yielded = this._yielded
          return MicroExitTypeId in yielded ? (this._yielded = void 0, yielded) : Yield
        }
      }
    } catch (error) {
      return hasProperty(current, evaluate$1)
        ? exitDie(error)
        : exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`)
    }
  }
  getCont(symbol$3) {
    for (;;) {
      let op = this._stack.pop()
      if (!op) return
      let cont = op[ensureCont] && op[ensureCont](this)
      if (cont) return { [symbol$3]: cont }
      if (op[symbol$3]) return op
    }
  }
  _yielded = void 0
  yieldWith(value$2) {
    return this._yielded = value$2, Yield
  }
  children() {
    return this._children ??= new Set()
  }
}
const fiberMiddleware = globalValue(`effect/Micro/fiberMiddleware`, () => ({ interruptChildren: void 0 })),
  fiberInterruptAll = fibers =>
    suspend$3(() => {
      for (let fiber of fibers) fiber.unsafeInterrupt()
      let iter = fibers[Symbol.iterator](),
        wait = suspend$3(() => {
          let result = iter.next()
          for (; !result.done;) {
            if (result.value.unsafePoll()) {
              result = iter.next()
              continue
            }
            let fiber = result.value
            return async$1(resume$1 => {
              fiber.addObserver(_$1 => {
                resume$1(wait)
              })
            })
          }
          return exitVoid
        })
      return wait
    }),
  identifier = Symbol.for(`effect/Micro/identifier`),
  args = Symbol.for(`effect/Micro/args`),
  evaluate$1 = Symbol.for(`effect/Micro/evaluate`),
  successCont = Symbol.for(`effect/Micro/successCont`),
  failureCont = Symbol.for(`effect/Micro/failureCont`),
  ensureCont = Symbol.for(`effect/Micro/ensureCont`),
  Yield = Symbol.for(`effect/Micro/Yield`),
  microVariance = { _A: identity, _E: identity, _R: identity },
  MicroProto = {
    ...EffectPrototype,
    _op: `Micro`,
    [TypeId$6]: microVariance,
    pipe() {
      return pipeArguments(this, arguments)
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this))
    },
    toJSON() {
      return { _id: `Micro`, op: this[identifier], ...args in this ? { args: this[args] } : void 0 }
    },
    toString() {
      return format$1(this)
    },
    [NodeInspectSymbol]() {
      return format$1(this)
    },
  }
function defaultEvaluate(_fiber) {
  return exitDie(`Micro.evaluate: Not implemented`)
}
const makePrimitiveProto = options$2 => ({
    ...MicroProto,
    [identifier]: options$2.op,
    [evaluate$1]: options$2.eval ?? defaultEvaluate,
    [successCont]: options$2.contA,
    [failureCont]: options$2.contE,
    [ensureCont]: options$2.ensure,
  }),
  makePrimitive = options$2 => {
    let Proto$1 = makePrimitiveProto(options$2)
    return function() {
      let self$1 = Object.create(Proto$1)
      return self$1[args] = options$2.single === !1 ? arguments : arguments[0], self$1
    }
  },
  makeExit = options$2 => {
    let Proto$1 = {
      ...makePrimitiveProto(options$2),
      [MicroExitTypeId]: MicroExitTypeId,
      _tag: options$2.op,
      get [options$2.prop]() {
        return this[args]
      },
      toJSON() {
        return { _id: `MicroExit`, _tag: options$2.op, [options$2.prop]: this[args] }
      },
      [symbol$1](that) {
        return isMicroExit(that) && that._tag === options$2.op && equals(this[args], that[args])
      },
      [symbol$2]() {
        return cached$2(this, combine$11(string$4(options$2.op))(hash(this[args])))
      },
    }
    return function(value$2) {
      let self$1 = Object.create(Proto$1)
      return self$1[args] = value$2,
        self$1[successCont] = void 0,
        self$1[failureCont] = void 0,
        self$1[ensureCont] = void 0,
        self$1
    }
  },
  succeed$6 = makeExit({
    op: `Success`,
    prop: `value`,
    eval(fiber) {
      let cont = fiber.getCont(successCont)
      return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this)
    },
  }),
  failCause$5 = makeExit({
    op: `Failure`,
    prop: `cause`,
    eval(fiber) {
      let cont = fiber.getCont(failureCont)
      for (; causeIsInterrupt(this[args]) && cont && fiber.interruptible;) cont = fiber.getCont(failureCont)
      return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this)
    },
  }),
  sync$1 = makePrimitive({
    op: `Sync`,
    eval(fiber) {
      let value$2 = this[args](), cont = fiber.getCont(successCont)
      return cont ? cont[successCont](value$2, fiber) : fiber.yieldWith(exitSucceed(value$2))
    },
  }),
  suspend$3 = makePrimitive({
    op: `Suspend`,
    eval(_fiber) {
      return this[args]()
    },
  }),
  yieldNowWith = makePrimitive({
    op: `Yield`,
    eval(fiber) {
      let resumed = !1
      return fiber.getRef(CurrentScheduler).scheduleTask(() => {
        resumed || fiber.evaluate(exitVoid)
      }, this[args] ?? 0),
        fiber.yieldWith(() => {
          resumed = !0
        })
    },
  }),
  yieldNow$2 = yieldNowWith(0),
  void_$2 = succeed$6(void 0),
  withMicroFiber = makePrimitive({
    op: `WithMicroFiber`,
    eval(fiber) {
      return this[args](fiber)
    },
  }),
  asyncOptions = makePrimitive({
    op: `Async`,
    single: !1,
    eval(fiber) {
      let register = this[args][0],
        resumed = !1,
        yielded = !1,
        controller = this[args][1] ? new AbortController() : void 0,
        onCancel = register(effect => {
          resumed || (resumed = !0, yielded ? fiber.evaluate(effect) : yielded = effect)
        }, controller?.signal)
      return yielded === !1
        ? (yielded = !0,
          fiber._yielded = () => {
            resumed = !0
          },
          controller === void 0 && onCancel === void 0
          || fiber._stack.push(asyncFinalizer(() => (resumed = !0, controller?.abort(), onCancel ?? exitVoid))),
          Yield)
        : yielded
    },
  }),
  asyncFinalizer = makePrimitive({
    op: `AsyncFinalizer`,
    ensure(fiber) {
      fiber.interruptible && (fiber.interruptible = !1, fiber._stack.push(setInterruptible(!0)))
    },
    contE(cause$2, _fiber) {
      return causeIsInterrupt(cause$2) ? flatMap$3(this[args](), () => failCause$5(cause$2)) : failCause$5(cause$2)
    },
  }),
  async$1 = register => asyncOptions(register, register.length >= 2),
  as$2 = dual(2, (self$1, value$2) => map$9(self$1, _$1 => value$2)),
  exit$3 = self$1 => matchCause$1(self$1, { onFailure: exitFailCause, onSuccess: exitSucceed }),
  flatMap$3 = dual(2, (self$1, f$14) => {
    let onSuccess = Object.create(OnSuccessProto)
    return onSuccess[args] = self$1, onSuccess[successCont] = f$14, onSuccess
  }),
  OnSuccessProto = makePrimitiveProto({
    op: `OnSuccess`,
    eval(fiber) {
      return fiber._stack.push(this), this[args]
    },
  }),
  map$9 = dual(2, (self$1, f$14) => flatMap$3(self$1, a$22 => succeed$6(f$14(a$22)))),
  isMicroExit = u$7 => hasProperty(u$7, MicroExitTypeId),
  exitSucceed = succeed$6,
  exitFailCause = failCause$5,
  exitInterrupt = exitFailCause(causeInterrupt()),
  exitDie = defect => exitFailCause(causeDie(defect)),
  exitVoid = exitSucceed(void 0),
  exitVoidAll = exits => {
    for (let exit$5 of exits) if (exit$5._tag === `Failure`) return exit$5
    return exitVoid
  },
  setImmediate$1 = `setImmediate` in globalThis ? globalThis.setImmediate : f$14 => setTimeout(f$14, 0)
var MicroSchedulerDefault = class {
  tasks = []
  running = !1
  scheduleTask(task, _priority) {
    this.tasks.push(task), this.running || (this.running = !0, setImmediate$1(this.afterScheduled))
  }
  afterScheduled = () => {
    this.running = !1, this.runTasks()
  }
  runTasks() {
    let tasks = this.tasks
    this.tasks = []
    for (let i$14 = 0, len = tasks.length; i$14 < len; i$14++) tasks[i$14]()
  }
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield)
  }
  flush() {
    for (; this.tasks.length > 0;) this.runTasks()
  }
}
const updateContext = dual(2, (self$1, f$14) =>
    withMicroFiber(fiber => {
      let prev = fiber.context
      return fiber.context = f$14(prev), onExit$1(self$1, () => (fiber.context = prev, void_$2))
    })),
  provideContext = dual(2, (self$1, provided) => updateContext(self$1, merge$6(provided)))
var MaxOpsBeforeYield = class
    extends Reference()(`effect/Micro/currentMaxOpsBeforeYield`, { defaultValue: () => 2048 })
  {},
  CurrentConcurrency = class
    extends Reference()(`effect/Micro/currentConcurrency`, { defaultValue: () => `unbounded` })
  {},
  CurrentScheduler = class
    extends Reference()(`effect/Micro/currentScheduler`, { defaultValue: () => new MicroSchedulerDefault() })
  {}
const matchCauseEffect$1 = dual(2, (self$1, options$2) => {
    let primitive = Object.create(OnSuccessAndFailureProto)
    return primitive[args] = self$1,
      primitive[successCont] = options$2.onSuccess,
      primitive[failureCont] = options$2.onFailure,
      primitive
  }),
  OnSuccessAndFailureProto = makePrimitiveProto({
    op: `OnSuccessAndFailure`,
    eval(fiber) {
      return fiber._stack.push(this), this[args]
    },
  }),
  matchCause$1 = dual(
    2,
    (self$1, options$2) =>
      matchCauseEffect$1(self$1, {
        onFailure: cause$2 => sync$1(() => options$2.onFailure(cause$2)),
        onSuccess: value$2 => sync$1(() => options$2.onSuccess(value$2)),
      }),
  ),
  MicroScopeTypeId = Symbol.for(`effect/Micro/MicroScope`)
var MicroScopeImpl = class MicroScopeImpl {
  [MicroScopeTypeId]
  state = { _tag: `Open`, finalizers: new Set() }
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId
  }
  unsafeAddFinalizer(finalizer) {
    this.state._tag === `Open` && this.state.finalizers.add(finalizer)
  }
  addFinalizer(finalizer) {
    return suspend$3(() =>
      this.state._tag === `Open` ? (this.state.finalizers.add(finalizer), void_$2) : finalizer(this.state.exit)
    )
  }
  unsafeRemoveFinalizer(finalizer) {
    this.state._tag === `Open` && this.state.finalizers.delete(finalizer)
  }
  close(microExit) {
    return suspend$3(() => {
      if (this.state._tag === `Open`) {
        let finalizers = Array.from(this.state.finalizers).reverse()
        return this.state = { _tag: `Closed`, exit: microExit },
          flatMap$3(forEach$4(finalizers, finalizer => exit$3(finalizer(microExit))), exitVoidAll)
      }
      return void_$2
    })
  }
  get fork() {
    return sync$1(() => {
      let newScope = new MicroScopeImpl()
      if (this.state._tag === `Closed`) return newScope.state = this.state, newScope
      function fin(exit$5) {
        return newScope.close(exit$5)
      }
      return this.state.finalizers.add(fin),
        newScope.unsafeAddFinalizer(_$1 => sync$1(() => this.unsafeRemoveFinalizer(fin))),
        newScope
    })
  }
}
const onExit$1 = dual(
    2,
    (self$1, f$14) =>
      uninterruptibleMask$1(restore =>
        matchCauseEffect$1(restore(self$1), {
          onFailure: cause$2 => flatMap$3(f$14(exitFailCause(cause$2)), () => failCause$5(cause$2)),
          onSuccess: a$22 => flatMap$3(f$14(exitSucceed(a$22)), () => succeed$6(a$22)),
        })
      ),
  ),
  setInterruptible = makePrimitive({
    op: `SetInterruptible`,
    ensure(fiber) {
      if (fiber.interruptible = this[args], fiber._interrupted && fiber.interruptible) return () => exitInterrupt
    },
  }),
  interruptible$1 = self$1 =>
    withMicroFiber(fiber =>
      fiber.interruptible
        ? self$1
        : (fiber.interruptible = !0,
          fiber._stack.push(setInterruptible(!1)),
          fiber._interrupted ? exitInterrupt : self$1)
    ),
  uninterruptibleMask$1 = f$14 =>
    withMicroFiber(fiber =>
      fiber.interruptible
        ? (fiber.interruptible = !1, fiber._stack.push(setInterruptible(!0)), f$14(interruptible$1))
        : f$14(identity)
    ),
  whileLoop$1 = makePrimitive({
    op: `While`,
    contA(value$2, fiber) {
      return this[args].step(value$2), this[args].while() ? (fiber._stack.push(this), this[args].body()) : exitVoid
    },
    eval(fiber) {
      return this[args].while() ? (fiber._stack.push(this), this[args].body()) : exitVoid
    },
  }),
  forEach$4 = (iterable, f$14, options$2) =>
    withMicroFiber(parent => {
      let concurrencyOption = options$2?.concurrency === `inherit`
          ? parent.getRef(CurrentConcurrency)
          : options$2?.concurrency ?? 1,
        concurrency = concurrencyOption === `unbounded` ? 1 / 0 : Math.max(1, concurrencyOption),
        items = fromIterable$10(iterable),
        length$1 = items.length
      if (length$1 === 0) return options$2?.discard ? void_$2 : succeed$6([])
      let out = options$2?.discard ? void 0 : Array(length$1), index$4 = 0
      return concurrency === 1
        ? as$2(
          whileLoop$1({
            while: () => index$4 < items.length,
            body: () => f$14(items[index$4], index$4),
            step: out
              ? b$3 => out[index$4++] = b$3
              : _$1 => index$4++,
          }),
          out,
        )
        : async$1(resume$1 => {
          let fibers = new Set(), result, inProgress = 0, doneCount = 0, pumping = !1, interrupted$2 = !1
          function pump() {
            for (pumping = !0; inProgress < concurrency && index$4 < length$1;) {
              let currentIndex = index$4, item = items[currentIndex]
              index$4++, inProgress++
              try {
                let child = unsafeFork$2(parent, f$14(item, currentIndex), !0, !0)
                fibers.add(child),
                  child.addObserver(exit$5 => {
                    fibers.delete(child),
                      !interrupted$2 && (exit$5._tag === `Failure`
                        ? result === void 0
                          && (result = exit$5, length$1 = index$4, fibers.forEach(fiber => fiber.unsafeInterrupt()))
                        : out !== void 0 && (out[currentIndex] = exit$5.value),
                        doneCount++,
                        inProgress--,
                        doneCount === length$1
                          ? resume$1(result ?? succeed$6(out))
                          : !pumping && inProgress < concurrency && pump())
                  })
              } catch (err) {
                result = exitDie(err), length$1 = index$4, fibers.forEach(fiber => fiber.unsafeInterrupt())
              }
            }
            pumping = !1
          }
          return pump(), suspend$3(() => (interrupted$2 = !0, index$4 = length$1, fiberInterruptAll(fibers)))
        })
    }),
  unsafeFork$2 = (parent, effect, immediate = !1, daemon = !1) => {
    let child = new MicroFiberImpl(parent.context, parent.interruptible)
    return daemon || (parent.children().add(child), child.addObserver(() => parent.children().delete(child))),
      immediate
        ? child.evaluate(effect)
        : parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect), 0),
      child
  },
  runFork$1 = (effect, options$2) => {
    let fiber = new MicroFiberImpl(CurrentScheduler.context(options$2?.scheduler ?? new MicroSchedulerDefault()))
    if (fiber.evaluate(effect), options$2?.signal) {
      if (options$2.signal.aborted) fiber.unsafeInterrupt()
      else {
        let abort = () => fiber.unsafeInterrupt()
        options$2.signal.addEventListener(`abort`, abort, { once: !0 }),
          fiber.addObserver(() => options$2.signal.removeEventListener(`abort`, abort))
      }
    }
    return fiber
  }
var PriorityBuckets = class {
    buckets = []
    scheduleTask(task, priority) {
      let length$1 = this.buckets.length, bucket, index$4 = 0
      for (; index$4 < length$1 && this.buckets[index$4][0] <= priority; index$4++) bucket = this.buckets[index$4]
      bucket && bucket[0] === priority
        ? bucket[1].push(task)
        : index$4 === length$1
        ? this.buckets.push([priority, [task]])
        : this.buckets.splice(index$4, 0, [priority, [task]])
    }
  },
  MixedScheduler = class {
    maxNextTickBeforeTimer
    running = !1
    tasks = new PriorityBuckets()
    constructor(maxNextTickBeforeTimer) {
      this.maxNextTickBeforeTimer = maxNextTickBeforeTimer
    }
    starveInternal(depth) {
      let tasks = this.tasks.buckets
      this.tasks.buckets = []
      for (let [_$1, toRun] of tasks) for (let i$14 = 0; i$14 < toRun.length; i$14++) toRun[i$14]()
      this.tasks.buckets.length === 0 ? this.running = !1 : this.starve(depth)
    }
    starve(depth = 0) {
      depth >= this.maxNextTickBeforeTimer
        ? setTimeout(() => this.starveInternal(0), 0)
        : Promise.resolve(void 0).then(() => this.starveInternal(depth + 1))
    }
    shouldYield(fiber) {
      return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield)
        ? fiber.getFiberRef(currentSchedulingPriority)
        : !1
    }
    scheduleTask(task, priority) {
      this.tasks.scheduleTask(task, priority), this.running || (this.running = !0, this.starve())
    }
  }
const defaultScheduler = globalValue(Symbol.for(`effect/Scheduler/defaultScheduler`), () => new MixedScheduler(2048))
var SyncScheduler = class {
  tasks = new PriorityBuckets()
  deferred = !1
  scheduleTask(task, priority) {
    this.deferred ? defaultScheduler.scheduleTask(task, priority) : this.tasks.scheduleTask(task, priority)
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield)
      ? fiber.getFiberRef(currentSchedulingPriority)
      : !1
  }
  flush() {
    for (; this.tasks.buckets.length > 0;) {
      let tasks = this.tasks.buckets
      this.tasks.buckets = []
      for (let [_$1, toRun] of tasks) for (let i$14 = 0; i$14 < toRun.length; i$14++) toRun[i$14]()
    }
    this.deferred = !0
  }
}
const currentScheduler = globalValue(
    Symbol.for(`effect/FiberRef/currentScheduler`),
    () => fiberRefUnsafeMake(defaultScheduler),
  ),
  withScheduler$1 = dual(2, (self$1, scheduler) => fiberRefLocally(self$1, currentScheduler, scheduler)),
  currentRequestMap = globalValue(Symbol.for(`effect/FiberRef/currentRequestMap`), () => fiberRefUnsafeMake(new Map())),
  match$4 = (concurrency, sequential$4, unbounded$1, bounded) => {
    switch (concurrency) {
      case void 0:
        return sequential$4()
      case `unbounded`:
        return unbounded$1()
      case `inherit`:
        return fiberRefGetWith(
          currentConcurrency,
          concurrency$1 =>
            concurrency$1 === `unbounded` ? unbounded$1() : concurrency$1 > 1 ? bounded(concurrency$1) : sequential$4(),
        )
      default:
        return concurrency > 1 ? bounded(concurrency) : sequential$4()
    }
  },
  matchSimple = (concurrency, sequential$4, concurrent) => {
    switch (concurrency) {
      case void 0:
        return sequential$4()
      case `unbounded`:
        return concurrent()
      case `inherit`:
        return fiberRefGetWith(
          currentConcurrency,
          concurrency$1 => concurrency$1 === `unbounded` || concurrency$1 > 1 ? concurrent() : sequential$4(),
        )
      default:
        return concurrency > 1 ? concurrent() : sequential$4()
    }
  },
  OP_INTERRUPT_SIGNAL = `InterruptSignal`,
  OP_STATEFUL = `Stateful`,
  OP_RESUME = `Resume`,
  OP_YIELD_NOW = `YieldNow`,
  interruptSignal = cause$2 => ({ _tag: OP_INTERRUPT_SIGNAL, cause: cause$2 }),
  stateful = onFiber => ({ _tag: OP_STATEFUL, onFiber }),
  resume = effect => ({ _tag: OP_RESUME, effect }),
  yieldNow$1 = () => ({ _tag: OP_YIELD_NOW }),
  FiberScopeSymbolKey = `effect/FiberScope`,
  FiberScopeTypeId = Symbol.for(FiberScopeSymbolKey)
var Global = class {
    [FiberScopeTypeId] = FiberScopeTypeId
    fiberId = none$6
    roots = new Set()
    add(_runtimeFlags, child) {
      this.roots.add(child),
        child.addObserver(() => {
          this.roots.delete(child)
        })
    }
  },
  Local = class {
    fiberId
    parent;
    [FiberScopeTypeId] = FiberScopeTypeId
    constructor(fiberId$2, parent) {
      this.fiberId = fiberId$2, this.parent = parent
    }
    add(_runtimeFlags, child) {
      this.parent.tell(stateful(parentFiber => {
        parentFiber.addChild(child),
          child.addObserver(() => {
            parentFiber.removeChild(child)
          })
      }))
    }
  }
const unsafeMake$1 = fiber => new Local(fiber.id(), fiber),
  globalScope = globalValue(Symbol.for(`effect/FiberScope/Global`), () => new Global()),
  FiberSymbolKey = `effect/Fiber`,
  FiberTypeId$1 = Symbol.for(FiberSymbolKey),
  fiberVariance = { _E: _$1 => _$1, _A: _$1 => _$1 },
  fiberProto = {
    [FiberTypeId$1]: fiberVariance,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  RuntimeFiberSymbolKey = `effect/Fiber`,
  RuntimeFiberTypeId$1 = Symbol.for(RuntimeFiberSymbolKey),
  Order$1 = pipe(tuple(Order$4, Order$4), mapInput(fiber => [fiber.id().startTimeMillis, fiber.id().id])),
  isFiber$1 = u$7 => hasProperty(u$7, FiberTypeId$1),
  isRuntimeFiber$1 = self$1 => RuntimeFiberTypeId$1 in self$1,
  _await$1 = self$1 => self$1.await,
  children$2 = self$1 => self$1.children,
  done$3 = exit$5 => {
    let _fiber = {
      ...CommitPrototype$1,
      commit() {
        return join$4(this)
      },
      ...fiberProto,
      id: () => none$6,
      await: succeed$9(exit$5),
      children: succeed$9([]),
      inheritAll: void_$4,
      poll: succeed$9(some$4(exit$5)),
      interruptAsFork: () => void_$4,
    }
    return _fiber
  },
  dump$1 = self$1 => map$11(self$1.status, status$2 => ({ id: self$1.id(), status: status$2 })),
  dumpAll$1 = fibers => forEachSequential(fibers, dump$1),
  fail$6 = error => done$3(fail$7(error)),
  failCause$4 = cause$2 => done$3(failCause$6(cause$2)),
  fromEffect$2 = effect => map$11(exit$4(effect), done$3),
  id$1 = self$1 => self$1.id(),
  inheritAll$1 = self$1 => self$1.inheritAll,
  interrupted$1 = fiberId$2 => done$3(interrupt$3(fiberId$2)),
  interruptAll$1 = fibers => flatMap$5(fiberId$1, fiberId$2 => pipe(fibers, interruptAllAs$1(fiberId$2))),
  interruptAllAs$1 = dual(
    2,
    (fibers, fiberId$2) =>
      pipe(
        forEachSequentialDiscard(fibers, interruptAsFork$1(fiberId$2)),
        zipRight$3(pipe(fibers, forEachSequentialDiscard(_await$1))),
      ),
  ),
  interruptAsFork$1 = dual(2, (self$1, fiberId$2) => self$1.interruptAsFork(fiberId$2)),
  join$4 = self$1 => zipLeft$3(flatten$3(self$1.await), self$1.inheritAll),
  map$8 = dual(2, (self$1, f$14) => mapEffect$2(self$1, a$22 => sync$3(() => f$14(a$22)))),
  mapEffect$2 = dual(2, (self$1, f$14) => {
    let _fiber = {
      ...CommitPrototype$1,
      commit() {
        return join$4(this)
      },
      ...fiberProto,
      id: () => self$1.id(),
      await: flatMap$5(self$1.await, forEachEffect(f$14)),
      children: self$1.children,
      inheritAll: self$1.inheritAll,
      poll: flatMap$5(self$1.poll, result => {
        switch (result._tag) {
          case `None`:
            return succeed$9(none$7())
          case `Some`:
            return pipe(forEachEffect(result.value, f$14), map$11(some$4))
        }
      }),
      interruptAsFork: id$2 => self$1.interruptAsFork(id$2),
    }
    return _fiber
  }),
  mapFiber$1 = dual(
    2,
    (self$1, f$14) =>
      map$11(self$1.await, match$8({ onFailure: cause$2 => failCause$4(cause$2), onSuccess: a$22 => f$14(a$22) })),
  ),
  match$3 = dual(
    2,
    (self$1, { onFiber, onRuntimeFiber }) => isRuntimeFiber$1(self$1) ? onRuntimeFiber(self$1) : onFiber(self$1),
  ),
  _never = {
    ...CommitPrototype$1,
    commit() {
      return join$4(this)
    },
    ...fiberProto,
    id: () => none$6,
    await: never$4,
    children: succeed$9([]),
    inheritAll: never$4,
    poll: succeed$9(none$7()),
    interruptAsFork: () => never$4,
  },
  never$3 = _never,
  orElse$5 = dual(2, (self$1, that) => ({
    ...CommitPrototype$1,
    commit() {
      return join$4(this)
    },
    ...fiberProto,
    id: () => getOrElse$1(self$1.id(), that.id()),
    await: zipWith$4(self$1.await, that.await, (exit1, exit2) => isSuccess$2(exit1) ? exit1 : exit2),
    children: self$1.children,
    inheritAll: zipRight$3(that.inheritAll, self$1.inheritAll),
    poll: zipWith$4(self$1.poll, that.poll, (option1, option2) => {
      switch (option1._tag) {
        case `None`:
          return none$7()
        case `Some`:
          return isSuccess$2(option1.value) ? option1 : option2
      }
    }),
    interruptAsFork: id$2 =>
      pipe(interruptAsFiber(self$1, id$2), zipRight$3(pipe(that, interruptAsFiber(id$2))), asVoid$3),
  })),
  orElseEither$2 = dual(2, (self$1, that) => orElse$5(map$8(self$1, left), map$8(that, right))),
  poll$1 = self$1 => self$1.poll,
  parseMs = milliseconds => {
    let roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil
    return {
      days: roundTowardsZero(milliseconds / 864e5),
      hours: roundTowardsZero(milliseconds / 36e5) % 24,
      minutes: roundTowardsZero(milliseconds / 6e4) % 60,
      seconds: roundTowardsZero(milliseconds / 1e3) % 60,
      milliseconds: roundTowardsZero(milliseconds) % 1e3,
      microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
      nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3,
    }
  },
  renderStatus = status$2 => {
    if (isDone$2(status$2)) return `Done`
    if (isRunning(status$2)) return `Running`
    let isInterruptible = interruptible$3(status$2.runtimeFlags) ? `interruptible` : `uninterruptible`
    return `Suspended(${isInterruptible})`
  },
  pretty$2 = self$1 =>
    flatMap$5(currentTimeMillis, now$1 =>
      map$11(dump$1(self$1), dump$2 => {
        let time = now$1 - dump$2.id.startTimeMillis,
          { days: days$1, hours: hours$1, milliseconds, minutes: minutes$1, seconds: seconds$1 } = parseMs(time),
          lifeMsg = (days$1 === 0 ? `` : `${days$1}d`) + (days$1 === 0 && hours$1 === 0 ? `` : `${hours$1}h`)
            + (days$1 === 0 && hours$1 === 0 && minutes$1 === 0 ? `` : `${minutes$1}m`)
            + (days$1 === 0 && hours$1 === 0 && minutes$1 === 0 && seconds$1 === 0 ? `` : `${seconds$1}s`)
            + `${milliseconds}ms`,
          waitMsg = isSuspended(dump$2.status)
            ? (() => {
              let ids$2 = ids(dump$2.status.blockingOn)
              return size$11(ids$2) > 0 ? `waiting on ` + Array.from(ids$2).map(id$2 => `${id$2}`).join(`, `) : ``
            })()
            : ``,
          statusMsg = renderStatus(dump$2.status)
        return `[Fiber](#${dump$2.id.id}) (${lifeMsg}) ${waitMsg}\n   Status: ${statusMsg}`
      })),
  unsafeRoots$1 = () => Array.from(globalScope.roots),
  roots$1 = sync$3(unsafeRoots$1),
  status$1 = self$1 => self$1.status,
  succeed$5 = value$2 => done$3(succeed$7(value$2)),
  void_$1 = succeed$5(void 0),
  currentFiberURI = `effect/FiberCurrent`,
  getCurrentFiber$1 = () => fromNullable$2(globalThis[currentFiberURI]),
  LoggerSymbolKey = `effect/Logger`,
  LoggerTypeId = Symbol.for(LoggerSymbolKey),
  loggerVariance = { _Message: _$1 => _$1, _Output: _$1 => _$1 },
  makeLogger = log$3 => ({
    [LoggerTypeId]: loggerVariance,
    log: log$3,
    pipe() {
      return pipeArguments(this, arguments)
    },
  }),
  map$7 = dual(2, (self$1, f$14) => makeLogger(options$2 => f$14(self$1.log(options$2)))),
  none$3 = {
    [LoggerTypeId]: loggerVariance,
    log: constVoid,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  textOnly = /^[^\s"=]*$/,
  format$2 =
    (quoteValue, whitespace$1) =>
    ({ annotations: annotations$2, cause: cause$2, date: date$1, fiberId: fiberId$2, logLevel, message, spans }) => {
      let formatValue$1 = value$2 => value$2.match(textOnly) ? value$2 : quoteValue(value$2),
        format$4 = (label, value$2) => `${formatLabel(label)}=${formatValue$1(value$2)}`,
        append$3 = (label, value$2) => ` ` + format$4(label, value$2),
        out = format$4(`timestamp`, date$1.toISOString())
      out += append$3(`level`, logLevel.label), out += append$3(`fiber`, threadName$1(fiberId$2))
      let messages = ensure(message)
      for (let i$14 = 0; i$14 < messages.length; i$14++) {
        out += append$3(`message`, toStringUnknown(messages[i$14], whitespace$1))
      }
      isEmptyType$1(cause$2) || (out += append$3(`cause`, pretty$3(cause$2, { renderErrorCause: !0 })))
      for (let span$1 of spans) out += ` ` + render$1(date$1.getTime())(span$1)
      for (let [label, value$2] of annotations$2) out += append$3(label, toStringUnknown(value$2, whitespace$1))
      return out
    },
  escapeDoubleQuotes = s$14 => `"${s$14.replace(/\\([\s\S])|(")/g, `\\$1$2`)}"`,
  stringLogger = makeLogger(format$2(escapeDoubleQuotes)),
  structuredLogger = makeLogger(
    ({ annotations: annotations$2, cause: cause$2, date: date$1, fiberId: fiberId$2, logLevel, message, spans }) => {
      let now$1 = date$1.getTime(), annotationsObj = {}, spansObj = {}
      if (size$10(annotations$2) > 0) for (let [k$1, v$4] of annotations$2) annotationsObj[k$1] = structuredMessage(v$4)
      if (isCons(spans)) for (let span$1 of spans) spansObj[span$1.label] = now$1 - span$1.startTime
      let messageArr = ensure(message)
      return {
        message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
        logLevel: logLevel.label,
        timestamp: date$1.toISOString(),
        cause: isEmpty$4(cause$2) ? void 0 : pretty$3(cause$2, { renderErrorCause: !0 }),
        annotations: annotationsObj,
        spans: spansObj,
        fiberId: threadName$1(fiberId$2),
      }
    },
  ),
  structuredMessage = u$7 => {
    switch (typeof u$7) {
      case `bigint`:
      case `function`:
      case `symbol`:
        return String(u$7)
      default:
        return toJSON(u$7)
    }
  },
  jsonLogger = map$7(structuredLogger, stringifyCircular),
  colors = {
    bold: `1`,
    red: `31`,
    green: `32`,
    yellow: `33`,
    blue: `34`,
    cyan: `36`,
    white: `37`,
    gray: `90`,
    black: `30`,
    bgBrightRed: `101`,
  },
  logLevelColors = {
    None: [],
    All: [],
    Trace: [colors.gray],
    Debug: [colors.blue],
    Info: [colors.green],
    Warning: [colors.yellow],
    Error: [colors.red],
    Fatal: [colors.bgBrightRed, colors.black],
  },
  hasProcessStdout = typeof process == `object` && process !== null && typeof process.stdout == `object`
    && process.stdout !== null,
  processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === !0,
  hasProcessStdoutOrDeno = hasProcessStdout || `Deno` in globalThis,
  MetricBoundariesSymbolKey = `effect/MetricBoundaries`,
  MetricBoundariesTypeId = Symbol.for(MetricBoundariesSymbolKey)
var MetricBoundariesImpl = class {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId
  constructor(values$6) {
    this.values = values$6, this._hash = pipe(string$4(MetricBoundariesSymbolKey), combine$11(array$1(this.values)))
  }
  _hash;
  [symbol$2]() {
    return this._hash
  }
  [symbol$1](u$7) {
    return isMetricBoundaries(u$7) && equals(this.values, u$7.values)
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const isMetricBoundaries = u$7 => hasProperty(u$7, MetricBoundariesTypeId),
  fromIterable$4 = iterable => {
    let values$6 = pipe(iterable, appendAll$2(of$3(1 / 0)), dedupe)
    return new MetricBoundariesImpl(values$6)
  },
  exponential = options$2 =>
    pipe(
      makeBy(options$2.count - 1, i$14 => options$2.start * options$2.factor ** +i$14),
      unsafeFromArray,
      fromIterable$4,
    ),
  MetricKeyTypeSymbolKey = `effect/MetricKeyType`,
  MetricKeyTypeTypeId = Symbol.for(MetricKeyTypeSymbolKey),
  CounterKeyTypeSymbolKey = `effect/MetricKeyType/Counter`,
  CounterKeyTypeTypeId = Symbol.for(CounterKeyTypeSymbolKey),
  FrequencyKeyTypeSymbolKey = `effect/MetricKeyType/Frequency`,
  FrequencyKeyTypeTypeId = Symbol.for(FrequencyKeyTypeSymbolKey),
  GaugeKeyTypeSymbolKey = `effect/MetricKeyType/Gauge`,
  GaugeKeyTypeTypeId = Symbol.for(GaugeKeyTypeSymbolKey),
  HistogramKeyTypeSymbolKey = `effect/MetricKeyType/Histogram`,
  HistogramKeyTypeTypeId = Symbol.for(HistogramKeyTypeSymbolKey),
  SummaryKeyTypeSymbolKey = `effect/MetricKeyType/Summary`,
  SummaryKeyTypeTypeId = Symbol.for(SummaryKeyTypeSymbolKey),
  metricKeyTypeVariance = { _In: _$1 => _$1, _Out: _$1 => _$1 }
var CounterKeyType = class {
  incremental
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId
  constructor(incremental, bigint$1) {
    this.incremental = incremental, this.bigint = bigint$1, this._hash = string$4(CounterKeyTypeSymbolKey)
  }
  _hash;
  [symbol$2]() {
    return this._hash
  }
  [symbol$1](that) {
    return isCounterKey(that)
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const FrequencyKeyTypeHash = string$4(FrequencyKeyTypeSymbolKey)
var FrequencyKeyType = class {
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords
  }
  [symbol$2]() {
    return FrequencyKeyTypeHash
  }
  [symbol$1](that) {
    return isFrequencyKey(that)
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const GaugeKeyTypeHash = string$4(GaugeKeyTypeSymbolKey)
var GaugeKeyType = class {
    bigint;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId
    constructor(bigint$1) {
      this.bigint = bigint$1
    }
    [symbol$2]() {
      return GaugeKeyTypeHash
    }
    [symbol$1](that) {
      return isGaugeKey(that)
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
  },
  HistogramKeyType = class {
    boundaries;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId
    constructor(boundaries) {
      this.boundaries = boundaries,
        this._hash = pipe(string$4(HistogramKeyTypeSymbolKey), combine$11(hash(this.boundaries)))
    }
    _hash;
    [symbol$2]() {
      return this._hash
    }
    [symbol$1](that) {
      return isHistogramKey(that) && equals(this.boundaries, that.boundaries)
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
  },
  SummaryKeyType = class {
    maxAge
    maxSize
    error
    quantiles;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId
    constructor(maxAge, maxSize, error, quantiles) {
      this.maxAge = maxAge,
        this.maxSize = maxSize,
        this.error = error,
        this.quantiles = quantiles,
        this._hash = pipe(
          string$4(SummaryKeyTypeSymbolKey),
          combine$11(hash(this.maxAge)),
          combine$11(hash(this.maxSize)),
          combine$11(hash(this.error)),
          combine$11(array$1(this.quantiles)),
        )
    }
    _hash;
    [symbol$2]() {
      return this._hash
    }
    [symbol$1](that) {
      return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize
        && this.error === that.error && equals(this.quantiles, that.quantiles)
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
  }
const counter$4 = options$2 => new CounterKeyType(options$2?.incremental ?? !1, options$2?.bigint ?? !1),
  histogram$4 = boundaries => new HistogramKeyType(boundaries),
  isCounterKey = u$7 => hasProperty(u$7, CounterKeyTypeTypeId),
  isFrequencyKey = u$7 => hasProperty(u$7, FrequencyKeyTypeTypeId),
  isGaugeKey = u$7 => hasProperty(u$7, GaugeKeyTypeTypeId),
  isHistogramKey = u$7 => hasProperty(u$7, HistogramKeyTypeTypeId),
  isSummaryKey = u$7 => hasProperty(u$7, SummaryKeyTypeTypeId),
  MetricKeySymbolKey = `effect/MetricKey`,
  MetricKeyTypeId = Symbol.for(MetricKeySymbolKey),
  metricKeyVariance = { _Type: _$1 => _$1 },
  arrayEquivilence = getEquivalence$3(equals)
var MetricKeyImpl = class {
  name
  keyType
  description
  tags;
  [MetricKeyTypeId] = metricKeyVariance
  constructor(name, keyType, description, tags$2 = []) {
    this.name = name,
      this.keyType = keyType,
      this.description = description,
      this.tags = tags$2,
      this._hash = pipe(
        string$4(this.name + this.description),
        combine$11(hash(this.keyType)),
        combine$11(array$1(this.tags)),
      )
  }
  _hash;
  [symbol$2]() {
    return this._hash
  }
  [symbol$1](u$7) {
    return isMetricKey(u$7) && this.name === u$7.name && equals(this.keyType, u$7.keyType)
      && equals(this.description, u$7.description) && arrayEquivilence(this.tags, u$7.tags)
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const isMetricKey = u$7 => hasProperty(u$7, MetricKeyTypeId),
  counter$3 = (name, options$2) =>
    new MetricKeyImpl(name, counter$4(options$2), fromNullable$2(options$2?.description)),
  histogram$3 = (name, boundaries, description) =>
    new MetricKeyImpl(name, histogram$4(boundaries), fromNullable$2(description)),
  taggedWithLabels$1 = dual(
    2,
    (self$1, extraTags) =>
      extraTags.length === 0
        ? self$1
        : new MetricKeyImpl(self$1.name, self$1.keyType, self$1.description, union$8(self$1.tags, extraTags)),
  ),
  MetricStateSymbolKey = `effect/MetricState`,
  MetricStateTypeId = Symbol.for(MetricStateSymbolKey),
  CounterStateSymbolKey = `effect/MetricState/Counter`,
  CounterStateTypeId = Symbol.for(CounterStateSymbolKey),
  FrequencyStateSymbolKey = `effect/MetricState/Frequency`,
  FrequencyStateTypeId = Symbol.for(FrequencyStateSymbolKey),
  GaugeStateSymbolKey = `effect/MetricState/Gauge`,
  GaugeStateTypeId = Symbol.for(GaugeStateSymbolKey),
  HistogramStateSymbolKey = `effect/MetricState/Histogram`,
  HistogramStateTypeId = Symbol.for(HistogramStateSymbolKey),
  SummaryStateSymbolKey = `effect/MetricState/Summary`,
  SummaryStateTypeId = Symbol.for(SummaryStateSymbolKey),
  metricStateVariance = { _A: _$1 => _$1 }
var CounterState = class {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId
  constructor(count$2) {
    this.count = count$2
  }
  [symbol$2]() {
    return pipe(hash(CounterStateSymbolKey), combine$11(hash(this.count)), cached$2(this))
  }
  [symbol$1](that) {
    return isCounterState(that) && this.count === that.count
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const arrayEquals = getEquivalence$3(equals)
var FrequencyState = class {
    occurrences;
    [MetricStateTypeId] = metricStateVariance;
    [FrequencyStateTypeId] = FrequencyStateTypeId
    constructor(occurrences) {
      this.occurrences = occurrences
    }
    _hash;
    [symbol$2]() {
      return pipe(
        string$4(FrequencyStateSymbolKey),
        combine$11(array$1(fromIterable$10(this.occurrences.entries()))),
        cached$2(this),
      )
    }
    [symbol$1](that) {
      return isFrequencyState(that)
        && arrayEquals(fromIterable$10(this.occurrences.entries()), fromIterable$10(that.occurrences.entries()))
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
  },
  GaugeState = class {
    value;
    [MetricStateTypeId] = metricStateVariance;
    [GaugeStateTypeId] = GaugeStateTypeId
    constructor(value$2) {
      this.value = value$2
    }
    [symbol$2]() {
      return pipe(hash(GaugeStateSymbolKey), combine$11(hash(this.value)), cached$2(this))
    }
    [symbol$1](u$7) {
      return isGaugeState(u$7) && this.value === u$7.value
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
  },
  HistogramState = class {
    buckets
    count
    min
    max
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [HistogramStateTypeId] = HistogramStateTypeId
    constructor(buckets, count$2, min$10, max$12, sum) {
      this.buckets = buckets, this.count = count$2, this.min = min$10, this.max = max$12, this.sum = sum
    }
    [symbol$2]() {
      return pipe(
        hash(HistogramStateSymbolKey),
        combine$11(hash(this.buckets)),
        combine$11(hash(this.count)),
        combine$11(hash(this.min)),
        combine$11(hash(this.max)),
        combine$11(hash(this.sum)),
        cached$2(this),
      )
    }
    [symbol$1](that) {
      return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count
        && this.min === that.min && this.max === that.max && this.sum === that.sum
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
  },
  SummaryState = class {
    error
    quantiles
    count
    min
    max
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [SummaryStateTypeId] = SummaryStateTypeId
    constructor(error, quantiles, count$2, min$10, max$12, sum) {
      this.error = error,
        this.quantiles = quantiles,
        this.count = count$2,
        this.min = min$10,
        this.max = max$12,
        this.sum = sum
    }
    [symbol$2]() {
      return pipe(
        hash(SummaryStateSymbolKey),
        combine$11(hash(this.error)),
        combine$11(hash(this.quantiles)),
        combine$11(hash(this.count)),
        combine$11(hash(this.min)),
        combine$11(hash(this.max)),
        combine$11(hash(this.sum)),
        cached$2(this),
      )
    }
    [symbol$1](that) {
      return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles)
        && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum
    }
    pipe() {
      return pipeArguments(this, arguments)
    }
  }
const counter$2 = count$2 => new CounterState(count$2),
  frequency$1 = occurrences => new FrequencyState(occurrences),
  gauge$1 = count$2 => new GaugeState(count$2),
  histogram$2 = options$2 =>
    new HistogramState(options$2.buckets, options$2.count, options$2.min, options$2.max, options$2.sum),
  summary$1 = options$2 =>
    new SummaryState(
      options$2.error,
      options$2.quantiles,
      options$2.count,
      options$2.min,
      options$2.max,
      options$2.sum,
    ),
  isCounterState = u$7 => hasProperty(u$7, CounterStateTypeId),
  isFrequencyState = u$7 => hasProperty(u$7, FrequencyStateTypeId),
  isGaugeState = u$7 => hasProperty(u$7, GaugeStateTypeId),
  isHistogramState = u$7 => hasProperty(u$7, HistogramStateTypeId),
  isSummaryState = u$7 => hasProperty(u$7, SummaryStateTypeId),
  MetricHookSymbolKey = `effect/MetricHook`,
  MetricHookTypeId = Symbol.for(MetricHookSymbolKey),
  metricHookVariance = { _In: _$1 => _$1, _Out: _$1 => _$1 },
  make$29 = options$2 => ({
    [MetricHookTypeId]: metricHookVariance,
    pipe() {
      return pipeArguments(this, arguments)
    },
    ...options$2,
  }),
  bigint0 = BigInt(0),
  counter$1 = key$1 => {
    let sum = key$1.keyType.bigint ? bigint0 : 0,
      canUpdate = key$1.keyType.incremental
        ? key$1.keyType.bigint ? value$2 => value$2 >= bigint0 : value$2 => value$2 >= 0
        : _value => !0,
      update$5 = value$2 => {
        canUpdate(value$2) && (sum += value$2)
      }
    return make$29({ get: () => counter$2(sum), update: update$5, modify: update$5 })
  },
  frequency = key$1 => {
    let values$6 = new Map()
    for (let word of key$1.keyType.preregisteredWords) values$6.set(word, 0)
    let update$5 = word => {
      let slotCount = values$6.get(word) ?? 0
      values$6.set(word, slotCount + 1)
    }
    return make$29({ get: () => frequency$1(values$6), update: update$5, modify: update$5 })
  },
  gauge = (_key, startAt) => {
    let value$2 = startAt
    return make$29({
      get: () => gauge$1(value$2),
      update: v$4 => {
        value$2 = v$4
      },
      modify: v$4 => {
        value$2 += v$4
      },
    })
  },
  histogram$1 = key$1 => {
    let bounds = key$1.keyType.boundaries.values,
      size$14 = bounds.length,
      values$6 = new Uint32Array(size$14 + 1),
      boundaries = new Float32Array(size$14),
      count$2 = 0,
      sum = 0,
      min$10 = Number.MAX_VALUE,
      max$12 = Number.MIN_VALUE
    pipe(
      bounds,
      sort(Order$4),
      map$17((n$19, i$14) => {
        boundaries[i$14] = n$19
      }),
    )
    let update$5 = value$2 => {
        let from = 0, to = size$14
        for (; from !== to;) {
          let mid = Math.floor(from + (to - from) / 2), boundary = boundaries[mid]
          value$2 <= boundary ? to = mid : from = mid,
            to === from + 1 && (value$2 <= boundaries[from] ? to = from : from = to)
        }
        values$6[from] = values$6[from] + 1,
          count$2 += 1,
          sum += value$2,
          value$2 < min$10 && (min$10 = value$2),
          value$2 > max$12 && (max$12 = value$2)
      },
      getBuckets = () => {
        let builder = allocate(size$14), cumulated = 0
        for (let i$14 = 0; i$14 < size$14; i$14++) {
          let boundary = boundaries[i$14], value$2 = values$6[i$14]
          cumulated += value$2, builder[i$14] = [boundary, cumulated]
        }
        return builder
      }
    return make$29({
      get: () => histogram$2({ buckets: getBuckets(), count: count$2, min: min$10, max: max$12, sum }),
      update: update$5,
      modify: update$5,
    })
  },
  summary = key$1 => {
    let { error, maxAge, maxSize, quantiles } = key$1.keyType,
      sortedQuantiles = pipe(quantiles, sort(Order$4)),
      values$6 = allocate(maxSize),
      head$5 = 0,
      count$2 = 0,
      sum = 0,
      min$10 = 0,
      max$12 = 0,
      snapshot$1 = now$1 => {
        let builder = [], i$14 = 0
        for (; i$14 !== maxSize - 1;) {
          let item = values$6[i$14]
          if (item != null) {
            let [t$18, v$4] = item, age = millis(now$1 - t$18)
            greaterThanOrEqualTo(age, zero) && lessThanOrEqualTo(age, maxAge) && builder.push(v$4)
          }
          i$14 += 1
        }
        return calculateQuantiles(error, sortedQuantiles, sort(builder, Order$4))
      },
      observe = (value$2, timestamp) => {
        if (maxSize > 0) {
          head$5 += 1
          let target = head$5 % maxSize
          values$6[target] = [timestamp, value$2]
        }
        min$10 = count$2 === 0 ? value$2 : Math.min(min$10, value$2),
          max$12 = count$2 === 0 ? value$2 : Math.max(max$12, value$2),
          count$2 += 1,
          sum += value$2
      }
    return make$29({
      get: () => summary$1({ error, quantiles: snapshot$1(Date.now()), count: count$2, min: min$10, max: max$12, sum }),
      update: ([value$2, timestamp]) => observe(value$2, timestamp),
      modify: ([value$2, timestamp]) => observe(value$2, timestamp),
    })
  },
  calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
    let sampleCount = sortedSamples.length
    if (!isNonEmptyReadonlyArray(sortedQuantiles)) return empty$35()
    let head$5 = sortedQuantiles[0],
      tail = sortedQuantiles.slice(1),
      resolvedHead = resolveQuantile(error, sampleCount, none$7(), 0, head$5, sortedSamples),
      resolved = of$4(resolvedHead)
    return tail.forEach(quantile => {
      resolved.push(
        resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest),
      )
    }),
      map$17(resolved, rq => [rq.quantile, rq.value])
  },
  resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
    let error_1 = error,
      sampleCount_1 = sampleCount,
      current_1 = current,
      consumed_1 = consumed,
      quantile_1 = quantile,
      rest_1 = rest,
      error_2 = error,
      sampleCount_2 = sampleCount,
      current_2 = current,
      consumed_2 = consumed,
      quantile_2 = quantile,
      rest_2 = rest
    for (;;) {
      if (!isNonEmptyReadonlyArray(rest_1)) {
        return { quantile: quantile_1, value: none$7(), consumed: consumed_1, rest: [] }
      }
      if (quantile_1 === 1) {
        return {
          quantile: quantile_1,
          value: some$4(lastNonEmpty(rest_1)),
          consumed: consumed_1 + rest_1.length,
          rest: [],
        }
      }
      let headValue = headNonEmpty$1(rest_1),
        sameHead = span(rest_1, n$19 => n$19 === headValue),
        desired = quantile_1 * sampleCount_1,
        allowedError = error_1 / 2 * desired,
        candConsumed = consumed_1 + sameHead[0].length,
        candError = Math.abs(candConsumed - desired)
      if (candConsumed < desired - allowedError) {
        error_2 = error_1,
          sampleCount_2 = sampleCount_1,
          current_2 = head$4(rest_1),
          consumed_2 = candConsumed,
          quantile_2 = quantile_1,
          rest_2 = sameHead[1],
          error_1 = error_2,
          sampleCount_1 = sampleCount_2,
          current_1 = current_2,
          consumed_1 = consumed_2,
          quantile_1 = quantile_2,
          rest_1 = rest_2
        continue
      }
      if (candConsumed > desired + allowedError) {
        let valueToReturn = isNone$2(current_1) ? some$4(headValue) : current_1
        return { quantile: quantile_1, value: valueToReturn, consumed: consumed_1, rest: rest_1 }
      }
      switch (current_1._tag) {
        case `None`:
          error_2 = error_1,
            sampleCount_2 = sampleCount_1,
            current_2 = head$4(rest_1),
            consumed_2 = candConsumed,
            quantile_2 = quantile_1,
            rest_2 = sameHead[1],
            error_1 = error_2,
            sampleCount_1 = sampleCount_2,
            current_1 = current_2,
            consumed_1 = consumed_2,
            quantile_1 = quantile_2,
            rest_1 = rest_2
          continue
        case `Some`: {
          let prevError = Math.abs(desired - current_1.value)
          if (candError < prevError) {
            error_2 = error_1,
              sampleCount_2 = sampleCount_1,
              current_2 = head$4(rest_1),
              consumed_2 = candConsumed,
              quantile_2 = quantile_1,
              rest_2 = sameHead[1],
              error_1 = error_2,
              sampleCount_1 = sampleCount_2,
              current_1 = current_2,
              consumed_1 = consumed_2,
              quantile_1 = quantile_2,
              rest_1 = rest_2
            continue
          }
          return { quantile: quantile_1, value: some$4(current_1.value), consumed: consumed_1, rest: rest_1 }
        }
      }
    }
    throw Error(
      `BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues`,
    )
  },
  MetricPairSymbolKey = `effect/MetricPair`,
  MetricPairTypeId = Symbol.for(MetricPairSymbolKey),
  metricPairVariance = { _Type: _$1 => _$1 },
  unsafeMake = (metricKey, metricState) => ({
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments)
    },
  }),
  MetricRegistrySymbolKey = `effect/MetricRegistry`,
  MetricRegistryTypeId = Symbol.for(MetricRegistrySymbolKey)
var MetricRegistryImpl = class {
  [MetricRegistryTypeId] = MetricRegistryTypeId
  map = empty$16()
  snapshot() {
    let result = []
    for (let [key$1, hook] of this.map) result.push(unsafeMake(key$1, hook.get()))
    return result
  }
  get(key$1) {
    let hook = pipe(this.map, get$4(key$1), getOrUndefined)
    if (hook == null) {
      if (isCounterKey(key$1.keyType)) return this.getCounter(key$1)
      if (isGaugeKey(key$1.keyType)) return this.getGauge(key$1)
      if (isFrequencyKey(key$1.keyType)) return this.getFrequency(key$1)
      if (isHistogramKey(key$1.keyType)) return this.getHistogram(key$1)
      if (isSummaryKey(key$1.keyType)) return this.getSummary(key$1)
      throw Error(
        `BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues`,
      )
    } else return hook
  }
  getCounter(key$1) {
    let value$2 = pipe(this.map, get$4(key$1), getOrUndefined)
    if (value$2 == null) {
      let counter$5 = counter$1(key$1)
      pipe(this.map, has$2(key$1)) || pipe(this.map, set$2(key$1, counter$5)), value$2 = counter$5
    }
    return value$2
  }
  getFrequency(key$1) {
    let value$2 = pipe(this.map, get$4(key$1), getOrUndefined)
    if (value$2 == null) {
      let frequency$2 = frequency(key$1)
      pipe(this.map, has$2(key$1)) || pipe(this.map, set$2(key$1, frequency$2)), value$2 = frequency$2
    }
    return value$2
  }
  getGauge(key$1) {
    let value$2 = pipe(this.map, get$4(key$1), getOrUndefined)
    if (value$2 == null) {
      let gauge$2 = gauge(key$1, key$1.keyType.bigint ? BigInt(0) : 0)
      pipe(this.map, has$2(key$1)) || pipe(this.map, set$2(key$1, gauge$2)), value$2 = gauge$2
    }
    return value$2
  }
  getHistogram(key$1) {
    let value$2 = pipe(this.map, get$4(key$1), getOrUndefined)
    if (value$2 == null) {
      let histogram$5 = histogram$1(key$1)
      pipe(this.map, has$2(key$1)) || pipe(this.map, set$2(key$1, histogram$5)), value$2 = histogram$5
    }
    return value$2
  }
  getSummary(key$1) {
    let value$2 = pipe(this.map, get$4(key$1), getOrUndefined)
    if (value$2 == null) {
      let summary$2 = summary(key$1)
      pipe(this.map, has$2(key$1)) || pipe(this.map, set$2(key$1, summary$2)), value$2 = summary$2
    }
    return value$2
  }
}
const make$28 = () => new MetricRegistryImpl(),
  MetricSymbolKey = `effect/Metric`,
  MetricTypeId = Symbol.for(MetricSymbolKey),
  metricVariance = { _Type: _$1 => _$1, _In: _$1 => _$1, _Out: _$1 => _$1 },
  globalMetricRegistry = globalValue(Symbol.for(`effect/Metric/globalMetricRegistry`), () => make$28()),
  make$27 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
    let metric = Object.assign(effect => tap$1(effect, a$22 => update$1(metric, a$22)), {
      [MetricTypeId]: metricVariance,
      keyType,
      unsafeUpdate,
      unsafeValue,
      unsafeModify,
      register() {
        return this.unsafeValue([]), this
      },
      pipe() {
        return pipeArguments(this, arguments)
      },
    })
    return metric
  },
  counter = (name, options$2) => fromMetricKey(counter$3(name, options$2)),
  fromMetricKey = key$1 => {
    let untaggedHook,
      hookCache = new WeakMap(),
      hook = extraTags => {
        if (extraTags.length === 0) {
          return untaggedHook === void 0 && (untaggedHook = globalMetricRegistry.get(key$1)), untaggedHook
        }
        let hook$1 = hookCache.get(extraTags)
        return hook$1 === void 0
          ? (hook$1 = globalMetricRegistry.get(taggedWithLabels$1(key$1, extraTags)),
            hookCache.set(extraTags, hook$1),
            hook$1)
          : hook$1
      }
    return make$27(
      key$1.keyType,
      (input, extraTags) => hook(extraTags).update(input),
      extraTags => hook(extraTags).get(),
      (input, extraTags) => hook(extraTags).modify(input),
    )
  },
  histogram = (name, boundaries, description) => fromMetricKey(histogram$3(name, boundaries, description)),
  tagged$2 = dual(3, (self$1, key$1, value$2) => taggedWithLabels(self$1, [make$30(key$1, value$2)])),
  taggedWithLabels = dual(
    2,
    (self$1, extraTags) =>
      make$27(
        self$1.keyType,
        (input, extraTags1) => self$1.unsafeUpdate(input, union$8(extraTags, extraTags1)),
        extraTags1 => self$1.unsafeValue(union$8(extraTags, extraTags1)),
        (input, extraTags1) => self$1.unsafeModify(input, union$8(extraTags, extraTags1)),
      ),
  ),
  update$1 = dual(
    2,
    (self$1, input) => fiberRefGetWith(currentMetricLabels, tags$2 => sync$3(() => self$1.unsafeUpdate(input, tags$2))),
  ),
  RequestSymbolKey = `effect/Request`,
  RequestTypeId$1 = Symbol.for(RequestSymbolKey),
  requestVariance = { _E: _$1 => _$1, _A: _$1 => _$1 },
  RequestPrototype = { ...StructuralPrototype, [RequestTypeId$1]: requestVariance },
  isRequest$1 = u$7 => hasProperty(u$7, RequestTypeId$1),
  of$1 = () => args$1 => Object.assign(Object.create(RequestPrototype), args$1),
  tagged$1 = tag$3 => args$1 => {
    let request$1 = Object.assign(Object.create(RequestPrototype), args$1)
    return request$1._tag = tag$3, request$1
  },
  Class$3 = function() {
    function Class$6(args$1) {
      args$1 && Object.assign(this, args$1)
    }
    return Class$6.prototype = RequestPrototype, Class$6
  }(),
  TaggedClass$2 = tag$3 =>
    class extends Class$3 {
      _tag = tag$3
    },
  complete$2 = dual(2, (self$1, result) =>
    fiberRefGetWith(currentRequestMap, map$20 =>
      sync$3(() => {
        if (map$20.has(self$1)) {
          let entry = map$20.get(self$1)
          entry.state.completed || (entry.state.completed = !0, deferredUnsafeDone(entry.result, result))
        }
      }))),
  completeEffect$1 = dual(
    2,
    (self$1, effect) =>
      matchEffect$2(effect, {
        onFailure: error => complete$2(self$1, exitFail(error)),
        onSuccess: value$2 => complete$2(self$1, exitSucceed$1(value$2)),
      }),
  ),
  fail$5 = dual(2, (self$1, error) => complete$2(self$1, exitFail(error))),
  failCause$3 = dual(2, (self$1, cause$2) => complete$2(self$1, exitFailCause$1(cause$2))),
  succeed$4 = dual(2, (self$1, value$2) => complete$2(self$1, exitSucceed$1(value$2)))
var Listeners = class {
  count = 0
  observers = new Set()
  interrupted = !1
  addObserver(f$14) {
    this.observers.add(f$14)
  }
  removeObserver(f$14) {
    this.observers.delete(f$14)
  }
  increment() {
    this.count++, this.observers.forEach(f$14 => f$14(this.count))
  }
  decrement() {
    this.count--, this.observers.forEach(f$14 => f$14(this.count))
  }
}
const Direction$1 = { Forward: 0, Backward: 1 }
var RedBlackTreeIterator = class RedBlackTreeIterator {
  self
  stack
  direction
  count = 0
  constructor(self$1, stack, direction) {
    this.self = self$1, this.stack = stack, this.direction = direction
  }
  clone() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction)
  }
  reversed() {
    return new RedBlackTreeIterator(
      this.self,
      this.stack.slice(),
      this.direction === Direction$1.Forward ? Direction$1.Backward : Direction$1.Forward,
    )
  }
  next() {
    let entry = this.entry
    switch (this.count++, this.direction === Direction$1.Forward ? this.moveNext() : this.movePrev(), entry._tag) {
      case `None`:
        return { done: !0, value: this.count }
      case `Some`:
        return { done: !1, value: entry.value }
    }
  }
  get key() {
    return this.stack.length > 0 ? some$4(this.stack[this.stack.length - 1].key) : none$7()
  }
  get value() {
    return this.stack.length > 0 ? some$4(this.stack[this.stack.length - 1].value) : none$7()
  }
  get entry() {
    return map$18(last$2(this.stack), node$1 => [node$1.key, node$1.value])
  }
  get index() {
    let idx = 0, stack = this.stack
    if (stack.length === 0) {
      let r$26 = this.self._root
      return r$26 == null ? 0 : r$26.count
    } else stack[stack.length - 1].left != null && (idx = stack[stack.length - 1].left.count)
    for (let s$14 = stack.length - 2; s$14 >= 0; --s$14) {
      stack[s$14 + 1] === stack[s$14].right && (++idx, stack[s$14].left != null && (idx += stack[s$14].left.count))
    }
    return idx
  }
  moveNext() {
    let stack = this.stack
    if (stack.length === 0) return
    let n$19 = stack[stack.length - 1]
    if (n$19.right != null) for (n$19 = n$19.right; n$19 != null;) stack.push(n$19), n$19 = n$19.left
    else {for (stack.pop(); stack.length > 0 && stack[stack.length - 1].right === n$19;) {
        n$19 = stack[stack.length - 1], stack.pop()
      }}
  }
  get hasNext() {
    let stack = this.stack
    if (stack.length === 0) return !1
    if (stack[stack.length - 1].right != null) return !0
    for (let s$14 = stack.length - 1; s$14 > 0; --s$14) if (stack[s$14 - 1].left === stack[s$14]) return !0
    return !1
  }
  movePrev() {
    let stack = this.stack
    if (stack.length === 0) return
    let n$19 = stack[stack.length - 1]
    if (n$19 != null && n$19.left != null) for (n$19 = n$19.left; n$19 != null;) stack.push(n$19), n$19 = n$19.right
    else {for (stack.pop(); stack.length > 0 && stack[stack.length - 1].left === n$19;) {
        n$19 = stack[stack.length - 1], stack.pop()
      }}
  }
  get hasPrev() {
    let stack = this.stack
    if (stack.length === 0) return !1
    if (stack[stack.length - 1].left != null) return !0
    for (let s$14 = stack.length - 1; s$14 > 0; --s$14) if (stack[s$14 - 1].right === stack[s$14]) return !0
    return !1
  }
}
const Color = { Red: 0, Black: 1 },
  clone = ({ color: color$1, count: count$2, key: key$1, left: left$2, right: right$2, value: value$2 }) => ({
    color: color$1,
    key: key$1,
    value: value$2,
    left: left$2,
    right: right$2,
    count: count$2,
  })
function swap(n$19, v$4) {
  n$19.key = v$4.key,
    n$19.value = v$4.value,
    n$19.left = v$4.left,
    n$19.right = v$4.right,
    n$19.color = v$4.color,
    n$19.count = v$4.count
}
const repaint = ({ count: count$2, key: key$1, left: left$2, right: right$2, value: value$2 }, color$1) => ({
    color: color$1,
    key: key$1,
    value: value$2,
    left: left$2,
    right: right$2,
    count: count$2,
  }),
  recount = node$1 => {
    node$1.count = 1 + (node$1.left?.count ?? 0) + (node$1.right?.count ?? 0)
  },
  RedBlackTreeSymbolKey = `effect/RedBlackTree`,
  RedBlackTreeTypeId = Symbol.for(RedBlackTreeSymbolKey),
  redBlackTreeVariance = { _Key: _$1 => _$1, _Value: _$1 => _$1 },
  RedBlackTreeProto = {
    [RedBlackTreeTypeId]: redBlackTreeVariance,
    [symbol$2]() {
      let hash$1 = hash(RedBlackTreeSymbolKey)
      for (let item of this) hash$1 ^= pipe(hash(item[0]), combine$11(hash(item[1])))
      return cached$2(this, hash$1)
    },
    [symbol$1](that) {
      if (isRedBlackTree$1(that)) {
        if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) return !1
        let entries$2 = Array.from(that)
        return Array.from(this).every((itemSelf, i$14) => {
          let itemThat = entries$2[i$14]
          return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1])
        })
      }
      return !1
    },
    [Symbol.iterator]() {
      let stack = [], n$19 = this._root
      for (; n$19 != null;) stack.push(n$19), n$19 = n$19.left
      return new RedBlackTreeIterator(this, stack, Direction$1.Forward)
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `RedBlackTree`, values: Array.from(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  makeImpl = (ord, root$5) => {
    let tree = Object.create(RedBlackTreeProto)
    return tree._ord = ord, tree._root = root$5, tree
  },
  isRedBlackTree$1 = u$7 => hasProperty(u$7, RedBlackTreeTypeId),
  empty$9 = ord => makeImpl(ord, void 0),
  fromIterable$3 = dual(2, (entries$2, ord) => {
    let tree = empty$9(ord)
    for (let [key$1, value$2] of entries$2) tree = insert$1(tree, key$1, value$2)
    return tree
  }),
  make$26 = ord => (...entries$2) => fromIterable$3(entries$2, ord),
  atBackwards = dual(2, (self$1, index$4) => at$1(self$1, index$4, Direction$1.Backward)),
  atForwards = dual(2, (self$1, index$4) => at$1(self$1, index$4, Direction$1.Forward)),
  at$1 = (self$1, index$4, direction) => ({
    [Symbol.iterator]: () => {
      if (index$4 < 0) return new RedBlackTreeIterator(self$1, [], direction)
      let node$1 = self$1._root, stack = []
      for (; node$1 !== void 0;) {
        if (stack.push(node$1), node$1.left !== void 0) {
          if (index$4 < node$1.left.count) {
            node$1 = node$1.left
            continue
          }
          index$4 -= node$1.left.count
        }
        if (!index$4) return new RedBlackTreeIterator(self$1, stack, direction)
        if (--index$4, node$1.right !== void 0) {
          if (index$4 >= node$1.right.count) break
          node$1 = node$1.right
        } else break
      }
      return new RedBlackTreeIterator(self$1, [], direction)
    },
  }),
  findAll$1 = dual(2, (self$1, key$1) => {
    let stack = [], node$1 = self$1._root, result = empty$32()
    for (; node$1 !== void 0 || stack.length > 0;) {
      if (node$1) stack.push(node$1), node$1 = node$1.left
      else {
        let current = stack.pop()
        equals(key$1, current.key) && (result = prepend$1(current.value)(result)), node$1 = current.right
      }
    }
    return result
  }),
  findFirst$2 = dual(2, (self$1, key$1) => {
    let cmp = self$1._ord, node$1 = self$1._root
    for (; node$1 !== void 0;) {
      let d$7 = cmp(key$1, node$1.key)
      if (equals(key$1, node$1.key)) return some$4(node$1.value)
      node$1 = d$7 <= 0 ? node$1.left : node$1.right
    }
    return none$7()
  }),
  first$1 = self$1 => {
    let node$1 = self$1._root, current = self$1._root
    for (; node$1 !== void 0;) current = node$1, node$1 = node$1.left
    return current ? some$4([current.key, current.value]) : none$7()
  },
  getAt$1 = dual(2, (self$1, index$4) => {
    if (index$4 < 0) return none$7()
    let root$5 = self$1._root, node$1
    for (; root$5 !== void 0;) {
      if (node$1 = root$5, root$5.left) {
        if (index$4 < root$5.left.count) {
          root$5 = root$5.left
          continue
        }
        index$4 -= root$5.left.count
      }
      if (!index$4) return some$4([node$1.key, node$1.value])
      if (--index$4, root$5.right) {
        if (index$4 >= root$5.right.count) break
        root$5 = root$5.right
      } else break
    }
    return none$7()
  }),
  getOrder$2 = tree => tree._ord,
  has$1 = dual(2, (self$1, key$1) => isSome(findFirst$2(self$1, key$1))),
  insert$1 = dual(3, (self$1, key$1, value$2) => {
    let cmp = self$1._ord, n$19 = self$1._root, n_stack = [], d_stack = []
    for (; n$19 != null;) {
      let d$7 = cmp(key$1, n$19.key)
      n_stack.push(n$19), d_stack.push(d$7), n$19 = d$7 <= 0 ? n$19.left : n$19.right
    }
    n_stack.push({ color: Color.Red, key: key$1, value: value$2, left: void 0, right: void 0, count: 1 })
    for (let s$14 = n_stack.length - 2; s$14 >= 0; --s$14) {
      let n2 = n_stack[s$14]
      d_stack[s$14] <= 0
        ? n_stack[s$14] = {
          color: n2.color,
          key: n2.key,
          value: n2.value,
          left: n_stack[s$14 + 1],
          right: n2.right,
          count: n2.count + 1,
        }
        : n_stack[s$14] = {
          color: n2.color,
          key: n2.key,
          value: n2.value,
          left: n2.left,
          right: n_stack[s$14 + 1],
          count: n2.count + 1,
        }
    }
    for (let s$14 = n_stack.length - 1; s$14 > 1; --s$14) {
      let p$25 = n_stack[s$14 - 1], n3 = n_stack[s$14]
      if (p$25.color === Color.Black || n3.color === Color.Black) break
      let pp = n_stack[s$14 - 2]
      if (pp.left === p$25) {
        if (p$25.left === n3) {
          let y$3 = pp.right
          if (y$3 && y$3.color === Color.Red) {
            p$25.color = Color.Black, pp.right = repaint(y$3, Color.Black), pp.color = Color.Red, --s$14
          } else {
            if (
              pp.color = Color.Red,
                pp.left = p$25.right,
                p$25.color = Color.Black,
                p$25.right = pp,
                n_stack[s$14 - 2] = p$25,
                n_stack[s$14 - 1] = n3,
                recount(pp),
                recount(p$25),
                s$14 >= 3
            ) {
              let ppp = n_stack[s$14 - 3]
              ppp.left === pp ? ppp.left = p$25 : ppp.right = p$25
            }
            break
          }
        } else {
          let y$3 = pp.right
          if (y$3 && y$3.color === Color.Red) {
            p$25.color = Color.Black, pp.right = repaint(y$3, Color.Black), pp.color = Color.Red, --s$14
          } else {
            if (
              p$25.right = n3.left,
                pp.color = Color.Red,
                pp.left = n3.right,
                n3.color = Color.Black,
                n3.left = p$25,
                n3.right = pp,
                n_stack[s$14 - 2] = n3,
                n_stack[s$14 - 1] = p$25,
                recount(pp),
                recount(p$25),
                recount(n3),
                s$14 >= 3
            ) {
              let ppp = n_stack[s$14 - 3]
              ppp.left === pp ? ppp.left = n3 : ppp.right = n3
            }
            break
          }
        }
      } else if (p$25.right === n3) {
        let y$3 = pp.left
        if (y$3 && y$3.color === Color.Red) {
          p$25.color = Color.Black, pp.left = repaint(y$3, Color.Black), pp.color = Color.Red, --s$14
        } else {
          if (
            pp.color = Color.Red,
              pp.right = p$25.left,
              p$25.color = Color.Black,
              p$25.left = pp,
              n_stack[s$14 - 2] = p$25,
              n_stack[s$14 - 1] = n3,
              recount(pp),
              recount(p$25),
              s$14 >= 3
          ) {
            let ppp = n_stack[s$14 - 3]
            ppp.right === pp ? ppp.right = p$25 : ppp.left = p$25
          }
          break
        }
      } else {
        let y$3 = pp.left
        if (y$3 && y$3.color === Color.Red) {
          p$25.color = Color.Black, pp.left = repaint(y$3, Color.Black), pp.color = Color.Red, --s$14
        } else {
          if (
            p$25.left = n3.right,
              pp.color = Color.Red,
              pp.right = n3.left,
              n3.color = Color.Black,
              n3.right = p$25,
              n3.left = pp,
              n_stack[s$14 - 2] = n3,
              n_stack[s$14 - 1] = p$25,
              recount(pp),
              recount(p$25),
              recount(n3),
              s$14 >= 3
          ) {
            let ppp = n_stack[s$14 - 3]
            ppp.right === pp ? ppp.right = n3 : ppp.left = n3
          }
          break
        }
      }
    }
    return n_stack[0].color = Color.Black, makeImpl(self$1._ord, n_stack[0])
  }),
  keysForward = self$1 => keys$2(self$1, Direction$1.Forward),
  keysBackward = self$1 => keys$2(self$1, Direction$1.Backward),
  keys$2 = (self$1, direction) => {
    let begin = self$1[Symbol.iterator](), count$2 = 0
    return {
      [Symbol.iterator]: () => keys$2(self$1, direction),
      next: () => {
        count$2++
        let entry = begin.key
        switch (direction === Direction$1.Forward ? begin.moveNext() : begin.movePrev(), entry._tag) {
          case `None`:
            return { done: !0, value: count$2 }
          case `Some`:
            return { done: !1, value: entry.value }
        }
      },
    }
  },
  last$1 = self$1 => {
    let node$1 = self$1._root, current = self$1._root
    for (; node$1 !== void 0;) current = node$1, node$1 = node$1.right
    return current ? some$4([current.key, current.value]) : none$7()
  },
  reversed$1 = self$1 => ({
    [Symbol.iterator]: () => {
      let stack = [], node$1 = self$1._root
      for (; node$1 !== void 0;) stack.push(node$1), node$1 = node$1.right
      return new RedBlackTreeIterator(self$1, stack, Direction$1.Backward)
    },
  }),
  greaterThanBackwards = dual(2, (self$1, key$1) => greaterThan$7(self$1, key$1, Direction$1.Backward)),
  greaterThanForwards = dual(2, (self$1, key$1) => greaterThan$7(self$1, key$1, Direction$1.Forward)),
  greaterThan$7 = (self$1, key$1, direction) => ({
    [Symbol.iterator]: () => {
      let cmp = self$1._ord, node$1 = self$1._root, stack = [], last_ptr = 0
      for (; node$1 !== void 0;) {
        let d$7 = cmp(key$1, node$1.key)
        stack.push(node$1), d$7 < 0 && (last_ptr = stack.length), node$1 = d$7 < 0 ? node$1.left : node$1.right
      }
      return stack.length = last_ptr, new RedBlackTreeIterator(self$1, stack, direction)
    },
  }),
  greaterThanEqualBackwards = dual(2, (self$1, key$1) => greaterThanEqual$1(self$1, key$1, Direction$1.Backward)),
  greaterThanEqualForwards = dual(2, (self$1, key$1) => greaterThanEqual$1(self$1, key$1, Direction$1.Forward)),
  greaterThanEqual$1 = (self$1, key$1, direction = Direction$1.Forward) => ({
    [Symbol.iterator]: () => {
      let cmp = self$1._ord, node$1 = self$1._root, stack = [], last_ptr = 0
      for (; node$1 !== void 0;) {
        let d$7 = cmp(key$1, node$1.key)
        stack.push(node$1), d$7 <= 0 && (last_ptr = stack.length), node$1 = d$7 <= 0 ? node$1.left : node$1.right
      }
      return stack.length = last_ptr, new RedBlackTreeIterator(self$1, stack, direction)
    },
  }),
  lessThanBackwards = dual(2, (self$1, key$1) => lessThan$11(self$1, key$1, Direction$1.Backward)),
  lessThanForwards = dual(2, (self$1, key$1) => lessThan$11(self$1, key$1, Direction$1.Forward)),
  lessThan$11 = (self$1, key$1, direction) => ({
    [Symbol.iterator]: () => {
      let cmp = self$1._ord, node$1 = self$1._root, stack = [], last_ptr = 0
      for (; node$1 !== void 0;) {
        let d$7 = cmp(key$1, node$1.key)
        stack.push(node$1), d$7 > 0 && (last_ptr = stack.length), node$1 = d$7 <= 0 ? node$1.left : node$1.right
      }
      return stack.length = last_ptr, new RedBlackTreeIterator(self$1, stack, direction)
    },
  }),
  lessThanEqualBackwards = dual(2, (self$1, key$1) => lessThanEqual$1(self$1, key$1, Direction$1.Backward)),
  lessThanEqualForwards = dual(2, (self$1, key$1) => lessThanEqual$1(self$1, key$1, Direction$1.Forward)),
  lessThanEqual$1 = (self$1, key$1, direction) => ({
    [Symbol.iterator]: () => {
      let cmp = self$1._ord, node$1 = self$1._root, stack = [], last_ptr = 0
      for (; node$1 !== void 0;) {
        let d$7 = cmp(key$1, node$1.key)
        stack.push(node$1), d$7 >= 0 && (last_ptr = stack.length), node$1 = d$7 < 0 ? node$1.left : node$1.right
      }
      return stack.length = last_ptr, new RedBlackTreeIterator(self$1, stack, direction)
    },
  }),
  forEach$3 = dual(2, (self$1, f$14) => {
    let root$5 = self$1._root
    root$5 !== void 0 && visitFull(root$5, (key$1, value$2) => (f$14(key$1, value$2), none$7()))
  }),
  forEachGreaterThanEqual$1 = dual(3, (self$1, min$10, f$14) => {
    let root$5 = self$1._root, ord = self$1._ord
    root$5 !== void 0
      && visitGreaterThanEqual(root$5, min$10, ord, (key$1, value$2) => (f$14(key$1, value$2), none$7()))
  }),
  forEachLessThan$1 = dual(3, (self$1, max$12, f$14) => {
    let root$5 = self$1._root, ord = self$1._ord
    root$5 !== void 0 && visitLessThan(root$5, max$12, ord, (key$1, value$2) => (f$14(key$1, value$2), none$7()))
  }),
  forEachBetween$1 = dual(2, (self$1, { body: body$2, max: max$12, min: min$10 }) => {
    let root$5 = self$1._root, ord = self$1._ord
    root$5 && visitBetween(root$5, min$10, max$12, ord, (key$1, value$2) => (body$2(key$1, value$2), none$7()))
  }),
  reduce$3 = dual(3, (self$1, zero$1, f$14) => {
    let accumulator = zero$1
    for (let entry of self$1) accumulator = f$14(accumulator, entry[1], entry[0])
    return accumulator
  }),
  removeFirst$1 = dual(2, (self$1, key$1) => {
    if (!has$1(self$1, key$1)) return self$1
    let ord = self$1._ord, cmp = ord, node$1 = self$1._root, stack = []
    for (; node$1 !== void 0;) {
      let d$7 = cmp(key$1, node$1.key)
      stack.push(node$1), node$1 = equals(key$1, node$1.key) ? void 0 : d$7 <= 0 ? node$1.left : node$1.right
    }
    if (stack.length === 0) return self$1
    let cstack = Array(stack.length), n$19 = stack[stack.length - 1]
    cstack[cstack.length - 1] = {
      color: n$19.color,
      key: n$19.key,
      value: n$19.value,
      left: n$19.left,
      right: n$19.right,
      count: n$19.count,
    }
    for (let i$14 = stack.length - 2; i$14 >= 0; --i$14) {
      n$19 = stack[i$14],
        n$19.left === stack[i$14 + 1]
          ? cstack[i$14] = {
            color: n$19.color,
            key: n$19.key,
            value: n$19.value,
            left: cstack[i$14 + 1],
            right: n$19.right,
            count: n$19.count,
          }
          : cstack[i$14] = {
            color: n$19.color,
            key: n$19.key,
            value: n$19.value,
            left: n$19.left,
            right: cstack[i$14 + 1],
            count: n$19.count,
          }
    }
    if (n$19 = cstack[cstack.length - 1], n$19.left !== void 0 && n$19.right !== void 0) {
      let split = cstack.length
      for (n$19 = n$19.left; n$19.right != null;) cstack.push(n$19), n$19 = n$19.right
      let v$4 = cstack[split - 1]
      cstack.push({
        color: n$19.color,
        key: v$4.key,
        value: v$4.value,
        left: n$19.left,
        right: n$19.right,
        count: n$19.count,
      }),
        cstack[split - 1].key = n$19.key,
        cstack[split - 1].value = n$19.value
      for (let i$14 = cstack.length - 2; i$14 >= split; --i$14) {
        n$19 = cstack[i$14],
          cstack[i$14] = {
            color: n$19.color,
            key: n$19.key,
            value: n$19.value,
            left: n$19.left,
            right: cstack[i$14 + 1],
            count: n$19.count,
          }
      }
      cstack[split - 1].left = cstack[split]
    }
    if (n$19 = cstack[cstack.length - 1], n$19.color === Color.Red) {
      let p$25 = cstack[cstack.length - 2]
      p$25.left === n$19 ? p$25.left = void 0 : p$25.right === n$19 && (p$25.right = void 0), cstack.pop()
      for (let i$14 = 0; i$14 < cstack.length; ++i$14) cstack[i$14].count--
      return makeImpl(ord, cstack[0])
    } else if (n$19.left !== void 0 || n$19.right !== void 0) {
      n$19.left === void 0 ? n$19.right !== void 0 && swap(n$19, n$19.right) : swap(n$19, n$19.left),
        n$19.color = Color.Black
      for (let i$14 = 0; i$14 < cstack.length - 1; ++i$14) cstack[i$14].count--
      return makeImpl(ord, cstack[0])
    } else if (cstack.length === 1) return makeImpl(ord, void 0)
    else {
      for (let i$14 = 0; i$14 < cstack.length; ++i$14) cstack[i$14].count--
      let parent = cstack[cstack.length - 2]
      fixDoubleBlack(cstack), parent.left === n$19 ? parent.left = void 0 : parent.right = void 0
    }
    return makeImpl(ord, cstack[0])
  }),
  size$7 = self$1 => self$1._root?.count ?? 0,
  valuesForward = self$1 => values$1(self$1, Direction$1.Forward),
  valuesBackward = self$1 => values$1(self$1, Direction$1.Backward),
  values$1 = (self$1, direction) => {
    let begin = self$1[Symbol.iterator](), count$2 = 0
    return {
      [Symbol.iterator]: () => values$1(self$1, direction),
      next: () => {
        count$2++
        let entry = begin.value
        switch (direction === Direction$1.Forward ? begin.moveNext() : begin.movePrev(), entry._tag) {
          case `None`:
            return { done: !0, value: count$2 }
          case `Some`:
            return { done: !1, value: entry.value }
        }
      },
    }
  },
  visitFull = (node$1, visit$2) => {
    let current = node$1, stack, done$8 = !1
    for (; !done$8;) {
      if (current != null) stack = make$54(current, stack), current = current.left
      else if (stack != null) {
        let value$2 = visit$2(stack.value.key, stack.value.value)
        if (isSome(value$2)) return value$2
        current = stack.value.right, stack = stack.previous
      } else done$8 = !0
    }
    return none$7()
  },
  visitGreaterThanEqual = (node$1, min$10, ord, visit$2) => {
    let current = node$1, stack, done$8 = !1
    for (; !done$8;) {
      if (current !== void 0) {
        stack = make$54(current, stack), current = ord(min$10, current.key) <= 0 ? current.left : void 0
      } else if (stack !== void 0) {
        if (ord(min$10, stack.value.key) <= 0) {
          let value$2 = visit$2(stack.value.key, stack.value.value)
          if (isSome(value$2)) return value$2
        }
        current = stack.value.right, stack = stack.previous
      } else done$8 = !0
    }
    return none$7()
  },
  visitLessThan = (node$1, max$12, ord, visit$2) => {
    let current = node$1, stack, done$8 = !1
    for (; !done$8;) {
      if (current !== void 0) stack = make$54(current, stack), current = current.left
      else if (stack !== void 0 && ord(max$12, stack.value.key) > 0) {
        let value$2 = visit$2(stack.value.key, stack.value.value)
        if (isSome(value$2)) return value$2
        current = stack.value.right, stack = stack.previous
      } else done$8 = !0
    }
    return none$7()
  },
  visitBetween = (node$1, min$10, max$12, ord, visit$2) => {
    let current = node$1, stack, done$8 = !1
    for (; !done$8;) {
      if (current !== void 0) {
        stack = make$54(current, stack), current = ord(min$10, current.key) <= 0 ? current.left : void 0
      } else if (stack !== void 0 && ord(max$12, stack.value.key) > 0) {
        if (ord(min$10, stack.value.key) <= 0) {
          let value$2 = visit$2(stack.value.key, stack.value.value)
          if (isSome(value$2)) {
            return value$2
          }
        }
        current = stack.value.right, stack = stack.previous
      } else done$8 = !0
    }
    return none$7()
  },
  fixDoubleBlack = stack => {
    let n$19, p$25, s$14, z$1
    for (let i$14 = stack.length - 1; i$14 >= 0; --i$14) {
      if (n$19 = stack[i$14], i$14 === 0) {
        n$19.color = Color.Black
        return
      }
      if (p$25 = stack[i$14 - 1], p$25.left === n$19) {
        if (s$14 = p$25.right, s$14 !== void 0 && s$14.right !== void 0 && s$14.right.color === Color.Red) {
          if (
            s$14 = p$25.right = clone(s$14),
              z$1 = s$14.right = clone(s$14.right),
              p$25.right = s$14.left,
              s$14.left = p$25,
              s$14.right = z$1,
              s$14.color = p$25.color,
              n$19.color = Color.Black,
              p$25.color = Color.Black,
              z$1.color = Color.Black,
              recount(p$25),
              recount(s$14),
              i$14 > 1
          ) {
            let pp = stack[i$14 - 2]
            pp.left === p$25 ? pp.left = s$14 : pp.right = s$14
          }
          stack[i$14 - 1] = s$14
          return
        } else if (s$14 !== void 0 && s$14.left !== void 0 && s$14.left.color === Color.Red) {
          if (
            s$14 = p$25.right = clone(s$14),
              z$1 = s$14.left = clone(s$14.left),
              p$25.right = z$1.left,
              s$14.left = z$1.right,
              z$1.left = p$25,
              z$1.right = s$14,
              z$1.color = p$25.color,
              p$25.color = Color.Black,
              s$14.color = Color.Black,
              n$19.color = Color.Black,
              recount(p$25),
              recount(s$14),
              recount(z$1),
              i$14 > 1
          ) {
            let pp = stack[i$14 - 2]
            pp.left === p$25 ? pp.left = z$1 : pp.right = z$1
          }
          stack[i$14 - 1] = z$1
          return
        }
        if (s$14 !== void 0 && s$14.color === Color.Black) {
          if (p$25.color === Color.Red) {
            p$25.color = Color.Black, p$25.right = repaint(s$14, Color.Red)
            return
          } else {
            p$25.right = repaint(s$14, Color.Red)
            continue
          }
        } else if (s$14 !== void 0) {
          if (
            s$14 = clone(s$14),
              p$25.right = s$14.left,
              s$14.left = p$25,
              s$14.color = p$25.color,
              p$25.color = Color.Red,
              recount(p$25),
              recount(s$14),
              i$14 > 1
          ) {
            let pp = stack[i$14 - 2]
            pp.left === p$25 ? pp.left = s$14 : pp.right = s$14
          }
          stack[i$14 - 1] = s$14,
            stack[i$14] = p$25,
            i$14 + 1 < stack.length ? stack[i$14 + 1] = n$19 : stack.push(n$19),
            i$14 += 2
        }
      } else {
        if (s$14 = p$25.left, s$14 !== void 0 && s$14.left !== void 0 && s$14.left.color === Color.Red) {
          if (
            s$14 = p$25.left = clone(s$14),
              z$1 = s$14.left = clone(s$14.left),
              p$25.left = s$14.right,
              s$14.right = p$25,
              s$14.left = z$1,
              s$14.color = p$25.color,
              n$19.color = Color.Black,
              p$25.color = Color.Black,
              z$1.color = Color.Black,
              recount(p$25),
              recount(s$14),
              i$14 > 1
          ) {
            let pp = stack[i$14 - 2]
            pp.right === p$25 ? pp.right = s$14 : pp.left = s$14
          }
          stack[i$14 - 1] = s$14
          return
        } else if (s$14 !== void 0 && s$14.right !== void 0 && s$14.right.color === Color.Red) {
          if (
            s$14 = p$25.left = clone(s$14),
              z$1 = s$14.right = clone(s$14.right),
              p$25.left = z$1.right,
              s$14.right = z$1.left,
              z$1.right = p$25,
              z$1.left = s$14,
              z$1.color = p$25.color,
              p$25.color = Color.Black,
              s$14.color = Color.Black,
              n$19.color = Color.Black,
              recount(p$25),
              recount(s$14),
              recount(z$1),
              i$14 > 1
          ) {
            let pp = stack[i$14 - 2]
            pp.right === p$25 ? pp.right = z$1 : pp.left = z$1
          }
          stack[i$14 - 1] = z$1
          return
        }
        if (s$14 !== void 0 && s$14.color === Color.Black) {
          if (p$25.color === Color.Red) {
            p$25.color = Color.Black, p$25.left = repaint(s$14, Color.Red)
            return
          } else {
            p$25.left = repaint(s$14, Color.Red)
            continue
          }
        } else if (s$14 !== void 0) {
          if (
            s$14 = clone(s$14),
              p$25.left = s$14.right,
              s$14.right = p$25,
              s$14.color = p$25.color,
              p$25.color = Color.Red,
              recount(p$25),
              recount(s$14),
              i$14 > 1
          ) {
            let pp = stack[i$14 - 2]
            pp.right === p$25 ? pp.right = s$14 : pp.left = s$14
          }
          stack[i$14 - 1] = s$14,
            stack[i$14] = p$25,
            i$14 + 1 < stack.length ? stack[i$14 + 1] = n$19 : stack.push(n$19),
            i$14 += 2
        }
      }
    }
  },
  TypeId$5 = RedBlackTreeTypeId,
  Direction = Direction$1,
  isRedBlackTree = isRedBlackTree$1,
  empty$8 = empty$9,
  fromIterable$2 = fromIterable$3,
  make$25 = make$26,
  at = atForwards,
  atReversed = atBackwards,
  findAll = findAll$1,
  findFirst$1 = findFirst$2,
  first = first$1,
  getAt = getAt$1,
  getOrder$1 = getOrder$2,
  greaterThan$6 = greaterThanForwards,
  greaterThanReversed = greaterThanBackwards,
  greaterThanEqual = greaterThanEqualForwards,
  greaterThanEqualReversed = greaterThanEqualBackwards,
  has = has$1,
  insert = insert$1,
  keys$1 = keysForward,
  keysReversed = keysBackward,
  last = last$1,
  lessThan$10 = lessThanForwards,
  lessThanReversed = lessThanBackwards,
  lessThanEqual = lessThanEqualForwards,
  lessThanEqualReversed = lessThanEqualBackwards,
  forEach$2 = forEach$3,
  forEachGreaterThanEqual = forEachGreaterThanEqual$1,
  forEachLessThan = forEachLessThan$1,
  forEachBetween = forEachBetween$1,
  reduce$2 = reduce$3,
  removeFirst = removeFirst$1,
  reversed = reversed$1,
  size$6 = size$7,
  values = valuesForward,
  valuesReversed = valuesBackward,
  TypeId$4 = Symbol.for(`effect/SortedSet`),
  SortedSetProto = {
    [TypeId$4]: { _A: _$1 => _$1 },
    [symbol$2]() {
      return pipe(hash(this.keyTree), combine$11(hash(TypeId$4)), cached$2(this))
    },
    [symbol$1](that) {
      return isSortedSet(that) && equals(this.keyTree, that.keyTree)
    },
    [Symbol.iterator]() {
      return keys$1(this.keyTree)
    },
    toString() {
      return format$1(this.toJSON())
    },
    toJSON() {
      return { _id: `SortedSet`, values: Array.from(this).map(toJSON) }
    },
    [NodeInspectSymbol]() {
      return this.toJSON()
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  fromTree = keyTree => {
    let a$22 = Object.create(SortedSetProto)
    return a$22.keyTree = keyTree, a$22
  },
  isSortedSet = u$7 => hasProperty(u$7, TypeId$4),
  add = dual(
    2,
    (self$1, value$2) => has(self$1.keyTree, value$2) ? self$1 : fromTree(insert(self$1.keyTree, value$2, !0)),
  ),
  remove = dual(2, (self$1, value$2) => fromTree(removeFirst(self$1.keyTree, value$2))),
  SupervisorSymbolKey = `effect/Supervisor`,
  SupervisorTypeId = Symbol.for(SupervisorSymbolKey),
  supervisorVariance = { _T: _$1 => _$1 }
var ProxySupervisor = class ProxySupervisor {
    underlying
    value0;
    [SupervisorTypeId] = supervisorVariance
    constructor(underlying, value0) {
      this.underlying = underlying, this.value0 = value0
    }
    get value() {
      return this.value0
    }
    onStart(context$2, effect, parent, fiber) {
      this.underlying.onStart(context$2, effect, parent, fiber)
    }
    onEnd(value$2, fiber) {
      this.underlying.onEnd(value$2, fiber)
    }
    onEffect(fiber, effect) {
      this.underlying.onEffect(fiber, effect)
    }
    onSuspend(fiber) {
      this.underlying.onSuspend(fiber)
    }
    onResume(fiber) {
      this.underlying.onResume(fiber)
    }
    map(f$14) {
      return new ProxySupervisor(this, pipe(this.value, map$11(f$14)))
    }
    zip(right$2) {
      return new Zip(this, right$2)
    }
  },
  Zip = class Zip {
    left
    right
    _tag = `Zip`;
    [SupervisorTypeId] = supervisorVariance
    constructor(left$2, right$2) {
      this.left = left$2, this.right = right$2
    }
    get value() {
      return zip$4(this.left.value, this.right.value)
    }
    onStart(context$2, effect, parent, fiber) {
      this.left.onStart(context$2, effect, parent, fiber), this.right.onStart(context$2, effect, parent, fiber)
    }
    onEnd(value$2, fiber) {
      this.left.onEnd(value$2, fiber), this.right.onEnd(value$2, fiber)
    }
    onEffect(fiber, effect) {
      this.left.onEffect(fiber, effect), this.right.onEffect(fiber, effect)
    }
    onSuspend(fiber) {
      this.left.onSuspend(fiber), this.right.onSuspend(fiber)
    }
    onResume(fiber) {
      this.left.onResume(fiber), this.right.onResume(fiber)
    }
    map(f$14) {
      return new ProxySupervisor(this, pipe(this.value, map$11(f$14)))
    }
    zip(right$2) {
      return new Zip(this, right$2)
    }
  }
const isZip = self$1 => hasProperty(self$1, SupervisorTypeId) && isTagged(self$1, `Zip`)
var Track = class {
    [SupervisorTypeId] = supervisorVariance
    fibers = new Set()
    get value() {
      return sync$3(() => Array.from(this.fibers))
    }
    onStart(_context, _effect, _parent, fiber) {
      this.fibers.add(fiber)
    }
    onEnd(_value, fiber) {
      this.fibers.delete(fiber)
    }
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f$14) {
      return new ProxySupervisor(this, pipe(this.value, map$11(f$14)))
    }
    zip(right$2) {
      return new Zip(this, right$2)
    }
    onRun(execution, _fiber) {
      return execution()
    }
  },
  Const = class {
    effect;
    [SupervisorTypeId] = supervisorVariance
    constructor(effect) {
      this.effect = effect
    }
    get value() {
      return this.effect
    }
    onStart(_context, _effect, _parent, _fiber) {}
    onEnd(_value, _fiber) {}
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f$14) {
      return new ProxySupervisor(this, pipe(this.value, map$11(f$14)))
    }
    zip(right$2) {
      return new Zip(this, right$2)
    }
    onRun(execution, _fiber) {
      return execution()
    }
  },
  FibersIn = class {
    ref;
    [SupervisorTypeId] = supervisorVariance
    constructor(ref) {
      this.ref = ref
    }
    get value() {
      return sync$3(() => get$6(this.ref))
    }
    onStart(_context, _effect, _parent, fiber) {
      pipe(this.ref, set$4(pipe(get$6(this.ref), add(fiber))))
    }
    onEnd(_value, fiber) {
      pipe(this.ref, set$4(pipe(get$6(this.ref), remove(fiber))))
    }
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f$14) {
      return new ProxySupervisor(this, pipe(this.value, map$11(f$14)))
    }
    zip(right$2) {
      return new Zip(this, right$2)
    }
    onRun(execution, _fiber) {
      return execution()
    }
  }
const unsafeTrack = () => new Track(),
  track = sync$3(unsafeTrack),
  fromEffect$1 = effect => new Const(effect),
  none$2 = globalValue(`effect/Supervisor/none`, () => fromEffect$1(void_$4)),
  TypeId$3 = DifferTypeId,
  ChunkPatchTypeId = ChunkPatchTypeId$1,
  ContextPatchTypeId = ContextPatchTypeId$1,
  HashMapPatchTypeId = HashMapPatchTypeId$1,
  HashSetPatchTypeId = HashSetPatchTypeId$1,
  OrPatchTypeId = OrPatchTypeId$1,
  ReadonlyArrayPatchTypeId = ReadonlyArrayPatchTypeId$1,
  make$24 = make$46,
  environment = environment$1,
  chunk = chunk$1,
  hashMap = hashMap$1,
  hashSet = hashSet$1,
  orElseEither$1 = orElseEither$3,
  readonlyArray = readonlyArray$1,
  transform$1 = transform$2,
  update = update$4,
  updateWith = updateWith$1,
  zip$2 = zip$5,
  OP_EMPTY = `Empty`,
  OP_ADD_SUPERVISOR = `AddSupervisor`,
  OP_REMOVE_SUPERVISOR = `RemoveSupervisor`,
  OP_AND_THEN = `AndThen`,
  empty$7 = { _tag: OP_EMPTY },
  combine = (self$1, that) => ({ _tag: OP_AND_THEN, first: self$1, second: that }),
  patch$1 = (self$1, supervisor) => patchLoop(supervisor, of$3(self$1)),
  patchLoop = (_supervisor, _patches) => {
    let supervisor = _supervisor, patches = _patches
    for (; isNonEmpty$4(patches);) {
      let head$5 = headNonEmpty(patches)
      switch (head$5._tag) {
        case OP_EMPTY:
          patches = tailNonEmpty(patches)
          break
        case OP_ADD_SUPERVISOR:
          supervisor = supervisor.zip(head$5.supervisor), patches = tailNonEmpty(patches)
          break
        case OP_REMOVE_SUPERVISOR:
          supervisor = removeSupervisor(supervisor, head$5.supervisor), patches = tailNonEmpty(patches)
          break
        case OP_AND_THEN:
          patches = prepend$1(head$5.first)(prepend$1(head$5.second)(tailNonEmpty(patches)))
          break
      }
    }
    return supervisor
  },
  removeSupervisor = (self$1, that) =>
    equals(self$1, that)
      ? none$2
      : isZip(self$1)
      ? removeSupervisor(self$1.left, that).zip(removeSupervisor(self$1.right, that))
      : self$1,
  toSet = self$1 =>
    equals(self$1, none$2)
      ? empty$29()
      : isZip(self$1)
      ? pipe(toSet(self$1.left), union$5(toSet(self$1.right)))
      : make$51(self$1),
  diff = (oldValue, newValue) => {
    if (equals(oldValue, newValue)) return empty$7
    let oldSupervisors = toSet(oldValue),
      newSupervisors = toSet(newValue),
      added = pipe(
        newSupervisors,
        difference(oldSupervisors),
        reduce$8(empty$7, (patch$12, supervisor) => combine(patch$12, { _tag: OP_ADD_SUPERVISOR, supervisor })),
      ),
      removed = pipe(
        oldSupervisors,
        difference(newSupervisors),
        reduce$8(empty$7, (patch$12, supervisor) => combine(patch$12, { _tag: OP_REMOVE_SUPERVISOR, supervisor })),
      )
    return combine(added, removed)
  },
  differ = make$24({ empty: empty$7, patch: patch$1, combine, diff }),
  fiberStarted = counter(`effect_fiber_started`, { incremental: !0 }),
  fiberActive = counter(`effect_fiber_active`),
  fiberSuccesses = counter(`effect_fiber_successes`, { incremental: !0 }),
  fiberFailures = counter(`effect_fiber_failures`, { incremental: !0 }),
  fiberLifetimes = tagged$2(
    histogram(`effect_fiber_lifetimes`, exponential({ start: .5, factor: 2, count: 35 })),
    `time_unit`,
    `milliseconds`,
  ),
  EvaluationSignalContinue = `Continue`,
  EvaluationSignalDone = `Done`,
  EvaluationSignalYieldNow = `Yield`,
  runtimeFiberVariance = { _E: _$1 => _$1, _A: _$1 => _$1 },
  absurd = _$1 => {
    throw Error(
      `BUG: FiberRuntime - ${
        toStringUnknown(_$1)
      } - please report an issue at https://github.com/Effect-TS/effect/issues`,
    )
  },
  YieldedOp = Symbol.for(`effect/internal/fiberRuntime/YieldedOp`),
  yieldedOpChannel = globalValue(`effect/internal/fiberRuntime/yieldedOpChannel`, () => ({ currentOp: null })),
  contOpSuccess = {
    [OP_ON_SUCCESS]: (_$1, cont, value$2) => internalCall(() => cont.effect_instruction_i1(value$2)),
    OnStep: (_$1, _cont, value$2) => exitSucceed$1(exitSucceed$1(value$2)),
    [OP_ON_SUCCESS_AND_FAILURE]: (_$1, cont, value$2) => internalCall(() => cont.effect_instruction_i2(value$2)),
    [OP_REVERT_FLAGS]: (
      self$1,
      cont,
      value$2,
    ) => (self$1.patchRuntimeFlags(self$1.currentRuntimeFlags, cont.patch),
      interruptible$3(self$1.currentRuntimeFlags) && self$1.isInterrupted()
        ? exitFailCause$1(self$1.getInterruptedCause())
        : exitSucceed$1(value$2)),
    [OP_WHILE]: (
      self$1,
      cont,
      value$2,
    ) => (internalCall(() => cont.effect_instruction_i2(value$2)),
      internalCall(() => cont.effect_instruction_i0())
        ? (self$1.pushStack(cont), internalCall(() => cont.effect_instruction_i1()))
        : void_$4),
    [OP_ITERATOR]: (self$1, cont, value$2) => {
      let state = internalCall(() => cont.effect_instruction_i0.next(value$2))
      return state.done ? exitSucceed$1(state.value) : (self$1.pushStack(cont), yieldWrapGet(state.value))
    },
  },
  drainQueueWhileRunningTable = {
    [OP_INTERRUPT_SIGNAL]: (
      self$1,
      runtimeFlags$1,
      cur,
      message,
    ) => (self$1.processNewInterruptSignal(message.cause),
      interruptible$3(runtimeFlags$1) ? exitFailCause$1(message.cause) : cur),
    [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
      throw Error(`It is illegal to have multiple concurrent run loops in a single fiber`)
    },
    [OP_STATEFUL]: (self$1, runtimeFlags$1, cur, message) => (message.onFiber(self$1, running(runtimeFlags$1)), cur),
    [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => flatMap$5(yieldNow$3(), () => cur),
  },
  runBlockedRequests = self$1 =>
    forEachSequentialDiscard(
      flatten$5(self$1),
      requestsByRequestResolver =>
        forEachConcurrentDiscard(
          sequentialCollectionToChunk(requestsByRequestResolver),
          ([dataSource, sequential$4]) => {
            let map$20 = new Map(), arr = []
            for (let block$1 of sequential$4) {
              arr.push(toReadonlyArray(block$1))
              for (let entry of block$1) map$20.set(entry.request, entry)
            }
            let flat = arr.flat()
            return fiberRefLocally(
              invokeWithInterrupt(dataSource.runAll(arr), flat, () =>
                flat.forEach(entry => {
                  entry.listeners.interrupted = !0
                })),
              currentRequestMap,
              map$20,
            )
          },
          !1,
          !1,
        ),
    ),
  _version = getCurrentVersion()
var FiberRuntime = class extends Class$4 {
  [FiberTypeId$1] = fiberVariance;
  [RuntimeFiberTypeId$1] = runtimeFiberVariance
  _fiberRefs
  _fiberId
  _queue = []
  _children = null
  _observers = []
  _running = !1
  _stack = []
  _asyncInterruptor = null
  _asyncBlockingOn = null
  _exitValue = null
  _steps = []
  _isYielding = !1
  currentRuntimeFlags
  currentOpCount = 0
  currentSupervisor
  currentScheduler
  currentTracer
  currentSpan
  currentContext
  currentDefaultServices
  constructor(fiberId$2, fiberRefs0, runtimeFlags0) {
    if (
      super(),
        this.currentRuntimeFlags = runtimeFlags0,
        this._fiberId = fiberId$2,
        this._fiberRefs = fiberRefs0,
        runtimeMetrics(runtimeFlags0)
    ) {
      let tags$2 = this.getFiberRef(currentMetricLabels)
      fiberStarted.unsafeUpdate(1, tags$2), fiberActive.unsafeUpdate(1, tags$2)
    }
    this.refreshRefCache()
  }
  commit() {
    return join$4(this)
  }
  id() {
    return this._fiberId
  }
  resume(effect) {
    this.tell(resume(effect))
  }
  get status() {
    return this.ask((_$1, status$2) => status$2)
  }
  get runtimeFlags() {
    return this.ask((state, status$2) => isDone$2(status$2) ? state.currentRuntimeFlags : status$2.runtimeFlags)
  }
  scope() {
    return unsafeMake$1(this)
  }
  get children() {
    return this.ask(fiber => Array.from(fiber.getChildren()))
  }
  getChildren() {
    return this._children === null && (this._children = new Set()), this._children
  }
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause)
  }
  fiberRefs() {
    return this.ask(fiber => fiber.getFiberRefs())
  }
  ask(f$14) {
    return suspend$4(() => {
      let deferred = deferredUnsafeMake(this._fiberId)
      return this.tell(stateful((fiber, status$2) => {
        deferredUnsafeDone(deferred, sync$3(() => f$14(fiber, status$2)))
      })),
        deferredAwait(deferred)
    })
  }
  tell(message) {
    this._queue.push(message), this._running || (this._running = !0, this.drainQueueLaterOnExecutor())
  }
  get await() {
    return async_(resume$1 => {
      let cb = exit$5 => resume$1(succeed$9(exit$5))
      return this.tell(stateful((fiber, _$1) => {
        fiber._exitValue === null ? fiber.addObserver(cb) : cb(this._exitValue)
      })),
        sync$3(() =>
          this.tell(stateful((fiber, _$1) => {
            fiber.removeObserver(cb)
          }))
        )
    }, this.id())
  }
  get inheritAll() {
    return withFiberRuntime$1((parentFiber, parentStatus) => {
      let parentFiberId = parentFiber.id(),
        parentFiberRefs = parentFiber.getFiberRefs(),
        parentRuntimeFlags = parentStatus.runtimeFlags,
        childFiberRefs = this.getFiberRefs(),
        updatedFiberRefs = joinAs$1(parentFiberRefs, parentFiberId, childFiberRefs)
      parentFiber.setFiberRefs(updatedFiberRefs)
      let updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags),
        patch$12 = pipe(diff$3(parentRuntimeFlags, updatedRuntimeFlags), exclude(Interruption), exclude(WindDown))
      return updateRuntimeFlags(patch$12)
    })
  }
  get poll() {
    return sync$3(() => fromNullable$2(this._exitValue))
  }
  unsafePoll() {
    return this._exitValue
  }
  interruptAsFork(fiberId$2) {
    return sync$3(() => this.tell(interruptSignal(interrupt$6(fiberId$2))))
  }
  unsafeInterruptAsFork(fiberId$2) {
    this.tell(interruptSignal(interrupt$6(fiberId$2)))
  }
  addObserver(observer) {
    this._exitValue === null ? this._observers.push(observer) : observer(this._exitValue)
  }
  removeObserver(observer) {
    this._observers = this._observers.filter(o$18 => o$18 !== observer)
  }
  getFiberRefs() {
    return this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags), this._fiberRefs
  }
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_$1(this._fiberRefs, fiberRef)
  }
  getFiberRef(fiberRef) {
    return this._fiberRefs.locals.has(fiberRef) ? this._fiberRefs.locals.get(fiberRef)[0][1] : fiberRef.initial
  }
  setFiberRef(fiberRef, value$2) {
    this._fiberRefs = updateAs$1(this._fiberRefs, { fiberId: this._fiberId, fiberRef, value: value$2 }),
      this.refreshRefCache()
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices),
      this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key),
      this.currentSupervisor = this.getFiberRef(currentSupervisor),
      this.currentScheduler = this.getFiberRef(currentScheduler),
      this.currentContext = this.getFiberRef(currentContext),
      this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key)
  }
  setFiberRefs(fiberRefs$3) {
    this._fiberRefs = fiberRefs$3, this.refreshRefCache()
  }
  addChild(child) {
    this.getChildren().add(child)
  }
  removeChild(child) {
    this.getChildren().delete(child)
  }
  transferChildren(scope$2) {
    let children$3 = this._children
    if (this._children = null, children$3 !== null && children$3.size > 0) {
      for (let child of children$3) child._exitValue === null && scope$2.add(this.currentRuntimeFlags, child)
    }
  }
  drainQueueOnCurrentThread() {
    let recurse = !0
    for (; recurse;) {
      let evaluationSignal = EvaluationSignalContinue, prev = globalThis[currentFiberURI]
      globalThis[currentFiberURI] = this
      try {
        for (; evaluationSignal === EvaluationSignalContinue;) {
          evaluationSignal = this._queue.length === 0
            ? EvaluationSignalDone
            : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0])
        }
      } finally {
        this._running = !1, globalThis[currentFiberURI] = prev
      }
      this._queue.length > 0 && !this._running
        ? (this._running = !0,
          evaluationSignal === EvaluationSignalYieldNow
            ? (this.drainQueueLaterOnExecutor(), recurse = !1)
            : recurse = !0)
        : recurse = !1
    }
  }
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority))
  }
  drainQueueWhileRunning(runtimeFlags$1, cur0) {
    let cur = cur0
    for (; this._queue.length > 0;) {
      let message = this._queue.splice(0, 1)[0]
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags$1, cur, message)
    }
    return cur
  }
  isInterrupted() {
    return !isEmpty$4(this.getFiberRef(currentInterruptedCause))
  }
  addInterruptedCause(cause$2) {
    let oldSC = this.getFiberRef(currentInterruptedCause)
    this.setFiberRef(currentInterruptedCause, sequential$3(oldSC, cause$2))
  }
  processNewInterruptSignal(cause$2) {
    this.addInterruptedCause(cause$2), this.sendInterruptSignalToAllChildren()
  }
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) return !1
    let told = !1
    for (let child of this._children) child.tell(interruptSignal(interrupt$6(this.id()))), told = !0
    return told
  }
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      let it = this._children.values()
      this._children = null
      let isDone$5 = !1,
        body$2 = () => {
          let next = it.next()
          return next.done
            ? sync$3(() => {
              isDone$5 = !0
            })
            : asVoid$3(next.value.await)
        }
      return whileLoop$2({ while: () => !isDone$5, body: body$2, step: () => {} })
    }
    return null
  }
  reportExitValue(exit$5) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      let tags$2 = this.getFiberRef(currentMetricLabels),
        startTimeMillis = this.id().startTimeMillis,
        endTimeMillis = Date.now()
      switch (
        fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags$2),
          fiberActive.unsafeUpdate(-1, tags$2),
          exit$5._tag
      ) {
        case OP_SUCCESS:
          fiberSuccesses.unsafeUpdate(1, tags$2)
          break
        case OP_FAILURE:
          fiberFailures.unsafeUpdate(1, tags$2)
          break
      }
    }
    if (exit$5._tag === `Failure`) {
      let level = this.getFiberRef(currentUnhandledErrorLogLevel)
      !isInterruptedOnly$1(exit$5.cause) && level._tag === `Some`
        && this.log(`Fiber terminated with an unhandled error`, exit$5.cause, level)
    }
  }
  setExitValue(exit$5) {
    this._exitValue = exit$5, this.reportExitValue(exit$5)
    for (let i$14 = this._observers.length - 1; i$14 >= 0; i$14--) this._observers[i$14](exit$5)
    this._observers = []
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers)
  }
  log(message, cause$2, overrideLogLevel) {
    let logLevel = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel),
      minimumLogLevel = this.getFiberRef(currentMinimumLogLevel)
    if (greaterThan$8(minimumLogLevel, logLevel)) return
    let spans = this.getFiberRef(currentLogSpan),
      annotations$2 = this.getFiberRef(currentLogAnnotations),
      loggers = this.getLoggers(),
      contextMap = this.getFiberRefs()
    if (size$11(loggers) > 0) {
      let clockService = get$9(this.getFiberRef(currentServices), clockTag),
        date$1 = new Date(clockService.unsafeCurrentTimeMillis())
      withRedactableContext(contextMap, () => {
        for (let logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause: cause$2,
            context: contextMap,
            spans,
            annotations: annotations$2,
            date: date$1,
          })
        }
      })
    }
  }
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW:
        return EvaluationSignalYieldNow
      case OP_INTERRUPT_SIGNAL:
        return this.processNewInterruptSignal(message.cause),
          this._asyncInterruptor !== null
          && (this._asyncInterruptor(exitFailCause$1(message.cause)), this._asyncInterruptor = null),
          EvaluationSignalContinue
      case OP_RESUME:
        return this._asyncInterruptor = null,
          this._asyncBlockingOn = null,
          this.evaluateEffect(message.effect),
          EvaluationSignalContinue
      case OP_STATEFUL:
        return message.onFiber(
          this,
          this._exitValue === null ? suspended(this.currentRuntimeFlags, this._asyncBlockingOn) : done$4,
        ),
          EvaluationSignalContinue
      default:
        return absurd(message)
    }
  }
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this)
    try {
      let effect = interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()
        ? exitFailCause$1(this.getInterruptedCause())
        : effect0
      for (; effect !== null;) {
        let eff = effect, exit$5 = this.runLoop(eff)
        if (exit$5 === YieldedOp) {
          let op = yieldedOpChannel.currentOp
          yieldedOpChannel.currentOp = null,
            op._op === OP_YIELD
              ? cooperativeYielding(this.currentRuntimeFlags)
                ? (this.tell(yieldNow$1()), this.tell(resume(exitVoid$1)), effect = null)
                : effect = exitVoid$1
              : op._op === OP_ASYNC && (effect = null)
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable$1(WindDown))
          let interruption$1 = this.interruptAllChildren()
          interruption$1 === null
            ? (this._queue.length === 0 ? this.setExitValue(exit$5) : this.tell(resume(exit$5)), effect = null)
            : effect = flatMap$5(interruption$1, () => exit$5)
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this)
    }
  }
  start(effect) {
    if (this._running) this.tell(resume(effect))
    else {
      this._running = !0
      let prev = globalThis[currentFiberURI]
      globalThis[currentFiberURI] = this
      try {
        this.evaluateEffect(effect)
      } finally {
        this._running = !1,
          globalThis[currentFiberURI] = prev,
          this._queue.length > 0 && this.drainQueueLaterOnExecutor()
      }
    }
  }
  startFork(effect) {
    this.tell(resume(effect))
  }
  patchRuntimeFlags(oldRuntimeFlags, patch$12) {
    let newRuntimeFlags = patch$5(oldRuntimeFlags, patch$12)
    return globalThis[currentFiberURI] = this, this.currentRuntimeFlags = newRuntimeFlags, newRuntimeFlags
  }
  initiateAsync(runtimeFlags$1, asyncRegister) {
    let alreadyCalled = !1,
      callback = effect => {
        alreadyCalled || (alreadyCalled = !0, this.tell(resume(effect)))
      }
    interruptible$3(runtimeFlags$1) && (this._asyncInterruptor = callback)
    try {
      asyncRegister(callback)
    } catch (e$26) {
      callback(failCause$8(die$5(e$26)))
    }
  }
  pushStack(cont) {
    this._stack.push(cont),
      cont._op === `OnStep` && this._steps.push({ refs: this.getFiberRefs(), flags: this.currentRuntimeFlags })
  }
  popStack() {
    let item = this._stack.pop()
    if (item) return item._op === `OnStep` && this._steps.pop(), item
  }
  getNextSuccessCont() {
    let frame = this.popStack()
    for (; frame;) {
      if (frame._op !== OP_ON_FAILURE) return frame
      frame = this.popStack()
    }
  }
  getNextFailCont() {
    let frame = this.popStack()
    for (; frame;) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) return frame
      frame = this.popStack()
    }
  }
  [OP_TAG](op) {
    return sync$3(() => unsafeGet$3(this.currentContext, op))
  }
  Left(op) {
    return fail$9(op.left)
  }
  None(_$1) {
    return fail$9(new NoSuchElementException$1())
  }
  Right(op) {
    return exitSucceed$1(op.right)
  }
  Some(op) {
    return exitSucceed$1(op.value)
  }
  Micro(op) {
    return unsafeAsync(microResume => {
      let resume$1 = microResume, fiber = runFork$1(provideContext(op, this.currentContext))
      return fiber.addObserver(exit$5 => {
        if (exit$5._tag === `Success`) return resume$1(exitSucceed$1(exit$5.value))
        switch (exit$5.cause._tag) {
          case `Interrupt`:
            return resume$1(exitFailCause$1(interrupt$6(none$6)))
          case `Fail`:
            return resume$1(fail$9(exit$5.cause.error))
          case `Die`:
            return resume$1(die$4(exit$5.cause.defect))
        }
      }),
        unsafeAsync(abortResume => {
          resume$1 = _$1 => {
            abortResume(void_$4)
          }, fiber.unsafeInterrupt()
        })
    })
  }
  [OP_SYNC](op) {
    let value$2 = internalCall(() => op.effect_instruction_i0()), cont = this.getNextSuccessCont()
    return cont === void 0
      ? (yieldedOpChannel.currentOp = exitSucceed$1(value$2), YieldedOp)
      : (cont._op in contOpSuccess || absurd(cont), contOpSuccess[cont._op](this, cont, value$2))
  }
  [OP_SUCCESS](op) {
    let oldCur = op, cont = this.getNextSuccessCont()
    return cont === void 0
      ? (yieldedOpChannel.currentOp = oldCur, YieldedOp)
      : (cont._op in contOpSuccess || absurd(cont), contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0))
  }
  [OP_FAILURE](op) {
    let cause$2 = op.effect_instruction_i0, cont = this.getNextFailCont()
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE:
          return interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()
            ? exitFailCause$1(stripFailures$1(cause$2))
            : internalCall(() => cont.effect_instruction_i1(cause$2))
        case `OnStep`:
          return interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()
            ? exitFailCause$1(stripFailures$1(cause$2))
            : exitSucceed$1(exitFailCause$1(cause$2))
        case OP_REVERT_FLAGS:
          return this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch),
            interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()
              ? exitFailCause$1(sequential$3(cause$2, this.getInterruptedCause()))
              : exitFailCause$1(cause$2)
        default:
          absurd(cont)
      }
    } else return yieldedOpChannel.currentOp = exitFailCause$1(cause$2), YieldedOp
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running(this.currentRuntimeFlags)))
  }
  Blocked(op) {
    let refs = this.getFiberRefs(), flags = this.currentRuntimeFlags
    if (this._steps.length > 0) {
      let frames = [], snap = this._steps[this._steps.length - 1], frame = this.popStack()
      for (; frame && frame._op !== `OnStep`;) frames.push(frame), frame = this.popStack()
      this.setFiberRefs(snap.refs), this.currentRuntimeFlags = snap.flags
      let patchRefs = diff$1(snap.refs, refs), patchFlags = diff$3(snap.flags, flags)
      return exitSucceed$1(blocked$1(
        op.effect_instruction_i0,
        withFiberRuntime$1(newFiber => {
          for (; frames.length > 0;) newFiber.pushStack(frames.pop())
          return newFiber.setFiberRefs(patch$2(newFiber.id(), newFiber.getFiberRefs())(patchRefs)),
            newFiber.currentRuntimeFlags = patch$5(patchFlags)(newFiber.currentRuntimeFlags),
            op.effect_instruction_i1
        }),
      ))
    }
    return uninterruptibleMask$2(restore =>
      flatMap$5(forkDaemon$1(runRequestBlock$1(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1))
    )
  }
  RunBlocked(op) {
    return runBlockedRequests(op.effect_instruction_i0)
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    let updateFlags = op.effect_instruction_i0,
      oldRuntimeFlags = this.currentRuntimeFlags,
      newRuntimeFlags = patch$5(oldRuntimeFlags, updateFlags)
    if (interruptible$3(newRuntimeFlags) && this.isInterrupted()) return exitFailCause$1(this.getInterruptedCause())
    if (this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags), op.effect_instruction_i1) {
      let revertFlags = diff$3(newRuntimeFlags, oldRuntimeFlags)
      return this.pushStack(new RevertFlags(revertFlags, op)),
        internalCall(() => op.effect_instruction_i1(oldRuntimeFlags))
    } else return exitVoid$1
  }
  [OP_ON_SUCCESS](op) {
    return this.pushStack(op), op.effect_instruction_i0
  }
  OnStep(op) {
    return this.pushStack(op), op.effect_instruction_i0
  }
  [OP_ON_FAILURE](op) {
    return this.pushStack(op), op.effect_instruction_i0
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    return this.pushStack(op), op.effect_instruction_i0
  }
  [OP_ASYNC](op) {
    return this._asyncBlockingOn = op.effect_instruction_i1,
      this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0),
      yieldedOpChannel.currentOp = op,
      YieldedOp
  }
  [OP_YIELD](op) {
    return this._isYielding = !1, yieldedOpChannel.currentOp = op, YieldedOp
  }
  [OP_WHILE](op) {
    let check$1 = op.effect_instruction_i0, body$2 = op.effect_instruction_i1
    return check$1() ? (this.pushStack(op), body$2()) : exitVoid$1
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0)
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit())
  }
  runLoop(effect0) {
    let cur = effect0
    for (this.currentOpCount = 0;;) {
      if (
        (this.currentRuntimeFlags & OpSupervision) !== 0 && this.currentSupervisor.onEffect(this, cur),
          this._queue.length > 0 && (cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur)),
          !this._isYielding
      ) {
        this.currentOpCount += 1
        let shouldYield$1 = this.currentScheduler.shouldYield(this)
        if (shouldYield$1 !== !1) {
          this._isYielding = !0, this.currentOpCount = 0
          let oldCur = cur
          cur = flatMap$5(yieldNow$3({ priority: shouldYield$1 }), () => oldCur)
        }
      }
      try {
        if (
          cur = this.currentTracer.context(() => {
            if (_version !== cur[EffectTypeId$2]._V) {
              let level = this.getFiberRef(currentVersionMismatchErrorLogLevel)
              if (level._tag === `Some`) {
                let effectVersion = cur[EffectTypeId$2]._V
                this.log(
                  `Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`,
                  empty$17,
                  level,
                )
              }
            }
            return this[cur._op](cur)
          }, this), cur === YieldedOp
        ) {
          let op = yieldedOpChannel.currentOp
          return op._op === OP_YIELD || op._op === OP_ASYNC
            ? YieldedOp
            : (yieldedOpChannel.currentOp = null,
              op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause$1(die$5(op)))
        }
      } catch (e$26) {
        cur = cur !== YieldedOp && !hasProperty(cur, `_op`) || !(cur._op in this)
          ? dieMessage$1(`Not a valid effect: ${toStringUnknown(cur)}`)
          : isInterruptedException$1(e$26)
          ? exitFailCause$1(sequential$3(die$5(e$26), interrupt$6(none$6)))
          : die$4(e$26)
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread()
  }
}
const currentMinimumLogLevel = globalValue(
    `effect/FiberRef/currentMinimumLogLevel`,
    () => fiberRefUnsafeMake(fromLiteral(`Info`)),
  ),
  loggerWithConsoleLog = self$1 =>
    makeLogger(opts => {
      let services = getOrDefault(opts.context, currentServices)
      get$9(services, consoleTag).unsafe.log(self$1.log(opts))
    }),
  defaultLogger = globalValue(Symbol.for(`effect/Logger/defaultLogger`), () => loggerWithConsoleLog(stringLogger)),
  tracerLogger = globalValue(
    Symbol.for(`effect/Logger/tracerLogger`),
    () =>
      makeLogger(
        ({ annotations: annotations$2, cause: cause$2, context: context$2, fiberId: fiberId$2, logLevel, message }) => {
          let span$1 = getOption(getOrDefault$1(context$2, currentContext), spanTag)
          if (span$1._tag === `None` || span$1.value._tag === `ExternalSpan`) return
          let clockService = unsafeGet$3(getOrDefault$1(context$2, currentServices), clockTag), attributes = {}
          for (let [key$1, value$2] of annotations$2) attributes[key$1] = value$2
          attributes[`effect.fiberId`] = threadName(fiberId$2),
            attributes[`effect.logLevel`] = logLevel.label,
            cause$2 !== null && cause$2._tag !== `Empty`
            && (attributes[`effect.cause`] = pretty$3(cause$2, { renderErrorCause: !0 })),
            span$1.value.event(
              toStringUnknown(Array.isArray(message) ? message[0] : message),
              clockService.unsafeCurrentTimeNanos(),
              attributes,
            )
        },
      ),
  ),
  currentLoggers = globalValue(
    Symbol.for(`effect/FiberRef/currentLoggers`),
    () => fiberRefUnsafeMakeHashSet(make$51(defaultLogger, tracerLogger)),
  ),
  annotateLogsScoped$1 = function() {
    if (typeof arguments[0] == `string`) {
      return fiberRefLocallyScopedWith(currentLogAnnotations, set$3(arguments[0], arguments[1]))
    }
    let entries$2 = Object.entries(arguments[0])
    return fiberRefLocallyScopedWith(
      currentLogAnnotations,
      mutate(annotations$2 => {
        for (let i$14 = 0; i$14 < entries$2.length; i$14++) {
          let [key$1, value$2] = entries$2[i$14]
          set$3(annotations$2, key$1, value$2)
        }
        return annotations$2
      }),
    )
  },
  whenLogLevel$1 = dual(2, (effect, level) => {
    let requiredLogLevel = typeof level == `string` ? fromLiteral(level) : level
    return withFiberRuntime$1(fiberState => {
      let minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel)
      return greaterThan$8(minimumLogLevel, requiredLogLevel) ? succeed$9(none$7()) : map$11(effect, some$4)
    })
  }),
  acquireRelease$1 = dual(
    args$1 => isEffect$1(args$1[0]),
    (acquire, release) => uninterruptible$1(tap$1(acquire, a$22 => addFinalizer$2(exit$5 => release(a$22, exit$5)))),
  ),
  acquireReleaseInterruptible$1 = dual(
    args$1 => isEffect$1(args$1[0]),
    (acquire, release) => ensuring$1(acquire, addFinalizer$2(exit$5 => release(exit$5))),
  ),
  addFinalizer$2 = finalizer =>
    withFiberRuntime$1(runtime$4 => {
      let acquireRefs = runtime$4.getFiberRefs(), acquireFlags = disable$2(runtime$4.currentRuntimeFlags, Interruption)
      return flatMap$5(scope$1, scope$2 =>
        scopeAddFinalizerExit(scope$2, exit$5 =>
          withFiberRuntime$1(runtimeFinalizer => {
            let preRefs = runtimeFinalizer.getFiberRefs(),
              preFlags = runtimeFinalizer.currentRuntimeFlags,
              patchRefs = diff$1(preRefs, acquireRefs),
              patchFlags = diff$3(preFlags, acquireFlags),
              inverseRefs = diff$1(acquireRefs, preRefs)
            return runtimeFinalizer.setFiberRefs(patch$2(patchRefs, runtimeFinalizer.id(), acquireRefs)),
              ensuring$1(
                withRuntimeFlags(finalizer(exit$5), patchFlags),
                sync$3(() => {
                  runtimeFinalizer.setFiberRefs(
                    patch$2(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()),
                  )
                }),
              )
          })))
    }),
  daemonChildren$1 = self$1 => {
    let forkScope = fiberRefLocally(currentForkScopeOverride, some$4(globalScope))
    return forkScope(self$1)
  },
  _existsParFound = Symbol.for(`effect/Effect/existsPar/found`),
  exists$1 = dual(
    args$1 => isIterable(args$1[0]) && !isEffect$1(args$1[0]),
    (elements, predicate, options$2) =>
      matchSimple(
        options$2?.concurrency,
        () => suspend$4(() => existsLoop(elements[Symbol.iterator](), 0, predicate)),
        () =>
          matchEffect$2(
            forEach$1(elements, (a$22, i$14) =>
              if_$1(predicate(a$22, i$14), {
                onTrue: () => fail$9(_existsParFound),
                onFalse: () => void_$4,
              }), options$2),
            {
              onFailure: e$26 => e$26 === _existsParFound ? succeed$9(!0) : fail$9(e$26),
              onSuccess: () => succeed$9(!1),
            },
          ),
      ),
  ),
  existsLoop = (iterator, index$4, f$14) => {
    let next = iterator.next()
    return next.done
      ? succeed$9(!1)
      : flatMap$5(f$14(next.value, index$4), b$3 => b$3 ? succeed$9(b$3) : existsLoop(iterator, index$4 + 1, f$14))
  },
  filter$3 = dual(args$1 => isIterable(args$1[0]) && !isEffect$1(args$1[0]), (elements, predicate, options$2) => {
    let predicate_ = options$2?.negate ? (a$22, i$14) => map$11(predicate(a$22, i$14), not$2) : predicate
    return matchSimple(
      options$2?.concurrency,
      () =>
        suspend$4(() =>
          fromIterable$10(elements).reduceRight((effect, a$22, i$14) =>
            zipWith$4(
              effect,
              suspend$4(() => predicate_(a$22, i$14)),
              (list$3, b$3) => b$3 ? [a$22, ...list$3] : list$3,
            ), sync$3(() => []))
        ),
      () =>
        map$11(
          forEach$1(elements, (a$22, i$14) =>
            map$11(predicate_(a$22, i$14), b$3 => b$3 ? some$4(a$22) : none$7()), options$2),
          getSomes,
        ),
    )
  }),
  allResolveInput = input => {
    if (Array.isArray(input) || isIterable(input)) return [input, none$7()]
    let keys$6 = Object.keys(input), size$14 = keys$6.length
    return [
      keys$6.map(k$1 => input[k$1]),
      some$4(values$6 => {
        let res = {}
        for (let i$14 = 0; i$14 < size$14; i$14++) res[keys$6[i$14]] = values$6[i$14]
        return res
      }),
    ]
  },
  allValidate = (effects, reconcile, options$2) => {
    let eitherEffects = []
    for (let effect of effects) eitherEffects.push(either$3(effect))
    return flatMap$5(
      forEach$1(eitherEffects, identity, {
        concurrency: options$2?.concurrency,
        batching: options$2?.batching,
        concurrentFinalizers: options$2?.concurrentFinalizers,
      }),
      eithers => {
        let none$9 = none$7(),
          size$14 = eithers.length,
          errors = Array(size$14),
          successes = Array(size$14),
          errored = !1
        for (let i$14 = 0; i$14 < size$14; i$14++) {
          let either$6 = eithers[i$14]
          either$6._tag === `Left`
            ? (errors[i$14] = some$4(either$6.left), errored = !0)
            : (successes[i$14] = either$6.right, errors[i$14] = none$9)
        }
        return errored
          ? reconcile._tag === `Some` ? fail$9(reconcile.value(errors)) : fail$9(errors)
          : options$2?.discard
          ? void_$4
          : reconcile._tag === `Some`
          ? succeed$9(reconcile.value(successes))
          : succeed$9(successes)
      },
    )
  },
  allEither = (effects, reconcile, options$2) => {
    let eitherEffects = []
    for (let effect of effects) eitherEffects.push(either$3(effect))
    return options$2?.discard
      ? forEach$1(eitherEffects, identity, {
        concurrency: options$2?.concurrency,
        batching: options$2?.batching,
        discard: !0,
        concurrentFinalizers: options$2?.concurrentFinalizers,
      })
      : map$11(
        forEach$1(eitherEffects, identity, {
          concurrency: options$2?.concurrency,
          batching: options$2?.batching,
          concurrentFinalizers: options$2?.concurrentFinalizers,
        }),
        eithers => reconcile._tag === `Some` ? reconcile.value(eithers) : eithers,
      )
  },
  all$4 = (arg, options$2) => {
    let [effects, reconcile] = allResolveInput(arg)
    return options$2?.mode === `validate`
      ? allValidate(effects, reconcile, options$2)
      : options$2?.mode === `either`
      ? allEither(effects, reconcile, options$2)
      : options$2?.discard !== !0 && reconcile._tag === `Some`
      ? map$11(forEach$1(effects, identity, options$2), reconcile.value)
      : forEach$1(effects, identity, options$2)
  },
  allWith$1 = options$2 => arg => all$4(arg, options$2),
  allSuccesses$1 = (elements, options$2) =>
    map$11(
      all$4(fromIterable$10(elements).map(exit$4), options$2),
      filterMap$4(exit$5 => exitIsSuccess(exit$5) ? some$4(exit$5.effect_instruction_i0) : none$7()),
    ),
  replicate$1 = dual(2, (self$1, n$19) => Array.from({ length: n$19 }, () => self$1)),
  replicateEffect$1 = dual(
    args$1 => isEffect$1(args$1[0]),
    (self$1, n$19, options$2) => all$4(replicate$1(self$1, n$19), options$2),
  ),
  forEach$1 = dual(args$1 => isIterable(args$1[0]), (self$1, f$14, options$2) =>
    withFiberRuntime$1(r$26 => {
      let isRequestBatchingEnabled = options$2?.batching === !0
        || options$2?.batching === `inherit` && r$26.getFiberRef(currentRequestBatching)
      return options$2?.discard
        ? match$4(
          options$2.concurrency,
          () =>
            finalizersMaskInternal(sequential$1, options$2?.concurrentFinalizers)(restore =>
              isRequestBatchingEnabled
                ? forEachConcurrentDiscard(self$1, (a$22, i$14) => restore(f$14(a$22, i$14)), !0, !1, 1)
                : forEachSequentialDiscard(self$1, (a$22, i$14) => restore(f$14(a$22, i$14)))
            ),
          () =>
            finalizersMaskInternal(parallel$1, options$2?.concurrentFinalizers)(restore =>
              forEachConcurrentDiscard(
                self$1,
                (a$22, i$14) => restore(f$14(a$22, i$14)),
                isRequestBatchingEnabled,
                !1,
              )
            ),
          n$19 =>
            finalizersMaskInternal(parallelN(n$19), options$2?.concurrentFinalizers)(restore =>
              forEachConcurrentDiscard(
                self$1,
                (a$22, i$14) => restore(f$14(a$22, i$14)),
                isRequestBatchingEnabled,
                !1,
                n$19,
              )
            ),
        )
        : match$4(
          options$2?.concurrency,
          () =>
            finalizersMaskInternal(sequential$1, options$2?.concurrentFinalizers)(restore =>
              isRequestBatchingEnabled
                ? forEachParN(self$1, 1, (a$22, i$14) => restore(f$14(a$22, i$14)), !0)
                : forEachSequential(self$1, (a$22, i$14) => restore(f$14(a$22, i$14)))
            ),
          () =>
            finalizersMaskInternal(parallel$1, options$2?.concurrentFinalizers)(restore =>
              forEachParUnbounded(self$1, (a$22, i$14) => restore(f$14(a$22, i$14)), isRequestBatchingEnabled)
            ),
          n$19 =>
            finalizersMaskInternal(parallelN(n$19), options$2?.concurrentFinalizers)(restore =>
              forEachParN(self$1, n$19, (a$22, i$14) => restore(f$14(a$22, i$14)), isRequestBatchingEnabled)
            ),
        )
    })),
  forEachParUnbounded = (self$1, f$14, batching) =>
    suspend$4(() => {
      let as$6 = fromIterable$10(self$1),
        array$3 = Array(as$6.length),
        fn = (a$22, i$14) => flatMap$5(f$14(a$22, i$14), b$3 => sync$3(() => array$3[i$14] = b$3))
      return zipRight$3(forEachConcurrentDiscard(as$6, fn, batching, !1), succeed$9(array$3))
    }),
  forEachConcurrentDiscard = (self$1, f$14, batching, processAll, n$19) =>
    uninterruptibleMask$2(restore =>
      transplant$1(graft =>
        withFiberRuntime$1(parent => {
          let todos = Array.from(self$1).reverse(), target = todos.length
          if (target === 0) return void_$4
          let counter$5 = 0,
            interrupted$2 = !1,
            fibersCount = n$19 ? Math.min(todos.length, n$19) : todos.length,
            fibers = new Set(),
            results = [],
            interruptAll$2 = () =>
              fibers.forEach(fiber => {
                fiber.currentScheduler.scheduleTask(() => {
                  fiber.unsafeInterruptAsFork(parent.id())
                }, 0)
              }),
            startOrder = [],
            joinOrder = [],
            residual = [],
            collectExits = () => {
              let exits = results.filter(({ exit: exit$5 }) => exit$5._tag === `Failure`).sort((a$22, b$3) =>
                a$22.index < b$3.index ? -1 : a$22.index === b$3.index ? 0 : 1
              ).map(({ exit: exit$5 }) => exit$5)
              return exits.length === 0 && exits.push(exitVoid$1), exits
            },
            runFiber = (eff, interruptImmediately = !1) => {
              let runnable = uninterruptible$1(graft(eff)),
                fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope)
              return parent.currentScheduler.scheduleTask(() => {
                interruptImmediately && fiber.unsafeInterruptAsFork(parent.id()), fiber.resume(runnable)
              }, 0),
                fiber
            },
            onInterruptSignal = () => {
              processAll || (target -= todos.length, todos = []), interrupted$2 = !0, interruptAll$2()
            },
            stepOrExit = batching ? step$1 : exit$4,
            processingFiber = runFiber(async_(resume$1 => {
              let pushResult = (res, index$4) => {
                  res._op === `Blocked`
                    ? residual.push(res)
                    : (results.push({ index: index$4, exit: res }),
                      res._op === `Failure` && !interrupted$2 && onInterruptSignal())
                },
                next = () => {
                  if (todos.length > 0) {
                    let a$22 = todos.pop(),
                      index$4 = counter$5++,
                      returnNextElement = () => {
                        let a$23 = todos.pop()
                        return index$4 = counter$5++,
                          flatMap$5(yieldNow$3(), () => flatMap$5(stepOrExit(restore(f$14(a$23, index$4))), onRes))
                      },
                      onRes = res =>
                        todos.length > 0 && (pushResult(res, index$4), todos.length > 0)
                          ? returnNextElement()
                          : succeed$9(res),
                      todo = flatMap$5(stepOrExit(restore(f$14(a$22, index$4))), onRes),
                      fiber = runFiber(todo)
                    startOrder.push(fiber),
                      fibers.add(fiber),
                      interrupted$2 && fiber.currentScheduler.scheduleTask(() => {
                        fiber.unsafeInterruptAsFork(parent.id())
                      }, 0),
                      fiber.addObserver(wrapped => {
                        let exit$5
                        if (
                          exit$5 = wrapped._op === `Failure` ? wrapped : wrapped.effect_instruction_i0,
                            joinOrder.push(fiber),
                            fibers.delete(fiber),
                            pushResult(exit$5, index$4),
                            results.length === target
                        ) {
                          resume$1(
                            succeed$9(getOrElse$5(exitCollectAll(collectExits(), { parallel: !0 }), () => exitVoid$1)),
                          )
                        } else if (residual.length + results.length === target) {
                          let exits = collectExits(),
                            requests = residual.map(blocked$2 => blocked$2.effect_instruction_i0).reduce(par)
                          resume$1(
                            succeed$9(
                              blocked$1(
                                requests,
                                forEachConcurrentDiscard(
                                  [
                                    getOrElse$5(exitCollectAll(exits, { parallel: !0 }), () => exitVoid$1),
                                    ...residual.map(blocked$2 => blocked$2.effect_instruction_i1),
                                  ],
                                  i$14 => i$14,
                                  batching,
                                  !0,
                                  n$19,
                                ),
                              ),
                            ),
                          )
                        } else next()
                      })
                  }
                }
              for (let i$14 = 0; i$14 < fibersCount; i$14++) next()
            }))
          return asVoid$3(onExit$2(
            flatten$3(restore(join$4(processingFiber))),
            exitMatch({
              onFailure: cause$2 => {
                onInterruptSignal()
                let target$1 = residual.length + 1,
                  concurrency = Math.min(typeof n$19 == `number` ? n$19 : residual.length, residual.length),
                  toPop = Array.from(residual)
                return async_(cb => {
                  let exits = [],
                    count$2 = 0,
                    index$4 = 0,
                    check$1 = (index$5, hitNext) => exit$5 => {
                      exits[index$5] = exit$5,
                        count$2++,
                        count$2 === target$1 && cb(exitSucceed$1(exitFailCause$1(cause$2))),
                        toPop.length > 0 && hitNext && next()
                    },
                    next = () => {
                      runFiber(toPop.pop(), !0).addObserver(check$1(index$4, !0)), index$4++
                    }
                  processingFiber.addObserver(check$1(index$4, !1)), index$4++
                  for (let i$14 = 0; i$14 < concurrency; i$14++) next()
                })
              },
              onSuccess: () => forEachSequential(joinOrder, f$15 => f$15.inheritAll),
            }),
          ))
        })
      )
    ),
  forEachParN = (self$1, n$19, f$14, batching) =>
    suspend$4(() => {
      let as$6 = fromIterable$10(self$1),
        array$3 = Array(as$6.length),
        fn = (a$22, i$14) => map$11(f$14(a$22, i$14), b$3 => array$3[i$14] = b$3)
      return zipRight$3(forEachConcurrentDiscard(as$6, fn, batching, !1, n$19), succeed$9(array$3))
    }),
  fork$2 = self$1 =>
    withFiberRuntime$1((state, status$2) => succeed$9(unsafeFork$1(self$1, state, status$2.runtimeFlags))),
  forkDaemon$1 = self$1 => forkWithScopeOverride(self$1, globalScope),
  forkWithErrorHandler$1 = dual(2, (self$1, handler) =>
    fork$2(onError$1(self$1, cause$2 => {
      let either$6 = failureOrCause$1(cause$2)
      switch (either$6._tag) {
        case `Left`:
          return handler(either$6.left)
        case `Right`:
          return failCause$8(either$6.right)
      }
    }))),
  unsafeFork$1 = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    let childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope)
    return childFiber.resume(effect), childFiber
  },
  unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    let childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope)
    return childFiber
  },
  unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    let childId = unsafeMake$7(),
      parentFiberRefs = parentFiber.getFiberRefs(),
      childFiberRefs = forkAs$1(parentFiberRefs, childId),
      childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags),
      childContext = getOrDefault$1(childFiberRefs, currentContext),
      supervisor = childFiber.currentSupervisor
    supervisor.onStart(childContext, effect, some$4(parentFiber), childFiber),
      childFiber.addObserver(exit$5 => supervisor.onEnd(exit$5, childFiber))
    let parentScope = overrideScope === null
      ? pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse$5(() => parentFiber.scope()))
      : overrideScope
    return parentScope.add(parentRuntimeFlags, childFiber), childFiber
  },
  forkWithScopeOverride = (self$1, scopeOverride) =>
    withFiberRuntime$1((parentFiber, parentStatus) =>
      succeed$9(unsafeFork$1(self$1, parentFiber, parentStatus.runtimeFlags, scopeOverride))
    ),
  mergeAll$2 = dual(
    args$1 => isFunction$1(args$1[2]),
    (elements, zero$1, f$14, options$2) =>
      matchSimple(
        options$2?.concurrency,
        () =>
          fromIterable$10(elements).reduce(
            (acc, a$22, i$14) => zipWith$4(acc, a$22, (acc$1, a$23) => f$14(acc$1, a$23, i$14)),
            succeed$9(zero$1),
          ),
        () =>
          flatMap$5(make$32(zero$1), acc =>
            flatMap$5(
              forEach$1(
                elements,
                (effect, i$14) => flatMap$5(effect, a$22 => update$2(acc, b$3 => f$14(b$3, a$22, i$14))),
                options$2,
              ),
              () => get(acc),
            )),
      ),
  ),
  partition$1 = dual(
    args$1 => isIterable(args$1[0]),
    (elements, f$14, options$2) =>
      pipe(
        forEach$1(elements, (a$22, i$14) => either$3(f$14(a$22, i$14)), options$2),
        map$11(chunk$2 => partitionMap(chunk$2, identity)),
      ),
  ),
  validateAll$1 = dual(
    args$1 => isIterable(args$1[0]),
    (elements, f$14, options$2) =>
      flatMap$5(
        partition$1(elements, f$14, {
          concurrency: options$2?.concurrency,
          batching: options$2?.batching,
          concurrentFinalizers: options$2?.concurrentFinalizers,
        }),
        ([es, bs]) => isNonEmptyArray(es) ? fail$9(es) : options$2?.discard ? void_$4 : succeed$9(bs),
      ),
  ),
  raceAll$1 = all$8 => {
    let list$3 = fromIterable$9(all$8)
    if (!isNonEmpty$4(list$3)) {
      return dieSync$2(() => new IllegalArgumentException$1(`Received an empty collection of effects`))
    }
    let self$1 = headNonEmpty(list$3),
      effects = tailNonEmpty(list$3),
      inheritAll$2 = res => pipe(inheritAll$1(res[1]), as$4(res[0]))
    return pipe(
      deferredMake(),
      flatMap$5(done$8 =>
        pipe(
          make$32(effects.length),
          flatMap$5(fails =>
            uninterruptibleMask$2(restore =>
              pipe(
                fork$2(interruptible$2(self$1)),
                flatMap$5(head$5 =>
                  pipe(
                    effects,
                    forEachSequential(effect => fork$2(interruptible$2(effect))),
                    map$11(fibers => unsafeFromArray(fibers)),
                    map$11(tail => pipe(tail, prepend$1(head$5))),
                    tap$1(fibers =>
                      pipe(
                        fibers,
                        reduce$12(void_$4, (effect, fiber) =>
                          pipe(
                            effect,
                            zipRight$3(
                              pipe(
                                _await$1(fiber),
                                flatMap$5(raceAllArbiter(fibers, fiber, done$8, fails)),
                                fork$2,
                                asVoid$3,
                              ),
                            ),
                          )),
                      )
                    ),
                    flatMap$5(fibers =>
                      pipe(
                        restore(pipe(_await$2(done$8), flatMap$5(inheritAll$2))),
                        onInterrupt$1(() =>
                          pipe(
                            fibers,
                            reduce$12(void_$4, (effect, fiber) => pipe(effect, zipLeft$3(interruptFiber(fiber)))),
                          )
                        ),
                      )
                    ),
                  )
                ),
              )
            )
          ),
        )
      ),
    )
  },
  raceAllArbiter = (fibers, winner, deferred, fails) => exit$5 =>
    exitMatchEffect(exit$5, {
      onFailure: cause$2 =>
        pipe(
          modify(
            fails,
            fails$1 => [fails$1 === 0 ? pipe(deferredFailCause(deferred, cause$2), asVoid$3) : void_$4, fails$1 - 1],
          ),
          flatten$3,
        ),
      onSuccess: value$2 =>
        pipe(
          deferredSucceed(deferred, [value$2, winner]),
          flatMap$5(set$6 =>
            set$6
              ? pipe(
                fromIterable$9(fibers),
                reduce$12(
                  void_$4,
                  (effect, fiber) => fiber === winner ? effect : pipe(effect, zipLeft$3(interruptFiber(fiber))),
                ),
              )
              : void_$4
          ),
        ),
    }),
  reduceEffect$1 = dual(
    args$1 => isIterable(args$1[0]) && !isEffect$1(args$1[0]),
    (elements, zero$1, f$14, options$2) =>
      matchSimple(
        options$2?.concurrency,
        () =>
          fromIterable$10(elements).reduce(
            (acc, a$22, i$14) => zipWith$4(acc, a$22, (acc$1, a$23) => f$14(acc$1, a$23, i$14)),
            zero$1,
          ),
        () =>
          suspend$4(() =>
            pipe(
              mergeAll$2([zero$1, ...elements], none$7(), (acc, elem, i$14) => {
                switch (acc._tag) {
                  case `None`:
                    return some$4(elem)
                  case `Some`:
                    return some$4(f$14(acc.value, elem, i$14))
                }
              }, options$2),
              map$11(option$5 => {
                switch (option$5._tag) {
                  case `None`:
                    throw Error(
                      `BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues`,
                    )
                  case `Some`:
                    return option$5.value
                }
              }),
            )
          ),
      ),
  ),
  parallelFinalizers$1 = self$1 =>
    contextWithEffect$1(context$2 =>
      match$11(getOption(context$2, scopeTag), {
        onNone: () => self$1,
        onSome: scope$2 => {
          switch (scope$2.strategy._tag) {
            case `Parallel`:
              return self$1
            case `Sequential`:
            case `ParallelN`:
              return flatMap$5(scopeFork(scope$2, parallel$1), inner => scopeExtend(self$1, inner))
          }
        },
      })
    ),
  parallelNFinalizers = parallelism => self$1 =>
    contextWithEffect$1(context$2 =>
      match$11(getOption(context$2, scopeTag), {
        onNone: () => self$1,
        onSome: scope$2 =>
          scope$2.strategy._tag === `ParallelN` && scope$2.strategy.parallelism === parallelism
            ? self$1
            : flatMap$5(scopeFork(scope$2, parallelN(parallelism)), inner => scopeExtend(self$1, inner)),
      })
    ),
  finalizersMask$1 = strategy => self$1 => finalizersMaskInternal(strategy, !0)(self$1),
  finalizersMaskInternal = (strategy, concurrentFinalizers) => self$1 =>
    contextWithEffect$1(context$2 =>
      match$11(getOption(context$2, scopeTag), {
        onNone: () => self$1(identity),
        onSome: scope$2 => {
          if (concurrentFinalizers === !0) {
            let patch$12 = strategy._tag === `Parallel`
              ? parallelFinalizers$1
              : strategy._tag === `Sequential`
              ? sequentialFinalizers$1
              : parallelNFinalizers(strategy.parallelism)
            switch (scope$2.strategy._tag) {
              case `Parallel`:
                return patch$12(self$1(parallelFinalizers$1))
              case `Sequential`:
                return patch$12(self$1(sequentialFinalizers$1))
              case `ParallelN`:
                return patch$12(self$1(parallelNFinalizers(scope$2.strategy.parallelism)))
            }
          } else return self$1(identity)
        },
      })
    ),
  scopeWith$1 = f$14 => flatMap$5(scopeTag, f$14),
  scopedWith$1 = f$14 => flatMap$5(scopeMake(), scope$2 => onExit$2(f$14(scope$2), exit$5 => scope$2.close(exit$5))),
  scopedEffect = effect => flatMap$5(scopeMake(), scope$2 => scopeUse(effect, scope$2)),
  sequentialFinalizers$1 = self$1 =>
    contextWithEffect$1(context$2 =>
      match$11(getOption(context$2, scopeTag), {
        onNone: () => self$1,
        onSome: scope$2 => {
          switch (scope$2.strategy._tag) {
            case `Sequential`:
              return self$1
            case `Parallel`:
            case `ParallelN`:
              return flatMap$5(scopeFork(scope$2, sequential$1), inner => scopeExtend(self$1, inner))
          }
        },
      })
    ),
  tagMetricsScoped$1 = (key$1, value$2) => labelMetricsScoped$1([make$30(key$1, value$2)]),
  labelMetricsScoped$1 = labels => fiberRefLocallyScopedWith(currentMetricLabels, old => union$8(old, labels)),
  using$1 = dual(2, (self$1, use$2) => scopedWith$1(scope$2 => flatMap$5(scopeExtend(self$1, scope$2), use$2))),
  validate$1 = dual(
    args$1 => isEffect$1(args$1[1]),
    (self$1, that, options$2) => validateWith$1(self$1, that, (a$22, b$3) => [a$22, b$3], options$2),
  ),
  validateWith$1 = dual(
    args$1 => isEffect$1(args$1[1]),
    (self$1, that, f$14, options$2) =>
      flatten$3(zipWithOptions(exit$4(self$1), exit$4(that), (ea, eb) =>
        exitZipWith(ea, eb, {
          onSuccess: f$14,
          onFailure: (ca, cb) => options$2?.concurrent ? parallel$3(ca, cb) : sequential$3(ca, cb),
        }), options$2)),
  ),
  validateFirst$1 = dual(
    args$1 => isIterable(args$1[0]),
    (elements, f$14, options$2) => flip$4(forEach$1(elements, (a$22, i$14) => flip$4(f$14(a$22, i$14)), options$2)),
  ),
  withClockScoped$1 = c$3 => fiberRefLocallyScopedWith(currentServices, add$3(clockTag, c$3)),
  withRandomScoped$1 = value$2 => fiberRefLocallyScopedWith(currentServices, add$3(randomTag, value$2)),
  withConfigProviderScoped$1 = provider =>
    fiberRefLocallyScopedWith(currentServices, add$3(configProviderTag, provider)),
  withEarlyRelease$1 = self$1 =>
    scopeWith$1(parent =>
      flatMap$5(
        scopeFork(parent, sequential$2),
        child =>
          pipe(
            self$1,
            scopeExtend(child),
            map$11(value$2 => [fiberIdWith$1(fiberId$2 => scopeClose(child, exitInterrupt$1(fiberId$2))), value$2]),
          ),
      )
    ),
  zipOptions = dual(
    args$1 => isEffect$1(args$1[1]),
    (self$1, that, options$2) => zipWithOptions(self$1, that, (a$22, b$3) => [a$22, b$3], options$2),
  ),
  zipLeftOptions = dual(
    args$1 => isEffect$1(args$1[1]),
    (self$1, that, options$2) =>
      options$2?.concurrent !== !0 && (options$2?.batching === void 0 || options$2.batching === !1)
        ? zipLeft$3(self$1, that)
        : zipWithOptions(self$1, that, (a$22, _$1) => a$22, options$2),
  ),
  zipRightOptions = dual(
    args$1 => isEffect$1(args$1[1]),
    (self$1, that, options$2) =>
      options$2?.concurrent !== !0 && (options$2?.batching === void 0 || options$2.batching === !1)
        ? zipRight$3(self$1, that)
        : zipWithOptions(self$1, that, (_$1, b$3) => b$3, options$2),
  ),
  zipWithOptions = dual(
    args$1 => isEffect$1(args$1[1]),
    (self$1, that, f$14, options$2) =>
      map$11(
        all$4([self$1, that], {
          concurrency: options$2?.concurrent ? 2 : 1,
          batching: options$2?.batching,
          concurrentFinalizers: options$2?.concurrentFinalizers,
        }),
        ([a$22, a2]) => f$14(a$22, a2),
      ),
  ),
  withRuntimeFlagsScoped = update$5 =>
    update$5 === empty$19 ? void_$4 : pipe(
      runtimeFlags,
      flatMap$5(runtimeFlags$1 => {
        let updatedRuntimeFlags = patch$5(runtimeFlags$1, update$5),
          revertRuntimeFlags = diff$3(updatedRuntimeFlags, runtimeFlags$1)
        return pipe(
          updateRuntimeFlags(update$5),
          zipRight$3(addFinalizer$2(() => updateRuntimeFlags(revertRuntimeFlags))),
          asVoid$3,
        )
      }),
      uninterruptible$1,
    ),
  scopeTag = GenericTag(`effect/Scope`),
  scope$1 = scopeTag,
  scopeUnsafeAddFinalizer = (scope$2, fin) => {
    scope$2.state._tag === `Open` && scope$2.state.finalizers.set({}, fin)
  },
  ScopeImplProto = {
    [ScopeTypeId$1]: ScopeTypeId$1,
    [CloseableScopeTypeId$1]: CloseableScopeTypeId$1,
    pipe() {
      return pipeArguments(this, arguments)
    },
    fork(strategy) {
      return sync$3(() => {
        let newScope = scopeUnsafeMake(strategy)
        if (this.state._tag === `Closed`) return newScope.state = this.state, newScope
        let key$1 = {}, fin = exit$5 => newScope.close(exit$5)
        return this.state.finalizers.set(key$1, fin),
          scopeUnsafeAddFinalizer(newScope, _$1 =>
            sync$3(() => {
              this.state._tag === `Open` && this.state.finalizers.delete(key$1)
            })),
          newScope
      })
    },
    close(exit$5) {
      return suspend$4(() => {
        if (this.state._tag === `Closed`) return void_$4
        let finalizers = Array.from(this.state.finalizers.values()).reverse()
        return this.state = { _tag: `Closed`, exit: exit$5 },
          finalizers.length === 0
            ? void_$4
            : isSequential$1(this.strategy)
            ? pipe(
              forEachSequential(finalizers, fin => exit$4(fin(exit$5))),
              flatMap$5(results => pipe(exitCollectAll(results), map$18(exitAsVoid), getOrElse$5(() => exitVoid$1))),
            )
            : isParallel$1(this.strategy)
            ? pipe(
              forEachParUnbounded(finalizers, fin => exit$4(fin(exit$5)), !1),
              flatMap$5(results =>
                pipe(
                  exitCollectAll(results, { parallel: !0 }),
                  map$18(exitAsVoid),
                  getOrElse$5(() => exitVoid$1),
                )
              ),
            )
            : pipe(
              forEachParN(finalizers, this.strategy.parallelism, fin => exit$4(fin(exit$5)), !1),
              flatMap$5(results =>
                pipe(exitCollectAll(results, { parallel: !0 }), map$18(exitAsVoid), getOrElse$5(() => exitVoid$1))
              ),
            )
      })
    },
    addFinalizer(fin) {
      return suspend$4(() =>
        this.state._tag === `Closed` ? fin(this.state.exit) : (this.state.finalizers.set({}, fin), void_$4)
      )
    },
  },
  scopeUnsafeMake = (strategy = sequential$2) => {
    let scope$2 = Object.create(ScopeImplProto)
    return scope$2.strategy = strategy, scope$2.state = { _tag: `Open`, finalizers: new Map() }, scope$2
  },
  scopeMake = (strategy = sequential$2) => sync$3(() => scopeUnsafeMake(strategy)),
  scopeExtend = dual(2, (effect, scope$2) => mapInputContext$1(effect, merge$6(make$57(scopeTag, scope$2)))),
  scopeUse = dual(
    2,
    (effect, scope$2) => pipe(effect, scopeExtend(scope$2), onExit$2(exit$5 => scope$2.close(exit$5))),
  ),
  fiberRefUnsafeMakeSupervisor = initial => fiberRefUnsafeMakePatch(initial, { differ, fork: empty$7 }),
  fiberRefLocallyScoped = dual(
    2,
    (self$1, value$2) =>
      asVoid$3(acquireRelease$1(
        flatMap$5(fiberRefGet(self$1), oldValue => as$4(fiberRefSet(self$1, value$2), oldValue)),
        oldValue => fiberRefSet(self$1, oldValue),
      )),
  ),
  fiberRefLocallyScopedWith = dual(
    2,
    (self$1, f$14) => fiberRefGetWith(self$1, a$22 => fiberRefLocallyScoped(self$1, f$14(a$22))),
  ),
  currentRuntimeFlags = fiberRefUnsafeMakeRuntimeFlags(none$5),
  currentSupervisor = fiberRefUnsafeMakeSupervisor(none$2),
  fiberAwaitAll = fibers => forEach$1(fibers, _await$1),
  fiberAll = fibers => {
    let _fiberAll = {
      ...CommitPrototype,
      commit() {
        return join$4(this)
      },
      [FiberTypeId$1]: fiberVariance,
      id: () => fromIterable$10(fibers).reduce((id$2, fiber) => combine$9(id$2, fiber.id()), none$6),
      await: exit$4(forEachParUnbounded(fibers, fiber => flatten$3(fiber.await), !1)),
      children: map$11(forEachParUnbounded(fibers, fiber => fiber.children, !1), flatten$7),
      inheritAll: forEachSequentialDiscard(fibers, fiber => fiber.inheritAll),
      poll: map$11(
        forEachSequential(fibers, fiber => fiber.poll),
        reduceRight$3(some$4(exitSucceed$1([])), (optionB, optionA) => {
          switch (optionA._tag) {
            case `None`:
              return none$7()
            case `Some`:
              switch (optionB._tag) {
                case `None`:
                  return none$7()
                case `Some`:
                  return some$4(
                    exitZipWith(optionA.value, optionB.value, {
                      onSuccess: (a$22, chunk$2) => [a$22, ...chunk$2],
                      onFailure: parallel$3,
                    }),
                  )
              }
          }
        }),
      ),
      interruptAsFork: fiberId$2 => forEachSequentialDiscard(fibers, fiber => fiber.interruptAsFork(fiberId$2)),
    }
    return _fiberAll
  },
  fiberInterruptFork = self$1 => asVoid$3(forkDaemon$1(interruptFiber(self$1))),
  fiberJoinAll = fibers => join$4(fiberAll(fibers)),
  fiberScoped = self$1 => acquireRelease$1(succeed$9(self$1), interruptFiber),
  raceWith$1 = dual(3, (self$1, other, options$2) =>
    raceFibersWith(self$1, other, {
      onSelfWin: (winner, loser) =>
        flatMap$5(winner.await, exit$5 => {
          switch (exit$5._tag) {
            case OP_SUCCESS:
              return flatMap$5(winner.inheritAll, () => options$2.onSelfDone(exit$5, loser))
            case OP_FAILURE:
              return options$2.onSelfDone(exit$5, loser)
          }
        }),
      onOtherWin: (winner, loser) =>
        flatMap$5(winner.await, exit$5 => {
          switch (exit$5._tag) {
            case OP_SUCCESS:
              return flatMap$5(winner.inheritAll, () => options$2.onOtherDone(exit$5, loser))
            case OP_FAILURE:
              return options$2.onOtherDone(exit$5, loser)
          }
        }),
    })),
  disconnect$1 = self$1 =>
    uninterruptibleMask$2(restore =>
      fiberIdWith$1(fiberId$2 =>
        flatMap$5(
          forkDaemon$1(restore(self$1)),
          fiber => pipe(restore(join$4(fiber)), onInterrupt$1(() => pipe(fiber, interruptAsFork$1(fiberId$2)))),
        )
      )
    ),
  race$1 = dual(2, (self$1, that) =>
    fiberIdWith$1(parentFiberId =>
      raceWith$1(self$1, that, {
        onSelfDone: (exit$5, right$2) =>
          exitMatchEffect(exit$5, {
            onFailure: cause$2 => pipe(join$4(right$2), mapErrorCause$1(cause2 => parallel$3(cause$2, cause2))),
            onSuccess: value$2 => pipe(right$2, interruptAsFiber(parentFiberId), as$4(value$2)),
          }),
        onOtherDone: (exit$5, left$2) =>
          exitMatchEffect(exit$5, {
            onFailure: cause$2 => pipe(join$4(left$2), mapErrorCause$1(cause2 => parallel$3(cause2, cause$2))),
            onSuccess: value$2 => pipe(left$2, interruptAsFiber(parentFiberId), as$4(value$2)),
          }),
      })
    )),
  raceFibersWith = dual(3, (self$1, other, options$2) =>
    withFiberRuntime$1((parentFiber, parentStatus) => {
      let parentRuntimeFlags = parentStatus.runtimeFlags,
        raceIndicator = make$50(!0),
        leftFiber = unsafeMakeChildFiber(self$1, parentFiber, parentRuntimeFlags, options$2.selfScope),
        rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options$2.otherScope)
      return async_(cb => {
        leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options$2.onSelfWin, raceIndicator, cb)),
          rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options$2.onOtherWin, raceIndicator, cb)),
          leftFiber.startFork(self$1),
          rightFiber.startFork(other)
      }, combine$9(leftFiber.id(), rightFiber.id()))
    })),
  completeRace = (winner, loser, cont, ab, cb) => {
    compareAndSet(!0, !1)(ab) && cb(cont(winner, loser))
  },
  ensuring$1 = dual(
    2,
    (self$1, finalizer) =>
      uninterruptibleMask$2(restore =>
        matchCauseEffect$2(restore(self$1), {
          onFailure: cause1 =>
            matchCauseEffect$2(finalizer, {
              onFailure: cause2 => failCause$8(sequential$3(cause1, cause2)),
              onSuccess: () => failCause$8(cause1),
            }),
          onSuccess: a$22 => as$4(finalizer, a$22),
        })
      ),
  ),
  invokeWithInterrupt = (self$1, entries$2, onInterrupt$2) =>
    fiberIdWith$1(id$2 =>
      flatMap$5(
        flatMap$5(forkDaemon$1(interruptible$2(self$1)), processing =>
          async_(cb => {
            let counts = entries$2.map(_$1 => _$1.listeners.count),
              checkDone = () => {
                counts.every(count$2 => count$2 === 0) && entries$2.every(_$1 =>
                  _$1.result.state.current._tag === `Pending`
                    ? !0
                    : !!(_$1.result.state.current._tag === `Done` && exitIsExit(_$1.result.state.current.effect)
                      && _$1.result.state.current.effect._tag === `Failure`
                      && isInterrupted$2(_$1.result.state.current.effect.cause))
                ) && (cleanup.forEach(f$14 => f$14()), onInterrupt$2?.(), cb(interruptFiber(processing)))
              }
            processing.addObserver(exit$5 => {
              cleanup.forEach(f$14 => f$14()), cb(exit$5)
            })
            let cleanup = entries$2.map((r$26, i$14) => {
              let observer = count$2 => {
                counts[i$14] = count$2, checkDone()
              }
              return r$26.listeners.addObserver(observer), () => r$26.listeners.removeObserver(observer)
            })
            return checkDone(),
              sync$3(() => {
                cleanup.forEach(f$14 => f$14())
              })
          })),
        () =>
          suspend$4(() => {
            let residual = entries$2.flatMap(entry => entry.state.completed ? [] : [entry])
            return forEachSequentialDiscard(residual, entry => complete$2(entry.request, exitInterrupt$1(id$2)))
          }),
      )
    ),
  interruptWhenPossible$1 = dual(2, (self$1, all$8) =>
    fiberRefGetWith(currentRequestMap, map$20 =>
      suspend$4(() => {
        let entries$2 = fromIterable$10(all$8).flatMap(_$1 => map$20.has(_$1) ? [map$20.get(_$1)] : [])
        return invokeWithInterrupt(self$1, entries$2)
      }))),
  makeSpanScoped$1 = (
    name,
    options$2,
  ) => (options$2 = addSpanStackTrace(options$2),
    uninterruptible$1(withFiberRuntime$1(fiber => {
      let scope$2 = unsafeGet$3(fiber.getFiberRef(currentContext), scopeTag),
        span$1 = unsafeMakeSpan(fiber, name, options$2),
        timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled),
        clock_ = get$9(fiber.getFiberRef(currentServices), clockTag)
      return as$4(scopeAddFinalizerExit(scope$2, exit$5 => endSpan(span$1, exit$5, clock_, timingEnabled)), span$1)
    }))),
  withTracerScoped$1 = value$2 => fiberRefLocallyScopedWith(currentServices, add$3(tracerTag, value$2)),
  withSpanScoped$1 = function() {
    let dataFirst = typeof arguments[0] != `string`,
      name = dataFirst ? arguments[1] : arguments[0],
      options$2 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])
    if (dataFirst) {
      let self$1 = arguments[0]
      return flatMap$5(
        makeSpanScoped$1(name, addSpanStackTrace(options$2)),
        span$1 => provideService$1(self$1, spanTag, span$1),
      )
    }
    return self$1 =>
      flatMap$5(
        makeSpanScoped$1(name, addSpanStackTrace(options$2)),
        span$1 => provideService$1(self$1, spanTag, span$1),
      )
  },
  complete$1 = (key$1, exit$5, entryStats, timeToLiveMillis) =>
    struct$1({ _tag: `Complete`, key: key$1, exit: exit$5, entryStats, timeToLiveMillis }),
  pending = (key$1, deferred) => struct$1({ _tag: `Pending`, key: key$1, deferred }),
  refreshing = (deferred, complete$4) => struct$1({ _tag: `Refreshing`, deferred, complete: complete$4 }),
  MapKeyTypeId = Symbol.for(`effect/Cache/MapKey`)
var MapKeyImpl = class {
  current;
  [MapKeyTypeId] = MapKeyTypeId
  previous = void 0
  next = void 0
  constructor(current) {
    this.current = current
  }
  [symbol$2]() {
    return pipe(hash(this.current), combine$11(hash(this.previous)), combine$11(hash(this.next)), cached$2(this))
  }
  [symbol$1](that) {
    return this === that
      ? !0
      : isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous)
        && equals(this.next, that.next)
  }
}
const makeMapKey = current => new MapKeyImpl(current), isMapKey = u$7 => hasProperty(u$7, MapKeyTypeId)
var KeySetImpl = class {
  head = void 0
  tail = void 0
  add(key$1) {
    if (key$1 !== this.tail) {
      if (this.tail === void 0) this.head = key$1, this.tail = key$1
      else {
        let previous$2 = key$1.previous, next = key$1.next
        next !== void 0 && (key$1.next = void 0,
          previous$2 === void 0
            ? (this.head = next, this.head.previous = void 0)
            : (previous$2.next = next, next.previous = previous$2)),
          this.tail.next = key$1,
          key$1.previous = this.tail,
          this.tail = key$1
      }
    }
  }
  remove() {
    let key$1 = this.head
    if (key$1 !== void 0) {
      let next = key$1.next
      next === void 0
        ? (this.head = void 0, this.tail = void 0)
        : (key$1.next = void 0, this.head = next, this.head.previous = void 0)
    }
    return key$1
  }
}
const makeKeySet = () => new KeySetImpl(),
  makeCacheState = (map$20, keys$6, accesses, updating, hits, misses) => ({
    map: map$20,
    keys: keys$6,
    accesses,
    updating,
    hits,
    misses,
  }),
  initialCacheState = () => makeCacheState(empty$16(), makeKeySet(), unbounded(), make$50(!1), 0, 0),
  CacheSymbolKey = `effect/Cache`,
  CacheTypeId = Symbol.for(CacheSymbolKey),
  cacheVariance = { _Key: _$1 => _$1, _Error: _$1 => _$1, _Value: _$1 => _$1 },
  ConsumerCacheSymbolKey = `effect/ConsumerCache`,
  ConsumerCacheTypeId = Symbol.for(ConsumerCacheSymbolKey),
  consumerCacheVariance = { _Key: _$1 => _$1, _Error: _$1 => _$1, _Value: _$1 => _$1 },
  makeCacheStats = options$2 => options$2,
  makeEntryStats = loadedMillis => ({ loadedMillis })
var CacheImpl = class {
  capacity
  context
  fiberId
  lookup
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance
  cacheState
  constructor(capacity, context$2, fiberId$2, lookup, timeToLive) {
    this.capacity = capacity,
      this.context = context$2,
      this.fiberId = fiberId$2,
      this.lookup = lookup,
      this.timeToLive = timeToLive,
      this.cacheState = initialCacheState()
  }
  get(key$1) {
    return map$11(this.getEither(key$1), merge$8)
  }
  get cacheStats() {
    return sync$3(() =>
      makeCacheStats({ hits: this.cacheState.hits, misses: this.cacheState.misses, size: size$8(this.cacheState.map) })
    )
  }
  getOption(key$1) {
    return suspend$4(() =>
      match$11(get$4(this.cacheState.map, key$1), {
        onNone: () => {
          let mapKey = makeMapKey(key$1)
          return this.trackAccess(mapKey), this.trackMiss(), succeed$9(none$7())
        },
        onSome: value$2 => this.resolveMapValue(value$2),
      })
    )
  }
  getOptionComplete(key$1) {
    return suspend$4(() =>
      match$11(get$4(this.cacheState.map, key$1), {
        onNone: () => {
          let mapKey = makeMapKey(key$1)
          return this.trackAccess(mapKey), this.trackMiss(), succeed$9(none$7())
        },
        onSome: value$2 => this.resolveMapValue(value$2, !0),
      })
    )
  }
  contains(key$1) {
    return sync$3(() => has$2(this.cacheState.map, key$1))
  }
  entryStats(key$1) {
    return sync$3(() => {
      let option$5 = get$4(this.cacheState.map, key$1)
      if (isSome(option$5)) {
        switch (option$5.value._tag) {
          case `Complete`: {
            let loaded = option$5.value.entryStats.loadedMillis
            return some$4(makeEntryStats(loaded))
          }
          case `Pending`:
            return none$7()
          case `Refreshing`: {
            let loaded = option$5.value.complete.entryStats.loadedMillis
            return some$4(makeEntryStats(loaded))
          }
        }
      }
      return none$7()
    })
  }
  getEither(key$1) {
    return suspend$4(() => {
      let k$1 = key$1, mapKey, deferred, value$2 = getOrUndefined(get$4(this.cacheState.map, k$1))
      return value$2 === void 0
        && (deferred = unsafeMake$6(this.fiberId),
          mapKey = makeMapKey(k$1),
          has$2(this.cacheState.map, k$1)
            ? value$2 = getOrUndefined(get$4(this.cacheState.map, k$1))
            : set$2(this.cacheState.map, k$1, pending(mapKey, deferred))),
        value$2 === void 0
          ? (this.trackAccess(mapKey), this.trackMiss(), map$11(this.lookupValueOf(key$1, deferred), right))
          : flatMap$5(
            this.resolveMapValue(value$2),
            match$11({ onNone: () => this.getEither(key$1), onSome: value$3 => succeed$9(left(value$3)) }),
          )
    })
  }
  invalidate(key$1) {
    return sync$3(() => {
      remove$2(this.cacheState.map, key$1)
    })
  }
  invalidateWhen(key$1, when$4) {
    return sync$3(() => {
      let value$2 = get$4(this.cacheState.map, key$1)
      isSome(value$2) && value$2.value._tag === `Complete` && value$2.value.exit._tag === `Success`
        && when$4(value$2.value.exit.value) && remove$2(this.cacheState.map, key$1)
    })
  }
  get invalidateAll() {
    return sync$3(() => {
      this.cacheState.map = empty$16()
    })
  }
  refresh(key$1) {
    return clockWith$1(clock$2 =>
      suspend$4(() => {
        let k$1 = key$1,
          deferred = unsafeMake$6(this.fiberId),
          value$2 = getOrUndefined(get$4(this.cacheState.map, k$1))
        if (
          value$2 === void 0 && (has$2(this.cacheState.map, k$1)
            ? value$2 = getOrUndefined(get$4(this.cacheState.map, k$1))
            : set$2(this.cacheState.map, k$1, pending(makeMapKey(k$1), deferred))), value$2 === void 0
        ) return asVoid$3(this.lookupValueOf(key$1, deferred))
        switch (value$2._tag) {
          case `Complete`:
            if (this.hasExpired(clock$2, value$2.timeToLiveMillis)) {
              let found = getOrUndefined(get$4(this.cacheState.map, k$1))
              return equals(found, value$2) && remove$2(this.cacheState.map, k$1), asVoid$3(this.get(key$1))
            }
            return pipe(
              this.lookupValueOf(key$1, deferred),
              when$3(() => {
                let current = getOrUndefined(get$4(this.cacheState.map, k$1))
                if (equals(current, value$2)) {
                  let mapValue$1 = refreshing(deferred, value$2)
                  return set$2(this.cacheState.map, k$1, mapValue$1), !0
                }
                return !1
              }),
              asVoid$3,
            )
          case `Pending`:
            return _await$2(value$2.deferred)
          case `Refreshing`:
            return _await$2(value$2.deferred)
        }
      })
    )
  }
  set(key$1, value$2) {
    return clockWith$1(clock$2 =>
      sync$3(() => {
        let now$1 = clock$2.unsafeCurrentTimeMillis(),
          k$1 = key$1,
          lookupResult = succeed$7(value$2),
          mapValue$1 = complete$1(
            makeMapKey(k$1),
            lookupResult,
            makeEntryStats(now$1),
            now$1 + toMillis(decode$30(this.timeToLive(lookupResult))),
          )
        set$2(this.cacheState.map, k$1, mapValue$1)
      })
    )
  }
  get size() {
    return sync$3(() => size$8(this.cacheState.map))
  }
  get values() {
    return sync$3(() => {
      let values$6 = []
      for (let entry of this.cacheState.map) {
        entry[1]._tag === `Complete` && entry[1].exit._tag === `Success` && values$6.push(entry[1].exit.value)
      }
      return values$6
    })
  }
  get entries() {
    return sync$3(() => {
      let values$6 = []
      for (let entry of this.cacheState.map) {
        entry[1]._tag === `Complete` && entry[1].exit._tag === `Success`
          && values$6.push([entry[0], entry[1].exit.value])
      }
      return values$6
    })
  }
  get keys() {
    return sync$3(() => {
      let keys$6 = []
      for (let entry of this.cacheState.map) {
        entry[1]._tag === `Complete` && entry[1].exit._tag === `Success` && keys$6.push(entry[0])
      }
      return keys$6
    })
  }
  resolveMapValue(value$2, ignorePending = !1) {
    return clockWith$1(clock$2 => {
      switch (value$2._tag) {
        case `Complete`:
          return this.trackAccess(value$2.key),
            this.hasExpired(clock$2, value$2.timeToLiveMillis)
              ? (remove$2(this.cacheState.map, value$2.key.current), succeed$9(none$7()))
              : (this.trackHit(), map$11(value$2.exit, some$4))
        case `Pending`:
          return this.trackAccess(value$2.key),
            this.trackHit(),
            ignorePending ? succeed$9(none$7()) : map$11(_await$2(value$2.deferred), some$4)
        case `Refreshing`:
          return this.trackAccess(value$2.complete.key),
            this.trackHit(),
            this.hasExpired(clock$2, value$2.complete.timeToLiveMillis)
              ? ignorePending ? succeed$9(none$7()) : map$11(_await$2(value$2.deferred), some$4)
              : map$11(value$2.complete.exit, some$4)
      }
    })
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1
  }
  trackAccess(key$1) {
    if (offer(this.cacheState.accesses, key$1), compareAndSet(this.cacheState.updating, !1, !0)) {
      let loop$2 = !0
      for (; loop$2;) {
        let key$2 = poll$2(this.cacheState.accesses, EmptyMutableQueue)
        key$2 === EmptyMutableQueue ? loop$2 = !1 : this.cacheState.keys.add(key$2)
      }
      let size$14 = size$8(this.cacheState.map)
      for (loop$2 = size$14 > this.capacity; loop$2;) {
        let key$2 = this.cacheState.keys.remove()
        key$2 === void 0
          ? loop$2 = !1
          : has$2(this.cacheState.map, key$2.current)
            && (remove$2(this.cacheState.map, key$2.current), --size$14, loop$2 = size$14 > this.capacity)
      }
      set$4(this.cacheState.updating, !1)
    }
  }
  hasExpired(clock$2, timeToLiveMillis) {
    return clock$2.unsafeCurrentTimeMillis() > timeToLiveMillis
  }
  lookupValueOf(input, deferred) {
    return clockWith$1(clock$2 =>
      suspend$4(() => {
        let key$1 = input
        return pipe(
          this.lookup(input),
          provideContext$1(this.context),
          exit$4,
          flatMap$5(exit$5 => {
            let now$1 = clock$2.unsafeCurrentTimeMillis(),
              stats = makeEntryStats(now$1),
              value$2 = complete$1(
                makeMapKey(key$1),
                exit$5,
                stats,
                now$1 + toMillis(decode$30(this.timeToLive(exit$5))),
              )
            return set$2(this.cacheState.map, key$1, value$2), zipRight$3(done$6(deferred, exit$5), exit$5)
          }),
          onInterrupt$1(() =>
            zipRight$3(
              interrupt$4(deferred),
              sync$3(() => {
                remove$2(this.cacheState.map, key$1)
              }),
            )
          ),
        )
      })
    )
  }
}
const unsafeMakeWith = (capacity, lookup, timeToLive) =>
    new CacheImpl(capacity, empty$33(), none$1, lookup, exit$5 => decode$30(timeToLive(exit$5))),
  CauseTypeId = CauseTypeId$1,
  RuntimeExceptionTypeId = RuntimeExceptionTypeId$1,
  InterruptedExceptionTypeId = InterruptedExceptionTypeId$1,
  IllegalArgumentExceptionTypeId = IllegalArgumentExceptionTypeId$1,
  NoSuchElementExceptionTypeId = NoSuchElementExceptionTypeId$1,
  InvalidPubSubCapacityExceptionTypeId = InvalidPubSubCapacityExceptionTypeId$1,
  ExceededCapacityExceptionTypeId = ExceededCapacityExceptionTypeId$1,
  TimeoutExceptionTypeId = TimeoutExceptionTypeId$1,
  UnknownExceptionTypeId = UnknownExceptionTypeId$1,
  YieldableError = YieldableError$1,
  empty$6 = empty$17,
  fail$4 = fail$10,
  die$1 = die$5,
  interrupt$2 = interrupt$6,
  parallel = parallel$3,
  sequential = sequential$3,
  isCause = isCause$1,
  isEmptyType = isEmptyType$1,
  isFailType = isFailType$1,
  isDieType = isDieType$1,
  isInterruptType = isInterruptType$1,
  isSequentialType = isSequentialType$1,
  isParallelType = isParallelType$1,
  size$5 = size$9,
  isEmpty$2 = isEmpty$4,
  isFailure$1 = isFailure$4,
  isDie = isDie$1,
  isInterrupted = isInterrupted$2,
  isInterruptedOnly = isInterruptedOnly$1,
  failures = failures$1,
  defects = defects$1,
  interruptors = interruptors$1,
  failureOption = failureOption$1,
  failureOrCause = failureOrCause$1,
  flipCauseOption = flipCauseOption$1,
  dieOption = dieOption$1,
  interruptOption = interruptOption$1,
  keepDefects = keepDefects$1,
  linearize = linearize$1,
  stripFailures = stripFailures$1,
  stripSomeDefects = stripSomeDefects$1,
  as$1 = as$5,
  map$6 = map$12,
  flatMap$2 = flatMap$6,
  andThen$1 = andThen$3,
  flatten$1 = flatten$4,
  contains$1 = contains$2,
  squash = causeSquash,
  squashWith = causeSquashWith,
  find$1 = find$2,
  filter$2 = filter$4,
  match$2 = match$9,
  reduce$1 = reduce$5,
  reduceWithContext = reduceWithContext$1,
  InterruptedException = InterruptedException$1,
  isInterruptedException = isInterruptedException$1,
  IllegalArgumentException = IllegalArgumentException$1,
  isIllegalArgumentException = isIllegalArgumentException$1,
  NoSuchElementException = NoSuchElementException$1,
  isNoSuchElementException = isNoSuchElementException$1,
  RuntimeException = RuntimeException$1,
  isRuntimeException = isRuntimeException$1,
  TimeoutException = TimeoutException$1,
  isTimeoutException = isTimeoutException$1,
  UnknownException = UnknownException$1,
  isUnknownException = isUnknownException$1,
  ExceededCapacityException = ExceededCapacityException$1,
  isExceededCapacityException = isExceededCapacityException$1,
  pretty$1 = pretty$3,
  prettyErrors = prettyErrors$1,
  originalError = originalInstance,
  IntervalSymbolKey = `effect/ScheduleInterval`,
  IntervalTypeId$1 = Symbol.for(IntervalSymbolKey),
  empty$5 = { [IntervalTypeId$1]: IntervalTypeId$1, startMillis: 0, endMillis: 0 },
  make$23 = (startMillis, endMillis) =>
    startMillis > endMillis ? empty$5 : { [IntervalTypeId$1]: IntervalTypeId$1, startMillis, endMillis },
  lessThan$9 = dual(2, (self$1, that) => min$8(self$1, that) === self$1),
  min$8 = dual(
    2,
    (self$1, that) =>
      self$1.endMillis <= that.startMillis
        ? self$1
        : that.endMillis <= self$1.startMillis
        ? that
        : self$1.startMillis < that.startMillis
        ? self$1
        : that.startMillis < self$1.startMillis
        ? that
        : self$1.endMillis <= that.endMillis
        ? self$1
        : that,
  ),
  max$10 = dual(2, (self$1, that) => min$8(self$1, that) === self$1 ? that : self$1),
  isEmpty$1 = self$1 => self$1.startMillis >= self$1.endMillis,
  isNonEmpty$3 = self$1 => !isEmpty$1(self$1),
  intersect$4 = dual(2, (self$1, that) => {
    let start$2 = Math.max(self$1.startMillis, that.startMillis), end$2 = Math.min(self$1.endMillis, that.endMillis)
    return make$23(start$2, end$2)
  }),
  size$4 = self$1 => millis(self$1.endMillis - self$1.startMillis),
  union$3 = dual(2, (self$1, that) => {
    let start$2 = Math.max(self$1.startMillis, that.startMillis), end$2 = Math.min(self$1.endMillis, that.endMillis)
    return start$2 < end$2 ? none$7() : some$4(make$23(start$2, end$2))
  }),
  after$1 = startMilliseconds => make$23(startMilliseconds, 1 / 0),
  before$1 = endMilliseconds => make$23(-1 / 0, endMilliseconds),
  IntervalTypeId = IntervalTypeId$1,
  make$22 = make$23,
  empty$4 = empty$5,
  lessThan$8 = lessThan$9,
  min$7 = min$8,
  max$9 = max$10,
  isEmpty = isEmpty$1,
  isNonEmpty$2 = isNonEmpty$3,
  intersect$3 = intersect$4,
  size$3 = size$4,
  union$2 = union$3,
  after = after$1,
  before = before$1,
  IntervalsSymbolKey = `effect/ScheduleIntervals`,
  IntervalsTypeId$1 = Symbol.for(IntervalsSymbolKey),
  make$21 = intervals => ({ [IntervalsTypeId$1]: IntervalsTypeId$1, intervals }),
  empty$3 = make$21(empty$32()),
  fromIterable$1 = intervals =>
    Array.from(intervals).reduce(
      (intervals$1, interval) => pipe(intervals$1, union$1(make$21(of$3(interval)))),
      empty$3,
    ),
  union$1 = dual(
    2,
    (self$1, that) =>
      isNonEmpty$4(that.intervals)
        ? isNonEmpty$4(self$1.intervals)
          ? headNonEmpty(self$1.intervals).startMillis < headNonEmpty(that.intervals).startMillis
            ? unionLoop(tailNonEmpty(self$1.intervals), that.intervals, headNonEmpty(self$1.intervals), empty$32())
            : unionLoop(self$1.intervals, tailNonEmpty(that.intervals), headNonEmpty(that.intervals), empty$32())
          : that
        : self$1,
  ),
  unionLoop = (_self, _that, _interval, _acc) => {
    let self$1 = _self, that = _that, interval = _interval, acc = _acc
    for (; isNonEmpty$4(self$1) || isNonEmpty$4(that);) {
      if (!isNonEmpty$4(self$1) && isNonEmpty$4(that)) {
        interval.endMillis < headNonEmpty(that).startMillis
          ? (acc = pipe(acc, prepend$1(interval)),
            interval = headNonEmpty(that),
            that = tailNonEmpty(that),
            self$1 = empty$32())
          : (interval = make$22(interval.startMillis, headNonEmpty(that).endMillis),
            that = tailNonEmpty(that),
            self$1 = empty$32())
      } else if (isNonEmpty$4(self$1) && isEmpty$9(that)) {
        interval.endMillis < headNonEmpty(self$1).startMillis
          ? (acc = pipe(acc, prepend$1(interval)),
            interval = headNonEmpty(self$1),
            that = empty$32(),
            self$1 = tailNonEmpty(self$1))
          : (interval = make$22(interval.startMillis, headNonEmpty(self$1).endMillis),
            that = empty$32(),
            self$1 = tailNonEmpty(self$1))
      } else if (isNonEmpty$4(self$1) && isNonEmpty$4(that)) {
        headNonEmpty(self$1).startMillis < headNonEmpty(that).startMillis
          ? interval.endMillis < headNonEmpty(self$1).startMillis
            ? (acc = pipe(acc, prepend$1(interval)), interval = headNonEmpty(self$1), self$1 = tailNonEmpty(self$1))
            : (interval = make$22(interval.startMillis, headNonEmpty(self$1).endMillis), self$1 = tailNonEmpty(self$1))
          : interval.endMillis < headNonEmpty(that).startMillis
          ? (acc = pipe(acc, prepend$1(interval)), interval = headNonEmpty(that), that = tailNonEmpty(that))
          : (interval = make$22(interval.startMillis, headNonEmpty(that).endMillis), that = tailNonEmpty(that))
      } else throw Error(getBugErrorMessage(`Intervals.unionLoop`))
    }
    return make$21(pipe(acc, prepend$1(interval), reverse$1))
  },
  intersect$2 = dual(2, (self$1, that) => intersectLoop(self$1.intervals, that.intervals, empty$32())),
  intersectLoop = (_left, _right, _acc) => {
    let left$2 = _left, right$2 = _right, acc = _acc
    for (; isNonEmpty$4(left$2) && isNonEmpty$4(right$2);) {
      let interval = pipe(headNonEmpty(left$2), intersect$3(headNonEmpty(right$2))),
        intervals = isEmpty(interval) ? acc : pipe(acc, prepend$1(interval))
      pipe(headNonEmpty(left$2), lessThan$8(headNonEmpty(right$2)))
        ? left$2 = tailNonEmpty(left$2)
        : right$2 = tailNonEmpty(right$2), acc = intervals
    }
    return make$21(reverse$1(acc))
  },
  start$1 = self$1 => pipe(self$1.intervals, head$3, getOrElse$5(() => empty$4)).startMillis,
  end$1 = self$1 => pipe(self$1.intervals, head$3, getOrElse$5(() => empty$4)).endMillis,
  lessThan$7 = dual(2, (self$1, that) => start$1(self$1) < start$1(that)),
  isNonEmpty$1 = self$1 => isNonEmpty$4(self$1.intervals),
  max$8 = dual(2, (self$1, that) => lessThan$7(self$1, that) ? that : self$1),
  IntervalsTypeId = IntervalsTypeId$1,
  make$20 = make$21,
  empty$2 = empty$3,
  fromIterable = fromIterable$1,
  union = union$1,
  intersect$1 = intersect$2,
  start = start$1,
  end = end$1,
  lessThan$6 = lessThan$7,
  isNonEmpty = isNonEmpty$1,
  max$7 = max$8,
  OP_CONTINUE = `Continue`,
  OP_DONE = `Done`,
  _continue$1 = intervals => ({ _tag: OP_CONTINUE, intervals }),
  continueWith$1 = interval => ({ _tag: OP_CONTINUE, intervals: make$20(of$3(interval)) }),
  done$2 = { _tag: OP_DONE },
  isContinue$1 = self$1 => self$1._tag === OP_CONTINUE,
  isDone$1 = self$1 => self$1._tag === OP_DONE,
  _continue = _continue$1,
  continueWith = continueWith$1,
  done$1 = done$2,
  isContinue = isContinue$1,
  isDone = isDone$1,
  ScopeTypeId = ScopeTypeId$1,
  CloseableScopeTypeId = CloseableScopeTypeId$1,
  Scope = scopeTag,
  addFinalizer$1 = scopeAddFinalizer,
  addFinalizerExit = scopeAddFinalizerExit,
  close = scopeClose,
  extend$2 = scopeExtend,
  fork$1 = scopeFork,
  use = scopeUse,
  make$19 = scopeMake
var Semaphore = class {
  permits
  waiters = new Set()
  taken = 0
  constructor(permits) {
    this.permits = permits
  }
  get free() {
    return this.permits - this.taken
  }
  take = n$19 =>
    asyncInterrupt(resume$1 => {
      if (this.free < n$19) {
        let observer = () => {
          this.free < n$19 || (this.waiters.delete(observer), this.taken += n$19, resume$1(succeed$9(n$19)))
        }
        return this.waiters.add(observer),
          sync$3(() => {
            this.waiters.delete(observer)
          })
      }
      return this.taken += n$19, resume$1(succeed$9(n$19))
    })
  updateTaken = f$14 =>
    withFiberRuntime$1(
      fiber => (this.taken = f$14(this.taken),
        this.waiters.size > 0 && fiber.getFiberRef(currentScheduler).scheduleTask(() => {
          let iter = this.waiters.values(), item = iter.next()
          for (; item.done === !1 && this.free > 0;) item.value(), item = iter.next()
        }, fiber.getFiberRef(currentSchedulingPriority)),
        succeed$9(this.free)),
    )
  release = n$19 => this.updateTaken(taken => taken - n$19)
  releaseAll = this.updateTaken(_$1 => 0)
  withPermits = n$19 => self$1 =>
    uninterruptibleMask$2(restore =>
      flatMap$5(restore(this.take(n$19)), permits => ensuring$1(restore(self$1), this.release(permits)))
    )
  withPermitsIfAvailable = n$19 => self$1 =>
    uninterruptibleMask$2(restore =>
      suspend$4(() =>
        this.free < n$19
          ? succeedNone$1
          : (this.taken += n$19, ensuring$1(restore(asSome$1(self$1)), this.release(n$19)))
      )
    )
}
const unsafeMakeSemaphore$1 = permits => new Semaphore(permits),
  makeSemaphore$1 = permits => sync$3(() => unsafeMakeSemaphore$1(permits))
var Latch = class extends Class$4 {
  isOpen
  waiters = []
  scheduled = !1
  constructor(isOpen) {
    super(), this.isOpen = isOpen
  }
  commit() {
    return this.await
  }
  unsafeSchedule(fiber) {
    return this.scheduled || this.waiters.length === 0
      ? void_$4
      : (this.scheduled = !0,
        fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority)),
        void_$4)
  }
  flushWaiters = () => {
    this.scheduled = !1
    let waiters = this.waiters
    this.waiters = []
    for (let i$14 = 0; i$14 < waiters.length; i$14++) waiters[i$14](exitVoid$1)
  }
  open = withFiberRuntime$1(fiber => this.isOpen ? void_$4 : (this.isOpen = !0, this.unsafeSchedule(fiber)))
  unsafeOpen() {
    this.isOpen || (this.isOpen = !0, this.flushWaiters())
  }
  release = withFiberRuntime$1(fiber => this.isOpen ? void_$4 : this.unsafeSchedule(fiber))
  await = asyncInterrupt(resume$1 =>
    this.isOpen ? resume$1(void_$4) : (this.waiters.push(resume$1),
      sync$3(() => {
        let index$4 = this.waiters.indexOf(resume$1)
        index$4 !== -1 && this.waiters.splice(index$4, 1)
      }))
  )
  unsafeClose() {
    this.isOpen = !1
  }
  close = sync$3(() => {
    this.isOpen = !1
  })
  whenOpen = self$1 => zipRight$3(this.await, self$1)
}
const unsafeMakeLatch$1 = open => new Latch(open ?? !1),
  makeLatch$1 = open => sync$3(() => unsafeMakeLatch$1(open)),
  awaitAllChildren$1 = self$1 => ensuringChildren$1(self$1, fiberAwaitAll),
  cached$1 = dual(
    2,
    (self$1, timeToLive) => map$11(cachedInvalidateWithTTL$1(self$1, timeToLive), tuple$2 => tuple$2[0]),
  ),
  cachedInvalidateWithTTL$1 = dual(2, (self$1, timeToLive) => {
    let duration = decode$30(timeToLive)
    return flatMap$5(
      context$1(),
      env$1 =>
        map$11(
          makeSynchronized(none$7()),
          cache => [provideContext$1(getCachedValue(self$1, duration, cache), env$1), invalidateCache(cache)],
        ),
    )
  }),
  computeCachedValue = (self$1, timeToLive, start$2) => {
    let timeToLiveMillis = toMillis(decode$30(timeToLive))
    return pipe(
      deferredMake(),
      tap$1(deferred => intoDeferred$1(self$1, deferred)),
      map$11(deferred => some$4([start$2 + timeToLiveMillis, deferred])),
    )
  },
  getCachedValue = (self$1, timeToLive, cache) =>
    uninterruptibleMask$2(restore =>
      pipe(
        clockWith$1(clock$2 => clock$2.currentTimeMillis),
        flatMap$5(time =>
          updateSomeAndGetEffectSynchronized(cache, option$5 => {
            switch (option$5._tag) {
              case `None`:
                return some$4(computeCachedValue(self$1, timeToLive, time))
              case `Some`: {
                let [end$2] = option$5.value
                return end$2 - time <= 0 ? some$4(computeCachedValue(self$1, timeToLive, time)) : none$7()
              }
            }
          })
        ),
        flatMap$5(option$5 =>
          isNone$2(option$5)
            ? dieMessage$1(
              `BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues`,
            )
            : restore(deferredAwait(option$5.value[1]))
        ),
      )
    ),
  invalidateCache = cache => set$1(cache, none$7()),
  ensuringChild$1 = dual(2, (self$1, f$14) => ensuringChildren$1(self$1, children$3 => f$14(fiberAll(children$3)))),
  ensuringChildren$1 = dual(
    2,
    (self$1, children$3) =>
      flatMap$5(
        track,
        supervisor => pipe(supervised$1(self$1, supervisor), ensuring$1(flatMap$5(supervisor.value, children$3))),
      ),
  ),
  forkAll$1 = dual(
    args$1 => isIterable(args$1[0]),
    (effects, options$2) =>
      options$2?.discard
        ? forEachSequentialDiscard(effects, fork$2)
        : map$11(forEachSequential(effects, fork$2), fiberAll),
  ),
  forkIn$1 = dual(2, (self$1, scope$2) =>
    withFiberRuntime$1((parent, parentStatus) => {
      let scopeImpl = scope$2, fiber = unsafeFork$1(self$1, parent, parentStatus.runtimeFlags, globalScope)
      if (scopeImpl.state._tag === `Open`) {
        let finalizer = () =>
            fiberIdWith$1(fiberId$2 => equals(fiberId$2, fiber.id()) ? void_$4 : asVoid$3(interruptFiber(fiber))),
          key$1 = {}
        scopeImpl.state.finalizers.set(key$1, finalizer),
          fiber.addObserver(() => {
            scopeImpl.state._tag !== `Closed` && scopeImpl.state.finalizers.delete(key$1)
          })
      } else fiber.unsafeInterruptAsFork(parent.id())
      return succeed$9(fiber)
    })),
  forkScoped$1 = self$1 => scopeWith$1(scope$2 => forkIn$1(self$1, scope$2)),
  fromFiber$1 = fiber => join$4(fiber),
  fromFiberEffect$1 = fiber => suspend$4(() => flatMap$5(fiber, join$4)),
  memoKeySymbol = Symbol.for(`effect/Effect/memoizeFunction.key`)
var Key = class {
  a
  eq;
  [memoKeySymbol] = memoKeySymbol
  constructor(a$22, eq) {
    this.a = a$22, this.eq = eq
  }
  [symbol$1](that) {
    return hasProperty(that, memoKeySymbol) ? this.eq ? this.eq(this.a, that.a) : equals(this.a, that.a) : !1
  }
  [symbol$2]() {
    return this.eq ? 0 : cached$2(this, hash(this.a))
  }
}
const cachedFunction$1 = (f$14, eq) =>
    pipe(
      sync$3(() => empty$16()),
      flatMap$5(makeSynchronized),
      map$11(ref => a$22 =>
        pipe(
          ref.modifyEffect(map$20 => {
            let result = pipe(map$20, get$4(new Key(a$22, eq)))
            return isNone$2(result)
              ? pipe(
                deferredMake(),
                tap$1(deferred => pipe(diffFiberRefs$1(f$14(a$22)), intoDeferred$1(deferred), fork$2)),
                map$11(deferred => [deferred, pipe(map$20, set$2(new Key(a$22, eq), deferred))]),
              )
              : succeed$9([result.value, map$20])
          }),
          flatMap$5(deferredAwait),
          flatMap$5(([patch$12, b$3]) => pipe(patchFiberRefs$1(patch$12), as$4(b$3))),
        )
      ),
    ),
  raceFirst$1 = dual(2, (self$1, that) => pipe(exit$4(self$1), race$1(exit$4(that)), effect => flatten$3(effect))),
  supervised$1 = dual(2, (self$1, supervisor) => {
    let supervise = fiberRefLocallyWith(currentSupervisor, s$14 => s$14.zip(supervisor))
    return supervise(self$1)
  }),
  timeout$1 = dual(
    2,
    (self$1, duration) => timeoutFail$1(self$1, { onTimeout: () => timeoutExceptionFromDuration(duration), duration }),
  ),
  timeoutFail$1 = dual(
    2,
    (self$1, { duration, onTimeout }) =>
      flatten$3(timeoutTo$1(self$1, { onTimeout: () => failSync$2(onTimeout), onSuccess: succeed$9, duration })),
  ),
  timeoutFailCause$1 = dual(
    2,
    (self$1, { duration, onTimeout }) =>
      flatten$3(timeoutTo$1(self$1, { onTimeout: () => failCauseSync$2(onTimeout), onSuccess: succeed$9, duration })),
  ),
  timeoutOption$1 = dual(
    2,
    (self$1, duration) => timeoutTo$1(self$1, { duration, onSuccess: some$4, onTimeout: none$7 }),
  ),
  timeoutTo$1 = dual(
    2,
    (self$1, { duration, onSuccess, onTimeout }) =>
      fiberIdWith$1(parentFiberId =>
        uninterruptibleMask$2(restore =>
          raceFibersWith(restore(self$1), interruptible$2(sleep$1(duration)), {
            onSelfWin: (winner, loser) =>
              flatMap$5(winner.await, exit$5 =>
                exit$5._tag === `Success`
                  ? flatMap$5(
                    winner.inheritAll,
                    () => as$4(interruptAsFiber(loser, parentFiberId), onSuccess(exit$5.value)),
                  )
                  : flatMap$5(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit$5.cause))),
            onOtherWin: (winner, loser) =>
              flatMap$5(winner.await, exit$5 =>
                exit$5._tag === `Success`
                  ? flatMap$5(winner.inheritAll, () => as$4(interruptAsFiber(loser, parentFiberId), onTimeout()))
                  : flatMap$5(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit$5.cause))),
            otherScope: globalScope,
          })
        )
      ),
  ),
  SynchronizedSymbolKey = `effect/Ref/SynchronizedRef`,
  SynchronizedTypeId = Symbol.for(SynchronizedSymbolKey),
  synchronizedVariance = { _A: _$1 => _$1 }
var SynchronizedImpl = class extends Class$4 {
  ref
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId$1] = refVariance;
  [TypeId$7] = TypeId$7
  constructor(ref, withLock) {
    super(), this.ref = ref, this.withLock = withLock, this.get = get$1(this.ref)
  }
  get commit() {
    return this.get
  }
  modify(f$14) {
    return this.modifyEffect(a$22 => succeed$9(f$14(a$22)))
  }
  modifyEffect(f$14) {
    return this.withLock(
      pipe(flatMap$5(get$1(this.ref), f$14), flatMap$5(([b$3, a$22]) => as$4(set$1(this.ref, a$22), b$3))),
    )
  }
}
const makeSynchronized = value$2 => sync$3(() => unsafeMakeSynchronized(value$2)),
  unsafeMakeSynchronized = value$2 => {
    let ref = unsafeMake$3(value$2), sem = unsafeMakeSemaphore$1(1)
    return new SynchronizedImpl(ref, sem.withPermits(1))
  },
  updateSomeAndGetEffectSynchronized = dual(2, (self$1, pf) =>
    self$1.modifyEffect(value$2 => {
      let result = pf(value$2)
      switch (result._tag) {
        case `None`:
          return succeed$9([value$2, value$2])
        case `Some`:
          return map$11(result.value, a$22 => [a$22, a$22])
      }
    })),
  zipFiber = dual(2, (self$1, that) => zipWithFiber(self$1, that, (a$22, b$3) => [a$22, b$3])),
  zipLeftFiber = dual(2, (self$1, that) => zipWithFiber(self$1, that, (a$22, _$1) => a$22)),
  zipRightFiber = dual(2, (self$1, that) => zipWithFiber(self$1, that, (_$1, b$3) => b$3)),
  zipWithFiber = dual(3, (self$1, that, f$14) => ({
    ...CommitPrototype,
    commit() {
      return join$4(this)
    },
    [FiberTypeId$1]: fiberVariance,
    id: () => pipe(self$1.id(), getOrElse$1(that.id())),
    await: pipe(self$1.await, flatten$3, zipWithOptions(flatten$3(that.await), f$14, { concurrent: !0 }), exit$4),
    children: self$1.children,
    inheritAll: zipRight$3(that.inheritAll, self$1.inheritAll),
    poll: zipWith$4(
      self$1.poll,
      that.poll,
      (optionA, optionB) =>
        pipe(
          optionA,
          flatMap$12(exitA =>
            pipe(optionB, map$18(exitB => zipWith$3(exitA, exitB, { onSuccess: f$14, onFailure: parallel$3 })))
          ),
        ),
    ),
    interruptAsFork: id$2 => zipRight$3(self$1.interruptAsFork(id$2), that.interruptAsFork(id$2)),
    pipe() {
      return pipeArguments(this, arguments)
    },
  })),
  bindAll$1 = dual(
    args$1 => isEffect$1(args$1[0]),
    (self$1, f$14, options$2) =>
      flatMap$5(
        self$1,
        a$22 => all$4(f$14(a$22), options$2).pipe(map$11(record$2 => Object.assign({}, a$22, record$2))),
      ),
  ),
  TypeId$2 = Symbol.for(`effect/ManagedRuntime`),
  OP_FRESH = `Fresh`,
  OP_SUSPEND = `Suspend`,
  OP_ZIP_WITH = `ZipWith`,
  FiberTypeId = FiberTypeId$1,
  RuntimeFiberTypeId = RuntimeFiberTypeId$1,
  Order = Order$1,
  isFiber = isFiber$1,
  isRuntimeFiber = isRuntimeFiber$1,
  id = id$1,
  _await = _await$1,
  awaitAll = fiberAwaitAll,
  children$1 = children$2,
  all$3 = fiberAll,
  done = done$3,
  dump = dump$1,
  dumpAll = dumpAll$1,
  fail$3 = fail$6,
  failCause$2 = failCause$4,
  fromEffect = fromEffect$2,
  getCurrentFiber = getCurrentFiber$1,
  inheritAll = inheritAll$1,
  interrupt$1 = interruptFiber,
  interrupted = interrupted$1,
  interruptAs = interruptAsFiber,
  interruptAsFork = interruptAsFork$1,
  interruptAll = interruptAll$1,
  interruptAllAs = interruptAllAs$1,
  interruptFork = fiberInterruptFork,
  join$3 = join$4,
  joinAll = fiberJoinAll,
  map$5 = map$8,
  mapEffect$1 = mapEffect$2,
  mapFiber = mapFiber$1,
  match$1 = match$3,
  never$2 = never$3,
  orElse$4 = orElse$5,
  orElseEither = orElseEither$2,
  poll = poll$1,
  pretty = pretty$2,
  roots = roots$1,
  unsafeRoots = unsafeRoots$1,
  scoped$1 = fiberScoped,
  status = status$1,
  succeed$3 = succeed$5,
  void_ = void_$1,
  zip$1 = zipFiber,
  zipLeft$1 = zipLeftFiber,
  zipRight$1 = zipRightFiber,
  zipWith$2 = zipWithFiber,
  makeDual = f$14 =>
    function() {
      if (arguments.length === 1) {
        let runtime$4 = arguments[0]
        return (effect, ...args$1) => f$14(runtime$4, effect, ...args$1)
      }
      return f$14.apply(this, arguments)
    },
  unsafeFork = makeDual((runtime$4, self$1, options$2) => {
    let fiberId$2 = unsafeMake$7(), fiberRefUpdates = [[currentContext, [[fiberId$2, runtime$4.context]]]]
    options$2?.scheduler && fiberRefUpdates.push([currentScheduler, [[fiberId$2, options$2.scheduler]]])
    let fiberRefs$3 = updateManyAs(runtime$4.fiberRefs, { entries: fiberRefUpdates, forkAs: fiberId$2 })
    options$2?.updateRefs && (fiberRefs$3 = options$2.updateRefs(fiberRefs$3, fiberId$2))
    let fiberRuntime = new FiberRuntime(fiberId$2, fiberRefs$3, runtime$4.runtimeFlags), effect = self$1
    options$2?.scope
      && (effect = flatMap$5(
        fork$1(options$2.scope, sequential$2),
        closeableScope =>
          zipRight$3(
            scopeAddFinalizer(
              closeableScope,
              fiberIdWith$1(id$2 => equals(id$2, fiberRuntime.id()) ? void_$4 : interruptAsFiber(fiberRuntime, id$2)),
            ),
            onExit$2(self$1, exit$5 => close(closeableScope, exit$5)),
          ),
      ))
    let supervisor = fiberRuntime.currentSupervisor
    return supervisor !== none$2
      && (supervisor.onStart(runtime$4.context, effect, none$7(), fiberRuntime),
        fiberRuntime.addObserver(exit$5 => supervisor.onEnd(exit$5, fiberRuntime))),
      globalScope.add(runtime$4.runtimeFlags, fiberRuntime),
      options$2?.immediate === !1 ? fiberRuntime.resume(effect) : fiberRuntime.start(effect),
      fiberRuntime
  }),
  unsafeRunCallback = makeDual((runtime$4, effect, options$2 = {}) => {
    let fiberRuntime = unsafeFork(runtime$4, effect, options$2)
    return options$2.onExit && fiberRuntime.addObserver(exit$5 => {
      options$2.onExit(exit$5)
    }),
      (id$2, cancelOptions) =>
        unsafeRunCallback(runtime$4)(pipe(fiberRuntime, interruptAs(id$2 ?? none$6)), {
          ...cancelOptions,
          onExit: cancelOptions?.onExit ? exit$5 => cancelOptions.onExit(flatten$2(exit$5)) : void 0,
        })
  }),
  unsafeRunSync = makeDual((runtime$4, effect) => {
    let result = unsafeRunSyncExit(runtime$4)(effect)
    if (result._tag === `Failure`) throw fiberFailure(result.effect_instruction_i0)
    return result.effect_instruction_i0
  })
var AsyncFiberExceptionImpl = class extends Error {
  fiber
  _tag = `AsyncFiberException`
  constructor(fiber) {
    super(
      `Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`,
    ),
      this.fiber = fiber,
      this.name = this._tag,
      this.stack = this.message
  }
}
const asyncFiberException = fiber => {
    let limit = Error.stackTraceLimit
    Error.stackTraceLimit = 0
    let error = new AsyncFiberExceptionImpl(fiber)
    return Error.stackTraceLimit = limit, error
  },
  FiberFailureId = Symbol.for(`effect/Runtime/FiberFailure`),
  FiberFailureCauseId = Symbol.for(`effect/Runtime/FiberFailure/Cause`)
var FiberFailureImpl = class extends Error {
  [FiberFailureId];
  [FiberFailureCauseId]
  constructor(cause$2) {
    let head$5 = prettyErrors$1(cause$2)[0]
    super(head$5?.message || `An error has occurred`),
      this[FiberFailureId] = FiberFailureId,
      this[FiberFailureCauseId] = cause$2,
      this.name = head$5 ? `(FiberFailure) ${head$5.name}` : `FiberFailure`,
      head$5?.stack && (this.stack = head$5.stack)
  }
  toJSON() {
    return { _id: `FiberFailure`, cause: this[FiberFailureCauseId].toJSON() }
  }
  toString() {
    return `(FiberFailure) ` + pretty$3(this[FiberFailureCauseId], { renderErrorCause: !0 })
  }
  [NodeInspectSymbol]() {
    return this.toString()
  }
}
const fiberFailure = cause$2 => {
    let limit = Error.stackTraceLimit
    Error.stackTraceLimit = 0
    let error = new FiberFailureImpl(cause$2)
    return Error.stackTraceLimit = limit, error
  },
  fastPath = effect => {
    let op = effect
    switch (op._op) {
      case `Failure`:
      case `Success`:
        return op
      case `Left`:
        return exitFail(op.left)
      case `Right`:
        return exitSucceed$1(op.right)
      case `Some`:
        return exitSucceed$1(op.value)
      case `None`:
        return exitFail(NoSuchElementException$1())
    }
  },
  unsafeRunSyncExit = makeDual((runtime$4, effect) => {
    let op = fastPath(effect)
    if (op) return op
    let scheduler = new SyncScheduler(), fiberRuntime = unsafeFork(runtime$4)(effect, { scheduler })
    scheduler.flush()
    let result = fiberRuntime.unsafePoll()
    return result || exitDie$1(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)))
  }),
  unsafeRunPromise = makeDual((runtime$4, effect, options$2) =>
    unsafeRunPromiseExit(runtime$4, effect, options$2).then(result => {
      switch (result._tag) {
        case OP_SUCCESS:
          return result.effect_instruction_i0
        case OP_FAILURE:
          throw fiberFailure(result.effect_instruction_i0)
      }
    })
  ),
  unsafeRunPromiseExit = makeDual((runtime$4, effect, options$2) =>
    new Promise(resolve => {
      let op = fastPath(effect)
      op && resolve(op)
      let fiber = unsafeFork(runtime$4)(effect)
      fiber.addObserver(exit$5 => {
        resolve(exit$5)
      }),
        options$2?.signal !== void 0 && (options$2.signal.aborted
          ? fiber.unsafeInterruptAsFork(fiber.id())
          : options$2.signal.addEventListener(`abort`, () => {
            fiber.unsafeInterruptAsFork(fiber.id())
          }, { once: !0 }))
    })
  )
var RuntimeImpl = class {
  context
  runtimeFlags
  fiberRefs
  constructor(context$2, runtimeFlags$1, fiberRefs$3) {
    this.context = context$2, this.runtimeFlags = runtimeFlags$1, this.fiberRefs = fiberRefs$3
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const make$18 = options$2 => new RuntimeImpl(options$2.context, options$2.runtimeFlags, options$2.fiberRefs),
  runtime$1 = () =>
    withFiberRuntime$1((state, status$2) =>
      succeed$9(new RuntimeImpl(state.getFiberRef(currentContext), status$2.runtimeFlags, state.getFiberRefs()))
    ),
  defaultRuntimeFlags = make$44(Interruption, CooperativeYielding, RuntimeMetrics),
  defaultRuntime = make$18({ context: empty$33(), runtimeFlags: defaultRuntimeFlags, fiberRefs: empty$12() }),
  unsafeRunEffect = unsafeRunCallback(defaultRuntime),
  unsafeForkEffect = unsafeFork(defaultRuntime),
  unsafeRunPromiseEffect = unsafeRunPromise(defaultRuntime),
  unsafeRunPromiseExitEffect = unsafeRunPromiseExit(defaultRuntime),
  unsafeRunSyncEffect = unsafeRunSync(defaultRuntime),
  unsafeRunSyncExitEffect = unsafeRunSyncExit(defaultRuntime),
  asyncEffect$1 = register =>
    suspend$4(() => {
      let cleanup
      return flatMap$5(deferredMake(), deferred =>
        flatMap$5(runtime$1(), runtime$4 =>
          uninterruptibleMask$2(restore =>
            zipRight$3(
              fork$2(
                restore(matchCauseEffect$2(
                  register(cb =>
                    unsafeRunCallback(runtime$4)(intoDeferred$1(cb, deferred))
                  ),
                  {
                    onFailure: cause$2 => deferredFailCause(deferred, cause$2),
                    onSuccess: cleanup_ => (cleanup = cleanup_, void_$4),
                  },
                )),
              ),
              restore(onInterrupt$1(deferredAwait(deferred), () => cleanup ?? void_$4)),
            )
          )))
    }),
  modifyEffect = dual(2, (self$1, f$14) => self$1.modifyEffect(f$14)),
  LayerSymbolKey = `effect/Layer`,
  LayerTypeId = Symbol.for(LayerSymbolKey),
  layerVariance = { _RIn: _$1 => _$1, _E: _$1 => _$1, _ROut: _$1 => _$1 },
  proto = {
    [LayerTypeId]: layerVariance,
    pipe() {
      return pipeArguments(this, arguments)
    },
  },
  MemoMapTypeIdKey = `effect/Layer/MemoMap`,
  MemoMapTypeId = Symbol.for(MemoMapTypeIdKey),
  CurrentMemoMap = Reference()(`effect/Layer/CurrentMemoMap`, { defaultValue: () => unsafeMakeMemoMap() }),
  isLayer = u$7 => hasProperty(u$7, LayerTypeId),
  isFresh = self$1 => self$1._op_layer === OP_FRESH
var MemoMapImpl = class {
  ref;
  [MemoMapTypeId]
  constructor(ref) {
    this.ref = ref, this[MemoMapTypeId] = MemoMapTypeId
  }
  getOrElseMemoize(layer, scope$2) {
    return pipe(
      modifyEffect(this.ref, map$20 => {
        let inMap = map$20.get(layer)
        if (inMap !== void 0) {
          let [acquire, release] = inMap,
            cached$3 = pipe(
              acquire,
              flatMap$5(([patch$12, b$3]) => pipe(patchFiberRefs$1(patch$12), as$4(b$3))),
              onExit$2(exitMatch({
                onFailure: () => void_$4,
                onSuccess: () => scopeAddFinalizerExit(scope$2, release),
              })),
            )
          return succeed$9([cached$3, map$20])
        }
        return pipe(
          make$33(0),
          flatMap$5(observers =>
            pipe(
              deferredMake(),
              flatMap$5(deferred =>
                pipe(
                  make$33(() => void_$4),
                  map$11(finalizerRef => {
                    let resource = uninterruptibleMask$2(restore =>
                        pipe(
                          scopeMake(),
                          flatMap$5(innerScope =>
                            pipe(
                              restore(
                                flatMap$5(makeBuilder(layer, innerScope, !0), f$14 => diffFiberRefs$1(f$14(this))),
                              ),
                              exit$4,
                              flatMap$5(exit$5 => {
                                switch (exit$5._tag) {
                                  case OP_FAILURE:
                                    return pipe(
                                      deferredFailCause(deferred, exit$5.effect_instruction_i0),
                                      zipRight$3(scopeClose(innerScope, exit$5)),
                                      zipRight$3(failCause$8(exit$5.effect_instruction_i0)),
                                    )
                                  case OP_SUCCESS:
                                    return pipe(
                                      set$1(finalizerRef, exit$6 =>
                                        pipe(
                                          scopeClose(innerScope, exit$6),
                                          whenEffect$1(modify$1(observers, n$19 => [n$19 === 1, n$19 - 1])),
                                          asVoid$3,
                                        )),
                                      zipRight$3(update$3(observers, n$19 => n$19 + 1)),
                                      zipRight$3(scopeAddFinalizerExit(scope$2, exit$6 =>
                                        pipe(
                                          sync$3(() => map$20.delete(layer)),
                                          zipRight$3(get$1(finalizerRef)),
                                          flatMap$5(finalizer => finalizer(exit$6)),
                                        ))),
                                      zipRight$3(deferredSucceed(deferred, exit$5.effect_instruction_i0)),
                                      as$4(exit$5.effect_instruction_i0[1]),
                                    )
                                }
                              }),
                            )
                          ),
                        )
                      ),
                      memoized = [
                        pipe(
                          deferredAwait(deferred),
                          onExit$2(exitMatchEffect({
                            onFailure: () => void_$4,
                            onSuccess: () => update$3(observers, n$19 => n$19 + 1),
                          })),
                        ),
                        exit$5 => pipe(get$1(finalizerRef), flatMap$5(finalizer => finalizer(exit$5))),
                      ]
                    return [resource, isFresh(layer) ? map$20 : map$20.set(layer, memoized)]
                  }),
                )
              ),
            )
          ),
        )
      }),
      flatten$3,
    )
  }
}
const makeMemoMap = suspend$4(() => map$11(makeSynchronized(new Map()), ref => new MemoMapImpl(ref))),
  unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map())),
  buildWithScope = dual(
    2,
    (self$1, scope$2) => flatMap$5(makeMemoMap, memoMap => buildWithMemoMap(self$1, memoMap, scope$2)),
  ),
  buildWithMemoMap = dual(
    3,
    (self$1, memoMap, scope$2) =>
      flatMap$5(makeBuilder(self$1, scope$2), run => provideService$1(run(memoMap), CurrentMemoMap, memoMap)),
  ),
  makeBuilder = (self$1, scope$2, inMemoMap = !1) => {
    let op = self$1
    switch (op._op_layer) {
      case `Locally`:
        return sync$3(() => memoMap => op.f(memoMap.getOrElseMemoize(op.self, scope$2)))
      case `ExtendScope`:
        return sync$3(() => memoMap => scopeWith$1(scope$3 => memoMap.getOrElseMemoize(op.layer, scope$3)))
      case `Fold`:
        return sync$3(() => memoMap =>
          pipe(
            memoMap.getOrElseMemoize(op.layer, scope$2),
            matchCauseEffect$2({
              onFailure: cause$2 => memoMap.getOrElseMemoize(op.failureK(cause$2), scope$2),
              onSuccess: value$2 => memoMap.getOrElseMemoize(op.successK(value$2), scope$2),
            }),
          )
        )
      case `Fresh`:
        return sync$3(() => _$1 => pipe(op.layer, buildWithScope(scope$2)))
      case `FromEffect`:
        return sync$3(inMemoMap ? () => _$1 => op.effect : () => memoMap => memoMap.getOrElseMemoize(self$1, scope$2))
      case `Provide`:
        return sync$3(() => memoMap =>
          pipe(
            memoMap.getOrElseMemoize(op.first, scope$2),
            flatMap$5(env$1 => pipe(memoMap.getOrElseMemoize(op.second, scope$2), provideContext$1(env$1))),
          )
        )
      case `Scoped`:
        return sync$3(
          inMemoMap
            ? () => _$1 => scopeExtend(op.effect, scope$2)
            : () => memoMap => memoMap.getOrElseMemoize(self$1, scope$2),
        )
      case `Suspend`:
        return sync$3(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope$2))
      case `ProvideMerge`:
        return sync$3(() => memoMap =>
          pipe(
            memoMap.getOrElseMemoize(op.first, scope$2),
            zipWith$4(memoMap.getOrElseMemoize(op.second, scope$2), op.zipK),
          )
        )
      case `ZipWith`:
        return sync$3(() => memoMap =>
          pipe(
            memoMap.getOrElseMemoize(op.first, scope$2),
            zipWithOptions(memoMap.getOrElseMemoize(op.second, scope$2), op.zipK, { concurrent: !0 }),
          )
        )
    }
  },
  merge$3 = dual(2, (self$1, that) => zipWith$1(self$1, that, (a$22, b$3) => merge$6(a$22, b$3))),
  mergeAll$1 = (...layers) => {
    let final = layers[0]
    for (let i$14 = 1; i$14 < layers.length; i$14++) final = merge$3(final, layers[i$14])
    return final
  },
  suspend$2 = evaluate$2 => {
    let suspend$5 = Object.create(proto)
    return suspend$5._op_layer = OP_SUSPEND, suspend$5.evaluate = evaluate$2, suspend$5
  },
  zipWith$1 = dual(3, (self$1, that, f$14) =>
    suspend$2(() => {
      let zipWith$6 = Object.create(proto)
      return zipWith$6._op_layer = OP_ZIP_WITH,
        zipWith$6.first = self$1,
        zipWith$6.second = that,
        zipWith$6.zipK = f$14,
        zipWith$6
    })),
  provideSomeLayer = dual(
    2,
    (self$1, layer) =>
      scopedWith$1(scope$2 =>
        flatMap$5(buildWithScope(layer, scope$2), context$2 => provideSomeContext(self$1, context$2))
      ),
  ),
  provideSomeRuntime = dual(2, (self$1, rt) => {
    let patchRefs = diff$1(defaultRuntime.fiberRefs, rt.fiberRefs),
      patchFlags = diff$3(defaultRuntime.runtimeFlags, rt.runtimeFlags)
    return uninterruptibleMask$2(restore =>
      withFiberRuntime$1(fiber => {
        let oldContext = fiber.getFiberRef(currentContext),
          oldRefs = fiber.getFiberRefs(),
          newRefs = patch$2(fiber.id(), oldRefs)(patchRefs),
          oldFlags = fiber.currentRuntimeFlags,
          newFlags = patch$5(patchFlags)(oldFlags),
          rollbackRefs = diff$1(newRefs, oldRefs),
          rollbackFlags = diff$3(newFlags, oldFlags)
        return fiber.setFiberRefs(newRefs),
          fiber.currentRuntimeFlags = newFlags,
          ensuring$1(
            provideSomeContext(restore(self$1), merge$6(oldContext, rt.context)),
            withFiberRuntime$1(
              fiber$1 => (fiber$1.setFiberRefs(patch$2(fiber$1.id(), fiber$1.getFiberRefs())(rollbackRefs)),
                fiber$1.currentRuntimeFlags = patch$5(rollbackFlags)(fiber$1.currentRuntimeFlags),
                void_$4),
            ),
          )
      })
    )
  }),
  effect_provide = dual(
    2,
    (self$1, source) =>
      Array.isArray(source)
        ? provideSomeLayer(self$1, mergeAll$1(...source))
        : isLayer(source)
        ? provideSomeLayer(self$1, source)
        : isContext(source)
        ? provideSomeContext(self$1, source)
        : TypeId$2 in source
        ? flatMap$5(source.runtimeEffect, rt => provideSomeRuntime(self$1, rt))
        : provideSomeRuntime(self$1, source),
  ),
  console$2 = map$11(fiberRefGet(currentServices), get$9(consoleTag)),
  consoleWith$1 = f$14 => fiberRefGetWith(currentServices, services => f$14(get$9(services, consoleTag))),
  withConsole$1 = dual(
    2,
    (effect, value$2) => fiberRefLocallyWith(effect, currentServices, add$3(consoleTag, value$2)),
  ),
  withConsoleScoped$1 = console$3 => fiberRefLocallyScopedWith(currentServices, add$3(consoleTag, console$3)),
  struct = struct$1,
  Class$2 = Structural$1,
  Structural = Structural$1,
  Error$1 = function() {
    let plainArgsSymbol = Symbol.for(`effect/Data/Error/plainArgs`),
      O$1 = {
        BaseEffectError: class extends YieldableError$1 {
          constructor(args$1) {
            super(args$1?.message, args$1?.cause ? { cause: args$1.cause } : void 0),
              args$1
              && (Object.assign(this, args$1),
                Object.defineProperty(this, plainArgsSymbol, { value: args$1, enumerable: !1 }))
          }
          toJSON() {
            return { ...this[plainArgsSymbol], ...this }
          }
        },
      }
    return O$1.BaseEffectError
  }(),
  TaggedError = tag$3 => {
    let O$1 = {
      BaseEffectError: class extends Error$1 {
        _tag = tag$3
      },
    }
    return O$1.BaseEffectError.prototype.name = tag$3, O$1.BaseEffectError
  },
  ScheduleSymbolKey = `effect/Schedule`,
  ScheduleTypeId = Symbol.for(ScheduleSymbolKey),
  isSchedule = u$7 => hasProperty(u$7, ScheduleTypeId),
  ScheduleDriverSymbolKey = `effect/ScheduleDriver`,
  ScheduleDriverTypeId = Symbol.for(ScheduleDriverSymbolKey),
  defaultIterationMetadata = {
    start: 0,
    now: 0,
    input: void 0,
    output: void 0,
    elapsed: zero,
    elapsedSincePrevious: zero,
    recurrence: 0,
  },
  CurrentIterationMetadata = Reference()(`effect/Schedule/CurrentIterationMetadata`, {
    defaultValue: () => defaultIterationMetadata,
  }),
  scheduleVariance = { _Out: _$1 => _$1, _In: _$1 => _$1, _R: _$1 => _$1 },
  scheduleDriverVariance = { _Out: _$1 => _$1, _In: _$1 => _$1, _R: _$1 => _$1 }
var ScheduleImpl = class {
  initial
  step;
  [ScheduleTypeId] = scheduleVariance
  constructor(initial, step$3) {
    this.initial = initial, this.step = step$3
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
}
const updateInfo = (iterationMetaRef, now$1, input, output) =>
  update$3(
    iterationMetaRef,
    prev =>
      prev.recurrence === 0
        ? {
          now: now$1,
          input,
          output,
          recurrence: prev.recurrence + 1,
          elapsed: zero,
          elapsedSincePrevious: zero,
          start: now$1,
        }
        : {
          now: now$1,
          input,
          output,
          recurrence: prev.recurrence + 1,
          elapsed: millis(now$1 - prev.start),
          elapsedSincePrevious: millis(now$1 - prev.now),
          start: prev.start,
        },
  )
var ScheduleDriverImpl = class {
  schedule
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance
  constructor(schedule$1, ref) {
    this.schedule = schedule$1, this.ref = ref
  }
  get state() {
    return map$11(get$1(this.ref), tuple$2 => tuple$2[1])
  }
  get last() {
    return flatMap$5(get$1(this.ref), ([element$2, _$1]) => {
      switch (element$2._tag) {
        case `None`:
          return failSync$2(() => new NoSuchElementException$1())
        case `Some`:
          return succeed$9(element$2.value)
      }
    })
  }
  iterationMeta = unsafeMake$3(defaultIterationMetadata)
  get reset() {
    return set$1(this.ref, [none$7(), this.schedule.initial]).pipe(
      zipLeft$3(set$1(this.iterationMeta, defaultIterationMetadata)),
    )
  }
  next(input) {
    return pipe(
      map$11(get$1(this.ref), tuple$2 => tuple$2[1]),
      flatMap$5(state =>
        pipe(
          currentTimeMillis,
          flatMap$5(now$1 =>
            pipe(
              suspend$4(() => this.schedule.step(now$1, input, state)),
              flatMap$5(([state$1, out, decision]) => {
                let setState = set$1(this.ref, [some$4(out), state$1])
                if (isDone(decision)) return setState.pipe(zipRight$3(fail$9(none$7())))
                let millis$1 = start(decision.intervals) - now$1
                if (millis$1 <= 0) {
                  return setState.pipe(zipRight$3(updateInfo(this.iterationMeta, now$1, input, out)), as$4(out))
                }
                let duration = millis(millis$1)
                return pipe(
                  setState,
                  zipRight$3(updateInfo(this.iterationMeta, now$1, input, out)),
                  zipRight$3(sleep$1(duration)),
                  as$4(out),
                )
              }),
            )
          ),
        )
      ),
    )
  }
}
const makeWithState = (initial, step$3) => new ScheduleImpl(initial, step$3),
  asVoid$1 = self$1 => map$4(self$1, constVoid),
  check = dual(2, (self$1, test) => checkEffect(self$1, (input, out) => sync$3(() => test(input, out)))),
  checkEffect = dual(
    2,
    (self$1, test) =>
      makeWithState(
        self$1.initial,
        (now$1, input, state) =>
          flatMap$5(self$1.step(now$1, input, state), ([state$1, out, decision]) =>
            isDone(decision)
              ? succeed$9([state$1, out, done$1])
              : map$11(test(input, out), cont => cont ? [state$1, out, decision] : [state$1, out, done$1])),
      ),
  ),
  driver = self$1 => pipe(make$33([none$7(), self$1.initial]), map$11(ref => new ScheduleDriverImpl(self$1, ref))),
  intersect = dual(2, (self$1, that) => intersectWith(self$1, that, intersect$1)),
  intersectWith = dual(
    3,
    (self$1, that, f$14) =>
      makeWithState([self$1.initial, that.initial], (now$1, input, state) =>
        pipe(
          zipWith$4(self$1.step(now$1, input, state[0]), that.step(now$1, input, state[1]), (a$22, b$3) => [a$22, b$3]),
          flatMap$5(([[lState, out, lDecision], [rState, out2, rDecision]]) =>
            isContinue(lDecision) && isContinue(rDecision)
              ? intersectWithLoop(
                self$1,
                that,
                input,
                lState,
                out,
                lDecision.intervals,
                rState,
                out2,
                rDecision.intervals,
                f$14,
              )
              : succeed$9([[lState, rState], [out, out2], done$1])
          ),
        )),
  ),
  intersectWithLoop = (self$1, that, input, lState, out, lInterval, rState, out2, rInterval, f$14) => {
    let combined = f$14(lInterval, rInterval)
    return isNonEmpty(combined)
      ? succeed$9([[lState, rState], [out, out2], _continue(combined)])
      : pipe(lInterval, lessThan$6(rInterval))
      ? flatMap$5(self$1.step(end(lInterval), input, lState), ([lState$1, out$1, decision]) =>
        isDone(decision)
          ? succeed$9([[lState$1, rState], [out$1, out2], done$1])
          : intersectWithLoop(self$1, that, input, lState$1, out$1, decision.intervals, rState, out2, rInterval, f$14))
      : flatMap$5(that.step(end(rInterval), input, rState), ([rState$1, out2$1, decision]) =>
        isDone(decision)
          ? succeed$9([[lState, rState$1], [out, out2$1], done$1])
          : intersectWithLoop(self$1, that, input, lState, out, lInterval, rState$1, out2$1, decision.intervals, f$14))
  },
  map$4 = dual(2, (self$1, f$14) => mapEffect(self$1, out => sync$3(() => f$14(out)))),
  mapEffect = dual(
    2,
    (self$1, f$14) =>
      makeWithState(
        self$1.initial,
        (now$1, input, state) =>
          flatMap$5(self$1.step(now$1, input, state), ([state$1, out, decision]) =>
            map$11(f$14(out), out2 => [state$1, out2, decision])),
      ),
  ),
  passthrough = self$1 =>
    makeWithState(
      self$1.initial,
      (now$1, input, state) =>
        pipe(self$1.step(now$1, input, state), map$11(([state$1, _$1, decision]) => [state$1, input, decision])),
    ),
  recurs = n$19 => whileOutput(forever$1, out => out < n$19),
  unfold = (initial, f$14) =>
    makeWithState(initial, (now$1, _$1, state) => sync$3(() => [f$14(state), state, continueWith(after(now$1))])),
  untilInputEffect = dual(2, (self$1, f$14) => checkEffect(self$1, (input, _$1) => negate$1(f$14(input)))),
  whileInputEffect = dual(2, (self$1, f$14) => checkEffect(self$1, (input, _$1) => f$14(input))),
  whileOutput = dual(2, (self$1, f$14) => check(self$1, (_$1, out) => f$14(out))),
  ScheduleDefectTypeId = Symbol.for(`effect/Schedule/ScheduleDefect`)
var ScheduleDefect = class {
  error;
  [ScheduleDefectTypeId]
  constructor(error) {
    this.error = error, this[ScheduleDefectTypeId] = ScheduleDefectTypeId
  }
}
const isScheduleDefect = u$7 => hasProperty(u$7, ScheduleDefectTypeId),
  scheduleDefectWrap = self$1 => catchAll$1(self$1, e$26 => die$4(new ScheduleDefect(e$26))),
  scheduleDefectRefailCause = cause$2 =>
    match$11(find$2(cause$2, _$1 => isDieType$1(_$1) && isScheduleDefect(_$1.defect) ? some$4(_$1.defect) : none$7()), {
      onNone: () => cause$2,
      onSome: error => fail$10(error.error),
    }),
  scheduleDefectRefail = effect => catchAllCause$1(effect, cause$2 => failCause$8(scheduleDefectRefailCause(cause$2))),
  repeat_Effect = dual(2, (self$1, schedule$1) => repeatOrElse_Effect(self$1, schedule$1, (e$26, _$1) => fail$9(e$26))),
  repeat_combined = dual(2, (self$1, options$2) => {
    if (isSchedule(options$2)) return repeat_Effect(self$1, options$2)
    let base = options$2.schedule ?? passthrough(forever$1),
      withWhile = options$2.while
        ? whileInputEffect(base, a$22 => {
          let applied = options$2.while(a$22)
          return typeof applied == `boolean` ? succeed$9(applied) : scheduleDefectWrap(applied)
        })
        : base,
      withUntil = options$2.until
        ? untilInputEffect(withWhile, a$22 => {
          let applied = options$2.until(a$22)
          return typeof applied == `boolean` ? succeed$9(applied) : scheduleDefectWrap(applied)
        })
        : withWhile,
      withTimes = options$2.times
        ? intersect(withUntil, recurs(options$2.times)).pipe(map$4(intersectionPair => intersectionPair[0]))
        : withUntil
    return scheduleDefectRefail(repeat_Effect(self$1, withTimes))
  }),
  repeatOrElse_Effect = dual(
    3,
    (self$1, schedule$1, orElse$8) =>
      flatMap$5(driver(schedule$1), driver$1 =>
        matchEffect$2(self$1, {
          onFailure: error => orElse$8(error, none$7()),
          onSuccess: value$2 =>
            repeatOrElseEffectLoop(
              provideServiceEffect$1(self$1, CurrentIterationMetadata, get$1(driver$1.iterationMeta)),
              driver$1,
              (error, option$5) =>
                provideServiceEffect$1(
                  orElse$8(error, option$5),
                  CurrentIterationMetadata,
                  get$1(driver$1.iterationMeta),
                ),
              value$2,
            ),
        })),
  ),
  repeatOrElseEffectLoop = (self$1, driver$1, orElse$8, value$2) =>
    matchEffect$2(driver$1.next(value$2), {
      onFailure: () => orDie$1(driver$1.last),
      onSuccess: b$3 =>
        matchEffect$2(self$1, {
          onFailure: error => orElse$8(error, some$4(b$3)),
          onSuccess: value$3 => repeatOrElseEffectLoop(self$1, driver$1, orElse$8, value$3),
        }),
    }),
  retry_Effect = dual(2, (self$1, policy) => retryOrElse_Effect(self$1, policy, (e$26, _$1) => fail$9(e$26))),
  retry_combined = dual(
    2,
    (self$1, options$2) =>
      isSchedule(options$2)
        ? retry_Effect(self$1, options$2)
        : scheduleDefectRefail(retry_Effect(self$1, fromRetryOptions(options$2))),
  ),
  fromRetryOptions = options$2 => {
    let base = options$2.schedule ?? forever$1,
      withWhile = options$2.while
        ? whileInputEffect(base, e$26 => {
          let applied = options$2.while(e$26)
          return typeof applied == `boolean` ? succeed$9(applied) : scheduleDefectWrap(applied)
        })
        : base,
      withUntil = options$2.until
        ? untilInputEffect(withWhile, e$26 => {
          let applied = options$2.until(e$26)
          return typeof applied == `boolean` ? succeed$9(applied) : scheduleDefectWrap(applied)
        })
        : withWhile
    return options$2.times ? intersect(withUntil, recurs(options$2.times)) : withUntil
  },
  retryOrElse_Effect = dual(
    3,
    (self$1, policy, orElse$8) =>
      flatMap$5(driver(policy), driver$1 =>
        retryOrElse_EffectLoop(
          provideServiceEffect$1(self$1, CurrentIterationMetadata, get$1(driver$1.iterationMeta)),
          driver$1,
          (e$26, out) =>
            provideServiceEffect$1(orElse$8(e$26, out), CurrentIterationMetadata, get$1(driver$1.iterationMeta)),
        )),
  ),
  retryOrElse_EffectLoop = (self$1, driver$1, orElse$8) =>
    catchAll$1(
      self$1,
      e$26 =>
        matchEffect$2(driver$1.next(e$26), {
          onFailure: () => pipe(driver$1.last, orDie$1, flatMap$5(out => orElse$8(e$26, out))),
          onSuccess: () => retryOrElse_EffectLoop(self$1, driver$1, orElse$8),
        }),
    ),
  schedule_Effect = dual(2, (self$1, schedule$1) => scheduleFrom_Effect(self$1, void 0, schedule$1)),
  scheduleFrom_Effect = dual(
    3,
    (self$1, initial, schedule$1) =>
      flatMap$5(driver(schedule$1), driver$1 =>
        scheduleFrom_EffectLoop(
          provideServiceEffect$1(self$1, CurrentIterationMetadata, get$1(driver$1.iterationMeta)),
          initial,
          driver$1,
        )),
  ),
  scheduleFrom_EffectLoop = (self$1, initial, driver$1) =>
    matchEffect$2(driver$1.next(initial), {
      onFailure: () => orDie$1(driver$1.last),
      onSuccess: () => flatMap$5(self$1, a$22 => scheduleFrom_EffectLoop(self$1, a$22, driver$1)),
    }),
  forever$1 = unfold(0, n$19 => n$19 + 1),
  once$1 = asVoid$1(recurs(1)),
  scheduleForked$1 = dual(2, (self$1, schedule$1) => forkScoped$1(schedule_Effect(self$1, schedule$1))),
  withExecutionPlan$1 = dual(2, (effect, plan) =>
    suspend$4(() => {
      let i$14 = 0, result
      return flatMap$5(
        whileLoop$2({
          while: () => i$14 < plan.steps.length && (result === void 0 || isLeft(result)),
          body: () => {
            let step$3 = plan.steps[i$14], nextEffect$1 = effect_provide(effect, step$3.provide)
            if (result) {
              let attempted = !1, wrapped = nextEffect$1
              nextEffect$1 = suspend$4(() => attempted ? wrapped : (attempted = !0, result)),
                nextEffect$1 = scheduleDefectRefail(retry_Effect(nextEffect$1, scheduleFromStep(step$3, !1)))
            } else {
              let schedule$1 = scheduleFromStep(step$3, !0)
              nextEffect$1 = schedule$1 ? scheduleDefectRefail(retry_Effect(nextEffect$1, schedule$1)) : nextEffect$1
            }
            return either$3(nextEffect$1)
          },
          step: either$6 => {
            result = either$6, i$14++
          },
        }),
        () => result,
      )
    })),
  scheduleFromStep = (step$3, first$2) => {
    if (first$2) {
      if (step$3.attempts === 1 || !(step$3.schedule || step$3.attempts)) return
      else {return fromRetryOptions({
          schedule: step$3.schedule ? step$3.schedule : step$3.attempts ? void 0 : once$1,
          times: step$3.attempts,
          while: step$3.while,
        })}
    }
    return fromRetryOptions({
      schedule: step$3.schedule,
      while: step$3.while,
      times: step$3.attempts ? step$3.attempts - 1 : void 0,
    })
  },
  currentCache = globalValue(
    Symbol.for(`effect/FiberRef/currentCache`),
    () =>
      fiberRefUnsafeMake(
        unsafeMakeWith(65536, () =>
          map$11(deferredMake(), handle$2 => ({ listeners: new Listeners(), handle: handle$2 })), () =>
          seconds(60)),
      ),
  ),
  currentCacheEnabled = globalValue(Symbol.for(`effect/FiberRef/currentCacheEnabled`), () => fiberRefUnsafeMake(!1)),
  fromRequest = (request$1, dataSource) =>
    flatMap$5(isEffect$1(dataSource) ? dataSource : succeed$9(dataSource), ds =>
      fiberIdWith$1(id$2 => {
        let proxy$1 = new Proxy(request$1, {})
        return fiberRefGetWith(currentCacheEnabled, cacheEnabled => {
          if (cacheEnabled) {
            let cached$3 = fiberRefGetWith(currentCache, cache =>
              flatMap$5(cache.getEither(proxy$1), orNew => {
                switch (orNew._tag) {
                  case `Left`:
                    return orNew.left.listeners.interrupted
                      ? flatMap$5(
                        cache.invalidateWhen(proxy$1, entry => entry.handle === orNew.left.handle),
                        () => cached$3,
                      )
                      : (orNew.left.listeners.increment(),
                        uninterruptibleMask$2(restore =>
                          flatMap$5(
                            exit$4(blocked$1(empty$18, restore(deferredAwait(orNew.left.handle)))),
                            exit$5 => (orNew.left.listeners.decrement(), exit$5),
                          )
                        ))
                  case `Right`:
                    return orNew.right.listeners.increment(),
                      uninterruptibleMask$2(restore =>
                        flatMap$5(
                          exit$4(
                            blocked$1(
                              single(
                                ds,
                                makeEntry$1({
                                  request: proxy$1,
                                  result: orNew.right.handle,
                                  listeners: orNew.right.listeners,
                                  ownerId: id$2,
                                  state: { completed: !1 },
                                }),
                              ),
                              restore(deferredAwait(orNew.right.handle)),
                            ),
                          ),
                          () => (orNew.right.listeners.decrement(), deferredAwait(orNew.right.handle)),
                        )
                      )
                }
              }))
            return cached$3
          }
          let listeners = new Listeners()
          return listeners.increment(),
            flatMap$5(deferredMake(), ref =>
              ensuring$1(
                blocked$1(
                  single(
                    ds,
                    makeEntry$1({ request: proxy$1, result: ref, listeners, ownerId: id$2, state: { completed: !1 } }),
                  ),
                  deferredAwait(ref),
                ),
                sync$3(() => listeners.decrement()),
              ))
        })
      })),
  cacheRequest = (request$1, result) =>
    fiberRefGetWith(
      currentCacheEnabled,
      cacheEnabled =>
        cacheEnabled
          ? fiberRefGetWith(currentCache, cache =>
            flatMap$5(cache.getEither(request$1), orNew => {
              switch (orNew._tag) {
                case `Left`:
                  return void_$4
                case `Right`:
                  return deferredComplete(orNew.right.handle, result)
              }
            }))
          : void_$4,
    ),
  withRequestCaching$1 = dual(2, (self$1, strategy) => fiberRefLocally(self$1, currentCacheEnabled, strategy)),
  withRequestCache$1 = dual(2, (self$1, cache) => fiberRefLocally(self$1, currentCache, cache)),
  RequestTypeId = RequestTypeId$1,
  isRequest = isRequest$1,
  of = of$1,
  tagged = tagged$1,
  Class$1 = Class$3,
  TaggedClass$1 = TaggedClass$2,
  complete = complete$2,
  interruptWhenPossible = interruptWhenPossible$1,
  completeEffect = completeEffect$1,
  fail$2 = fail$5,
  failCause$1 = failCause$3,
  succeed$2 = succeed$4,
  isEntry = isEntry$1,
  makeEntry = makeEntry$1,
  EffectTypeId = EffectTypeId$2,
  isEffect = isEffect$1,
  cachedWithTTL = cached$1,
  cachedInvalidateWithTTL = cachedInvalidateWithTTL$1,
  cached = memoize,
  cachedFunction = cachedFunction$1,
  once = once$2,
  all$2 = all$4,
  allWith = allWith$1,
  allSuccesses = allSuccesses$1,
  dropUntil = dropUntil$1,
  dropWhile = dropWhile$1,
  takeUntil = takeUntil$1,
  takeWhile = takeWhile$1,
  every = every$1,
  exists = exists$1,
  filter$1 = filter$3,
  filterMap = filterMap$1,
  findFirst = findFirst$3,
  forEach = forEach$1,
  head$1 = head$2,
  mergeAll = mergeAll$2,
  partition = partition$1,
  reduce = reduce$4,
  reduceWhile = reduceWhile$1,
  reduceRight = reduceRight$1,
  reduceEffect = reduceEffect$1,
  replicate = replicate$1,
  replicateEffect = replicateEffect$1,
  validateAll = validateAll$1,
  validateFirst = validateFirst$1,
  async = async_,
  asyncEffect = asyncEffect$1,
  custom = custom$1,
  withFiberRuntime = withFiberRuntime$1,
  fail$1 = fail$9,
  failSync = failSync$2,
  failCause = failCause$8,
  failCauseSync = failCauseSync$2,
  die = die$4,
  dieMessage = dieMessage$1,
  dieSync = dieSync$2,
  gen = gen$1,
  never$1 = never$4,
  none = none$4,
  promise = promise$1,
  succeed$1 = succeed$9,
  succeedNone = succeedNone$1,
  succeedSome = succeedSome$1,
  suspend$1 = suspend$4,
  sync = sync$3,
  _void = void_$4,
  yieldNow = yieldNow$3,
  _catch = _catch$1,
  catchAll = catchAll$1,
  catchAllCause = catchAllCause$1,
  catchAllDefect = catchAllDefect$1,
  catchIf = catchIf$1,
  catchSome = catchSome$1,
  catchSomeCause = catchSomeCause$1,
  catchSomeDefect = catchSomeDefect$1,
  catchTag = catchTag$1,
  catchTags = catchTags$1,
  cause = cause$1,
  eventually = eventually$1,
  ignore$1 = ignore$2,
  ignoreLogged = ignoreLogged$1,
  parallelErrors = parallelErrors$1,
  sandbox = sandbox$1,
  retry = retry_combined,
  withExecutionPlan = withExecutionPlan$1,
  retryOrElse = retryOrElse_Effect,
  try_ = try_$1,
  tryMap = tryMap$1,
  tryMapPromise = tryMapPromise$1,
  tryPromise = tryPromise$1,
  unsandbox = unsandbox$1,
  allowInterrupt = allowInterrupt$1,
  checkInterruptible = checkInterruptible$1,
  disconnect = disconnect$1,
  interrupt = interrupt$5,
  interruptWith = interruptWith$2,
  interruptible = interruptible$2,
  interruptibleMask = interruptibleMask$1,
  onInterrupt = onInterrupt$1,
  uninterruptible = uninterruptible$1,
  uninterruptibleMask = uninterruptibleMask$2,
  liftPredicate = liftPredicate$1,
  as = as$4,
  asSome = asSome$1,
  asSomeError = asSomeError$1,
  asVoid = asVoid$3,
  flip$3 = flip$4,
  flipWith = flipWith$1,
  map$3 = map$11,
  mapAccum = mapAccum$1,
  mapBoth$1 = mapBoth$3,
  mapError$1 = mapError$3,
  mapErrorCause = mapErrorCause$1,
  merge$2 = merge$4,
  negate = negate$1,
  acquireRelease = acquireRelease$1,
  acquireReleaseInterruptible = acquireReleaseInterruptible$1,
  acquireUseRelease = acquireUseRelease$1,
  addFinalizer = addFinalizer$2,
  ensuring = ensuring$1,
  onError = onError$1,
  onExit = onExit$2,
  parallelFinalizers = parallelFinalizers$1,
  sequentialFinalizers = sequentialFinalizers$1,
  finalizersMask = finalizersMask$1,
  scope = scope$1,
  scopeWith = scopeWith$1,
  scopedWith = scopedWith$1,
  scoped = scopedEffect,
  using = using$1,
  withEarlyRelease = withEarlyRelease$1,
  awaitAllChildren = awaitAllChildren$1,
  daemonChildren = daemonChildren$1,
  descriptor = descriptor$1,
  descriptorWith = descriptorWith$1,
  diffFiberRefs = diffFiberRefs$1,
  ensuringChild = ensuringChild$1,
  ensuringChildren = ensuringChildren$1,
  fiberId = fiberId$1,
  fiberIdWith = fiberIdWith$1,
  fork = fork$2,
  forkDaemon = forkDaemon$1,
  forkAll = forkAll$1,
  forkIn = forkIn$1,
  forkScoped = forkScoped$1,
  forkWithErrorHandler = forkWithErrorHandler$1,
  fromFiber = fromFiber$1,
  fromFiberEffect = fromFiberEffect$1,
  supervised = supervised$1,
  transplant = transplant$1,
  withConcurrency = withConcurrency$1,
  withScheduler = withScheduler$1,
  withSchedulingPriority = withSchedulingPriority$1,
  withMaxOpsBeforeYield = withMaxOpsBeforeYield$1,
  clock = clock$1,
  clockWith = clockWith$1,
  withClockScoped = withClockScoped$1,
  withClock = withClock$1,
  console$1 = console$2,
  consoleWith = consoleWith$1,
  withConsoleScoped = withConsoleScoped$1,
  withConsole = withConsole$1,
  delay = delay$1,
  sleep = sleep$1,
  timed = timed$1,
  timedWith = timedWith$1,
  timeout = timeout$1,
  timeoutOption = timeoutOption$1,
  timeoutFail = timeoutFail$1,
  timeoutFailCause = timeoutFailCause$1,
  timeoutTo = timeoutTo$1,
  configProviderWith = configProviderWith$1,
  withConfigProvider = withConfigProvider$1,
  withConfigProviderScoped = withConfigProviderScoped$1,
  context = context$1,
  contextWith = contextWith$1,
  contextWithEffect = contextWithEffect$1,
  mapInputContext = mapInputContext$1,
  provide = effect_provide,
  provideService = provideService$1,
  provideServiceEffect = provideServiceEffect$1,
  serviceFunction = serviceFunction$1,
  serviceFunctionEffect = serviceFunctionEffect$1,
  serviceFunctions = serviceFunctions$1,
  serviceConstants = serviceConstants$1,
  serviceMembers = serviceMembers$1,
  serviceOption = serviceOption$1,
  serviceOptional = serviceOptional$1,
  updateService = updateService$1,
  Do = Do$1,
  bind = bind$1,
  bindAll = bindAll$1,
  bindTo = bindTo$1,
  let_ = let_$1,
  option$3 = option$4,
  either$2 = either$3,
  exit$2 = exit$4,
  intoDeferred = intoDeferred$1,
  if_ = if_$1,
  filterOrDie = filterOrDie$1,
  filterOrDieMessage = filterOrDieMessage$1,
  filterOrElse = filterOrElse$1,
  filterOrFail = filterOrFail$1,
  filterEffectOrElse = filterEffectOrElse$1,
  filterEffectOrFail = filterEffectOrFail$1,
  unless = unless$1,
  unlessEffect = unlessEffect$1,
  when$2 = when$3,
  whenEffect = whenEffect$1,
  whenFiberRef = whenFiberRef$1,
  whenRef = whenRef$1,
  flatMap$1 = flatMap$5,
  andThen = andThen$2,
  flatten = flatten$3,
  race = race$1,
  raceAll = raceAll$1,
  raceFirst = raceFirst$1,
  raceWith = raceWith$1,
  summarized = summarized$1,
  tap = tap$1,
  tapBoth = tapBoth$1,
  tapDefect = tapDefect$1,
  tapError = tapError$1,
  tapErrorTag = tapErrorTag$1,
  tapErrorCause = tapErrorCause$1,
  forever = forever$2,
  iterate = iterate$1,
  loop = loop$1,
  repeat = repeat_combined,
  repeatN = repeatN$1,
  repeatOrElse = repeatOrElse_Effect,
  schedule = schedule_Effect,
  scheduleForked = scheduleForked$1,
  scheduleFrom = scheduleFrom_Effect,
  whileLoop = whileLoop$2,
  getFiberRefs = fiberRefs,
  inheritFiberRefs = inheritFiberRefs$1,
  locally = fiberRefLocally,
  locallyWith = fiberRefLocallyWith,
  locallyScoped = fiberRefLocallyScoped,
  locallyScopedWith = fiberRefLocallyScopedWith,
  patchFiberRefs = patchFiberRefs$1,
  setFiberRefs = setFiberRefs$1,
  updateFiberRefs = updateFiberRefs$1,
  isFailure = isFailure$2,
  isSuccess = isSuccess$1,
  match = match$7,
  matchCause = matchCause$2,
  matchCauseEffect = matchCauseEffect$2,
  matchEffect = matchEffect$2,
  log = log$1,
  logTrace = logTrace$1,
  logDebug = logDebug$1,
  logInfo = logInfo$1,
  logWarning = logWarning$1,
  logError = logError$1,
  logFatal = logFatal$1,
  withLogSpan = withLogSpan$1,
  annotateLogs = annotateLogs$1,
  annotateLogsScoped = annotateLogsScoped$1,
  logAnnotations = logAnnotations$1,
  withUnhandledErrorLogLevel = withUnhandledErrorLogLevel$1,
  whenLogLevel = whenLogLevel$1,
  orDie = orDie$1,
  orDieWith = orDieWith$1,
  orElse$3 = orElse$6,
  orElseFail = orElseFail$1,
  orElseSucceed = orElseSucceed$1,
  firstSuccessOf = firstSuccessOf$1,
  random = random$1,
  randomWith = randomWith$1,
  withRandom = withRandom$1,
  withRandomScoped = withRandomScoped$1,
  runtime = runtime$1,
  getRuntimeFlags = runtimeFlags,
  patchRuntimeFlags = updateRuntimeFlags,
  withRuntimeFlagsPatch = withRuntimeFlags,
  withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped,
  tagMetrics = tagMetrics$1,
  labelMetrics = labelMetrics$1,
  tagMetricsScoped = tagMetricsScoped$1,
  labelMetricsScoped = labelMetricsScoped$1,
  metricLabels = metricLabels$1,
  withMetric = withMetric$1,
  unsafeMakeSemaphore = unsafeMakeSemaphore$1,
  makeSemaphore = makeSemaphore$1,
  unsafeMakeLatch = unsafeMakeLatch$1,
  makeLatch = makeLatch$1,
  runFork = unsafeForkEffect,
  runCallback = unsafeRunEffect,
  runPromise = unsafeRunPromiseEffect,
  runPromiseExit = unsafeRunPromiseExitEffect,
  runSync = unsafeRunSyncEffect,
  runSyncExit = unsafeRunSyncExitEffect,
  validate = validate$1,
  validateWith = validateWith$1,
  zip = zipOptions,
  zipLeft = zipLeftOptions,
  zipRight = zipRightOptions,
  zipWith = zipWithOptions,
  blocked = blocked$1,
  runRequestBlock = runRequestBlock$1,
  step = step$1,
  request = dual(args$1 => isRequest(args$1[0]), fromRequest),
  cacheRequestResult = cacheRequest,
  withRequestBatching = withRequestBatching$1,
  withRequestCaching = withRequestCaching$1,
  withRequestCache = withRequestCache$1,
  tracer = tracer$1,
  tracerWith = tracerWith$3,
  withTracer = withTracer$1,
  withTracerScoped = withTracerScoped$1,
  withTracerEnabled = withTracerEnabled$1,
  withTracerTiming = withTracerTiming$1,
  annotateSpans = annotateSpans$1,
  annotateCurrentSpan = annotateCurrentSpan$1,
  currentSpan = currentSpan$1,
  currentParentSpan = currentParentSpan$1,
  spanAnnotations = spanAnnotations$1,
  spanLinks = spanLinks$1,
  linkSpans = linkSpans$1,
  linkSpanCurrent = linkSpanCurrent$1,
  makeSpan = makeSpan$1,
  makeSpanScoped = makeSpanScoped$1,
  useSpan = useSpan$1,
  withSpan = withSpan$1,
  functionWithSpan = functionWithSpan$1,
  withSpanScoped = withSpanScoped$1,
  withParentSpan = withParentSpan$1,
  fromNullable = fromNullable$1,
  optionFromOptional = optionFromOptional$1,
  fnUntraced = fnUntraced$1,
  DecodeExceptionTypeId$1 = Symbol.for(`effect/Encoding/errors/Decode`),
  DecodeException$1 = (input, message) => {
    let out = { _tag: `DecodeException`, [DecodeExceptionTypeId$1]: DecodeExceptionTypeId$1, input }
    return isString$1(message) && (out.message = message), out
  },
  isDecodeException$1 = u$7 => hasProperty(u$7, DecodeExceptionTypeId$1),
  EncodeExceptionTypeId$1 = Symbol.for(`effect/Encoding/errors/Encode`),
  EncodeException$1 = (input, message) => {
    let out = { _tag: `EncodeException`, [EncodeExceptionTypeId$1]: EncodeExceptionTypeId$1, input }
    return isString$1(message) && (out.message = message), out
  },
  isEncodeException$1 = u$7 => hasProperty(u$7, EncodeExceptionTypeId$1),
  encoder = new TextEncoder(),
  decoder = new TextDecoder(),
  encode$28 = bytes => {
    let length$1 = bytes.length, result = ``, i$14
    for (i$14 = 2; i$14 < length$1; i$14 += 3) {
      result += base64abc[bytes[i$14 - 2] >> 2],
        result += base64abc[(bytes[i$14 - 2] & 3) << 4 | bytes[i$14 - 1] >> 4],
        result += base64abc[(bytes[i$14 - 1] & 15) << 2 | bytes[i$14] >> 6],
        result += base64abc[bytes[i$14] & 63]
    }
    return i$14 === length$1 + 1
      && (result += base64abc[bytes[i$14 - 2] >> 2], result += base64abc[(bytes[i$14 - 2] & 3) << 4], result += `==`),
      i$14 === length$1
      && (result += base64abc[bytes[i$14 - 2] >> 2],
        result += base64abc[(bytes[i$14 - 2] & 3) << 4 | bytes[i$14 - 1] >> 4],
        result += base64abc[(bytes[i$14 - 1] & 15) << 2],
        result += `=`),
      result
  },
  decode$29 = str => {
    let stripped = stripCrlf(str), length$1 = stripped.length
    if (length$1 % 4 != 0) {
      return left(DecodeException$1(stripped, `Length must be a multiple of 4, but is ${length$1}`))
    }
    let index$4 = stripped.indexOf(`=`)
    if (index$4 !== -1 && (index$4 < length$1 - 2 || index$4 === length$1 - 2 && stripped[length$1 - 1] !== `=`)) {
      return left(DecodeException$1(stripped, `Found a '=' character, but it is not at the end`))
    }
    try {
      let missingOctets = stripped.endsWith(`==`) ? 2 : stripped.endsWith(`=`) ? 1 : 0,
        result = new Uint8Array(3 * (length$1 / 4) - missingOctets)
      for (let i$14 = 0, j$1 = 0; i$14 < length$1; i$14 += 4, j$1 += 3) {
        let buffer = getBase64Code(stripped.charCodeAt(i$14)) << 18 | getBase64Code(stripped.charCodeAt(i$14 + 1)) << 12
          | getBase64Code(stripped.charCodeAt(i$14 + 2)) << 6 | getBase64Code(stripped.charCodeAt(i$14 + 3))
        result[j$1] = buffer >> 16, result[j$1 + 1] = buffer >> 8 & 255, result[j$1 + 2] = buffer & 255
      }
      return right(result)
    } catch (e$26) {
      return left(DecodeException$1(stripped, e$26 instanceof Error ? e$26.message : `Invalid input`))
    }
  },
  stripCrlf = str => str.replace(/[\n\r]/g, ``)
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) throw TypeError(`Invalid character ${String.fromCharCode(charCode)}`)
  let code$3 = base64codes[charCode]
  if (code$3 === 255) throw TypeError(`Invalid character ${String.fromCharCode(charCode)}`)
  return code$3
}
const base64abc = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`.split(``),
  base64codes = [
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    62,
    255,
    255,
    255,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    255,
    255,
    255,
    0,
    255,
    255,
    255,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    255,
    255,
    255,
    255,
    255,
    255,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
  ],
  encode$27 = data => encode$28(data).replace(/=/g, ``).replace(/\+/g, `-`).replace(/\//g, `_`),
  decode$28 = str => {
    let stripped = stripCrlf(str), length$1 = stripped.length
    if (length$1 % 4 == 1) {
      return left(DecodeException$1(stripped, `Length should be a multiple of 4, but is ${length$1}`))
    }
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) return left(DecodeException$1(stripped, `Invalid input`))
    let sanitized = length$1 % 4 == 2 ? `${stripped}==` : length$1 % 4 == 3 ? `${stripped}=` : stripped
    return sanitized = sanitized.replace(/-/g, `+`).replace(/_/g, `/`), decode$29(sanitized)
  },
  encode$26 = bytes => {
    let result = ``
    for (let i$14 = 0; i$14 < bytes.length; ++i$14) result += bytesToHex[bytes[i$14]]
    return result
  },
  decode$27 = str => {
    let bytes = new TextEncoder().encode(str)
    if (bytes.length % 2 != 0) {
      return left(DecodeException$1(str, `Length must be a multiple of 2, but is ${bytes.length}`))
    }
    try {
      let length$1 = bytes.length / 2, result = new Uint8Array(length$1)
      for (let i$14 = 0; i$14 < length$1; i$14++) {
        let a$22 = fromHexChar(bytes[i$14 * 2]), b$3 = fromHexChar(bytes[i$14 * 2 + 1])
        result[i$14] = a$22 << 4 | b$3
      }
      return right(result)
    } catch (e$26) {
      return left(DecodeException$1(str, e$26 instanceof Error ? e$26.message : `Invalid input`))
    }
  },
  bytesToHex =
    `00.01.02.03.04.05.06.07.08.09.0a.0b.0c.0d.0e.0f.10.11.12.13.14.15.16.17.18.19.1a.1b.1c.1d.1e.1f.20.21.22.23.24.25.26.27.28.29.2a.2b.2c.2d.2e.2f.30.31.32.33.34.35.36.37.38.39.3a.3b.3c.3d.3e.3f.40.41.42.43.44.45.46.47.48.49.4a.4b.4c.4d.4e.4f.50.51.52.53.54.55.56.57.58.59.5a.5b.5c.5d.5e.5f.60.61.62.63.64.65.66.67.68.69.6a.6b.6c.6d.6e.6f.70.71.72.73.74.75.76.77.78.79.7a.7b.7c.7d.7e.7f.80.81.82.83.84.85.86.87.88.89.8a.8b.8c.8d.8e.8f.90.91.92.93.94.95.96.97.98.99.9a.9b.9c.9d.9e.9f.a0.a1.a2.a3.a4.a5.a6.a7.a8.a9.aa.ab.ac.ad.ae.af.b0.b1.b2.b3.b4.b5.b6.b7.b8.b9.ba.bb.bc.bd.be.bf.c0.c1.c2.c3.c4.c5.c6.c7.c8.c9.ca.cb.cc.cd.ce.cf.d0.d1.d2.d3.d4.d5.d6.d7.d8.d9.da.db.dc.dd.de.df.e0.e1.e2.e3.e4.e5.e6.e7.e8.e9.ea.eb.ec.ed.ee.ef.f0.f1.f2.f3.f4.f5.f6.f7.f8.f9.fa.fb.fc.fd.fe.ff`
      .split(`.`),
  fromHexChar = byte => {
    if (48 <= byte && byte <= 57) return byte - 48
    if (97 <= byte && byte <= 102) return byte - 97 + 10
    if (65 <= byte && byte <= 70) return byte - 65 + 10
    throw TypeError(`Invalid input`)
  },
  encodeBase64 = input => encode$28(typeof input == `string` ? encoder.encode(input) : input),
  decodeBase64 = str => decode$29(str),
  decodeBase64String = str => map$19(decodeBase64(str), _$1 => decoder.decode(_$1)),
  encodeBase64Url = input => encode$27(typeof input == `string` ? encoder.encode(input) : input),
  decodeBase64Url = str => decode$28(str),
  decodeBase64UrlString = str => map$19(decodeBase64Url(str), _$1 => decoder.decode(_$1)),
  encodeHex = input => encode$26(typeof input == `string` ? encoder.encode(input) : input),
  decodeHex = str => decode$27(str),
  decodeHexString = str => map$19(decodeHex(str), _$1 => decoder.decode(_$1)),
  DecodeExceptionTypeId = DecodeExceptionTypeId$1,
  DecodeException = DecodeException$1,
  isDecodeException = isDecodeException$1,
  EncodeExceptionTypeId = EncodeExceptionTypeId$1,
  EncodeException = EncodeException$1,
  isEncodeException = isEncodeException$1
var Pointer = class {
    path
    actual
    issue
    _tag = `Pointer`
    constructor(path$1, actual, issue) {
      this.path = path$1, this.actual = actual, this.issue = issue
    }
  },
  Unexpected = class {
    actual
    message
    _tag = `Unexpected`
    constructor(actual, message) {
      this.actual = actual, this.message = message
    }
  },
  Missing = class {
    ast
    message
    _tag = `Missing`
    actual = void 0
    constructor(ast, message) {
      this.ast = ast, this.message = message
    }
  },
  Composite = class {
    ast
    actual
    issues
    output
    _tag = `Composite`
    constructor(ast, actual, issues, output) {
      this.ast = ast, this.actual = actual, this.issues = issues, this.output = output
    }
  },
  Refinement = class {
    ast
    actual
    kind
    issue
    _tag = `Refinement`
    constructor(ast, actual, kind, issue) {
      this.ast = ast, this.actual = actual, this.kind = kind, this.issue = issue
    }
  },
  Transformation = class {
    ast
    actual
    kind
    issue
    _tag = `Transformation`
    constructor(ast, actual, kind, issue) {
      this.ast = ast, this.actual = actual, this.kind = kind, this.issue = issue
    }
  },
  Type$1 = class {
    ast
    actual
    message
    _tag = `Type`
    constructor(ast, actual, message) {
      this.ast = ast, this.actual = actual, this.message = message
    }
  },
  Forbidden = class {
    ast
    actual
    message
    _tag = `Forbidden`
    constructor(ast, actual, message) {
      this.ast = ast, this.actual = actual, this.message = message
    }
  }
const ParseErrorTypeId = Symbol.for(`effect/Schema/ParseErrorTypeId`)
var ParseError = class extends TaggedError(`ParseError`) {
  [ParseErrorTypeId] = ParseErrorTypeId
  get message() {
    return this.toString()
  }
  toString() {
    return TreeFormatter.formatIssueSync(this.issue)
  }
  toJSON() {
    return { _id: `ParseError`, message: this.toString() }
  }
  [NodeInspectSymbol]() {
    return this.toJSON()
  }
}
const parseError = issue => new ParseError({ issue }),
  succeed = right,
  fail = left,
  _try = try_$2,
  fromOption = fromOption$3,
  isEither = isEither$1,
  flatMap = dual(
    2,
    (self$1, f$14) => isEither(self$1) ? match$12(self$1, { onLeft: left, onRight: f$14 }) : flatMap$1(self$1, f$14),
  ),
  map$2 = dual(2, (self$1, f$14) => isEither(self$1) ? map$19(self$1, f$14) : map$3(self$1, f$14)),
  mapError = dual(2, (self$1, f$14) => isEither(self$1) ? mapLeft(self$1, f$14) : mapError$1(self$1, f$14)),
  mapBoth = dual(
    2,
    (self$1, options$2) =>
      isEither(self$1)
        ? mapBoth$4(self$1, { onLeft: options$2.onFailure, onRight: options$2.onSuccess })
        : mapBoth$1(self$1, options$2),
  ),
  orElse$2 = dual(
    2,
    (self$1, f$14) => isEither(self$1) ? match$12(self$1, { onLeft: f$14, onRight: right }) : catchAll(self$1, f$14),
  ),
  mergeInternalOptions = (options$2, overrideOptions) =>
    overrideOptions === void 0 || isNumber$1(overrideOptions)
      ? options$2
      : options$2 === void 0
      ? overrideOptions
      : { ...options$2, ...overrideOptions },
  getEither = (ast, isDecoding, options$2) => {
    let parser = goMemo(ast, isDecoding)
    return (u$7, overrideOptions) => parser(u$7, mergeInternalOptions(options$2, overrideOptions))
  },
  getSync = (ast, isDecoding, options$2) => {
    let parser = getEither(ast, isDecoding, options$2)
    return (input, overrideOptions) => getOrThrowWith$1(parser(input, overrideOptions), parseError)
  },
  getEffect = (ast, isDecoding, options$2) => {
    let parser = goMemo(ast, isDecoding)
    return (input, overrideOptions) =>
      parser(input, { ...mergeInternalOptions(options$2, overrideOptions), isEffectAllowed: !0 })
  },
  decodeUnknownSync = (schema, options$2) => getSync(schema.ast, !0, options$2),
  decodeUnknown$1 = (schema, options$2) => getEffect(schema.ast, !0, options$2),
  encodeUnknownSync = (schema, options$2) => getSync(schema.ast, !1, options$2),
  encodeUnknown$1 = (schema, options$2) => getEffect(schema.ast, !1, options$2),
  decodeSync$18 = decodeUnknownSync,
  validateSync = (schema, options$2) => getSync(typeAST(schema.ast), !0, options$2),
  is$25 = (schema, options$2) => {
    let parser = goMemo(typeAST(schema.ast), !0)
    return (u$7, overrideOptions) =>
      isRight(parser(u$7, { exact: !0, ...mergeInternalOptions(options$2, overrideOptions) }))
  },
  encodeSync$4 = encodeUnknownSync,
  decodeMemoMap = globalValue(Symbol.for(`effect/ParseResult/decodeMemoMap`), () => new WeakMap()),
  encodeMemoMap = globalValue(Symbol.for(`effect/ParseResult/encodeMemoMap`), () => new WeakMap()),
  goMemo = (ast, isDecoding) => {
    let memoMap = isDecoding ? decodeMemoMap : encodeMemoMap, memo = memoMap.get(ast)
    if (memo) return memo
    let raw$1 = go$1(ast, isDecoding),
      parseOptionsAnnotation = getParseOptionsAnnotation(ast),
      parserWithOptions = isSome(parseOptionsAnnotation)
        ? (i$14, options$2) => raw$1(i$14, mergeInternalOptions(options$2, parseOptionsAnnotation.value))
        : raw$1,
      decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast),
      parser = isDecoding && isSome(decodingFallbackAnnotation)
        ? (i$14, options$2) =>
          handleForbidden(
            orElse$2(parserWithOptions(i$14, options$2), decodingFallbackAnnotation.value),
            ast,
            i$14,
            options$2,
          )
        : parserWithOptions
    return memoMap.set(ast, parser), parser
  },
  getConcurrency = ast => getOrUndefined(getConcurrencyAnnotation(ast)),
  getBatching = ast => getOrUndefined(getBatchingAnnotation(ast)),
  go$1 = (ast, isDecoding) => {
    switch (ast._tag) {
      case `Refinement`:
        if (isDecoding) {
          let from = goMemo(ast.from, !0)
          return (i$14, options$2) => {
            options$2 ??= defaultParseOption
            let allErrors = options$2?.errors === `all`,
              result = flatMap(
                orElse$2(from(i$14, options$2), ef => {
                  let issue = new Refinement(ast, i$14, `From`, ef)
                  return allErrors && hasStableFilter(ast) && isComposite(ef)
                    ? match$11(ast.filter(i$14, options$2, ast), {
                      onNone: () => left(issue),
                      onSome: ep => left(new Composite(ast, i$14, [issue, new Refinement(ast, i$14, `Predicate`, ep)])),
                    })
                    : left(issue)
                }),
                a$22 =>
                  match$11(ast.filter(a$22, options$2, ast), {
                    onNone: () => right(a$22),
                    onSome: ep => left(new Refinement(ast, i$14, `Predicate`, ep)),
                  }),
              )
            return handleForbidden(result, ast, i$14, options$2)
          }
        } else {
          let from = goMemo(typeAST(ast), !0), to = goMemo(dropRightRefinement(ast.from), !1)
          return (i$14, options$2) =>
            handleForbidden(flatMap(from(i$14, options$2), a$22 => to(a$22, options$2)), ast, i$14, options$2)
        }
      case `Transformation`: {
        let transform$3 = getFinalTransformation(ast.transformation, isDecoding),
          from = isDecoding ? goMemo(ast.from, !0) : goMemo(ast.to, !1),
          to = isDecoding ? goMemo(ast.to, !0) : goMemo(ast.from, !1)
        return (i$14, options$2) =>
          handleForbidden(
            flatMap(
              mapError(
                from(i$14, options$2),
                e$26 => new Transformation(ast, i$14, isDecoding ? `Encoded` : `Type`, e$26),
              ),
              a$22 =>
                flatMap(
                  mapError(
                    transform$3(a$22, options$2 ?? defaultParseOption, ast, i$14),
                    e$26 => new Transformation(ast, i$14, `Transformation`, e$26),
                  ),
                  i2 =>
                    mapError(
                      to(i2, options$2),
                      e$26 => new Transformation(ast, i$14, isDecoding ? `Type` : `Encoded`, e$26),
                    ),
                ),
            ),
            ast,
            i$14,
            options$2,
          )
      }
      case `Declaration`: {
        let parse$3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters)
        return (i$14, options$2) =>
          handleForbidden(parse$3(i$14, options$2 ?? defaultParseOption, ast), ast, i$14, options$2)
      }
      case `Literal`:
        return fromRefinement(ast, u$7 => u$7 === ast.literal)
      case `UniqueSymbol`:
        return fromRefinement(ast, u$7 => u$7 === ast.symbol)
      case `UndefinedKeyword`:
        return fromRefinement(ast, isUndefined)
      case `NeverKeyword`:
        return fromRefinement(ast, isNever)
      case `UnknownKeyword`:
      case `AnyKeyword`:
      case `VoidKeyword`:
        return right
      case `StringKeyword`:
        return fromRefinement(ast, isString$1)
      case `NumberKeyword`:
        return fromRefinement(ast, isNumber$1)
      case `BooleanKeyword`:
        return fromRefinement(ast, isBoolean$2)
      case `BigIntKeyword`:
        return fromRefinement(ast, isBigInt)
      case `SymbolKeyword`:
        return fromRefinement(ast, isSymbol)
      case `ObjectKeyword`:
        return fromRefinement(ast, isObject$4)
      case `Enums`:
        return fromRefinement(ast, u$7 => ast.enums.some(([_$1, value$2]) => value$2 === u$7))
      case `TemplateLiteral`: {
        let regex = getTemplateLiteralRegExp(ast)
        return fromRefinement(ast, u$7 => isString$1(u$7) && regex.test(u$7))
      }
      case `TupleType`: {
        let elements = ast.elements.map(e$26 => goMemo(e$26.type, isDecoding)),
          rest = ast.rest.map(annotatedAST => goMemo(annotatedAST.type, isDecoding)),
          requiredTypes = ast.elements.filter(e$26 => !e$26.isOptional)
        ast.rest.length > 0 && (requiredTypes = requiredTypes.concat(ast.rest.slice(1)))
        let requiredLen = requiredTypes.length,
          expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_$1, i$14) => i$14).join(` | `) : `never`,
          concurrency = getConcurrency(ast),
          batching = getBatching(ast)
        return (input, options$2) => {
          if (!isArray$1(input)) return left(new Type$1(ast, input))
          let allErrors = options$2?.errors === `all`, es = [], stepKey = 0, output = [], len = input.length
          for (let i$15 = len; i$15 <= requiredLen - 1; i$15++) {
            let e$26 = new Pointer(i$15, input, new Missing(requiredTypes[i$15 - len]))
            if (allErrors) {
              es.push([stepKey++, e$26])
              continue
            } else return left(new Composite(ast, input, e$26, output))
          }
          if (ast.rest.length === 0) {
            for (let i$15 = ast.elements.length; i$15 <= len - 1; i$15++) {
              let e$26 = new Pointer(
                i$15,
                input,
                new Unexpected(input[i$15], `is unexpected, expected: ${expectedIndexes}`),
              )
              if (allErrors) {
                es.push([stepKey++, e$26])
                continue
              } else return left(new Composite(ast, input, e$26, output))
            }
          }
          let i$14 = 0, queue
          for (; i$14 < elements.length; i$14++) {
            if (len < i$14 + 1) {
              if (ast.elements[i$14].isOptional) continue
              else {
                let parser = elements[i$14], te = parser(input[i$14], options$2)
                if (isEither(te)) {
                  if (isLeft(te)) {
                    let e$26 = new Pointer(i$14, input, te.left)
                    if (allErrors) {
                      es.push([stepKey++, e$26])
                      continue
                    } else return left(new Composite(ast, input, e$26, sortByIndex(output)))
                  }
                  output.push([stepKey++, te.right])
                } else {
                  let nk = stepKey++, index$4 = i$14
                  queue ||= [],
                    queue.push(({ es: es$1, output: output$1 }) =>
                      flatMap$1(either$2(te), t$18 => {
                        if (isLeft(t$18)) {
                          let e$26 = new Pointer(index$4, input, t$18.left)
                          return allErrors
                            ? (es$1.push([nk, e$26]), _void)
                            : left(new Composite(ast, input, e$26, sortByIndex(output$1)))
                        }
                        return output$1.push([nk, t$18.right]), _void
                      })
                    )
                }
              }
            }
          }
          if (isNonEmptyReadonlyArray(rest)) {
            let [head$5, ...tail] = rest
            for (; i$14 < len - tail.length; i$14++) {
              let te = head$5(input[i$14], options$2)
              if (isEither(te)) {
                if (isLeft(te)) {
                  let e$26 = new Pointer(i$14, input, te.left)
                  if (allErrors) {
                    es.push([stepKey++, e$26])
                    continue
                  } else return left(new Composite(ast, input, e$26, sortByIndex(output)))
                } else output.push([stepKey++, te.right])
              } else {
                let nk = stepKey++, index$4 = i$14
                queue ||= [],
                  queue.push(({ es: es$1, output: output$1 }) =>
                    flatMap$1(either$2(te), t$18 => {
                      if (isLeft(t$18)) {
                        let e$26 = new Pointer(index$4, input, t$18.left)
                        return allErrors
                          ? (es$1.push([nk, e$26]), _void)
                          : left(new Composite(ast, input, e$26, sortByIndex(output$1)))
                      } else return output$1.push([nk, t$18.right]), _void
                    })
                  )
              }
            }
            for (let j$1 = 0; j$1 < tail.length; j$1++) {
              if (i$14 += j$1, !(len < i$14 + 1)) {
                let te = tail[j$1](input[i$14], options$2)
                if (isEither(te)) {
                  if (isLeft(te)) {
                    let e$26 = new Pointer(i$14, input, te.left)
                    if (allErrors) {
                      es.push([stepKey++, e$26])
                      continue
                    } else return left(new Composite(ast, input, e$26, sortByIndex(output)))
                  }
                  output.push([stepKey++, te.right])
                } else {
                  let nk = stepKey++, index$4 = i$14
                  queue ||= [],
                    queue.push(({ es: es$1, output: output$1 }) =>
                      flatMap$1(either$2(te), t$18 => {
                        if (isLeft(t$18)) {
                          let e$26 = new Pointer(index$4, input, t$18.left)
                          return allErrors
                            ? (es$1.push([nk, e$26]), _void)
                            : left(new Composite(ast, input, e$26, sortByIndex(output$1)))
                        }
                        return output$1.push([nk, t$18.right]), _void
                      })
                    )
                }
              }
            }
          }
          let computeResult = ({ es: es$1, output: output$1 }) =>
            isNonEmptyArray(es$1)
              ? left(new Composite(ast, input, sortByIndex(es$1), sortByIndex(output$1)))
              : right(sortByIndex(output$1))
          if (queue && queue.length > 0) {
            let cqueue = queue
            return suspend$1(() => {
              let state = { es: copy$1(es), output: copy$1(output) }
              return flatMap$1(
                forEach(cqueue, f$14 => f$14(state), { concurrency, batching, discard: !0 }),
                () => computeResult(state),
              )
            })
          }
          return computeResult({ output, es })
        }
      }
      case `TypeLiteral`: {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return fromRefinement(ast, isNotNullable)
        }
        let propertySignatures = [], expectedKeysMap = {}, expectedKeys = []
        for (let ps of ast.propertySignatures) {
          propertySignatures.push([goMemo(ps.type, isDecoding), ps]),
            expectedKeysMap[ps.name] = null,
            expectedKeys.push(ps.name)
        }
        let indexSignatures = ast.indexSignatures.map(
            is$29 => [goMemo(is$29.parameter, isDecoding), goMemo(is$29.type, isDecoding), is$29.parameter],
          ),
          expectedAST = Union$1.make(
            ast.indexSignatures.map(is$29 => is$29.parameter).concat(
              expectedKeys.map(key$1 => isSymbol(key$1) ? new UniqueSymbol(key$1) : new Literal$1(key$1)),
            ),
          ),
          expected = goMemo(expectedAST, isDecoding),
          concurrency = getConcurrency(ast),
          batching = getBatching(ast)
        return (input, options$2) => {
          if (!isRecord$1(input)) return left(new Type$1(ast, input))
          let allErrors = options$2?.errors === `all`,
            es = [],
            stepKey = 0,
            onExcessPropertyError = options$2?.onExcessProperty === `error`,
            onExcessPropertyPreserve = options$2?.onExcessProperty === `preserve`,
            output = {},
            inputKeys
          if (onExcessPropertyError || onExcessPropertyPreserve) {
            inputKeys = ownKeys(input)
            for (let key$1 of inputKeys) {
              let te = expected(key$1, options$2)
              if (isEither(te) && isLeft(te)) {
                if (onExcessPropertyError) {
                  let e$26 = new Pointer(
                    key$1,
                    input,
                    new Unexpected(input[key$1], `is unexpected, expected: ${String(expectedAST)}`),
                  )
                  if (allErrors) {
                    es.push([stepKey++, e$26])
                    continue
                  } else return left(new Composite(ast, input, e$26, output))
                } else output[key$1] = input[key$1]
              }
            }
          }
          let queue, isExact = options$2?.exact === !0
          for (let i$14 = 0; i$14 < propertySignatures.length; i$14++) {
            let ps = propertySignatures[i$14][1],
              name = ps.name,
              hasKey = Object.prototype.hasOwnProperty.call(input, name)
            if (!hasKey) {
              if (ps.isOptional) continue
              if (isExact) {
                let e$26 = new Pointer(name, input, new Missing(ps))
                if (allErrors) {
                  es.push([stepKey++, e$26])
                  continue
                } else return left(new Composite(ast, input, e$26, output))
              }
            }
            let parser = propertySignatures[i$14][0], te = parser(input[name], options$2)
            if (isEither(te)) {
              if (isLeft(te)) {
                let e$26 = new Pointer(name, input, hasKey ? te.left : new Missing(ps))
                if (allErrors) {
                  es.push([stepKey++, e$26])
                  continue
                } else return left(new Composite(ast, input, e$26, output))
              }
              output[name] = te.right
            } else {
              let nk = stepKey++, index$4 = name
              queue ||= [],
                queue.push(({ es: es$1, output: output$1 }) =>
                  flatMap$1(either$2(te), t$18 => {
                    if (isLeft(t$18)) {
                      let e$26 = new Pointer(index$4, input, hasKey ? t$18.left : new Missing(ps))
                      return allErrors
                        ? (es$1.push([nk, e$26]), _void)
                        : left(new Composite(ast, input, e$26, output$1))
                    }
                    return output$1[index$4] = t$18.right, _void
                  })
                )
            }
          }
          for (let i$14 = 0; i$14 < indexSignatures.length; i$14++) {
            let indexSignature = indexSignatures[i$14],
              parameter = indexSignature[0],
              type$2 = indexSignature[1],
              keys$6 = getKeysForIndexSignature(input, indexSignature[2])
            for (let key$1 of keys$6) {
              let keu = parameter(key$1, options$2)
              if (isEither(keu) && isRight(keu)) {
                let vpr = type$2(input[key$1], options$2)
                if (isEither(vpr)) {
                  if (isLeft(vpr)) {
                    let e$26 = new Pointer(key$1, input, vpr.left)
                    if (allErrors) {
                      es.push([stepKey++, e$26])
                      continue
                    } else return left(new Composite(ast, input, e$26, output))
                  } else Object.prototype.hasOwnProperty.call(expectedKeysMap, key$1) || (output[key$1] = vpr.right)
                } else {
                  let nk = stepKey++, index$4 = key$1
                  queue ||= [],
                    queue.push(({ es: es$1, output: output$1 }) =>
                      flatMap$1(either$2(vpr), tv => {
                        if (isLeft(tv)) {
                          let e$26 = new Pointer(index$4, input, tv.left)
                          return allErrors
                            ? (es$1.push([nk, e$26]), _void)
                            : left(new Composite(ast, input, e$26, output$1))
                        } else {return Object.prototype.hasOwnProperty.call(expectedKeysMap, key$1)
                            || (output$1[key$1] = tv.right),
                            _void}
                      })
                    )
                }
              }
            }
          }
          let computeResult = ({ es: es$1, output: output$1 }) => {
            if (isNonEmptyArray(es$1)) return left(new Composite(ast, input, sortByIndex(es$1), output$1))
            if (options$2?.propertyOrder === `original`) {
              let keys$6 = inputKeys || ownKeys(input)
              for (let name of expectedKeys) keys$6.indexOf(name) === -1 && keys$6.push(name)
              let out = {}
              for (let key$1 of keys$6) {
                Object.prototype.hasOwnProperty.call(output$1, key$1) && (out[key$1] = output$1[key$1])
              }
              return right(out)
            }
            return right(output$1)
          }
          if (queue && queue.length > 0) {
            let cqueue = queue
            return suspend$1(() => {
              let state = { es: copy$1(es), output: Object.assign({}, output) }
              return flatMap$1(
                forEach(cqueue, f$14 => f$14(state), { concurrency, batching, discard: !0 }),
                () => computeResult(state),
              )
            })
          }
          return computeResult({ es, output })
        }
      }
      case `Union`: {
        let searchTree = getSearchTree(ast.types, isDecoding),
          ownKeys$1 = ownKeys(searchTree.keys),
          ownKeysLen = ownKeys$1.length,
          astTypesLen = ast.types.length,
          map$20 = new Map()
        for (let i$14 = 0; i$14 < astTypesLen; i$14++) map$20.set(ast.types[i$14], goMemo(ast.types[i$14], isDecoding))
        let concurrency = getConcurrency(ast) ?? 1, batching = getBatching(ast)
        return (input, options$2) => {
          let es = [], stepKey = 0, candidates = []
          if (ownKeysLen > 0) {
            if (isRecordOrArray(input)) {
              for (let i$14 = 0; i$14 < ownKeysLen; i$14++) {
                let name = ownKeys$1[i$14], buckets = searchTree.keys[name].buckets
                if (Object.prototype.hasOwnProperty.call(input, name)) {
                  let literal = String(input[name])
                  if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                    candidates = candidates.concat(buckets[literal])
                  } else {
                    let { candidates: candidates$1, literals } = searchTree.keys[name],
                      literalsUnion = Union$1.make(literals),
                      errorAst = candidates$1.length === astTypesLen
                        ? new TypeLiteral([new PropertySignature(name, literalsUnion, !1, !0)], [])
                        : Union$1.make(candidates$1)
                    es.push([
                      stepKey++,
                      new Composite(errorAst, input, new Pointer(name, input, new Type$1(literalsUnion, input[name]))),
                    ])
                  }
                } else {
                  let { candidates: candidates$1, literals } = searchTree.keys[name],
                    fakePropertySignature = new PropertySignature(name, Union$1.make(literals), !1, !0),
                    errorAst = candidates$1.length === astTypesLen
                      ? new TypeLiteral([fakePropertySignature], [])
                      : Union$1.make(candidates$1)
                  es.push([
                    stepKey++,
                    new Composite(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature))),
                  ])
                }
              }
            } else {
              let errorAst = searchTree.candidates.length === astTypesLen ? ast : Union$1.make(searchTree.candidates)
              es.push([stepKey++, new Type$1(errorAst, input)])
            }
          }
          searchTree.otherwise.length > 0 && (candidates = candidates.concat(searchTree.otherwise))
          let queue
          for (let i$14 = 0; i$14 < candidates.length; i$14++) {
            let candidate = candidates[i$14], pr = map$20.get(candidate)(input, options$2)
            if (isEither(pr) && (!queue || queue.length === 0)) {
              if (isRight(pr)) return pr
              es.push([stepKey++, pr.left])
            } else {
              let nk = stepKey++
              queue ||= [],
                queue.push(state =>
                  suspend$1(() =>
                    `finalResult` in state
                      ? _void
                      : flatMap$1(
                        either$2(pr),
                        t$18 => (isRight(t$18) ? state.finalResult = t$18 : state.es.push([nk, t$18.left]), _void),
                      )
                  )
                )
            }
          }
          let computeResult = es$1 =>
            isNonEmptyArray(es$1)
              ? es$1.length === 1 && es$1[0][1]._tag === `Type`
                ? left(es$1[0][1])
                : left(new Composite(ast, input, sortByIndex(es$1)))
              : left(new Type$1(ast, input))
          if (queue && queue.length > 0) {
            let cqueue = queue
            return suspend$1(() => {
              let state = { es: copy$1(es) }
              return flatMap$1(
                forEach(cqueue, f$14 => f$14(state), { concurrency, batching, discard: !0 }),
                () => `finalResult` in state ? state.finalResult : computeResult(state.es),
              )
            })
          }
          return computeResult(es)
        }
      }
      case `Suspend`: {
        let get$12 = memoizeThunk(() => goMemo(annotations$1(ast.f(), ast.annotations), isDecoding))
        return (a$22, options$2) => get$12()(a$22, options$2)
      }
    }
  },
  fromRefinement = (ast, refinement) => u$7 => refinement(u$7) ? right(u$7) : left(new Type$1(ast, u$7)),
  getLiterals = (ast, isDecoding) => {
    switch (ast._tag) {
      case `Declaration`: {
        let annotation = getSurrogateAnnotation(ast)
        if (isSome(annotation)) return getLiterals(annotation.value, isDecoding)
        break
      }
      case `TypeLiteral`: {
        let out = []
        for (let i$14 = 0; i$14 < ast.propertySignatures.length; i$14++) {
          let propertySignature$1 = ast.propertySignatures[i$14],
            type$2 = isDecoding ? encodedAST(propertySignature$1.type) : typeAST(propertySignature$1.type)
          isLiteral(type$2) && !propertySignature$1.isOptional && out.push([propertySignature$1.name, type$2])
        }
        return out
      }
      case `TupleType`: {
        let out = []
        for (let i$14 = 0; i$14 < ast.elements.length; i$14++) {
          let element$2 = ast.elements[i$14], type$2 = isDecoding ? encodedAST(element$2.type) : typeAST(element$2.type)
          isLiteral(type$2) && !element$2.isOptional && out.push([i$14, type$2])
        }
        return out
      }
      case `Refinement`:
        return getLiterals(ast.from, isDecoding)
      case `Suspend`:
        return getLiterals(ast.f(), isDecoding)
      case `Transformation`:
        return getLiterals(isDecoding ? ast.from : ast.to, isDecoding)
    }
    return []
  },
  getSearchTree = (members, isDecoding) => {
    let keys$6 = {}, otherwise = [], candidates = []
    for (let i$14 = 0; i$14 < members.length; i$14++) {
      let member = members[i$14], tags$2 = getLiterals(member, isDecoding)
      if (tags$2.length > 0) {
        candidates.push(member)
        for (let j$1 = 0; j$1 < tags$2.length; j$1++) {
          let [key$1, literal] = tags$2[j$1], hash$1 = String(literal.literal)
          keys$6[key$1] = keys$6[key$1] || { buckets: {}, literals: [], candidates: [] }
          let buckets = keys$6[key$1].buckets
          if (Object.prototype.hasOwnProperty.call(buckets, hash$1)) {
            if (j$1 < tags$2.length - 1) continue
            buckets[hash$1].push(member), keys$6[key$1].literals.push(literal), keys$6[key$1].candidates.push(member)
          } else {
            buckets[hash$1] = [member], keys$6[key$1].literals.push(literal), keys$6[key$1].candidates.push(member)
            break
          }
        }
      } else otherwise.push(member)
    }
    return { keys: keys$6, otherwise, candidates }
  },
  dropRightRefinement = ast => isRefinement$1(ast) ? dropRightRefinement(ast.from) : ast,
  handleForbidden = (effect, ast, actual, options$2) => {
    if (options$2?.isEffectAllowed === !0 || isEither(effect)) return effect
    let scheduler = new SyncScheduler(), fiber = runFork(effect, { scheduler })
    scheduler.flush()
    let exit$5 = fiber.unsafePoll()
    if (exit$5) {
      if (isSuccess$2(exit$5)) return right(exit$5.value)
      let cause$2 = exit$5.cause
      return isFailType(cause$2) ? left(cause$2.error) : left(new Forbidden(ast, actual, pretty$1(cause$2)))
    }
    return left(
      new Forbidden(
        ast,
        actual,
        `cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work`,
      ),
    )
  },
  compare = ([a$22], [b$3]) => a$22 > b$3 ? 1 : a$22 < b$3 ? -1 : 0
function sortByIndex(es) {
  return es.sort(compare).map(t$18 => t$18[1])
}
const getFinalTransformation = (transformation, isDecoding) => {
    switch (transformation._tag) {
      case `FinalTransformation`:
        return isDecoding ? transformation.decode : transformation.encode
      case `ComposeTransformation`:
        return right
      case `TypeLiteralTransformation`:
        return input => {
          let out = right(input)
          for (let pst of transformation.propertySignatureTransformations) {
            let [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from],
              transformation$1 = isDecoding ? pst.decode : pst.encode,
              f$14 = input$1 => {
                let o$18 = transformation$1(
                  Object.prototype.hasOwnProperty.call(input$1, from) ? some$4(input$1[from]) : none$7(),
                )
                return delete input$1[from], isSome(o$18) && (input$1[to] = o$18.value), input$1
              }
            out = map$2(out, f$14)
          }
          return out
        }
    }
  },
  makeTree = (value$2, forest = []) => ({ value: value$2, forest }),
  TreeFormatter = {
    formatIssue: issue => map$2(formatTree(issue), drawTree),
    formatIssueSync: issue => {
      let e$26 = TreeFormatter.formatIssue(issue)
      return isEither(e$26) ? getOrThrow$1(e$26) : runSync(e$26)
    },
    formatError: error => TreeFormatter.formatIssue(error.issue),
    formatErrorSync: error => TreeFormatter.formatIssueSync(error.issue),
  },
  drawTree = tree =>
    tree.value + draw(
      `
`,
      tree.forest,
    ),
  draw = (indentation, forest) => {
    let r$26 = ``, len = forest.length, tree
    for (let i$14 = 0; i$14 < len; i$14++) {
      tree = forest[i$14]
      let isLast = i$14 === len - 1
      r$26 += indentation + (isLast ? `` : ``) + ` ` + tree.value,
        r$26 += draw(indentation + (len > 1 && !isLast ? `  ` : `   `), tree.forest)
    }
    return r$26
  },
  formatTransformationKind = kind => {
    switch (kind) {
      case `Encoded`:
        return `Encoded side transformation failure`
      case `Transformation`:
        return `Transformation process failure`
      case `Type`:
        return `Type side transformation failure`
    }
  },
  formatRefinementKind = kind => {
    switch (kind) {
      case `From`:
        return `From side refinement failure`
      case `Predicate`:
        return `Predicate refinement failure`
    }
  },
  getAnnotated = issue => `ast` in issue ? some$4(issue.ast) : none$7(),
  Either_void = right(void 0),
  getCurrentMessage = issue =>
    getAnnotated(issue).pipe(
      flatMap$12(getMessageAnnotation),
      match$11({
        onNone: () => Either_void,
        onSome: messageAnnotation => {
          let union$9 = messageAnnotation(issue)
          return isString$1(union$9)
            ? right({ message: union$9, override: !1 })
            : isEffect(union$9)
            ? map$3(union$9, message => ({ message, override: !1 }))
            : isString$1(union$9.message)
            ? right({ message: union$9.message, override: union$9.override })
            : map$3(union$9.message, message => ({ message, override: union$9.override }))
        },
      }),
    ),
  createParseIssueGuard = tag$3 => issue => issue._tag === tag$3,
  isComposite = createParseIssueGuard(`Composite`),
  isRefinement = createParseIssueGuard(`Refinement`),
  isTransformation = createParseIssueGuard(`Transformation`),
  getMessage = issue =>
    flatMap(getCurrentMessage(issue), currentMessage => {
      if (currentMessage !== void 0) {
        let useInnerMessage = !currentMessage.override
          && (isComposite(issue) || isRefinement(issue) && issue.kind === `From`
            || isTransformation(issue) && issue.kind !== `Transformation`)
        return useInnerMessage
          ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Either_void
          : right(currentMessage.message)
      }
      return Either_void
    }),
  getParseIssueTitleAnnotation = issue =>
    getAnnotated(issue).pipe(
      flatMap$12(getParseIssueTitleAnnotation$1),
      flatMapNullable(annotation => annotation(issue)),
      getOrUndefined,
    )
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(
    orElse$7(() => getTitleAnnotation(ast)),
    orElse$7(() => getAutoTitleAnnotation(ast)),
    orElse$7(() => getIdentifierAnnotation(ast)),
    getOrElse$5(() => `{ ${ast.from} | filter }`),
  )
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) return issue.message
  let expected = isRefinement$1(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast)
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`
}
const formatTypeMessage = issue =>
    map$2(getMessage(issue), message => message ?? getParseIssueTitleAnnotation(issue) ?? getDefaultTypeMessage(issue)),
  getParseIssueTitle = issue => getParseIssueTitleAnnotation(issue) ?? String(issue.ast),
  formatForbiddenMessage = issue => issue.message ?? `is forbidden`,
  formatUnexpectedMessage = issue => issue.message ?? `is unexpected`,
  formatMissingMessage = issue => {
    let missingMessageAnnotation = getMissingMessageAnnotation(issue.ast)
    if (isSome(missingMessageAnnotation)) {
      let annotation = missingMessageAnnotation.value()
      return isString$1(annotation) ? right(annotation) : annotation
    }
    return right(issue.message ?? `is missing`)
  },
  formatTree = issue => {
    switch (issue._tag) {
      case `Type`:
        return map$2(formatTypeMessage(issue), makeTree)
      case `Forbidden`:
        return right(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]))
      case `Unexpected`:
        return right(makeTree(formatUnexpectedMessage(issue)))
      case `Missing`:
        return map$2(formatMissingMessage(issue), makeTree)
      case `Transformation`:
        return flatMap(
          getMessage(issue),
          message =>
            message === void 0
              ? map$2(formatTree(issue.issue), tree =>
                makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]))
              : right(makeTree(message)),
        )
      case `Refinement`:
        return flatMap(
          getMessage(issue),
          message =>
            message === void 0
              ? map$2(formatTree(issue.issue), tree =>
                makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]))
              : right(makeTree(message)),
        )
      case `Pointer`:
        return map$2(formatTree(issue.issue), tree => makeTree(formatPath(issue.path), [tree]))
      case `Composite`:
        return flatMap(getMessage(issue), message => {
          if (message !== void 0) return right(makeTree(message))
          let parseIssueTitle = getParseIssueTitle(issue)
          return isNonEmpty$5(issue.issues)
            ? map$2(forEach(issue.issues, formatTree), forest => makeTree(parseIssueTitle, forest))
            : map$2(formatTree(issue.issues), tree => makeTree(parseIssueTitle, [tree]))
        })
    }
  },
  TypeId$1 = Symbol.for(`@effect/matcher/Matcher`),
  TypeMatcherProto = {
    [TypeId$1]: { _input: identity, _filters: identity, _remaining: identity, _result: identity, _return: identity },
    _tag: `TypeMatcher`,
    add(_case) {
      return makeTypeMatcher([...this.cases, _case])
    },
    pipe() {
      return pipeArguments(this, arguments)
    },
  }
function makeTypeMatcher(cases) {
  let matcher = Object.create(TypeMatcherProto)
  return matcher.cases = cases, matcher
}
const ValueMatcherProto = {
  [TypeId$1]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity,
  },
  _tag: `ValueMatcher`,
  add(_case) {
    return this.value._tag === `Right`
      ? this
      : _case._tag === `When` && _case.guard(this.provided) === !0
          || _case._tag === `Not` && _case.guard(this.provided) === !1
      ? makeValueMatcher(this.provided, right(_case.evaluate(this.provided)))
      : this
  },
  pipe() {
    return pipeArguments(this, arguments)
  },
}
function makeValueMatcher(provided, value$2) {
  let matcher = Object.create(ValueMatcherProto)
  return matcher.provided = provided, matcher.value = value$2, matcher
}
const makeWhen = (guard, evaluate$2) => ({ _tag: `When`, guard, evaluate: evaluate$2 }),
  makeNot = (guard, evaluate$2) => ({ _tag: `Not`, guard, evaluate: evaluate$2 }),
  makePredicate = pattern$1 => {
    if (typeof pattern$1 == `function`) return pattern$1
    if (Array.isArray(pattern$1)) {
      let predicates = pattern$1.map(makePredicate), len = predicates.length
      return u$7 => {
        if (!Array.isArray(u$7)) return !1
        for (let i$14 = 0; i$14 < len; i$14++) if (predicates[i$14](u$7[i$14]) === !1) return !1
        return !0
      }
    } else if (typeof pattern$1 == `object` && pattern$1) {
      let keysAndPredicates = Object.entries(pattern$1).map(([k$1, p$25]) => [k$1, makePredicate(p$25)]),
        len = keysAndPredicates.length
      return u$7 => {
        if (typeof u$7 != `object` || !u$7) return !1
        for (let i$14 = 0; i$14 < len; i$14++) {
          let [key$1, predicate] = keysAndPredicates[i$14]
          if (!(key$1 in u$7) || predicate(u$7[key$1]) === !1) return !1
        }
        return !0
      }
    }
    return u$7 => u$7 === pattern$1
  },
  makeOrPredicate = patterns => {
    let predicates = patterns.map(makePredicate), len = predicates.length
    return u$7 => {
      for (let i$14 = 0; i$14 < len; i$14++) if (predicates[i$14](u$7) === !0) return !0
      return !1
    }
  },
  makeAndPredicate = patterns => {
    let predicates = patterns.map(makePredicate), len = predicates.length
    return u$7 => {
      for (let i$14 = 0; i$14 < len; i$14++) if (predicates[i$14](u$7) === !1) return !1
      return !0
    }
  },
  type$1 = () => makeTypeMatcher([]),
  value$1 = i$14 => makeValueMatcher(i$14, left(i$14)),
  valueTags$1 = dual(2, (input, fields) => {
    let match$13 = tagsExhaustive$1(fields)(makeTypeMatcher([]))
    return match$13(input)
  }),
  typeTags$1 = () => fields => {
    let match$13 = tagsExhaustive$1(fields)(makeTypeMatcher([]))
    return input => match$13(input)
  },
  withReturnType$1 = () => self$1 => self$1,
  when$1 = (pattern$1, f$14) => self$1 => self$1.add(makeWhen(makePredicate(pattern$1), f$14)),
  whenOr$1 = (...args$1) => self$1 => {
    let onMatch = args$1[args$1.length - 1], patterns = args$1.slice(0, -1)
    return self$1.add(makeWhen(makeOrPredicate(patterns), onMatch))
  },
  whenAnd$1 = (...args$1) => self$1 => {
    let onMatch = args$1[args$1.length - 1], patterns = args$1.slice(0, -1)
    return self$1.add(makeWhen(makeAndPredicate(patterns), onMatch))
  },
  discriminator$1 = field => (...pattern$1) => {
    let f$14 = pattern$1[pattern$1.length - 1],
      values$6 = pattern$1.slice(0, -1),
      pred = values$6.length === 1 ? _$1 => _$1[field] === values$6[0] : _$1 => values$6.includes(_$1[field])
    return self$1 => self$1.add(makeWhen(pred, f$14))
  },
  discriminatorStartsWith$1 = field => (pattern$1, f$14) => {
    let pred = _$1 => typeof _$1[field] == `string` && _$1[field].startsWith(pattern$1)
    return self$1 => self$1.add(makeWhen(pred, f$14))
  },
  discriminators$1 = field => fields => {
    let predicate = makeWhen(arg => arg != null && arg[field] in fields, data => fields[data[field]](data))
    return self$1 => self$1.add(predicate)
  },
  discriminatorsExhaustive$1 = field => fields => {
    let addCases = discriminators$1(field)(fields)
    return matcher => exhaustive$1(addCases(matcher))
  },
  tag$2 = discriminator$1(`_tag`),
  tagStartsWith$1 = discriminatorStartsWith$1(`_tag`),
  tags$1 = discriminators$1(`_tag`),
  tagsExhaustive$1 = discriminatorsExhaustive$1(`_tag`),
  not$1 = (pattern$1, f$14) => self$1 => self$1.add(makeNot(makePredicate(pattern$1), f$14)),
  nonEmptyString$1 = u$7 => typeof u$7 == `string` && u$7.length > 0,
  is$27 = (...literals) => {
    let len = literals.length
    return u$7 => {
      for (let i$14 = 0; i$14 < len; i$14++) if (u$7 === literals[i$14]) return !0
      return !1
    }
  },
  any$1 = () => !0,
  defined$1 = u$7 => u$7 != null,
  instanceOf$3 = constructor => u$7 => u$7 instanceof constructor,
  orElse$1 = f$14 => self$1 => {
    let result = either$1(self$1)
    return isEither$1(result) ? result._tag === `Right` ? result.right : f$14(result.left) : input => {
      let a$22 = result(input)
      return a$22._tag === `Right` ? a$22.right : f$14(a$22.left)
    }
  },
  orElseAbsurd$1 = self$1 =>
    orElse$1(() => {
      throw Error(`effect/Match/orElseAbsurd: absurd`)
    })(self$1),
  either$1 = self$1 => {
    if (self$1._tag === `ValueMatcher`) return self$1.value
    let len = self$1.cases.length
    if (len === 1) {
      let _case = self$1.cases[0]
      return input =>
        _case._tag === `When` && _case.guard(input) === !0 || _case._tag === `Not` && _case.guard(input) === !1
          ? right(_case.evaluate(input))
          : left(input)
    }
    return input => {
      for (let i$14 = 0; i$14 < len; i$14++) {
        let _case = self$1.cases[i$14]
        if (_case._tag === `When` && _case.guard(input) === !0 || _case._tag === `Not` && _case.guard(input) === !1) {
          return right(_case.evaluate(input))
        }
      }
      return left(input)
    }
  },
  option$2 = self$1 => {
    let toEither = either$1(self$1)
    return isEither$1(toEither)
      ? match$12(toEither, { onLeft: () => none$7(), onRight: some$4 })
      : input => match$12(toEither(input), { onLeft: () => none$7(), onRight: some$4 })
  },
  getExhaustiveAbsurdErrorMessage = `effect/Match/exhaustive: absurd`,
  exhaustive$1 = self$1 => {
    let toEither = either$1(self$1)
    if (isEither$1(toEither)) {
      if (toEither._tag === `Right`) return toEither.right
      throw Error(getExhaustiveAbsurdErrorMessage)
    }
    return u$7 => {
      let result = toEither(u$7)
      if (result._tag === `Right`) return result.right
      throw Error(getExhaustiveAbsurdErrorMessage)
    }
  },
  MatcherTypeId = TypeId$1,
  type = type$1,
  value = value$1,
  valueTags = valueTags$1,
  typeTags = typeTags$1,
  withReturnType = withReturnType$1,
  when = when$1,
  whenOr = whenOr$1,
  whenAnd = whenAnd$1,
  discriminator = discriminator$1,
  discriminatorStartsWith = discriminatorStartsWith$1,
  discriminators = discriminators$1,
  discriminatorsExhaustive = discriminatorsExhaustive$1,
  tag$1 = tag$2,
  tagStartsWith = tagStartsWith$1,
  tags = tags$1,
  tagsExhaustive = tagsExhaustive$1,
  not = not$1,
  nonEmptyString = nonEmptyString$1,
  is$26 = is$27,
  string$2 = isString$1,
  number$1 = isNumber$1,
  any = any$1,
  defined = defined$1,
  boolean$1 = isBoolean$2,
  _undefined = isUndefined,
  _null = isNull,
  bigint = isBigInt,
  symbol = isSymbol,
  date = isDate,
  record = isRecord$1,
  instanceOf$2 = instanceOf$3,
  instanceOfUnsafe = instanceOf$3,
  orElse = orElse$1,
  orElseAbsurd = orElseAbsurd$1,
  either = either$1,
  option$1 = option$2,
  exhaustive = exhaustive$1,
  pick = dual(args$1 => isObject$4(args$1[0]), (s$14, ...keys$6) => {
    let out = {}
    for (let k$1 of keys$6) k$1 in s$14 && (out[k$1] = s$14[k$1])
    return out
  }),
  omit = dual(args$1 => isObject$4(args$1[0]), (s$14, ...keys$6) => {
    let out = { ...s$14 }
    for (let k$1 of keys$6) delete out[k$1]
    return out
  }),
  getEquivalence = struct$3,
  getOrder = struct$2,
  TypeId = Symbol.for(`effect/Schema`)
function make$17(ast) {
  return class {
    [TypeId] = variance
    static ast = ast
    static annotations(annotations$2) {
      return make$17(mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static pipe() {
      return pipeArguments(this, arguments)
    }
    static toString() {
      return String(ast)
    }
    static Type
    static Encoded
    static Context
    static [TypeId] = variance
  }
}
const variance = { _A: _$1 => _$1, _I: _$1 => _$1, _R: _$1 => _$1 },
  builtInAnnotations = {
    schemaId: SchemaIdAnnotationId,
    message: MessageAnnotationId,
    missingMessage: MissingMessageAnnotationId,
    identifier: IdentifierAnnotationId,
    title: TitleAnnotationId,
    description: DescriptionAnnotationId,
    examples: ExamplesAnnotationId,
    default: DefaultAnnotationId,
    documentation: DocumentationAnnotationId,
    jsonSchema: JSONSchemaAnnotationId,
    arbitrary: ArbitraryAnnotationId,
    pretty: PrettyAnnotationId,
    equivalence: EquivalenceAnnotationId,
    concurrency: ConcurrencyAnnotationId,
    batching: BatchingAnnotationId,
    parseIssueTitle: ParseIssueTitleAnnotationId,
    parseOptions: ParseOptionsAnnotationId,
    decodingFallback: DecodingFallbackAnnotationId,
  },
  toASTAnnotations = annotations$2 => {
    if (!annotations$2) return {}
    let out = { ...annotations$2 }
    for (let key$1 in builtInAnnotations) {
      if (key$1 in annotations$2) {
        let id$2 = builtInAnnotations[key$1]
        out[id$2] = annotations$2[key$1], delete out[key$1]
      }
    }
    return out
  },
  mergeSchemaAnnotations = (ast, annotations$2) => annotations$1(ast, toASTAnnotations(annotations$2))
function asSchema(schema) {
  return schema
}
const format = schema => String(schema.ast),
  encodedSchema = schema => make$17(encodedAST(schema.ast)),
  typeSchema = schema => make$17(typeAST(schema.ast)),
  encodeUnknown = (schema, options$2) => {
    let encodeUnknown$2 = encodeUnknown$1(schema, options$2)
    return (u$7, overrideOptions) => mapError(encodeUnknown$2(u$7, overrideOptions), parseError)
  },
  encode$25 = encodeUnknown,
  decodeUnknown = (schema, options$2) => {
    let decodeUnknown$2 = decodeUnknown$1(schema, options$2)
    return (u$7, overrideOptions) => mapError(decodeUnknown$2(u$7, overrideOptions), parseError)
  },
  decode$26 = decodeUnknown,
  isSchema = u$7 => hasProperty(u$7, TypeId) && isObject$4(u$7[TypeId])
function getDefaultLiteralAST(literals) {
  return isMembers(literals)
    ? Union$1.make(mapMembers(literals, literal => new Literal$1(literal)))
    : new Literal$1(literals[0])
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static literals = [...literals]
  }
}
function Literal(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never
}
const getDefaultEnumsAST = enums =>
    new Enums$1(
      Object.keys(enums).filter(key$1 => typeof enums[enums[key$1]] != `number`).map(key$1 => [key$1, enums[key$1]]),
    ),
  makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) =>
    class extends make$17(ast) {
      static annotations(annotations$2) {
        return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations$2))
      }
      static enums = { ...enums }
    },
  Enums = enums => makeEnumsClass(enums),
  declareConstructor = (typeParameters, options$2, annotations$2) =>
    makeDeclareClass(
      typeParameters,
      new Declaration(typeParameters.map(tp => tp.ast), (...typeParameters$1) =>
        options$2.decode(...typeParameters$1.map(make$17)), (...typeParameters$1) =>
        options$2.encode(...typeParameters$1.map(make$17)), toASTAnnotations(annotations$2)),
    ),
  declarePrimitive = (is$29, annotations$2) => {
    let decodeUnknown$2 = () => (input, _$1, ast) => is$29(input) ? succeed(input) : fail(new Type$1(ast, input)),
      encodeUnknown$2 = decodeUnknown$2
    return makeDeclareClass([], new Declaration([], decodeUnknown$2, encodeUnknown$2, toASTAnnotations(annotations$2)))
  }
function makeDeclareClass(typeParameters, ast) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static typeParameters = [...typeParameters]
  }
}
const declare = function() {
    if (Array.isArray(arguments[0])) {
      let typeParameters = arguments[0], options$2 = arguments[1], annotations$3 = arguments[2]
      return declareConstructor(typeParameters, options$2, annotations$3)
    }
    let is$29 = arguments[0], annotations$2 = arguments[1]
    return declarePrimitive(is$29, annotations$2)
  },
  InstanceOfSchemaId = Symbol.for(`effect/SchemaId/InstanceOf`),
  instanceOf$1 = (constructor, annotations$2) =>
    declare(u$7 => u$7 instanceof constructor, {
      title: constructor.name,
      description: `an instance of ${constructor.name}`,
      pretty: () => String,
      schemaId: InstanceOfSchemaId,
      [InstanceOfSchemaId]: { constructor },
      ...annotations$2,
    })
var Undefined = class extends make$17(undefinedKeyword) {},
  Null = class extends make$17($null) {},
  Never = class extends make$17(neverKeyword) {},
  Unknown = class extends make$17(unknownKeyword) {},
  Any = class extends make$17(anyKeyword) {},
  String$ = class extends make$17(stringKeyword) {},
  Number$ = class extends make$17(numberKeyword) {},
  Boolean$ = class extends make$17(booleanKeyword) {}
const getDefaultUnionAST = members => Union$1.make(members.map(m$12 => m$12.ast))
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static members = [...members]
  }
}
function Union(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never
}
const NullOr = self$1 => Union(self$1, Null), UndefinedOr = self$1 => Union(self$1, Undefined)
var ElementImpl = class ElementImpl {
  ast
  from;
  [TypeId]
  _Token
  constructor(ast, from) {
    this.ast = ast, this.from = from
  }
  annotations(annotations$2) {
    return new ElementImpl(
      new OptionalType(this.ast.type, this.ast.isOptional, {
        ...this.ast.annotations,
        ...toASTAnnotations(annotations$2),
      }),
      this.from,
    )
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? `?` : ``}`
  }
}
const getDefaultTupleTypeAST = (elements, rest) =>
  new TupleType(
    elements.map(el => isSchema(el) ? new OptionalType(el.ast, !1) : el.ast),
    rest.map(el => isSchema(el) ? new Type$2(el.ast) : el.ast),
    !0,
  )
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static elements = [...elements]
    static rest = [...rest]
  }
}
function Tuple(...args$1) {
  return Array.isArray(args$1[0]) ? makeTupleTypeClass(args$1[0], args$1.slice(1)) : makeTupleTypeClass(args$1, [])
}
function makeArrayClass(value$2, ast) {
  return class extends makeTupleTypeClass([], [value$2], ast) {
    static annotations(annotations$2) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static value = value$2
  }
}
const Array$ = value$2 => makeArrayClass(value$2)
function makeNonEmptyArrayClass(value$2, ast) {
  return class extends makeTupleTypeClass([value$2], [value$2], ast) {
    static annotations(annotations$2) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static value = value$2
  }
}
const NonEmptyArray = value$2 => makeNonEmptyArrayClass(value$2),
  formatPropertySignatureToken = isOptional => isOptional ? `"?:"` : `":"`
var PropertySignatureDeclaration = class extends OptionalType {
    isReadonly
    defaultValue
    _tag = `PropertySignatureDeclaration`
    constructor(type$2, isOptional, isReadonly, annotations$2, defaultValue) {
      super(type$2, isOptional, annotations$2), this.isReadonly = isReadonly, this.defaultValue = defaultValue
    }
    toString() {
      let token = formatPropertySignatureToken(this.isOptional), type$2 = String(this.type)
      return `PropertySignature<${token}, ${type$2}, never, ${token}, ${type$2}>`
    }
  },
  ToPropertySignature = class extends OptionalType {
    isReadonly
    defaultValue
    constructor(type$2, isOptional, isReadonly, annotations$2, defaultValue) {
      super(type$2, isOptional, annotations$2), this.isReadonly = isReadonly, this.defaultValue = defaultValue
    }
  }
const formatPropertyKey = p$25 => p$25 === void 0 ? `never` : isString$1(p$25) ? JSON.stringify(p$25) : String(p$25)
var PropertySignatureTransformation = class {
  from
  to
  decode
  encode
  _tag = `PropertySignatureTransformation`
  constructor(from, to, decode$31, encode$29) {
    this.from = from, this.to = to, this.decode = decode$31, this.encode = encode$29
  }
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${
      formatPropertyKey(this.from.fromKey)
    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`
  }
}
const mergeSignatureAnnotations = (ast, annotations$2) => {
    switch (ast._tag) {
      case `PropertySignatureDeclaration`:
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations$2,
        }, ast.defaultValue)
      case `PropertySignatureTransformation`:
        return new PropertySignatureTransformation(
          ast.from,
          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
            ...ast.to.annotations,
            ...annotations$2,
          }, ast.to.defaultValue),
          ast.decode,
          ast.encode,
        )
    }
  },
  PropertySignatureTypeId = Symbol.for(`effect/PropertySignature`),
  isPropertySignature = u$7 => hasProperty(u$7, PropertySignatureTypeId)
var PropertySignatureImpl = class PropertySignatureImpl {
  ast;
  [TypeId];
  [PropertySignatureTypeId] = null
  _TypeToken
  _Key
  _EncodedToken
  _HasDefault
  constructor(ast) {
    this.ast = ast
  }
  pipe() {
    return pipeArguments(this, arguments)
  }
  annotations(annotations$2) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations$2)))
  }
  toString() {
    return String(this.ast)
  }
}
const makePropertySignature = ast => new PropertySignatureImpl(ast)
var PropertySignatureWithFromImpl = class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from
  constructor(ast, from) {
    super(ast), this.from = from
  }
  annotations(annotations$2) {
    return new PropertySignatureWithFromImpl(
      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations$2)),
      this.from,
    )
  }
}
const propertySignature = self$1 =>
    new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self$1.ast, !1, !0, {}, void 0), self$1),
  withConstructorDefault = dual(2, (self$1, defaultValue) => {
    let ast = self$1.ast
    switch (ast._tag) {
      case `PropertySignatureDeclaration`:
        return makePropertySignature(
          new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue),
        )
      case `PropertySignatureTransformation`:
        return makePropertySignature(
          new PropertySignatureTransformation(
            ast.from,
            new ToPropertySignature(
              ast.to.type,
              ast.to.isOptional,
              ast.to.isReadonly,
              ast.to.annotations,
              defaultValue,
            ),
            ast.decode,
            ast.encode,
          ),
        )
    }
  }),
  optional = self$1 => {
    let ast = self$1.ast === undefinedKeyword || self$1.ast === neverKeyword
      ? undefinedKeyword
      : UndefinedOr(self$1).ast
    return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, !0, !0, {}, void 0), self$1)
  },
  preserveMissingMessageAnnotation = pickAnnotations([MissingMessageAnnotationId]),
  getDefaultTypeLiteralAST = (fields, records) => {
    let ownKeys$1 = ownKeys(fields), pss = []
    if (ownKeys$1.length > 0) {
      let from = [], to = [], transformations = []
      for (let i$14 = 0; i$14 < ownKeys$1.length; i$14++) {
        let key$1 = ownKeys$1[i$14], field = fields[key$1]
        if (isPropertySignature(field)) {
          let ast = field.ast
          switch (ast._tag) {
            case `PropertySignatureDeclaration`: {
              let type$2 = ast.type, isOptional = ast.isOptional, toAnnotations = ast.annotations
              from.push(new PropertySignature(key$1, type$2, isOptional, !0, preserveMissingMessageAnnotation(ast))),
                to.push(new PropertySignature(key$1, typeAST(type$2), isOptional, !0, toAnnotations)),
                pss.push(new PropertySignature(key$1, type$2, isOptional, !0, toAnnotations))
              break
            }
            case `PropertySignatureTransformation`: {
              let fromKey = ast.from.fromKey ?? key$1
              from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, !0, ast.from.annotations)),
                to.push(new PropertySignature(key$1, ast.to.type, ast.to.isOptional, !0, ast.to.annotations)),
                transformations.push(new PropertySignatureTransformation$1(fromKey, key$1, ast.decode, ast.encode))
              break
            }
          }
        } else {from.push(new PropertySignature(key$1, field.ast, !1, !0)),
            to.push(new PropertySignature(key$1, typeAST(field.ast), !1, !0)),
            pss.push(new PropertySignature(key$1, field.ast, !1, !0))}
      }
      if (isNonEmptyReadonlyArray(transformations)) {
        let issFrom = [], issTo = []
        for (let r$26 of records) {
          let { indexSignatures, propertySignatures } = record$1(r$26.key.ast, r$26.value.ast)
          propertySignatures.forEach(ps => {
            from.push(ps),
              to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations))
          }),
            indexSignatures.forEach(is$29 => {
              issFrom.push(is$29),
                issTo.push(new IndexSignature(is$29.parameter, typeAST(is$29.type), is$29.isReadonly))
            })
        }
        return new Transformation$1(
          new TypeLiteral(from, issFrom, { [AutoTitleAnnotationId]: `Struct (Encoded side)` }),
          new TypeLiteral(to, issTo, { [AutoTitleAnnotationId]: `Struct (Type side)` }),
          new TypeLiteralTransformation(transformations),
        )
      }
    }
    let iss = []
    for (let r$26 of records) {
      let { indexSignatures, propertySignatures } = record$1(r$26.key.ast, r$26.value.ast)
      propertySignatures.forEach(ps => pss.push(ps)), indexSignatures.forEach(is$29 => iss.push(is$29))
    }
    return new TypeLiteral(pss, iss)
  },
  lazilyMergeDefaults = (fields, out) => {
    let ownKeys$1 = ownKeys(fields)
    for (let key$1 of ownKeys$1) {
      let field = fields[key$1]
      if (out[key$1] === void 0 && isPropertySignature(field)) {
        let ast = field.ast,
          defaultValue = ast._tag === `PropertySignatureDeclaration` ? ast.defaultValue : ast.to.defaultValue
        defaultValue !== void 0 && (out[key$1] = defaultValue())
      }
    }
    return out
  }
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static fields = { ...fields }
    static records = [...records]
    static make = (props, options$2) => {
      let propsWithDefaults = lazilyMergeDefaults(fields, { ...props })
      return getDisableValidationMakeOption(options$2) ? propsWithDefaults : validateSync(this)(propsWithDefaults)
    }
    static pick(...keys$6) {
      return Struct(pick(fields, ...keys$6))
    }
    static omit(...keys$6) {
      return Struct(omit(fields, ...keys$6))
    }
  }
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records)
}
const tag = tag$3 => Literal(tag$3).pipe(propertySignature, withConstructorDefault(() => tag$3)),
  TaggedStruct = (value$2, fields) => Struct({ _tag: tag(value$2), ...fields })
function makeBrandClass(from, ast) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static make = (a$22, options$2) => getDisableValidationMakeOption(options$2) ? a$22 : validateSync(this)(a$22)
    static from = from
  }
}
const brand = (brand$1, annotations$2) => self$1 => {
    let annotation = match$11(getBrandAnnotation(self$1.ast), {
        onNone: () => [brand$1],
        onSome: brands => [...brands, brand$1],
      }),
      ast = annotations$1(self$1.ast, toASTAnnotations({ [BrandAnnotationId]: annotation, ...annotations$2 }))
    return makeBrandClass(self$1, ast)
  },
  mutable = schema => make$17(mutable$1(schema.ast)),
  intersectTypeLiterals = (x$2, y$3, path$1) => {
    if (isTypeLiteral(x$2) && isTypeLiteral(y$3)) {
      let propertySignatures = [...x$2.propertySignatures]
      for (let ps of y$3.propertySignatures) {
        let name = ps.name, i$14 = propertySignatures.findIndex(ps$1 => ps$1.name === name)
        if (i$14 === -1) propertySignatures.push(ps)
        else {
          let { isOptional, type: type$2 } = propertySignatures[i$14]
          propertySignatures[i$14] = new PropertySignature(
            name,
            extendAST(type$2, ps.type, path$1.concat(name)),
            isOptional,
            !0,
          )
        }
      }
      return new TypeLiteral(propertySignatures, x$2.indexSignatures.concat(y$3.indexSignatures))
    }
    throw Error(getSchemaExtendErrorMessage(x$2, y$3, path$1))
  },
  preserveRefinementAnnotations = omitAnnotations([IdentifierAnnotationId]),
  addRefinementToMembers = (refinement, asts) =>
    asts.map(ast => new Refinement$1(ast, refinement.filter, preserveRefinementAnnotations(refinement))),
  extendAST = (x$2, y$3, path$1) => Union$1.make(intersectUnionMembers([x$2], [y$3], path$1)),
  getTypes = ast => isUnion(ast) ? ast.types : [ast],
  intersectUnionMembers = (xs, ys, path$1) =>
    flatMap$11(xs, x$2 =>
      flatMap$11(ys, y$3 => {
        switch (y$3._tag) {
          case `Literal`:
            if (
              isString$1(y$3.literal) && isStringKeyword(x$2) || isNumber$1(y$3.literal) && isNumberKeyword(x$2)
              || isBoolean$2(y$3.literal) && isBooleanKeyword(x$2)
            ) return [y$3]
            break
          case `StringKeyword`:
            if (y$3 === stringKeyword) {
              if (isStringKeyword(x$2) || isLiteral(x$2) && isString$1(x$2.literal)) return [x$2]
              if (isRefinement$1(x$2)) {
                return addRefinementToMembers(x$2, intersectUnionMembers(getTypes(x$2.from), [y$3], path$1))
              }
            } else if (x$2 === stringKeyword) {
              return [y$3]
            }
            break
          case `NumberKeyword`:
            if (y$3 === numberKeyword) {
              if (isNumberKeyword(x$2) || isLiteral(x$2) && isNumber$1(x$2.literal)) return [x$2]
              if (isRefinement$1(x$2)) {
                return addRefinementToMembers(x$2, intersectUnionMembers(getTypes(x$2.from), [y$3], path$1))
              }
            } else if (x$2 === numberKeyword) {
              return [y$3]
            }
            break
          case `BooleanKeyword`:
            if (y$3 === booleanKeyword) {
              if (isBooleanKeyword(x$2) || isLiteral(x$2) && isBoolean$2(x$2.literal)) return [x$2]
              if (isRefinement$1(x$2)) {
                return addRefinementToMembers(x$2, intersectUnionMembers(getTypes(x$2.from), [y$3], path$1))
              }
            } else if (x$2 === booleanKeyword) return [y$3]
            break
          case `Union`:
            return intersectUnionMembers(getTypes(x$2), y$3.types, path$1)
          case `Suspend`:
            return [new Suspend(() => extendAST(x$2, y$3.f(), path$1))]
          case `Refinement`:
            return addRefinementToMembers(y$3, intersectUnionMembers(getTypes(x$2), getTypes(y$3.from), path$1))
          case `TypeLiteral`:
            switch (x$2._tag) {
              case `Union`:
                return intersectUnionMembers(x$2.types, [y$3], path$1)
              case `Suspend`:
                return [new Suspend(() => extendAST(x$2.f(), y$3, path$1))]
              case `Refinement`:
                return addRefinementToMembers(x$2, intersectUnionMembers(getTypes(x$2.from), [y$3], path$1))
              case `TypeLiteral`:
                return [intersectTypeLiterals(x$2, y$3, path$1)]
              case `Transformation`: {
                let transformation = x$2.transformation,
                  from = intersectTypeLiterals(x$2.from, y$3, path$1),
                  to = intersectTypeLiterals(x$2.to, typeAST(y$3), path$1)
                switch (transformation._tag) {
                  case `TypeLiteralTransformation`:
                    return [
                      new Transformation$1(
                        from,
                        to,
                        new TypeLiteralTransformation(transformation.propertySignatureTransformations),
                      ),
                    ]
                  case `ComposeTransformation`:
                    return [new Transformation$1(from, to, composeTransformation)]
                  case `FinalTransformation`:
                    return [
                      new Transformation$1(
                        from,
                        to,
                        new FinalTransformation(
                          (fromA, options$2, ast, fromI) =>
                            map$2(
                              transformation.decode(fromA, options$2, ast, fromI),
                              partial => ({ ...fromA, ...partial }),
                            ),
                          (toI, options$2, ast, toA) =>
                            map$2(transformation.encode(toI, options$2, ast, toA), partial => ({ ...toI, ...partial })),
                        ),
                      ),
                    ]
                }
              }
            }
            break
          case `Transformation`:
            if (isTransformation$1(x$2)) {
              if (isTypeLiteralTransformation(y$3.transformation) && isTypeLiteralTransformation(x$2.transformation)) {
                return [
                  new Transformation$1(
                    intersectTypeLiterals(x$2.from, y$3.from, path$1),
                    intersectTypeLiterals(x$2.to, y$3.to, path$1),
                    new TypeLiteralTransformation(
                      y$3.transformation.propertySignatureTransformations.concat(
                        x$2.transformation.propertySignatureTransformations,
                      ),
                    ),
                  ),
                ]
              }
            } else return intersectUnionMembers([y$3], [x$2], path$1)
            break
        }
        throw Error(getSchemaExtendErrorMessage(x$2, y$3, path$1))
      })),
  extend$1 = dual(2, (self$1, that) => make$17(extendAST(self$1.ast, that.ast, []))),
  compose = dual(
    args$1 => isSchema(args$1[1]),
    (from, to) => makeTransformationClass(from, to, compose$1(from.ast, to.ast)),
  ),
  suspend = f$14 => make$17(new Suspend(() => f$14().ast)),
  RefineSchemaId = Symbol.for(`effect/SchemaId/Refine`)
function makeRefineClass(from, filter$9, ast) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static [RefineSchemaId] = from
    static from = from
    static filter = filter$9
    static make = (a$22, options$2) => getDisableValidationMakeOption(options$2) ? a$22 : validateSync(this)(a$22)
  }
}
const fromFilterPredicateReturnTypeItem = (item, ast, input) => {
    if (isBoolean$2(item)) return item ? none$7() : some$4(new Type$1(ast, input))
    if (isString$1(item)) return some$4(new Type$1(ast, input, item))
    if (item !== void 0) {
      if (`_tag` in item) return some$4(item)
      let issue = new Type$1(ast, input, item.message)
      return some$4(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue)
    }
    return none$7()
  },
  toFilterParseIssue = (out, ast, input) => {
    if (isSingle$1(out)) return fromFilterPredicateReturnTypeItem(out, ast, input)
    if (isNonEmptyReadonlyArray(out)) {
      let issues = filterMap$4(out, issue => fromFilterPredicateReturnTypeItem(issue, ast, input))
      if (isNonEmptyReadonlyArray(issues)) {
        return some$4(issues.length === 1 ? issues[0] : new Composite(ast, input, issues))
      }
    }
    return none$7()
  }
function filter(predicate, annotations$2) {
  return self$1 => {
    function filter$9(input, options$2, ast$1) {
      return toFilterParseIssue(predicate(input, options$2, ast$1), ast$1, input)
    }
    let ast = new Refinement$1(self$1.ast, filter$9, toASTAnnotations(annotations$2))
    return makeRefineClass(self$1, filter$9, ast)
  }
}
function makeTransformationClass(from, to, ast) {
  return class extends make$17(ast) {
    static annotations(annotations$2) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations$2))
    }
    static from = from
    static to = to
  }
}
const transformOrFail = dual(
    args$1 => isSchema(args$1[0]) && isSchema(args$1[1]),
    (from, to, options$2) =>
      makeTransformationClass(
        from,
        to,
        new Transformation$1(from.ast, to.ast, new FinalTransformation(options$2.decode, options$2.encode)),
      ),
  ),
  transform = dual(
    args$1 => isSchema(args$1[0]) && isSchema(args$1[1]),
    (from, to, options$2) =>
      transformOrFail(from, to, {
        strict: !0,
        decode: (fromA, _options, _ast, toA) => succeed(options$2.decode(fromA, toA)),
        encode: (toI, _options, _ast, toA) => succeed(options$2.encode(toI, toA)),
      }),
  ),
  annotations = dual(2, (self$1, annotations$2) => self$1.annotations(annotations$2)),
  MaxLengthSchemaId = MaxLengthSchemaId$1,
  MinLengthSchemaId = MinLengthSchemaId$1,
  LengthSchemaId = LengthSchemaId$1,
  PatternSchemaId = Symbol.for(`effect/SchemaId/Pattern`),
  pattern = (regex, annotations$2) => self$1 => {
    let source = regex.source
    return self$1.pipe(
      filter(a$22 => (regex.lastIndex = 0, regex.test(a$22)), {
        schemaId: PatternSchemaId,
        [PatternSchemaId]: { regex },
        description: `a string matching the pattern ${source}`,
        jsonSchema: { pattern: source },
        ...annotations$2,
      }),
    )
  },
  FiniteSchemaId = FiniteSchemaId$1,
  GreaterThanSchemaId = GreaterThanSchemaId$1,
  GreaterThanOrEqualToSchemaId = GreaterThanOrEqualToSchemaId$1,
  IntSchemaId = IntSchemaId$1,
  LessThanSchemaId = LessThanSchemaId$1,
  LessThanOrEqualToSchemaId = LessThanOrEqualToSchemaId$1,
  BetweenSchemaId = BetweenSchemaId$1,
  NonNaNSchemaId = NonNaNSchemaId$1,
  JsonNumberSchemaId = JsonNumberSchemaId$1,
  GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId,
  GreaterThanOrEqualToBigIntSchemaId = GreaterThanOrEqualToBigIntSchemaId$1,
  LessThanBigIntSchemaId = LessThanBigIntSchemaId$1,
  LessThanOrEqualToBigIntSchemaId = LessThanOrEqualToBigIntSchemaId$1,
  BetweenBigIntSchemaId = BetweenBigintSchemaId,
  toComposite = (eff, onSuccess, ast, actual) =>
    mapBoth(eff, { onFailure: e$26 => new Composite(ast, actual, e$26), onSuccess })
var Uint8ArrayFromSelf = class extends declare(isUint8Array$2, {
  identifier: `Uint8ArrayFromSelf`,
  pretty: () => u8arr => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => fc => fc.uint8Array(),
  equivalence: () => getEquivalence$3(equals),
}) {}
const makeUint8ArrayTransformation = (id$2, decode$31, encode$29) =>
    transformOrFail(
      String$.annotations({ description: `a string to be decoded into a Uint8Array` }),
      Uint8ArrayFromSelf,
      {
        strict: !0,
        decode: (i$14, _$1, ast) =>
          mapLeft(decode$31(i$14), decodeException => new Type$1(ast, i$14, decodeException.message)),
        encode: a$22 => succeed(encode$29(a$22)),
      },
    ).annotations({ identifier: id$2 }),
  Uint8ArrayFromBase64 = makeUint8ArrayTransformation(`Uint8ArrayFromBase64`, decodeBase64, encodeBase64),
  Uint8ArrayFromBase64Url = makeUint8ArrayTransformation(`Uint8ArrayFromBase64Url`, decodeBase64Url, encodeBase64Url),
  Uint8ArrayFromHex = makeUint8ArrayTransformation(`Uint8ArrayFromHex`, decodeHex, encodeHex),
  makeEncodingTransformation = (id$2, decode$31, encode$29) =>
    transformOrFail(
      String$.annotations({
        description: `A string that is interpreted as being ${id$2}-encoded and will be decoded into a UTF-8 string`,
      }),
      String$,
      {
        strict: !0,
        decode: (i$14, _$1, ast) =>
          mapLeft(decode$31(i$14), decodeException => new Type$1(ast, i$14, decodeException.message)),
        encode: a$22 => succeed(encode$29(a$22)),
      },
    ).annotations({ identifier: `StringFrom${id$2}` }),
  StringFromBase64 = makeEncodingTransformation(`Base64`, decodeBase64String, encodeBase64),
  StringFromBase64Url = makeEncodingTransformation(`Base64Url`, decodeBase64UrlString, encodeBase64Url),
  StringFromHex = makeEncodingTransformation(`Hex`, decodeHexString, encodeHex),
  MinItemsSchemaId = MinItemsSchemaId$1,
  MaxItemsSchemaId = MaxItemsSchemaId$1,
  ItemsCountSchemaId = ItemsCountSchemaId$1,
  DateFromSelfSchemaId = DateFromSelfSchemaId$1,
  isField = u$7 => isSchema(u$7) || isPropertySignature(u$7),
  isFields = fields => ownKeys(fields).every(key$1 => isField(fields[key$1])),
  getFields$1 = hasFields => `fields` in hasFields ? hasFields.fields : getFields$1(hasFields[RefineSchemaId]),
  getSchemaFromFieldsOr = fieldsOr =>
    isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields$1(fieldsOr)),
  getFieldsFromFieldsOr = fieldsOr => isFields(fieldsOr) ? fieldsOr : getFields$1(fieldsOr),
  Class = identifier$1 => (fieldsOr, annotations$2) =>
    makeClass({
      kind: `Class`,
      identifier: identifier$1,
      schema: getSchemaFromFieldsOr(fieldsOr),
      fields: getFieldsFromFieldsOr(fieldsOr),
      Base: Class$2,
      annotations: annotations$2,
    }),
  getClassTag = tag$3 => withConstructorDefault(propertySignature(Literal(tag$3)), () => tag$3),
  TaggedClass = identifier$1 => (tag$3, fieldsOr, annotations$2) => {
    let fields = getFieldsFromFieldsOr(fieldsOr),
      schema = getSchemaFromFieldsOr(fieldsOr),
      newFields = { _tag: getClassTag(tag$3) },
      taggedFields = extendFields(newFields, fields)
    return class extends makeClass({
      kind: `TaggedClass`,
      identifier: identifier$1 ?? tag$3,
      schema: extend$1(schema, Struct(newFields)),
      fields: taggedFields,
      Base: Class$2,
      annotations: annotations$2,
    }) {
      static _tag = tag$3
    }
  },
  extendFields = (a$22, b$3) => {
    let out = { ...a$22 }
    for (let key$1 of ownKeys(b$3)) {
      if (key$1 in a$22) throw Error(getASTDuplicatePropertySignatureErrorMessage(key$1))
      out[key$1] = b$3[key$1]
    }
    return out
  }
function getDisableValidationMakeOption(options$2) {
  return isBoolean$2(options$2) ? options$2 : options$2?.disableValidation ?? !1
}
const astCache = globalValue(`effect/Schema/astCache`, () => new WeakMap()),
  getClassAnnotations = annotations$2 =>
    annotations$2 === void 0 ? [] : Array.isArray(annotations$2) ? annotations$2 : [annotations$2],
  makeClass = (
    { Base: Base$2, annotations: annotations$2, disableToString, fields, identifier: identifier$1, kind, schema },
  ) => {
    let classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier$1}`),
      [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations$2),
      typeSchema_ = typeSchema(schema),
      declarationSurrogate = typeSchema_.annotations({ identifier: identifier$1, ...typeAnnotations }),
      typeSide = typeSchema_.annotations({
        [AutoTitleAnnotationId]: `${identifier$1} (Type side)`,
        ...typeAnnotations,
      }),
      constructorSchema = schema.annotations({
        [AutoTitleAnnotationId]: `${identifier$1} (Constructor)`,
        ...typeAnnotations,
      }),
      encodedSide = schema.annotations({
        [AutoTitleAnnotationId]: `${identifier$1} (Encoded side)`,
        ...encodedAnnotations,
      }),
      transformationSurrogate = schema.annotations({
        [JSONIdentifierAnnotationId]: identifier$1,
        ...encodedAnnotations,
        ...typeAnnotations,
        ...transformationAnnotations,
      }),
      fallbackInstanceOf = u$7 => hasProperty(u$7, classSymbol) && is$25(typeSide)(u$7),
      klass = class extends Base$2 {
        constructor(props = {}, options$2 = !1) {
          props = { ...props },
            kind !== `Class` && delete props._tag,
            props = lazilyMergeDefaults(fields, props),
            getDisableValidationMakeOption(options$2) || (props = validateSync(constructorSchema)(props)),
            super(props, !0)
        }
        static [TypeId] = variance
        static get ast() {
          let out = astCache.get(this)
          if (out) return out
          let declaration = declare([schema], {
            decode: () => (input, _$1, ast) =>
              input instanceof this || fallbackInstanceOf(input) ? succeed(input) : fail(new Type$1(ast, input)),
            encode: () => (input, options$2) =>
              input instanceof this
                ? succeed(input)
                : map$2(encodeUnknown$1(typeSide)(input, options$2), props => new this(props, !0)),
          }, {
            identifier: identifier$1,
            pretty: pretty$4 => self$1 => `${identifier$1}(${pretty$4(self$1)})`,
            arbitrary: arb => fc => arb(fc).map(props => new this(props)),
            equivalence: identity,
            [SurrogateAnnotationId]: declarationSurrogate.ast,
            ...typeAnnotations,
          })
          return out = transform(encodedSide, declaration, {
            strict: !0,
            decode: i$14 => new this(i$14, !0),
            encode: identity,
          }).annotations({ [SurrogateAnnotationId]: transformationSurrogate.ast, ...transformationAnnotations }).ast,
            astCache.set(this, out),
            out
        }
        static pipe() {
          return pipeArguments(this, arguments)
        }
        static annotations(annotations$3) {
          return make$17(this.ast).annotations(annotations$3)
        }
        static toString() {
          return `(${String(encodedSide)} <-> ${identifier$1})`
        }
        static make(...args$1) {
          return new this(...args$1)
        }
        static fields = { ...fields }
        static identifier = identifier$1
        static extend(identifier$2) {
          return (newFieldsOr, annotations$3) => {
            let newFields = getFieldsFromFieldsOr(newFieldsOr),
              newSchema = getSchemaFromFieldsOr(newFieldsOr),
              extendedFields = extendFields(fields, newFields)
            return makeClass({
              kind,
              identifier: identifier$2,
              schema: extend$1(schema, newSchema),
              fields: extendedFields,
              Base: this,
              annotations: annotations$3,
            })
          }
        }
        static transformOrFail(identifier$2) {
          return (newFieldsOr, options$2, annotations$3) => {
            let transformedFields = extendFields(fields, newFieldsOr)
            return makeClass({
              kind,
              identifier: identifier$2,
              schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options$2),
              fields: transformedFields,
              Base: this,
              annotations: annotations$3,
            })
          }
        }
        static transformOrFailFrom(identifier$2) {
          return (newFields, options$2, annotations$3) => {
            let transformedFields = extendFields(fields, newFields)
            return makeClass({
              kind,
              identifier: identifier$2,
              schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options$2),
              fields: transformedFields,
              Base: this,
              annotations: annotations$3,
            })
          }
        }
        get [classSymbol]() {
          return classSymbol
        }
      }
    return disableToString !== !0 && Object.defineProperty(klass.prototype, `toString`, {
      value() {
        return `${identifier$1}({ ${
          ownKeys(fields).map(p$25 => `${formatPropertyKey$1(p$25)}: ${formatUnknown(this[p$25])}`).join(`, `)
        } })`
      },
      configurable: !0,
      writable: !0,
    }),
      klass
  },
  hashSetArbitrary = (item, ctx) => fc => {
    let items = fc.array(item(fc))
    return (ctx.depthIdentifier === void 0 ? items : fc.oneof(ctx, fc.constant([]), items)).map(fromIterable$6)
  },
  hashSetPretty = item => set$6 => `HashSet(${Array.from(set$6).map(a$22 => item(a$22)).join(`, `)})`,
  hashSetEquivalence = item => {
    let arrayEquivalence = getEquivalence$3(item)
    return make$61((a$22, b$3) => arrayEquivalence(Array.from(a$22), Array.from(b$3)))
  },
  hashSetParse = decodeUnknown$2 => (u$7, options$2, ast) =>
    isHashSet(u$7)
      ? toComposite(decodeUnknown$2(Array.from(u$7), options$2), fromIterable$6, ast, u$7)
      : fail(new Type$1(ast, u$7)),
  HashSetFromSelf = value$2 =>
    declare([value$2], {
      decode: item => hashSetParse(decodeUnknown$1(Array$(item))),
      encode: item => hashSetParse(encodeUnknown$1(Array$(item))),
    }, {
      description: `HashSet<${format(value$2)}>`,
      pretty: hashSetPretty,
      arbitrary: hashSetArbitrary,
      equivalence: hashSetEquivalence,
    })
function HashSet(value$2) {
  return transform(Array$(value$2), HashSetFromSelf(typeSchema(asSchema(value$2))), {
    strict: !0,
    decode: i$14 => fromIterable$6(i$14),
    encode: a$22 => Array.from(a$22),
  })
}
const hashMapArbitrary = (key$1, value$2, ctx) => fc => {
    let items = fc.array(fc.tuple(key$1(fc), value$2(fc)))
    return (ctx.depthIdentifier === void 0 ? items : fc.oneof(ctx, fc.constant([]), items)).map(fromIterable$5)
  },
  hashMapPretty = (key$1, value$2) => map$20 =>
    `HashMap([${Array.from(map$20).map(([k$1, v$4]) => `[${key$1(k$1)}, ${value$2(v$4)}]`).join(`, `)}])`,
  hashMapEquivalence = (key$1, value$2) => {
    let arrayEquivalence = getEquivalence$3(make$61(([ka, va], [kb, vb]) => key$1(ka, kb) && value$2(va, vb)))
    return make$61((a$22, b$3) => arrayEquivalence(Array.from(a$22), Array.from(b$3)))
  },
  hashMapParse = decodeUnknown$2 => (u$7, options$2, ast) =>
    isHashMap(u$7)
      ? toComposite(decodeUnknown$2(Array.from(u$7), options$2), fromIterable$5, ast, u$7)
      : fail(new Type$1(ast, u$7)),
  HashMapFromSelf = ({ key: key$1, value: value$2 }) =>
    declare([key$1, value$2], {
      decode: (key$2, value$3) => hashMapParse(decodeUnknown$1(Array$(Tuple(key$2, value$3)))),
      encode: (key$2, value$3) => hashMapParse(encodeUnknown$1(Array$(Tuple(key$2, value$3)))),
    }, {
      description: `HashMap<${format(key$1)}, ${format(value$2)}>`,
      pretty: hashMapPretty,
      arbitrary: hashMapArbitrary,
      equivalence: hashMapEquivalence,
    }),
  HashMap = ({ key: key$1, value: value$2 }) =>
    transform(
      Array$(Tuple(key$1, value$2)),
      HashMapFromSelf({ key: typeSchema(asSchema(key$1)), value: typeSchema(asSchema(value$2)) }),
      {
        strict: !0,
        decode: i$14 => fromIterable$5(i$14),
        encode: a$22 => Array.from(a$22),
      },
    ),
  equivalence$20 = schema => go(schema.ast, []),
  getEquivalenceAnnotation = getAnnotation(EquivalenceAnnotationId),
  go = (ast, path$1) => {
    let hook = getEquivalenceAnnotation(ast)
    if (isSome(hook)) {
      switch (ast._tag) {
        case `Declaration`:
          return hook.value(...ast.typeParameters.map(tp => go(tp, path$1)))
        case `Refinement`:
          return hook.value(go(ast.from, path$1))
        default:
          return hook.value()
      }
    }
    switch (ast._tag) {
      case `NeverKeyword`:
        throw Error(getEquivalenceUnsupportedErrorMessage(ast, path$1))
      case `Transformation`:
        return go(ast.to, path$1)
      case `Declaration`:
      case `Literal`:
      case `StringKeyword`:
      case `TemplateLiteral`:
      case `UniqueSymbol`:
      case `SymbolKeyword`:
      case `UnknownKeyword`:
      case `AnyKeyword`:
      case `NumberKeyword`:
      case `BooleanKeyword`:
      case `BigIntKeyword`:
      case `UndefinedKeyword`:
      case `VoidKeyword`:
      case `Enums`:
      case `ObjectKeyword`:
        return equals
      case `Refinement`:
        return go(ast.from, path$1)
      case `Suspend`: {
        let get$12 = memoizeThunk(() => go(ast.f(), path$1))
        return (a$22, b$3) => get$12()(a$22, b$3)
      }
      case `TupleType`: {
        let elements = ast.elements.map((element$2, i$14) => go(element$2.type, path$1.concat(i$14))),
          rest = ast.rest.map(annotatedAST => go(annotatedAST.type, path$1))
        return make$61((a$22, b$3) => {
          if (!Array.isArray(a$22) || !Array.isArray(b$3)) return !1
          let len = a$22.length
          if (len !== b$3.length) return !1
          let i$14 = 0
          for (; i$14 < Math.min(len, ast.elements.length); i$14++) {
            if (!elements[i$14](a$22[i$14], b$3[i$14])) return !1
          }
          if (isNonEmptyReadonlyArray(rest)) {
            let [head$5, ...tail] = rest
            for (; i$14 < len - tail.length; i$14++) if (!head$5(a$22[i$14], b$3[i$14])) return !1
            for (let j$1 = 0; j$1 < tail.length; j$1++) if (i$14 += j$1, !tail[j$1](a$22[i$14], b$3[i$14])) return !1
          }
          return !0
        })
      }
      case `TypeLiteral`: {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) return equals
        let propertySignatures = ast.propertySignatures.map(ps => go(ps.type, path$1.concat(ps.name))),
          indexSignatures = ast.indexSignatures.map(is$29 => go(is$29.type, path$1))
        return make$61((a$22, b$3) => {
          if (!isRecord$1(a$22) || !isRecord$1(b$3)) return !1
          let aStringKeys = Object.keys(a$22), aSymbolKeys = Object.getOwnPropertySymbols(a$22)
          for (let i$14 = 0; i$14 < propertySignatures.length; i$14++) {
            let ps = ast.propertySignatures[i$14],
              name = ps.name,
              aHas = Object.prototype.hasOwnProperty.call(a$22, name),
              bHas = Object.prototype.hasOwnProperty.call(b$3, name)
            if (ps.isOptional && aHas !== bHas || aHas && bHas && !propertySignatures[i$14](a$22[name], b$3[name])) {
              return !1
            }
          }
          let bSymbolKeys, bStringKeys
          for (let i$14 = 0; i$14 < indexSignatures.length; i$14++) {
            let is$29 = ast.indexSignatures[i$14],
              encodedParameter = getEncodedParameter(is$29.parameter),
              isSymbol$1 = isSymbolKeyword(encodedParameter)
            if (isSymbol$1) {
              if (bSymbolKeys ||= Object.getOwnPropertySymbols(b$3), aSymbolKeys.length !== bSymbolKeys.length) {
                return !1
              }
            } else if (bStringKeys ||= Object.keys(b$3), aStringKeys.length !== bStringKeys.length) return !1
            let aKeys = isSymbol$1 ? aSymbolKeys : aStringKeys
            for (let j$1 = 0; j$1 < aKeys.length; j$1++) {
              let key$1 = aKeys[j$1]
              if (
                !Object.prototype.hasOwnProperty.call(b$3, key$1) || !indexSignatures[i$14](a$22[key$1], b$3[key$1])
              ) return !1
            }
          }
          return !0
        })
      }
      case `Union`: {
        let searchTree = getSearchTree(ast.types, !0), ownKeys$1 = ownKeys(searchTree.keys), len = ownKeys$1.length
        return make$61((a$22, b$3) => {
          let candidates = []
          if (len > 0 && isRecordOrArray(a$22)) {
            for (let i$14 = 0; i$14 < len; i$14++) {
              let name = ownKeys$1[i$14], buckets = searchTree.keys[name].buckets
              if (Object.prototype.hasOwnProperty.call(a$22, name)) {
                let literal = String(a$22[name])
                Object.prototype.hasOwnProperty.call(buckets, literal)
                  && (candidates = candidates.concat(buckets[literal]))
              }
            }
          }
          searchTree.otherwise.length > 0 && (candidates = candidates.concat(searchTree.otherwise))
          let tuples = candidates.map(ast$1 => [go(ast$1, path$1), is$25({ ast: ast$1 })])
          for (let i$14 = 0; i$14 < tuples.length; i$14++) {
            let [equivalence$22, is$29] = tuples[i$14]
            if (is$29(a$22) && is$29(b$3) && equivalence$22(a$22, b$3)) return !0
          }
          return !1
        })
      }
    }
  },
  TRACK_MEMO_SYMBOL = Symbol(),
  GET_ORIGINAL_SYMBOL = Symbol(),
  AFFECTED_PROPERTY = `a`,
  IS_TARGET_COPIED_PROPERTY = `f`,
  PROXY_PROPERTY = `p`,
  PROXY_CACHE_PROPERTY = `c`,
  TARGET_CACHE_PROPERTY = `t`,
  HAS_KEY_PROPERTY = `h`,
  ALL_OWN_KEYS_PROPERTY = `w`,
  HAS_OWN_KEY_PROPERTY = `o`,
  KEYS_PROPERTY = `k`
let newProxy$1 = (target, handler) => new Proxy(target, handler)
const getProto = Object.getPrototypeOf,
  objectsToTrack = new WeakMap(),
  isObjectToTrack = obj =>
    obj
    && (objectsToTrack.has(obj)
      ? objectsToTrack.get(obj)
      : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype),
  isObject$3 = x$2 => typeof x$2 == `object` && !!x$2,
  needsToCopyTargetObject = obj =>
    Object.values(Object.getOwnPropertyDescriptors(obj)).some(descriptor$2 =>
      !descriptor$2.configurable && !descriptor$2.writable
    ),
  copyTargetObject = obj => {
    if (Array.isArray(obj)) return Array.from(obj)
    let descriptors = Object.getOwnPropertyDescriptors(obj)
    return Object.values(descriptors).forEach(desc => {
      desc.configurable = !0
    }),
      Object.create(getProto(obj), descriptors)
  },
  createProxyHandler = (origObj, isTargetCopied) => {
    let state = { [IS_TARGET_COPIED_PROPERTY]: isTargetCopied },
      trackObject = !1,
      recordUsage = (type$2, key$1) => {
        if (!trackObject) {
          let used = state[AFFECTED_PROPERTY].get(origObj)
          if (used || (used = {}, state[AFFECTED_PROPERTY].set(origObj, used)), type$2 === ALL_OWN_KEYS_PROPERTY) {
            used[ALL_OWN_KEYS_PROPERTY] = !0
          } else {
            let set$6 = used[type$2]
            set$6 || (set$6 = new Set(), used[type$2] = set$6), set$6.add(key$1)
          }
        }
      },
      recordObjectAsUsed = () => {
        trackObject = !0, state[AFFECTED_PROPERTY].delete(origObj)
      },
      handler = {
        get(target, key$1) {
          return key$1 === GET_ORIGINAL_SYMBOL
            ? origObj
            : (recordUsage(KEYS_PROPERTY, key$1),
              createProxy(
                Reflect.get(target, key$1),
                state[AFFECTED_PROPERTY],
                state[PROXY_CACHE_PROPERTY],
                state[TARGET_CACHE_PROPERTY],
              ))
        },
        has(target, key$1) {
          return key$1 === TRACK_MEMO_SYMBOL
            ? (recordObjectAsUsed(), !0)
            : (recordUsage(HAS_KEY_PROPERTY, key$1), Reflect.has(target, key$1))
        },
        getOwnPropertyDescriptor(target, key$1) {
          return recordUsage(HAS_OWN_KEY_PROPERTY, key$1), Reflect.getOwnPropertyDescriptor(target, key$1)
        },
        ownKeys(target) {
          return recordUsage(ALL_OWN_KEYS_PROPERTY), Reflect.ownKeys(target)
        },
      }
    return isTargetCopied && (handler.set = handler.deleteProperty = () => !1), [handler, state]
  },
  getOriginalObject = obj => obj[GET_ORIGINAL_SYMBOL] || obj,
  createProxy = (obj, affected, proxyCache$1, targetCache$1) => {
    if (!isObjectToTrack(obj)) return obj
    let targetAndCopied = targetCache$1 && targetCache$1.get(obj)
    if (!targetAndCopied) {
      let target$1 = getOriginalObject(obj)
      targetAndCopied = needsToCopyTargetObject(target$1) ? [target$1, copyTargetObject(target$1)] : [target$1],
        targetCache$1?.set(obj, targetAndCopied)
    }
    let [target, copiedTarget] = targetAndCopied, handlerAndState = proxyCache$1 && proxyCache$1.get(target)
    return (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget)
      && (handlerAndState = createProxyHandler(target, !!copiedTarget),
        handlerAndState[1][PROXY_PROPERTY] = newProxy$1(copiedTarget || target, handlerAndState[0]),
        proxyCache$1 && proxyCache$1.set(target, handlerAndState)),
      handlerAndState[1][AFFECTED_PROPERTY] = affected,
      handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache$1,
      handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache$1,
      handlerAndState[1][PROXY_PROPERTY]
  },
  isAllOwnKeysChanged = (prevObj, nextObj) => {
    let prevKeys = Reflect.ownKeys(prevObj), nextKeys = Reflect.ownKeys(nextObj)
    return prevKeys.length !== nextKeys.length || prevKeys.some((k$1, i$14) => k$1 !== nextKeys[i$14])
  },
  isChanged = (prevObj, nextObj, affected, cache, isEqual$1 = Object.is) => {
    if (isEqual$1(prevObj, nextObj)) return !1
    if (!isObject$3(prevObj) || !isObject$3(nextObj)) return !0
    let used = affected.get(getOriginalObject(prevObj))
    if (!used) return !0
    if (cache) {
      let hit = cache.get(prevObj)
      if (hit === nextObj) return !1
      cache.set(prevObj, nextObj)
    }
    let changed = null
    for (let key$1 of used[HAS_KEY_PROPERTY] || []) {
      if (changed = Reflect.has(prevObj, key$1) !== Reflect.has(nextObj, key$1), changed) return changed
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === !0) {
      if (changed = isAllOwnKeysChanged(prevObj, nextObj), changed) return changed
      else {for (let key$1 of used[HAS_OWN_KEY_PROPERTY] || []) {
          let hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key$1),
            hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key$1)
          if (changed = hasPrev !== hasNext, changed) return changed
        }}
    }
    for (let key$1 of used[KEYS_PROPERTY] || []) {
      if (changed = isChanged(prevObj[key$1], nextObj[key$1], affected, cache, isEqual$1), changed) return changed
    }
    if (changed === null) throw Error(`invalid used`)
    return changed
  },
  getUntracked = obj => isObjectToTrack(obj) && obj[GET_ORIGINAL_SYMBOL] || null,
  markToTrack = (obj, mark$1 = !0) => {
    objectsToTrack.set(obj, mark$1)
  },
  affectedToPathList = (obj, affected, onlyWithValues) => {
    let list$3 = [],
      seen$1 = new WeakSet(),
      walk = (x$2, path$1) => {
        var _a, _b, _c
        if (seen$1.has(x$2)) return
        isObject$3(x$2) && seen$1.add(x$2)
        let used = isObject$3(x$2) && affected.get(getOriginalObject(x$2))
        if (used) {
          if (
            (_a = used[HAS_KEY_PROPERTY]) == null || _a.forEach(key$1 => {
              let segment = `:has(${String(key$1)})`
              list$3.push(path$1 ? [...path$1, segment] : [segment])
            }), used[ALL_OWN_KEYS_PROPERTY] === !0
          ) {
            let segment = `:ownKeys`
            list$3.push(path$1 ? [...path$1, segment] : [segment])
          } else {
            ;(_b = used[HAS_OWN_KEY_PROPERTY]) == null || _b.forEach(key$1 => {
              let segment = `:hasOwn(${String(key$1)})`
              list$3.push(path$1 ? [...path$1, segment] : [segment])
            })
          }
          ;(_c = used[KEYS_PROPERTY]) == null || _c.forEach(key$1 => {
            ;(!onlyWithValues || `value` in (Object.getOwnPropertyDescriptor(x$2, key$1) || {}))
              && walk(x$2[key$1], path$1 ? [...path$1, key$1] : [key$1])
          })
        } else path$1 && list$3.push(path$1)
      }
    return walk(obj), list$3
  },
  __vite_import_meta_env__$1 = { BASE_URL: `/`, DEV: !1, MODE: `production`, PROD: !0, SSR: !1 },
  isObject$2 = x$2 => typeof x$2 == `object` && !!x$2,
  canProxyDefault = x$2 =>
    isObject$2(x$2) && !refSet.has(x$2) && (Array.isArray(x$2) || !(Symbol.iterator in x$2))
    && !(x$2 instanceof WeakMap) && !(x$2 instanceof WeakSet) && !(x$2 instanceof Error) && !(x$2 instanceof Number)
    && !(x$2 instanceof Date) && !(x$2 instanceof String) && !(x$2 instanceof RegExp) && !(x$2 instanceof ArrayBuffer)
    && !(x$2 instanceof Promise),
  createSnapshotDefault = (target, version) => {
    let cache = snapCache.get(target)
    if (cache?.[0] === version) return cache[1]
    let snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))
    return markToTrack(snap, !0),
      snapCache.set(target, [version, snap]),
      Reflect.ownKeys(target).forEach(key$1 => {
        if (Object.getOwnPropertyDescriptor(snap, key$1)) return
        let value$2 = Reflect.get(target, key$1),
          { enumerable } = Reflect.getOwnPropertyDescriptor(target, key$1),
          desc = { value: value$2, enumerable, configurable: !0 }
        if (refSet.has(value$2)) markToTrack(value$2, !1)
        else if (proxyStateMap.has(value$2)) {
          let [target2, ensureVersion] = proxyStateMap.get(value$2)
          desc.value = createSnapshotDefault(target2, ensureVersion())
        }
        Object.defineProperty(snap, key$1, desc)
      }),
      Object.preventExtensions(snap)
  },
  createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({
    deleteProperty(target, prop) {
      let prevValue = Reflect.get(target, prop)
      removePropListener(prop)
      let deleted = Reflect.deleteProperty(target, prop)
      return deleted && notifyUpdate([`delete`, [prop], prevValue]), deleted
    },
    set(target, prop, value$2, receiver) {
      let hasPrevValue = !isInitializing() && Reflect.has(target, prop), prevValue = Reflect.get(target, prop, receiver)
      if (
        hasPrevValue
        && (objectIs(prevValue, value$2) || proxyCache.has(value$2) && objectIs(prevValue, proxyCache.get(value$2)))
      ) return !0
      removePropListener(prop), isObject$2(value$2) && (value$2 = getUntracked(value$2) || value$2)
      let nextValue = !proxyStateMap.has(value$2) && canProxy(value$2) ? proxy(value$2) : value$2
      return addPropListener(prop, nextValue),
        Reflect.set(target, prop, nextValue, receiver),
        notifyUpdate([`set`, [prop], value$2, prevValue]),
        !0
    },
  }),
  proxyStateMap = new WeakMap(),
  refSet = new WeakSet(),
  snapCache = new WeakMap(),
  versionHolder = [1, 1],
  proxyCache = new WeakMap()
let objectIs = Object.is,
  newProxy = (target, handler) => new Proxy(target, handler),
  canProxy = canProxyDefault,
  createSnapshot = createSnapshotDefault,
  createHandler = createHandlerDefault
function proxy(baseObject = {}) {
  if (!isObject$2(baseObject)) throw Error(`object required`)
  let found = proxyCache.get(baseObject)
  if (found) return found
  let version = versionHolder[0],
    listeners = new Set(),
    notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
      version !== nextVersion && (version = nextVersion, listeners.forEach(listener => listener(op, nextVersion)))
    },
    checkVersion = versionHolder[1],
    ensureVersion = (
      nextCheckVersion = ++versionHolder[1],
    ) => (checkVersion !== nextCheckVersion && !listeners.size
      && (checkVersion = nextCheckVersion,
        propProxyStates.forEach(([propProxyState]) => {
          let propVersion = propProxyState[1](nextCheckVersion)
          propVersion > version && (version = propVersion)
        })),
      version),
    createPropListener = prop => (op, nextVersion) => {
      let newOp = [...op]
      newOp[1] = [prop, ...newOp[1]], notifyUpdate(newOp, nextVersion)
    },
    propProxyStates = new Map(),
    addPropListener = (prop, propValue) => {
      let propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue)
      if (propProxyState) {
        if ((__vite_import_meta_env__$1 ? `production` : void 0) !== `production` && propProxyStates.has(prop)) {
          throw Error(`prop listener already exists`)
        }
        if (listeners.size) {
          let remove$7 = propProxyState[2](createPropListener(prop))
          propProxyStates.set(prop, [propProxyState, remove$7])
        } else propProxyStates.set(prop, [propProxyState])
      }
    },
    removePropListener = prop => {
      var _a
      let entry = propProxyStates.get(prop)
      entry && (propProxyStates.delete(prop), (_a = entry[1]) == null || _a.call(entry))
    },
    addListener = listener => {
      listeners.add(listener),
        listeners.size === 1 && propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
          if ((__vite_import_meta_env__$1 ? `production` : void 0) !== `production` && prevRemove) {
            throw Error(`remove already exists`)
          }
          let remove$7 = propProxyState[2](createPropListener(prop))
          propProxyStates.set(prop, [propProxyState, remove$7])
        })
      let removeListener = () => {
        listeners.delete(listener),
          listeners.size === 0 && propProxyStates.forEach(([propProxyState, remove$7], prop) => {
            remove$7 && (remove$7(), propProxyStates.set(prop, [propProxyState]))
          })
      }
      return removeListener
    },
    initializing = !0,
    handler = createHandler(() => initializing, addPropListener, removePropListener, notifyUpdate),
    proxyObject = newProxy(baseObject, handler)
  proxyCache.set(baseObject, proxyObject)
  let proxyState = [baseObject, ensureVersion, addListener]
  return proxyStateMap.set(proxyObject, proxyState),
    Reflect.ownKeys(baseObject).forEach(key$1 => {
      let desc = Object.getOwnPropertyDescriptor(baseObject, key$1)
      ;`value` in desc && desc.writable && (proxyObject[key$1] = baseObject[key$1])
    }),
    initializing = !1,
    proxyObject
}
function subscribe(proxyObject, callback, notifyInSync) {
  let proxyState = proxyStateMap.get(proxyObject)
  ;(__vite_import_meta_env__$1 ? `production` : void 0) !== `production` && !proxyState
    && console.warn(`Please use proxy object`)
  let promise$2,
    ops = [],
    addListener = proxyState[2],
    isListenerActive = !1,
    listener = op => {
      if (ops.push(op), notifyInSync) {
        callback(ops.splice(0))
        return
      }
      promise$2 ||= Promise.resolve().then(() => {
        promise$2 = void 0, isListenerActive && callback(ops.splice(0))
      })
    },
    removeListener = addListener(listener)
  return isListenerActive = !0, () => {
    isListenerActive = !1, removeListener()
  }
}
function snapshot(proxyObject) {
  let proxyState = proxyStateMap.get(proxyObject)
  ;(__vite_import_meta_env__$1 ? `production` : void 0) !== `production` && !proxyState
    && console.warn(`Please use proxy object`)
  let [target, ensureVersion] = proxyState
  return createSnapshot(target, ensureVersion())
}
const __vite_import_meta_env__ = { BASE_URL: `/`, DEV: !1, MODE: `production`, PROD: !0, SSR: !1 },
  useAffectedDebugValue = (state, affected) => {
    let pathList = (0, import_react.useRef)(void 0)
    ;(0, import_react.useEffect)(() => {
      pathList.current = affectedToPathList(state, affected, !0)
    }),
      (0, import_react.useDebugValue)(pathList.current)
  },
  condUseAffectedDebugValue = useAffectedDebugValue,
  targetCache = new WeakMap()
function useSnapshot(proxyObject, options$2) {
  let notifyInSync = options$2?.sync,
    affected = (0, import_react.useMemo)(() => proxyObject && new WeakMap(), [proxyObject]),
    lastSnapshot = (0, import_react.useRef)(void 0),
    inRender = !0,
    currSnapshot = (0, import_react.useSyncExternalStore)(
      (0, import_react.useCallback)(callback => {
        let unsub = subscribe(proxyObject, callback, notifyInSync)
        return callback(), unsub
      }, [proxyObject, notifyInSync]),
      () => {
        let nextSnapshot = snapshot(proxyObject)
        try {
          if (
            !inRender && lastSnapshot.current && !isChanged(lastSnapshot.current, nextSnapshot, affected, new WeakMap())
          ) return lastSnapshot.current
        } catch {}
        return nextSnapshot
      },
      () => snapshot(proxyObject),
    )
  inRender = !1,
    (0, import_react.useLayoutEffect)(() => {
      lastSnapshot.current = currSnapshot
    }),
    (__vite_import_meta_env__ ? `production` : void 0) !== `production`
    && condUseAffectedDebugValue(currSnapshot, affected)
  let proxyCache$1 = (0, import_react.useMemo)(() => new WeakMap(), [])
  return createProxy(currSnapshot, affected, proxyCache$1, targetCache)
}
const Type = Enums({ Info: `info`, Success: `success`, Warning: `warning`, Error: `error` }),
  ToastAction = Struct({ label: String$, onClick: Any }),
  Toast = Struct({
    id: String$,
    message: String$,
    description: optional(String$),
    type: optional(Type),
    duration: optional(Number$),
    actions: Array$(ToastAction),
  }),
  State = Struct({ toasts: mutable(Array$(Toast)) }),
  initialState = { toasts: [] },
  DEFAULT_TOAST_DURATION = seconds(5),
  toastDefaults = { duration: toMillis(DEFAULT_TOAST_DURATION), actions: [] },
  store = proxy({
    ...initialState,
    add(toast) {
      let id$2 = `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`
      if (store.toasts.push({ ...toast, id: id$2 }), toast.duration !== 0) {
        let durationMs = toast.duration || toastDefaults.duration
        setTimeout(() => store.remove(id$2), durationMs)
      }
      return id$2
    },
    remove(id$2) {
      let index$4 = store.toasts.findIndex(t$18 => t$18.id === id$2)
      index$4 !== -1 && store.toasts.splice(index$4, 1)
    },
    reset() {
      Object.assign(store, initialState)
    },
    set(data) {
      Object.assign(store, data)
    },
    info(message, options$2) {
      return store.add({ ...toastDefaults, ...options$2, message, type: Type.enums.Info })
    },
    success(message, options$2) {
      return store.add({ ...toastDefaults, ...options$2, message, type: Type.enums.Success })
    },
    warning(message, options$2) {
      return store.add({ ...toastDefaults, ...options$2, message, type: Type.enums.Warning })
    },
    error(message, options$2) {
      return store.add({ ...toastDefaults, ...options$2, message, type: Type.enums.Error })
    },
  })
function devAssert(condition, message) {
  let booleanCondition = !!condition
  if (!booleanCondition) throw Error(message)
}
function isObjectLike(value$2) {
  return typeof value$2 == `object` && !!value$2
}
function invariant(condition, message) {
  let booleanCondition = !!condition
  if (!booleanCondition) throw Error(message ?? `Unexpected invariant triggered.`)
}
const LineRegExp = /\r\n|[\n\r]/g
function getLocation(source, position$2) {
  let lastLineStart = 0, line = 1
  for (let match$13 of source.body.matchAll(LineRegExp)) {
    if (typeof match$13.index == `number` || invariant(!1), match$13.index >= position$2) break
    lastLineStart = match$13.index + match$13[0].length, line += 1
  }
  return { line, column: position$2 + 1 - lastLineStart }
}
function printLocation(location) {
  return printSourceLocation(location.source, getLocation(location.source, location.start))
}
function printSourceLocation(source, sourceLocation) {
  let firstLineColumnOffset = source.locationOffset.column - 1,
    body$2 = ``.padStart(firstLineColumnOffset) + source.body,
    lineIndex = sourceLocation.line - 1,
    lineOffset = source.locationOffset.line - 1,
    lineNum = sourceLocation.line + lineOffset,
    columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0,
    columnNum = sourceLocation.column + columnOffset,
    locationStr = `${source.name}:${lineNum}:${columnNum}\n`,
    lines = body$2.split(/\r\n|[\n\r]/g),
    locationLine = lines[lineIndex]
  if (locationLine.length > 120) {
    let subLineIndex = Math.floor(columnNum / 80), subLineColumnNum = columnNum % 80, subLines = []
    for (let i$14 = 0; i$14 < locationLine.length; i$14 += 80) subLines.push(locationLine.slice(i$14, i$14 + 80))
    return locationStr
      + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map(subLine => [`|`, subLine]),
        [`|`, `^`.padStart(subLineColumnNum)],
        [`|`, subLines[subLineIndex + 1]],
      ])
  }
  return locationStr
    + printPrefixedLines([[`${lineNum - 1} |`, lines[lineIndex - 1]], [`${lineNum} |`, locationLine], [
      `|`,
      `^`.padStart(columnNum),
    ], [`${lineNum + 1} |`, lines[lineIndex + 1]]])
}
function printPrefixedLines(lines) {
  let existingLines = lines.filter(([_$1, line]) => line !== void 0),
    padLen = Math.max(...existingLines.map(([prefix$1]) => prefix$1.length))
  return existingLines.map(([prefix$1, line]) => prefix$1.padStart(padLen) + (line ? ` ` + line : ``)).join(`
`)
}
function toNormalizedOptions(args$1) {
  let firstArg = args$1[0]
  return firstArg == null || `kind` in firstArg || `length` in firstArg
    ? {
      nodes: firstArg,
      source: args$1[1],
      positions: args$1[2],
      path: args$1[3],
      originalError: args$1[4],
      extensions: args$1[5],
    }
    : firstArg
}
var GraphQLError = class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref
    let { nodes, source, positions, path: path$1, originalError: originalError$1, extensions } = toNormalizedOptions(
      rawArgs,
    )
    super(message),
      this.name = `GraphQLError`,
      this.path = path$1 ?? void 0,
      this.originalError = originalError$1 ?? void 0,
      this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0)
    let nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes)?.map(node$1 => node$1.loc).filter(loc => loc != null),
    )
    this.source = source ?? (nodeLocations == null ? void 0 : (_nodeLocations$ = nodeLocations[0])?.source),
      this.positions = positions ?? nodeLocations?.map(loc => loc.start),
      this.locations = positions && source
        ? positions.map(pos => getLocation(source, pos))
        : nodeLocations?.map(loc => getLocation(loc.source, loc.start))
    let originalExtensions = isObjectLike(originalError$1?.extensions) ? originalError$1?.extensions : void 0
    this.extensions = (_ref = extensions ?? originalExtensions) ?? Object.create(null),
      Object.defineProperties(this, {
        message: { writable: !0, enumerable: !0 },
        name: { enumerable: !1 },
        nodes: { enumerable: !1 },
        source: { enumerable: !1 },
        positions: { enumerable: !1 },
        originalError: { enumerable: !1 },
      }),
      originalError$1 != null && originalError$1.stack
        ? Object.defineProperty(this, `stack`, { value: originalError$1.stack, writable: !0, configurable: !0 })
        : Error.captureStackTrace
        ? Error.captureStackTrace(this, GraphQLError)
        : Object.defineProperty(this, `stack`, { value: Error().stack, writable: !0, configurable: !0 })
  }
  get [Symbol.toStringTag]() {
    return `GraphQLError`
  }
  toString() {
    let output = this.message
    if (this.nodes) {
      for (let node$1 of this.nodes) {
        node$1.loc && (output += `

` + printLocation(node$1.loc))
      }
    } else if (this.source && this.locations) {
      for (let location of this.locations) {
        output += `

` + printSourceLocation(this.source, location)
      }
    }
    return output
  }
  toJSON() {
    let formattedError = { message: this.message }
    return this.locations != null && (formattedError.locations = this.locations),
      this.path != null && (formattedError.path = this.path),
      this.extensions != null && Object.keys(this.extensions).length > 0
      && (formattedError.extensions = this.extensions),
      formattedError
  }
}
function undefinedIfEmpty(array$3) {
  return array$3 === void 0 || array$3.length === 0 ? void 0 : array$3
}
function syntaxError$1(source, position$2, description) {
  return new GraphQLError(`Syntax Error: ${description}`, { source, positions: [position$2] })
}
var Location = class {
    constructor(startToken, endToken, source) {
      this.start = startToken.start,
        this.end = endToken.end,
        this.startToken = startToken,
        this.endToken = endToken,
        this.source = source
    }
    get [Symbol.toStringTag]() {
      return `Location`
    }
    toJSON() {
      return { start: this.start, end: this.end }
    }
  },
  Token = class {
    constructor(kind, start$2, end$2, line, column, value$2) {
      this.kind = kind,
        this.start = start$2,
        this.end = end$2,
        this.line = line,
        this.column = column,
        this.value = value$2,
        this.prev = null,
        this.next = null
    }
    get [Symbol.toStringTag]() {
      return `Token`
    }
    toJSON() {
      return { kind: this.kind, value: this.value, line: this.line, column: this.column }
    }
  }
const QueryDocumentKeys = {
    Name: [],
    Document: [`definitions`],
    OperationDefinition: [`name`, `variableDefinitions`, `directives`, `selectionSet`],
    VariableDefinition: [`variable`, `type`, `defaultValue`, `directives`],
    Variable: [`name`],
    SelectionSet: [`selections`],
    Field: [`alias`, `name`, `arguments`, `directives`, `selectionSet`],
    Argument: [`name`, `value`],
    FragmentSpread: [`name`, `directives`],
    InlineFragment: [`typeCondition`, `directives`, `selectionSet`],
    FragmentDefinition: [`name`, `variableDefinitions`, `typeCondition`, `directives`, `selectionSet`],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: [`values`],
    ObjectValue: [`fields`],
    ObjectField: [`name`, `value`],
    Directive: [`name`, `arguments`],
    NamedType: [`name`],
    ListType: [`type`],
    NonNullType: [`type`],
    SchemaDefinition: [`description`, `directives`, `operationTypes`],
    OperationTypeDefinition: [`type`],
    ScalarTypeDefinition: [`description`, `name`, `directives`],
    ObjectTypeDefinition: [`description`, `name`, `interfaces`, `directives`, `fields`],
    FieldDefinition: [`description`, `name`, `arguments`, `type`, `directives`],
    InputValueDefinition: [`description`, `name`, `type`, `defaultValue`, `directives`],
    InterfaceTypeDefinition: [`description`, `name`, `interfaces`, `directives`, `fields`],
    UnionTypeDefinition: [`description`, `name`, `directives`, `types`],
    EnumTypeDefinition: [`description`, `name`, `directives`, `values`],
    EnumValueDefinition: [`description`, `name`, `directives`],
    InputObjectTypeDefinition: [`description`, `name`, `directives`, `fields`],
    DirectiveDefinition: [`description`, `name`, `arguments`, `locations`],
    SchemaExtension: [`directives`, `operationTypes`],
    ScalarTypeExtension: [`name`, `directives`],
    ObjectTypeExtension: [`name`, `interfaces`, `directives`, `fields`],
    InterfaceTypeExtension: [`name`, `interfaces`, `directives`, `fields`],
    UnionTypeExtension: [`name`, `directives`, `types`],
    EnumTypeExtension: [`name`, `directives`, `values`],
    InputObjectTypeExtension: [`name`, `directives`, `fields`],
  },
  kindValues = new Set(Object.keys(QueryDocumentKeys))
function isNode$1(maybeNode) {
  let maybeKind = maybeNode?.kind
  return typeof maybeKind == `string` && kindValues.has(maybeKind)
}
var OperationTypeNode
;(function(OperationTypeNode$1) {
  OperationTypeNode$1.QUERY = `query`,
    OperationTypeNode$1.MUTATION = `mutation`,
    OperationTypeNode$1.SUBSCRIPTION = `subscription`
})(OperationTypeNode ||= {})
var DirectiveLocation
;(function(DirectiveLocation$1) {
  DirectiveLocation$1.QUERY = `QUERY`,
    DirectiveLocation$1.MUTATION = `MUTATION`,
    DirectiveLocation$1.SUBSCRIPTION = `SUBSCRIPTION`,
    DirectiveLocation$1.FIELD = `FIELD`,
    DirectiveLocation$1.FRAGMENT_DEFINITION = `FRAGMENT_DEFINITION`,
    DirectiveLocation$1.FRAGMENT_SPREAD = `FRAGMENT_SPREAD`,
    DirectiveLocation$1.INLINE_FRAGMENT = `INLINE_FRAGMENT`,
    DirectiveLocation$1.VARIABLE_DEFINITION = `VARIABLE_DEFINITION`,
    DirectiveLocation$1.SCHEMA = `SCHEMA`,
    DirectiveLocation$1.SCALAR = `SCALAR`,
    DirectiveLocation$1.OBJECT = `OBJECT`,
    DirectiveLocation$1.FIELD_DEFINITION = `FIELD_DEFINITION`,
    DirectiveLocation$1.ARGUMENT_DEFINITION = `ARGUMENT_DEFINITION`,
    DirectiveLocation$1.INTERFACE = `INTERFACE`,
    DirectiveLocation$1.UNION = `UNION`,
    DirectiveLocation$1.ENUM = `ENUM`,
    DirectiveLocation$1.ENUM_VALUE = `ENUM_VALUE`,
    DirectiveLocation$1.INPUT_OBJECT = `INPUT_OBJECT`,
    DirectiveLocation$1.INPUT_FIELD_DEFINITION = `INPUT_FIELD_DEFINITION`
})(DirectiveLocation ||= {})
var Kind
;(function(Kind$1) {
  Kind$1.NAME = `Name`,
    Kind$1.DOCUMENT = `Document`,
    Kind$1.OPERATION_DEFINITION = `OperationDefinition`,
    Kind$1.VARIABLE_DEFINITION = `VariableDefinition`,
    Kind$1.SELECTION_SET = `SelectionSet`,
    Kind$1.FIELD = `Field`,
    Kind$1.ARGUMENT = `Argument`,
    Kind$1.FRAGMENT_SPREAD = `FragmentSpread`,
    Kind$1.INLINE_FRAGMENT = `InlineFragment`,
    Kind$1.FRAGMENT_DEFINITION = `FragmentDefinition`,
    Kind$1.VARIABLE = `Variable`,
    Kind$1.INT = `IntValue`,
    Kind$1.FLOAT = `FloatValue`,
    Kind$1.STRING = `StringValue`,
    Kind$1.BOOLEAN = `BooleanValue`,
    Kind$1.NULL = `NullValue`,
    Kind$1.ENUM = `EnumValue`,
    Kind$1.LIST = `ListValue`,
    Kind$1.OBJECT = `ObjectValue`,
    Kind$1.OBJECT_FIELD = `ObjectField`,
    Kind$1.DIRECTIVE = `Directive`,
    Kind$1.NAMED_TYPE = `NamedType`,
    Kind$1.LIST_TYPE = `ListType`,
    Kind$1.NON_NULL_TYPE = `NonNullType`,
    Kind$1.SCHEMA_DEFINITION = `SchemaDefinition`,
    Kind$1.OPERATION_TYPE_DEFINITION = `OperationTypeDefinition`,
    Kind$1.SCALAR_TYPE_DEFINITION = `ScalarTypeDefinition`,
    Kind$1.OBJECT_TYPE_DEFINITION = `ObjectTypeDefinition`,
    Kind$1.FIELD_DEFINITION = `FieldDefinition`,
    Kind$1.INPUT_VALUE_DEFINITION = `InputValueDefinition`,
    Kind$1.INTERFACE_TYPE_DEFINITION = `InterfaceTypeDefinition`,
    Kind$1.UNION_TYPE_DEFINITION = `UnionTypeDefinition`,
    Kind$1.ENUM_TYPE_DEFINITION = `EnumTypeDefinition`,
    Kind$1.ENUM_VALUE_DEFINITION = `EnumValueDefinition`,
    Kind$1.INPUT_OBJECT_TYPE_DEFINITION = `InputObjectTypeDefinition`,
    Kind$1.DIRECTIVE_DEFINITION = `DirectiveDefinition`,
    Kind$1.SCHEMA_EXTENSION = `SchemaExtension`,
    Kind$1.SCALAR_TYPE_EXTENSION = `ScalarTypeExtension`,
    Kind$1.OBJECT_TYPE_EXTENSION = `ObjectTypeExtension`,
    Kind$1.INTERFACE_TYPE_EXTENSION = `InterfaceTypeExtension`,
    Kind$1.UNION_TYPE_EXTENSION = `UnionTypeExtension`,
    Kind$1.ENUM_TYPE_EXTENSION = `EnumTypeExtension`,
    Kind$1.INPUT_OBJECT_TYPE_EXTENSION = `InputObjectTypeExtension`
})(Kind ||= {})
function isWhiteSpace(code$3) {
  return code$3 === 9 || code$3 === 32
}
function isDigit$1(code$3) {
  return code$3 >= 48 && code$3 <= 57
}
function isLetter(code$3) {
  return code$3 >= 97 && code$3 <= 122 || code$3 >= 65 && code$3 <= 90
}
function isNameStart(code$3) {
  return isLetter(code$3) || code$3 === 95
}
function isNameContinue(code$3) {
  return isLetter(code$3) || isDigit$1(code$3) || code$3 === 95
}
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2
  let commonIndent = 2 ** 53 - 1, firstNonEmptyLine = null, lastNonEmptyLine = -1
  for (let i$14 = 0; i$14 < lines.length; ++i$14) {
    var _firstNonEmptyLine
    let line = lines[i$14], indent$2 = leadingWhitespace(line)
    indent$2 !== line.length
      && (firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) ?? i$14,
        lastNonEmptyLine = i$14,
        i$14 !== 0 && indent$2 < commonIndent && (commonIndent = indent$2))
  }
  return lines.map((line, i$14) => i$14 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) ?? 0,
    lastNonEmptyLine + 1,
  )
}
function leadingWhitespace(str) {
  let i$14 = 0
  for (; i$14 < str.length && isWhiteSpace(str.charCodeAt(i$14));) ++i$14
  return i$14
}
function isPrintableAsBlockString(value$2) {
  if (value$2 === ``) return !0
  let isEmptyLine = !0, hasIndent = !1, hasCommonIndent = !0, seenNonEmptyLine = !1
  for (let i$14 = 0; i$14 < value$2.length; ++i$14) {
    switch (value$2.codePointAt(i$14)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return !1
      case 13:
        return !1
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) return !1
        seenNonEmptyLine = !0, isEmptyLine = !0, hasIndent = !1
        break
      case 9:
      case 32:
        hasIndent ||= isEmptyLine
        break
      default:
        hasCommonIndent &&= hasIndent, isEmptyLine = !1
    }
  }
  return !(isEmptyLine || hasCommonIndent && seenNonEmptyLine)
}
function printBlockString(value$2, options$2) {
  let escapedValue = value$2.replace(/"""/g, `\\"""`),
    lines = escapedValue.split(/\r\n|[\n\r]/g),
    isSingleLine = lines.length === 1,
    forceLeadingNewLine = lines.length > 1
      && lines.slice(1).every(line => line.length === 0 || isWhiteSpace(line.charCodeAt(0))),
    hasTrailingTripleQuotes = escapedValue.endsWith(`\\"""`),
    hasTrailingQuote = value$2.endsWith(`"`) && !hasTrailingTripleQuotes,
    hasTrailingSlash = value$2.endsWith(`\\`),
    forceTrailingNewline = hasTrailingQuote || hasTrailingSlash,
    printAsMultipleLines = !(options$2 != null && options$2.minimize)
      && (!isSingleLine || value$2.length > 70 || forceTrailingNewline || forceLeadingNewLine
        || hasTrailingTripleQuotes),
    result = ``,
    skipLeadingNewLine = isSingleLine && isWhiteSpace(value$2.charCodeAt(0))
  return (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) && (result += `
`),
    result += escapedValue,
    (printAsMultipleLines || forceTrailingNewline) && (result += `
`),
    `"""` + result + `"""`
}
var TokenKind
;(function(TokenKind$1) {
  TokenKind$1.SOF = `<SOF>`,
    TokenKind$1.EOF = `<EOF>`,
    TokenKind$1.BANG = `!`,
    TokenKind$1.DOLLAR = `$`,
    TokenKind$1.AMP = `&`,
    TokenKind$1.PAREN_L = `(`,
    TokenKind$1.PAREN_R = `)`,
    TokenKind$1.SPREAD = `...`,
    TokenKind$1.COLON = `:`,
    TokenKind$1.EQUALS = `=`,
    TokenKind$1.AT = `@`,
    TokenKind$1.BRACKET_L = `[`,
    TokenKind$1.BRACKET_R = `]`,
    TokenKind$1.BRACE_L = `{`,
    TokenKind$1.PIPE = `|`,
    TokenKind$1.BRACE_R = `}`,
    TokenKind$1.NAME = `Name`,
    TokenKind$1.INT = `Int`,
    TokenKind$1.FLOAT = `Float`,
    TokenKind$1.STRING = `String`,
    TokenKind$1.BLOCK_STRING = `BlockString`,
    TokenKind$1.COMMENT = `Comment`
})(TokenKind ||= {})
var Lexer = class {
  constructor(source) {
    let startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0)
    this.source = source,
      this.lastToken = startOfFileToken,
      this.token = startOfFileToken,
      this.line = 1,
      this.lineStart = 0
  }
  get [Symbol.toStringTag]() {
    return `Lexer`
  }
  advance() {
    this.lastToken = this.token
    let token = this.token = this.lookahead()
    return token
  }
  lookahead() {
    let token = this.token
    if (token.kind !== TokenKind.EOF) {
      do if (token.next) token = token.next
      else {
        let nextToken = readNextToken(this, token.end)
        token.next = nextToken, nextToken.prev = token, token = nextToken
      }
      while (token.kind === TokenKind.COMMENT)
    }
    return token
  }
}
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L
    || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS
    || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R
    || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R
}
function isUnicodeScalarValue(code$3) {
  return code$3 >= 0 && code$3 <= 55295 || code$3 >= 57344 && code$3 <= 1114111
}
function isSupplementaryCodePoint(body$2, location) {
  return isLeadingSurrogate(body$2.charCodeAt(location)) && isTrailingSurrogate(body$2.charCodeAt(location + 1))
}
function isLeadingSurrogate(code$3) {
  return code$3 >= 55296 && code$3 <= 56319
}
function isTrailingSurrogate(code$3) {
  return code$3 >= 56320 && code$3 <= 57343
}
function printCodePointAt(lexer, location) {
  let code$3 = lexer.source.body.codePointAt(location)
  if (code$3 === void 0) return TokenKind.EOF
  if (code$3 >= 32 && code$3 <= 126) {
    let char = String.fromCodePoint(code$3)
    return char === `"` ? `'"'` : `"${char}"`
  }
  return `U+` + code$3.toString(16).toUpperCase().padStart(4, `0`)
}
function createToken(lexer, kind, start$2, end$2, value$2) {
  let line = lexer.line, col = 1 + start$2 - lexer.lineStart
  return new Token(kind, start$2, end$2, line, col, value$2)
}
function readNextToken(lexer, start$2) {
  let body$2 = lexer.source.body, bodyLength = body$2.length, position$2 = start$2
  for (; position$2 < bodyLength;) {
    let code$3 = body$2.charCodeAt(position$2)
    switch (code$3) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ;++position$2
        continue
      case 10:
        ;++position$2, ++lexer.line, lexer.lineStart = position$2
        continue
      case 13:
        body$2.charCodeAt(position$2 + 1) === 10 ? position$2 += 2 : ++position$2,
          ++lexer.line,
          lexer.lineStart = position$2
        continue
      case 35:
        return readComment(lexer, position$2)
      case 33:
        return createToken(lexer, TokenKind.BANG, position$2, position$2 + 1)
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position$2, position$2 + 1)
      case 38:
        return createToken(lexer, TokenKind.AMP, position$2, position$2 + 1)
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position$2, position$2 + 1)
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position$2, position$2 + 1)
      case 46:
        if (body$2.charCodeAt(position$2 + 1) === 46 && body$2.charCodeAt(position$2 + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position$2, position$2 + 3)
        }
        break
      case 58:
        return createToken(lexer, TokenKind.COLON, position$2, position$2 + 1)
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position$2, position$2 + 1)
      case 64:
        return createToken(lexer, TokenKind.AT, position$2, position$2 + 1)
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position$2, position$2 + 1)
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position$2, position$2 + 1)
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position$2, position$2 + 1)
      case 124:
        return createToken(lexer, TokenKind.PIPE, position$2, position$2 + 1)
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position$2, position$2 + 1)
      case 34:
        return body$2.charCodeAt(position$2 + 1) === 34 && body$2.charCodeAt(position$2 + 2) === 34
          ? readBlockString(lexer, position$2)
          : readString(lexer, position$2)
    }
    if (isDigit$1(code$3) || code$3 === 45) return readNumber(lexer, position$2, code$3)
    if (isNameStart(code$3)) return readName(lexer, position$2)
    throw syntaxError$1(
      lexer.source,
      position$2,
      code$3 === 39
        ? `Unexpected single quote character ('), did you mean to use a double quote (")?`
        : isUnicodeScalarValue(code$3) || isSupplementaryCodePoint(body$2, position$2)
        ? `Unexpected character: ${printCodePointAt(lexer, position$2)}.`
        : `Invalid character: ${printCodePointAt(lexer, position$2)}.`,
    )
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength)
}
function readComment(lexer, start$2) {
  let body$2 = lexer.source.body, bodyLength = body$2.length, position$2 = start$2 + 1
  for (; position$2 < bodyLength;) {
    let code$3 = body$2.charCodeAt(position$2)
    if (code$3 === 10 || code$3 === 13) break
    if (isUnicodeScalarValue(code$3)) ++position$2
    else if (isSupplementaryCodePoint(body$2, position$2)) position$2 += 2
    else break
  }
  return createToken(lexer, TokenKind.COMMENT, start$2, position$2, body$2.slice(start$2 + 1, position$2))
}
function readNumber(lexer, start$2, firstCode) {
  let body$2 = lexer.source.body, position$2 = start$2, code$3 = firstCode, isFloat = !1
  if (code$3 === 45 && (code$3 = body$2.charCodeAt(++position$2)), code$3 === 48) {
    if (code$3 = body$2.charCodeAt(++position$2), isDigit$1(code$3)) {
      throw syntaxError$1(
        lexer.source,
        position$2,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position$2)}.`,
      )
    }
  } else position$2 = readDigits(lexer, position$2, code$3), code$3 = body$2.charCodeAt(position$2)
  if (
    code$3 === 46
    && (isFloat = !0,
      code$3 = body$2.charCodeAt(++position$2),
      position$2 = readDigits(lexer, position$2, code$3),
      code$3 = body$2.charCodeAt(position$2)),
      (code$3 === 69 || code$3 === 101)
      && (isFloat = !0,
        code$3 = body$2.charCodeAt(++position$2),
        (code$3 === 43 || code$3 === 45) && (code$3 = body$2.charCodeAt(++position$2)),
        position$2 = readDigits(lexer, position$2, code$3),
        code$3 = body$2.charCodeAt(position$2)),
      code$3 === 46 || isNameStart(code$3)
  ) {
    throw syntaxError$1(
      lexer.source,
      position$2,
      `Invalid number, expected digit but got: ${printCodePointAt(lexer, position$2)}.`,
    )
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start$2,
    position$2,
    body$2.slice(start$2, position$2),
  )
}
function readDigits(lexer, start$2, firstCode) {
  if (!isDigit$1(firstCode)) {
    throw syntaxError$1(
      lexer.source,
      start$2,
      `Invalid number, expected digit but got: ${printCodePointAt(lexer, start$2)}.`,
    )
  }
  let body$2 = lexer.source.body, position$2 = start$2 + 1
  for (; isDigit$1(body$2.charCodeAt(position$2));) ++position$2
  return position$2
}
function readString(lexer, start$2) {
  let body$2 = lexer.source.body,
    bodyLength = body$2.length,
    position$2 = start$2 + 1,
    chunkStart = position$2,
    value$2 = ``
  for (; position$2 < bodyLength;) {
    let code$3 = body$2.charCodeAt(position$2)
    if (code$3 === 34) {
      return value$2 += body$2.slice(chunkStart, position$2),
        createToken(lexer, TokenKind.STRING, start$2, position$2 + 1, value$2)
    }
    if (code$3 === 92) {
      value$2 += body$2.slice(chunkStart, position$2)
      let escape$2 = body$2.charCodeAt(position$2 + 1) === 117
        ? body$2.charCodeAt(position$2 + 2) === 123
          ? readEscapedUnicodeVariableWidth(lexer, position$2)
          : readEscapedUnicodeFixedWidth(lexer, position$2)
        : readEscapedCharacter(lexer, position$2)
      value$2 += escape$2.value, position$2 += escape$2.size, chunkStart = position$2
      continue
    }
    if (code$3 === 10 || code$3 === 13) break
    if (isUnicodeScalarValue(code$3)) ++position$2
    else if (isSupplementaryCodePoint(body$2, position$2)) position$2 += 2
    else {throw syntaxError$1(
        lexer.source,
        position$2,
        `Invalid character within String: ${printCodePointAt(lexer, position$2)}.`,
      )}
  }
  throw syntaxError$1(lexer.source, position$2, `Unterminated string.`)
}
function readEscapedUnicodeVariableWidth(lexer, position$2) {
  let body$2 = lexer.source.body, point$3 = 0, size$14 = 3
  for (; size$14 < 12;) {
    let code$3 = body$2.charCodeAt(position$2 + size$14++)
    if (code$3 === 125) {
      if (size$14 < 5 || !isUnicodeScalarValue(point$3)) break
      return { value: String.fromCodePoint(point$3), size: size$14 }
    }
    if (point$3 = point$3 << 4 | readHexDigit(code$3), point$3 < 0) break
  }
  throw syntaxError$1(
    lexer.source,
    position$2,
    `Invalid Unicode escape sequence: "${body$2.slice(position$2, position$2 + size$14)}".`,
  )
}
function readEscapedUnicodeFixedWidth(lexer, position$2) {
  let body$2 = lexer.source.body, code$3 = read16BitHexCode(body$2, position$2 + 2)
  if (isUnicodeScalarValue(code$3)) return { value: String.fromCodePoint(code$3), size: 6 }
  if (
    isLeadingSurrogate(code$3) && body$2.charCodeAt(position$2 + 6) === 92 && body$2.charCodeAt(position$2 + 7) === 117
  ) {
    let trailingCode = read16BitHexCode(body$2, position$2 + 8)
    if (isTrailingSurrogate(trailingCode)) return { value: String.fromCodePoint(code$3, trailingCode), size: 12 }
  }
  throw syntaxError$1(
    lexer.source,
    position$2,
    `Invalid Unicode escape sequence: "${body$2.slice(position$2, position$2 + 6)}".`,
  )
}
function read16BitHexCode(body$2, position$2) {
  return readHexDigit(body$2.charCodeAt(position$2)) << 12 | readHexDigit(body$2.charCodeAt(position$2 + 1)) << 8
    | readHexDigit(body$2.charCodeAt(position$2 + 2)) << 4 | readHexDigit(body$2.charCodeAt(position$2 + 3))
}
function readHexDigit(code$3) {
  return code$3 >= 48 && code$3 <= 57
    ? code$3 - 48
    : code$3 >= 65 && code$3 <= 70
    ? code$3 - 55
    : code$3 >= 97 && code$3 <= 102
    ? code$3 - 87
    : -1
}
function readEscapedCharacter(lexer, position$2) {
  let body$2 = lexer.source.body, code$3 = body$2.charCodeAt(position$2 + 1)
  switch (code$3) {
    case 34:
      return { value: `"`, size: 2 }
    case 92:
      return { value: `\\`, size: 2 }
    case 47:
      return { value: `/`, size: 2 }
    case 98:
      return { value: `\b`, size: 2 }
    case 102:
      return { value: `\f`, size: 2 }
    case 110:
      return {
        value: `
`,
        size: 2,
      }
    case 114:
      return { value: `\r`, size: 2 }
    case 116:
      return { value: `	`, size: 2 }
  }
  throw syntaxError$1(
    lexer.source,
    position$2,
    `Invalid character escape sequence: "${body$2.slice(position$2, position$2 + 2)}".`,
  )
}
function readBlockString(lexer, start$2) {
  let body$2 = lexer.source.body,
    bodyLength = body$2.length,
    lineStart = lexer.lineStart,
    position$2 = start$2 + 3,
    chunkStart = position$2,
    currentLine = ``,
    blockLines = []
  for (; position$2 < bodyLength;) {
    let code$3 = body$2.charCodeAt(position$2)
    if (code$3 === 34 && body$2.charCodeAt(position$2 + 1) === 34 && body$2.charCodeAt(position$2 + 2) === 34) {
      currentLine += body$2.slice(chunkStart, position$2), blockLines.push(currentLine)
      let token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start$2,
        position$2 + 3,
        dedentBlockStringLines(blockLines).join(`
`),
      )
      return lexer.line += blockLines.length - 1, lexer.lineStart = lineStart, token
    }
    if (
      code$3 === 92 && body$2.charCodeAt(position$2 + 1) === 34 && body$2.charCodeAt(position$2 + 2) === 34
      && body$2.charCodeAt(position$2 + 3) === 34
    ) {
      currentLine += body$2.slice(chunkStart, position$2), chunkStart = position$2 + 1, position$2 += 4
      continue
    }
    if (code$3 === 10 || code$3 === 13) {
      currentLine += body$2.slice(chunkStart, position$2),
        blockLines.push(currentLine),
        code$3 === 13 && body$2.charCodeAt(position$2 + 1) === 10 ? position$2 += 2 : ++position$2,
        currentLine = ``,
        chunkStart = position$2,
        lineStart = position$2
      continue
    }
    if (isUnicodeScalarValue(code$3)) ++position$2
    else if (isSupplementaryCodePoint(body$2, position$2)) position$2 += 2
    else {throw syntaxError$1(
        lexer.source,
        position$2,
        `Invalid character within String: ${printCodePointAt(lexer, position$2)}.`,
      )}
  }
  throw syntaxError$1(lexer.source, position$2, `Unterminated string.`)
}
function readName(lexer, start$2) {
  let body$2 = lexer.source.body, bodyLength = body$2.length, position$2 = start$2 + 1
  for (; position$2 < bodyLength;) {
    let code$3 = body$2.charCodeAt(position$2)
    if (isNameContinue(code$3)) ++position$2
    else break
  }
  return createToken(lexer, TokenKind.NAME, start$2, position$2, body$2.slice(start$2, position$2))
}
const MAX_ARRAY_LENGTH = 10, MAX_RECURSIVE_DEPTH = 2
function inspect(value$2) {
  return formatValue(value$2, [])
}
function formatValue(value$2, seenValues) {
  switch (typeof value$2) {
    case `string`:
      return JSON.stringify(value$2)
    case `function`:
      return value$2.name ? `[function ${value$2.name}]` : `[function]`
    case `object`:
      return formatObjectValue(value$2, seenValues)
    default:
      return String(value$2)
  }
}
function formatObjectValue(value$2, previouslySeenValues) {
  if (value$2 === null) return `null`
  if (previouslySeenValues.includes(value$2)) return `[Circular]`
  let seenValues = [...previouslySeenValues, value$2]
  if (isJSONable(value$2)) {
    let jsonValue = value$2.toJSON()
    if (jsonValue !== value$2) return typeof jsonValue == `string` ? jsonValue : formatValue(jsonValue, seenValues)
  } else if (Array.isArray(value$2)) return formatArray(value$2, seenValues)
  return formatObject(value$2, seenValues)
}
function isJSONable(value$2) {
  return typeof value$2.toJSON == `function`
}
function formatObject(object, seenValues) {
  let entries$2 = Object.entries(object)
  if (entries$2.length === 0) return `{}`
  if (seenValues.length > MAX_RECURSIVE_DEPTH) return `[` + getObjectTag(object) + `]`
  let properties = entries$2.map(([key$1, value$2]) => key$1 + `: ` + formatValue(value$2, seenValues))
  return `{ ` + properties.join(`, `) + ` }`
}
function formatArray(array$3, seenValues) {
  if (array$3.length === 0) return `[]`
  if (seenValues.length > MAX_RECURSIVE_DEPTH) return `[Array]`
  let len = Math.min(MAX_ARRAY_LENGTH, array$3.length), remaining = array$3.length - len, items = []
  for (let i$14 = 0; i$14 < len; ++i$14) items.push(formatValue(array$3[i$14], seenValues))
  return remaining === 1 ? items.push(`... 1 more item`) : remaining > 1 && items.push(`... ${remaining} more items`),
    `[` + items.join(`, `) + `]`
}
function getObjectTag(object) {
  let tag$3 = Object.prototype.toString.call(object).replace(/^\[object /, ``).replace(/]$/, ``)
  if (tag$3 === `Object` && typeof object.constructor == `function`) {
    let name = object.constructor.name
    if (typeof name == `string` && name !== ``) return name
  }
  return tag$3
}
const isProduction = globalThis.process && !0,
  instanceOf = isProduction
    ? function(value$2, constructor) {
      return value$2 instanceof constructor
    }
    : function(value$2, constructor) {
      if (value$2 instanceof constructor) return !0
      if (typeof value$2 == `object` && value$2) {
        var _value$constructor
        let className = constructor.prototype[Symbol.toStringTag],
          valueClassName = Symbol.toStringTag in value$2
            ? value$2[Symbol.toStringTag]
            : (_value$constructor = value$2.constructor)?.name
        if (className === valueClassName) {
          let stringifiedValue = inspect(value$2)
          throw Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`)
        }
      }
      return !1
    }
var Source = class {
  constructor(body$2, name = `GraphQL request`, locationOffset = { line: 1, column: 1 }) {
    typeof body$2 == `string` || devAssert(!1, `Body must be a string. Received: ${inspect(body$2)}.`),
      this.body = body$2,
      this.name = name,
      this.locationOffset = locationOffset,
      this.locationOffset.line > 0 || devAssert(!1, `line in locationOffset is 1-indexed and must be positive.`),
      this.locationOffset.column > 0 || devAssert(!1, `column in locationOffset is 1-indexed and must be positive.`)
  }
  get [Symbol.toStringTag]() {
    return `Source`
  }
}
function isSource(source) {
  return instanceOf(source, Source)
}
function parse$2(source, options$2) {
  let parser = new Parser$1(source, options$2), document$3 = parser.parseDocument()
  return Object.defineProperty(document$3, `tokenCount`, { enumerable: !1, value: parser.tokenCount }), document$3
}
var Parser$1 = class {
  constructor(source, options$2 = {}) {
    let sourceObj = isSource(source) ? source : new Source(source)
    this._lexer = new Lexer(sourceObj), this._options = options$2, this._tokenCounter = 0
  }
  get tokenCount() {
    return this._tokenCounter
  }
  parseName() {
    let token = this.expectToken(TokenKind.NAME)
    return this.node(token, { kind: Kind.NAME, value: token.value })
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
    })
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) return this.parseOperationDefinition()
    let hasDescription = this.peekDescription(),
      keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case `schema`:
          return this.parseSchemaDefinition()
        case `scalar`:
          return this.parseScalarTypeDefinition()
        case `type`:
          return this.parseObjectTypeDefinition()
        case `interface`:
          return this.parseInterfaceTypeDefinition()
        case `union`:
          return this.parseUnionTypeDefinition()
        case `enum`:
          return this.parseEnumTypeDefinition()
        case `input`:
          return this.parseInputObjectTypeDefinition()
        case `directive`:
          return this.parseDirectiveDefinition()
      }
      if (hasDescription) {
        throw syntaxError$1(
          this._lexer.source,
          this._lexer.token.start,
          `Unexpected description, descriptions are supported only on type definitions.`,
        )
      }
      switch (keywordToken.value) {
        case `query`:
        case `mutation`:
        case `subscription`:
          return this.parseOperationDefinition()
        case `fragment`:
          return this.parseFragmentDefinition()
        case `extend`:
          return this.parseTypeSystemExtension()
      }
    }
    throw this.unexpected(keywordToken)
  }
  parseOperationDefinition() {
    let start$2 = this._lexer.token
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start$2, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
      })
    }
    let operation = this.parseOperationType(), name
    return this.peek(TokenKind.NAME) && (name = this.parseName()),
      this.node(start$2, {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
      })
  }
  parseOperationType() {
    let operationToken = this.expectToken(TokenKind.NAME)
    switch (operationToken.value) {
      case `query`:
        return OperationTypeNode.QUERY
      case `mutation`:
        return OperationTypeNode.MUTATION
      case `subscription`:
        return OperationTypeNode.SUBSCRIPTION
    }
    throw this.unexpected(operationToken)
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R)
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives(),
    })
  }
  parseVariable() {
    let start$2 = this._lexer.token
    return this.expectToken(TokenKind.DOLLAR), this.node(start$2, { kind: Kind.VARIABLE, name: this.parseName() })
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
    })
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField()
  }
  parseField() {
    let start$2 = this._lexer.token, nameOrAlias = this.parseName(), alias, name
    return this.expectOptionalToken(TokenKind.COLON)
      ? (alias = nameOrAlias, name = this.parseName())
      : name = nameOrAlias,
      this.node(start$2, {
        kind: Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(!1),
        directives: this.parseDirectives(!1),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
      })
  }
  parseArguments(isConst) {
    let item = isConst ? this.parseConstArgument : this.parseArgument
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R)
  }
  parseArgument(isConst = !1) {
    let start$2 = this._lexer.token, name = this.parseName()
    return this.expectToken(TokenKind.COLON),
      this.node(start$2, { kind: Kind.ARGUMENT, name, value: this.parseValueLiteral(isConst) })
  }
  parseConstArgument() {
    return this.parseArgument(!0)
  }
  parseFragment() {
    let start$2 = this._lexer.token
    this.expectToken(TokenKind.SPREAD)
    let hasTypeCondition = this.expectOptionalKeyword(`on`)
    return !hasTypeCondition && this.peek(TokenKind.NAME)
      ? this.node(start$2, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(!1),
      })
      : this.node(start$2, {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
      })
  }
  parseFragmentDefinition() {
    let start$2 = this._lexer.token
    return this.expectKeyword(`fragment`),
      this._options.allowLegacyFragmentVariables === !0
        ? this.node(start$2, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword(`on`), this.parseNamedType()),
          directives: this.parseDirectives(!1),
          selectionSet: this.parseSelectionSet(),
        })
        : this.node(start$2, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword(`on`), this.parseNamedType()),
          directives: this.parseDirectives(!1),
          selectionSet: this.parseSelectionSet(),
        })
  }
  parseFragmentName() {
    if (this._lexer.token.value === `on`) throw this.unexpected()
    return this.parseName()
  }
  parseValueLiteral(isConst) {
    let token = this._lexer.token
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst)
      case TokenKind.BRACE_L:
        return this.parseObject(isConst)
      case TokenKind.INT:
        return this.advanceLexer(), this.node(token, { kind: Kind.INT, value: token.value })
      case TokenKind.FLOAT:
        return this.advanceLexer(), this.node(token, { kind: Kind.FLOAT, value: token.value })
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral()
      case TokenKind.NAME:
        switch (this.advanceLexer(), token.value) {
          case `true`:
            return this.node(token, { kind: Kind.BOOLEAN, value: !0 })
          case `false`:
            return this.node(token, { kind: Kind.BOOLEAN, value: !1 })
          case `null`:
            return this.node(token, { kind: Kind.NULL })
          default:
            return this.node(token, { kind: Kind.ENUM, value: token.value })
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          if (this.expectToken(TokenKind.DOLLAR), this._lexer.token.kind === TokenKind.NAME) {
            let varName = this._lexer.token.value
            throw syntaxError$1(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`)
          } else throw this.unexpected(token)
        }
        return this.parseVariable()
      default:
        throw this.unexpected()
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0)
  }
  parseStringLiteral() {
    let token = this._lexer.token
    return this.advanceLexer(),
      this.node(token, { kind: Kind.STRING, value: token.value, block: token.kind === TokenKind.BLOCK_STRING })
  }
  parseList(isConst) {
    let item = () => this.parseValueLiteral(isConst)
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
    })
  }
  parseObject(isConst) {
    let item = () => this.parseObjectField(isConst)
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
    })
  }
  parseObjectField(isConst) {
    let start$2 = this._lexer.token, name = this.parseName()
    return this.expectToken(TokenKind.COLON),
      this.node(start$2, { kind: Kind.OBJECT_FIELD, name, value: this.parseValueLiteral(isConst) })
  }
  parseDirectives(isConst) {
    let directives = []
    for (; this.peek(TokenKind.AT);) directives.push(this.parseDirective(isConst))
    return directives
  }
  parseConstDirectives() {
    return this.parseDirectives(!0)
  }
  parseDirective(isConst) {
    let start$2 = this._lexer.token
    return this.expectToken(TokenKind.AT),
      this.node(start$2, { kind: Kind.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(isConst) })
  }
  parseTypeReference() {
    let start$2 = this._lexer.token, type$2
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      let innerType = this.parseTypeReference()
      this.expectToken(TokenKind.BRACKET_R), type$2 = this.node(start$2, { kind: Kind.LIST_TYPE, type: innerType })
    } else type$2 = this.parseNamedType()
    return this.expectOptionalToken(TokenKind.BANG)
      ? this.node(start$2, { kind: Kind.NON_NULL_TYPE, type: type$2 })
      : type$2
  }
  parseNamedType() {
    return this.node(this._lexer.token, { kind: Kind.NAMED_TYPE, name: this.parseName() })
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING)
  }
  parseDescription() {
    if (this.peekDescription()) return this.parseStringLiteral()
  }
  parseSchemaDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`schema`)
    let directives = this.parseConstDirectives(),
      operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R)
    return this.node(start$2, { kind: Kind.SCHEMA_DEFINITION, description, directives, operationTypes })
  }
  parseOperationTypeDefinition() {
    let start$2 = this._lexer.token, operation = this.parseOperationType()
    this.expectToken(TokenKind.COLON)
    let type$2 = this.parseNamedType()
    return this.node(start$2, { kind: Kind.OPERATION_TYPE_DEFINITION, operation, type: type$2 })
  }
  parseScalarTypeDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`scalar`)
    let name = this.parseName(), directives = this.parseConstDirectives()
    return this.node(start$2, { kind: Kind.SCALAR_TYPE_DEFINITION, description, name, directives })
  }
  parseObjectTypeDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`type`)
    let name = this.parseName(),
      interfaces = this.parseImplementsInterfaces(),
      directives = this.parseConstDirectives(),
      fields = this.parseFieldsDefinition()
    return this.node(start$2, { kind: Kind.OBJECT_TYPE_DEFINITION, description, name, interfaces, directives, fields })
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword(`implements`) ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : []
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R)
  }
  parseFieldDefinition() {
    let start$2 = this._lexer.token,
      description = this.parseDescription(),
      name = this.parseName(),
      args$1 = this.parseArgumentDefs()
    this.expectToken(TokenKind.COLON)
    let type$2 = this.parseTypeReference(), directives = this.parseConstDirectives()
    return this.node(start$2, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args$1,
      type: type$2,
      directives,
    })
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R)
  }
  parseInputValueDef() {
    let start$2 = this._lexer.token, description = this.parseDescription(), name = this.parseName()
    this.expectToken(TokenKind.COLON)
    let type$2 = this.parseTypeReference(), defaultValue
    this.expectOptionalToken(TokenKind.EQUALS) && (defaultValue = this.parseConstValueLiteral())
    let directives = this.parseConstDirectives()
    return this.node(start$2, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type: type$2,
      defaultValue,
      directives,
    })
  }
  parseInterfaceTypeDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`interface`)
    let name = this.parseName(),
      interfaces = this.parseImplementsInterfaces(),
      directives = this.parseConstDirectives(),
      fields = this.parseFieldsDefinition()
    return this.node(start$2, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields,
    })
  }
  parseUnionTypeDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`union`)
    let name = this.parseName(), directives = this.parseConstDirectives(), types = this.parseUnionMemberTypes()
    return this.node(start$2, { kind: Kind.UNION_TYPE_DEFINITION, description, name, directives, types })
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : []
  }
  parseEnumTypeDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`enum`)
    let name = this.parseName(), directives = this.parseConstDirectives(), values$6 = this.parseEnumValuesDefinition()
    return this.node(start$2, { kind: Kind.ENUM_TYPE_DEFINITION, description, name, directives, values: values$6 })
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R)
  }
  parseEnumValueDefinition() {
    let start$2 = this._lexer.token,
      description = this.parseDescription(),
      name = this.parseEnumValueName(),
      directives = this.parseConstDirectives()
    return this.node(start$2, { kind: Kind.ENUM_VALUE_DEFINITION, description, name, directives })
  }
  parseEnumValueName() {
    if (
      this._lexer.token.value === `true` || this._lexer.token.value === `false` || this._lexer.token.value === `null`
    ) {
      throw syntaxError$1(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`,
      )
    }
    return this.parseName()
  }
  parseInputObjectTypeDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`input`)
    let name = this.parseName(), directives = this.parseConstDirectives(), fields = this.parseInputFieldsDefinition()
    return this.node(start$2, { kind: Kind.INPUT_OBJECT_TYPE_DEFINITION, description, name, directives, fields })
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R)
  }
  parseTypeSystemExtension() {
    let keywordToken = this._lexer.lookahead()
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case `schema`:
          return this.parseSchemaExtension()
        case `scalar`:
          return this.parseScalarTypeExtension()
        case `type`:
          return this.parseObjectTypeExtension()
        case `interface`:
          return this.parseInterfaceTypeExtension()
        case `union`:
          return this.parseUnionTypeExtension()
        case `enum`:
          return this.parseEnumTypeExtension()
        case `input`:
          return this.parseInputObjectTypeExtension()
      }
    }
    throw this.unexpected(keywordToken)
  }
  parseSchemaExtension() {
    let start$2 = this._lexer.token
    this.expectKeyword(`extend`), this.expectKeyword(`schema`)
    let directives = this.parseConstDirectives(),
      operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R)
    if (directives.length === 0 && operationTypes.length === 0) throw this.unexpected()
    return this.node(start$2, { kind: Kind.SCHEMA_EXTENSION, directives, operationTypes })
  }
  parseScalarTypeExtension() {
    let start$2 = this._lexer.token
    this.expectKeyword(`extend`), this.expectKeyword(`scalar`)
    let name = this.parseName(), directives = this.parseConstDirectives()
    if (directives.length === 0) throw this.unexpected()
    return this.node(start$2, { kind: Kind.SCALAR_TYPE_EXTENSION, name, directives })
  }
  parseObjectTypeExtension() {
    let start$2 = this._lexer.token
    this.expectKeyword(`extend`), this.expectKeyword(`type`)
    let name = this.parseName(),
      interfaces = this.parseImplementsInterfaces(),
      directives = this.parseConstDirectives(),
      fields = this.parseFieldsDefinition()
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) throw this.unexpected()
    return this.node(start$2, { kind: Kind.OBJECT_TYPE_EXTENSION, name, interfaces, directives, fields })
  }
  parseInterfaceTypeExtension() {
    let start$2 = this._lexer.token
    this.expectKeyword(`extend`), this.expectKeyword(`interface`)
    let name = this.parseName(),
      interfaces = this.parseImplementsInterfaces(),
      directives = this.parseConstDirectives(),
      fields = this.parseFieldsDefinition()
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) throw this.unexpected()
    return this.node(start$2, { kind: Kind.INTERFACE_TYPE_EXTENSION, name, interfaces, directives, fields })
  }
  parseUnionTypeExtension() {
    let start$2 = this._lexer.token
    this.expectKeyword(`extend`), this.expectKeyword(`union`)
    let name = this.parseName(), directives = this.parseConstDirectives(), types = this.parseUnionMemberTypes()
    if (directives.length === 0 && types.length === 0) throw this.unexpected()
    return this.node(start$2, { kind: Kind.UNION_TYPE_EXTENSION, name, directives, types })
  }
  parseEnumTypeExtension() {
    let start$2 = this._lexer.token
    this.expectKeyword(`extend`), this.expectKeyword(`enum`)
    let name = this.parseName(), directives = this.parseConstDirectives(), values$6 = this.parseEnumValuesDefinition()
    if (directives.length === 0 && values$6.length === 0) throw this.unexpected()
    return this.node(start$2, { kind: Kind.ENUM_TYPE_EXTENSION, name, directives, values: values$6 })
  }
  parseInputObjectTypeExtension() {
    let start$2 = this._lexer.token
    this.expectKeyword(`extend`), this.expectKeyword(`input`)
    let name = this.parseName(), directives = this.parseConstDirectives(), fields = this.parseInputFieldsDefinition()
    if (directives.length === 0 && fields.length === 0) throw this.unexpected()
    return this.node(start$2, { kind: Kind.INPUT_OBJECT_TYPE_EXTENSION, name, directives, fields })
  }
  parseDirectiveDefinition() {
    let start$2 = this._lexer.token, description = this.parseDescription()
    this.expectKeyword(`directive`), this.expectToken(TokenKind.AT)
    let name = this.parseName(),
      args$1 = this.parseArgumentDefs(),
      repeatable = this.expectOptionalKeyword(`repeatable`)
    this.expectKeyword(`on`)
    let locations = this.parseDirectiveLocations()
    return this.node(start$2, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args$1,
      repeatable,
      locations,
    })
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation)
  }
  parseDirectiveLocation() {
    let start$2 = this._lexer.token, name = this.parseName()
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) return name
    throw this.unexpected(start$2)
  }
  node(startToken, node$1) {
    return this._options.noLocation !== !0
      && (node$1.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source)),
      node$1
  }
  peek(kind) {
    return this._lexer.token.kind === kind
  }
  expectToken(kind) {
    let token = this._lexer.token
    if (token.kind === kind) return this.advanceLexer(), token
    throw syntaxError$1(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,
    )
  }
  expectOptionalToken(kind) {
    let token = this._lexer.token
    return token.kind === kind ? (this.advanceLexer(), !0) : !1
  }
  expectKeyword(value$2) {
    let token = this._lexer.token
    if (token.kind === TokenKind.NAME && token.value === value$2) this.advanceLexer()
    else throw syntaxError$1(this._lexer.source, token.start, `Expected "${value$2}", found ${getTokenDesc(token)}.`)
  }
  expectOptionalKeyword(value$2) {
    let token = this._lexer.token
    return token.kind === TokenKind.NAME && token.value === value$2 ? (this.advanceLexer(), !0) : !1
  }
  unexpected(atToken) {
    let token = atToken ?? this._lexer.token
    return syntaxError$1(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`)
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind)
    let nodes = []
    for (; !this.expectOptionalToken(closeKind);) nodes.push(parseFn.call(this))
    return nodes
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      let nodes = []
      do nodes.push(parseFn.call(this))
      while (!this.expectOptionalToken(closeKind))
      return nodes
    }
    return []
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind)
    let nodes = []
    do nodes.push(parseFn.call(this))
    while (!this.expectOptionalToken(closeKind))
    return nodes
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind)
    let nodes = []
    do nodes.push(parseFn.call(this))
    while (this.expectOptionalToken(delimiterKind))
    return nodes
  }
  advanceLexer() {
    let { maxTokens } = this._options, token = this._lexer.advance()
    if (
      token.kind !== TokenKind.EOF && (++this._tokenCounter, maxTokens !== void 0 && this._tokenCounter > maxTokens)
    ) {
      throw syntaxError$1(
        this._lexer.source,
        token.start,
        `Document contains more that ${maxTokens} tokens. Parsing aborted.`,
      )
    }
  }
}
function getTokenDesc(token) {
  let value$2 = token.value
  return getTokenKindDesc(token.kind) + (value$2 == null ? `` : ` "${value$2}"`)
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind
}
const MAX_SUGGESTIONS = 5
function didYouMean(firstArg, secondArg) {
  let [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg], message = ` Did you mean `
  subMessage && (message += subMessage + ` `)
  let suggestions = suggestionsArg.map(x$2 => `"${x$2}"`)
  switch (suggestions.length) {
    case 0:
      return ``
    case 1:
      return message + suggestions[0] + `?`
    case 2:
      return message + suggestions[0] + ` or ` + suggestions[1] + `?`
  }
  let selected = suggestions.slice(0, MAX_SUGGESTIONS), lastItem = selected.pop()
  return message + selected.join(`, `) + `, or ` + lastItem + `?`
}
function identityFunc(x$2) {
  return x$2
}
function keyMap(list$3, keyFn) {
  let result = Object.create(null)
  for (let item of list$3) result[keyFn(item)] = item
  return result
}
function keyValMap(list$3, keyFn, valFn) {
  let result = Object.create(null)
  for (let item of list$3) result[keyFn(item)] = valFn(item)
  return result
}
function mapValue(map$20, fn) {
  let result = Object.create(null)
  for (let key$1 of Object.keys(map$20)) result[key$1] = fn(map$20[key$1], key$1)
  return result
}
function naturalCompare(aStr, bStr) {
  let aIndex = 0, bIndex = 0
  for (; aIndex < aStr.length && bIndex < bStr.length;) {
    let aChar = aStr.charCodeAt(aIndex), bChar = bStr.charCodeAt(bIndex)
    if (isDigit(aChar) && isDigit(bChar)) {
      let aNum = 0
      do ++aIndex, aNum = aNum * 10 + aChar - DIGIT_0, aChar = aStr.charCodeAt(aIndex)
      while (isDigit(aChar) && aNum > 0)
      let bNum = 0
      do ++bIndex, bNum = bNum * 10 + bChar - DIGIT_0, bChar = bStr.charCodeAt(bIndex)
      while (isDigit(bChar) && bNum > 0)
      if (aNum < bNum) return -1
      if (aNum > bNum) return 1
    } else {
      if (aChar < bChar) return -1
      if (aChar > bChar) return 1
      ;++aIndex, ++bIndex
    }
  }
  return aStr.length - bStr.length
}
const DIGIT_0 = 48, DIGIT_9 = 57
function isDigit(code$3) {
  return !isNaN(code$3) && DIGIT_0 <= code$3 && code$3 <= DIGIT_9
}
function suggestionList(input, options$2) {
  let optionsByDistance = Object.create(null),
    lexicalDistance = new LexicalDistance(input),
    threshold = Math.floor(input.length * .4) + 1
  for (let option$5 of options$2) {
    let distance = lexicalDistance.measure(option$5, threshold)
    distance !== void 0 && (optionsByDistance[option$5] = distance)
  }
  return Object.keys(optionsByDistance).sort((a$22, b$3) => {
    let distanceDiff = optionsByDistance[a$22] - optionsByDistance[b$3]
    return distanceDiff === 0 ? naturalCompare(a$22, b$3) : distanceDiff
  })
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input,
      this._inputLowerCase = input.toLowerCase(),
      this._inputArray = stringToArray(this._inputLowerCase),
      this._rows = [Array(input.length + 1).fill(0), Array(input.length + 1).fill(0), Array(input.length + 1).fill(0)]
  }
  measure(option$5, threshold) {
    if (this._input === option$5) return 0
    let optionLowerCase = option$5.toLowerCase()
    if (this._inputLowerCase === optionLowerCase) return 1
    let a$22 = stringToArray(optionLowerCase), b$3 = this._inputArray
    if (a$22.length < b$3.length) {
      let tmp = a$22
      a$22 = b$3, b$3 = tmp
    }
    let aLength = a$22.length, bLength = b$3.length
    if (aLength - bLength > threshold) return
    let rows = this._rows
    for (let j$1 = 0; j$1 <= bLength; j$1++) rows[0][j$1] = j$1
    for (let i$14 = 1; i$14 <= aLength; i$14++) {
      let upRow = rows[(i$14 - 1) % 3], currentRow = rows[i$14 % 3], smallestCell = currentRow[0] = i$14
      for (let j$1 = 1; j$1 <= bLength; j$1++) {
        let cost = a$22[i$14 - 1] === b$3[j$1 - 1] ? 0 : 1,
          currentCell = Math.min(upRow[j$1] + 1, currentRow[j$1 - 1] + 1, upRow[j$1 - 1] + cost)
        if (i$14 > 1 && j$1 > 1 && a$22[i$14 - 1] === b$3[j$1 - 2] && a$22[i$14 - 2] === b$3[j$1 - 1]) {
          let doubleDiagonalCell = rows[(i$14 - 2) % 3][j$1 - 2]
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1)
        }
        currentCell < smallestCell && (smallestCell = currentCell), currentRow[j$1] = currentCell
      }
      if (smallestCell > threshold) return
    }
    let distance = rows[aLength % 3][bLength]
    return distance <= threshold ? distance : void 0
  }
}
function stringToArray(str) {
  let strLength = str.length, array$3 = Array(strLength)
  for (let i$14 = 0; i$14 < strLength; ++i$14) array$3[i$14] = str.charCodeAt(i$14)
  return array$3
}
function toObjMap(obj) {
  if (obj == null) return Object.create(null)
  if (Object.getPrototypeOf(obj) === null) return obj
  let map$20 = Object.create(null)
  for (let [key$1, value$2] of Object.entries(obj)) map$20[key$1] = value$2
  return map$20
}
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)]
}
const escapeSequences =
    `\\u0000.\\u0001.\\u0002.\\u0003.\\u0004.\\u0005.\\u0006.\\u0007.\\b.\\t.\\n.\\u000B.\\f.\\r.\\u000E.\\u000F.\\u0010.\\u0011.\\u0012.\\u0013.\\u0014.\\u0015.\\u0016.\\u0017.\\u0018.\\u0019.\\u001A.\\u001B.\\u001C.\\u001D.\\u001E.\\u001F...\\"..........................................................\\\\...................................\\u007F.\\u0080.\\u0081.\\u0082.\\u0083.\\u0084.\\u0085.\\u0086.\\u0087.\\u0088.\\u0089.\\u008A.\\u008B.\\u008C.\\u008D.\\u008E.\\u008F.\\u0090.\\u0091.\\u0092.\\u0093.\\u0094.\\u0095.\\u0096.\\u0097.\\u0098.\\u0099.\\u009A.\\u009B.\\u009C.\\u009D.\\u009E.\\u009F`
      .split(`.`),
  BREAK = Object.freeze({})
function visit$1(root$5, visitor, visitorKeys = QueryDocumentKeys) {
  let enterLeaveMap = new Map()
  for (let kind of Object.values(Kind)) enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind))
  let stack,
    inArray = Array.isArray(root$5),
    keys$6 = [root$5],
    index$4 = -1,
    edits = [],
    node$1 = root$5,
    key$1,
    parent,
    path$1 = [],
    ancestors = []
  do {
    index$4++
    let isLeaving = index$4 === keys$6.length, isEdited = isLeaving && edits.length !== 0
    if (isLeaving) {
      if (
        key$1 = ancestors.length === 0 ? void 0 : path$1[path$1.length - 1],
          node$1 = parent,
          parent = ancestors.pop(),
          isEdited
      ) {
        if (inArray) {
          node$1 = node$1.slice()
          let editOffset = 0
          for (let [editKey, editValue] of edits) {
            let arrayKey = editKey - editOffset
            editValue === null ? (node$1.splice(arrayKey, 1), editOffset++) : node$1[arrayKey] = editValue
          }
        } else {
          node$1 = { ...node$1 }
          for (let [editKey, editValue] of edits) node$1[editKey] = editValue
        }
      }
      index$4 = stack.index, keys$6 = stack.keys, edits = stack.edits, inArray = stack.inArray, stack = stack.prev
    } else if (parent) {
      if (key$1 = inArray ? index$4 : keys$6[index$4], node$1 = parent[key$1], node$1 == null) continue
      path$1.push(key$1)
    }
    let result
    if (!Array.isArray(node$1)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2
      isNode$1(node$1) || devAssert(!1, `Invalid AST Node: ${inspect(node$1)}.`)
      let visitFn = isLeaving
        ? (_enterLeaveMap$get = enterLeaveMap.get(node$1.kind))?.leave
        : (_enterLeaveMap$get2 = enterLeaveMap.get(node$1.kind))?.enter
      if (result = visitFn?.call(visitor, node$1, key$1, parent, path$1, ancestors), result === BREAK) break
      if (result === !1) {
        if (!isLeaving) {
          path$1.pop()
          continue
        }
      } else if (result !== void 0 && (edits.push([key$1, result]), !isLeaving)) {
        if (isNode$1(result)) node$1 = result
        else {
          path$1.pop()
          continue
        }
      }
    }
    if (result === void 0 && isEdited && edits.push([key$1, node$1]), isLeaving) path$1.pop()
    else {
      var _node$kind
      stack = { inArray, index: index$4, keys: keys$6, edits, prev: stack },
        inArray = Array.isArray(node$1),
        keys$6 = inArray ? node$1 : (_node$kind = visitorKeys[node$1.kind]) ?? [],
        index$4 = -1,
        edits = [],
        parent && ancestors.push(parent),
        parent = node$1
    }
  } while (stack !== void 0)
  return edits.length === 0 ? root$5 : edits[edits.length - 1][1]
}
function visitInParallel(visitors) {
  let skipping = Array(visitors.length).fill(null), mergedVisitor = Object.create(null)
  for (let kind of Object.values(Kind)) {
    let hasVisitor = !1,
      enterList = Array(visitors.length).fill(void 0),
      leaveList = Array(visitors.length).fill(void 0)
    for (let i$14 = 0; i$14 < visitors.length; ++i$14) {
      let { enter, leave } = getEnterLeaveForKind(visitors[i$14], kind)
      hasVisitor ||= enter != null || leave != null, enterList[i$14] = enter, leaveList[i$14] = leave
    }
    if (!hasVisitor) continue
    let mergedEnterLeave = {
      enter(...args$1) {
        let node$1 = args$1[0]
        for (let i$14 = 0; i$14 < visitors.length; i$14++) {
          if (skipping[i$14] === null) {
            var _enterList$i
            let result = (_enterList$i = enterList[i$14])?.apply(visitors[i$14], args$1)
            if (result === !1) skipping[i$14] = node$1
            else if (result === BREAK) skipping[i$14] = BREAK
            else if (result !== void 0) return result
          }
        }
      },
      leave(...args$1) {
        let node$1 = args$1[0]
        for (let i$14 = 0; i$14 < visitors.length; i$14++) {
          if (skipping[i$14] === null) {
            var _leaveList$i
            let result = (_leaveList$i = leaveList[i$14])?.apply(visitors[i$14], args$1)
            if (result === BREAK) skipping[i$14] = BREAK
            else if (result !== void 0 && result !== !1) return result
          } else skipping[i$14] === node$1 && (skipping[i$14] = null)
        }
      },
    }
    mergedVisitor[kind] = mergedEnterLeave
  }
  return mergedVisitor
}
function getEnterLeaveForKind(visitor, kind) {
  let kindVisitor = visitor[kind]
  return typeof kindVisitor == `object`
    ? kindVisitor
    : typeof kindVisitor == `function`
    ? { enter: kindVisitor, leave: void 0 }
    : { enter: visitor.enter, leave: visitor.leave }
}
function print(ast) {
  return visit$1(ast, printDocASTReducer)
}
const MAX_LINE_LENGTH = 80,
  printDocASTReducer = {
    Name: { leave: node$1 => node$1.value },
    Variable: { leave: node$1 => `$` + node$1.name },
    Document: {
      leave: node$1 =>
        join$2(
          node$1.definitions,
          `

`,
        ),
    },
    OperationDefinition: {
      leave(node$1) {
        let varDefs = wrap$2(`(`, join$2(node$1.variableDefinitions, `, `), `)`),
          prefix$1 = join$2([node$1.operation, join$2([node$1.name, varDefs]), join$2(node$1.directives, ` `)], ` `)
        return (prefix$1 === `query` ? `` : prefix$1 + ` `) + node$1.selectionSet
      },
    },
    VariableDefinition: {
      leave: ({ variable, type: type$2, defaultValue, directives }) =>
        variable + `: ` + type$2 + wrap$2(` = `, defaultValue) + wrap$2(` `, join$2(directives, ` `)),
    },
    SelectionSet: { leave: ({ selections }) => block(selections) },
    Field: {
      leave({ alias, name, arguments: args$1, directives, selectionSet }) {
        let prefix$1 = wrap$2(``, alias, `: `) + name, argsLine = prefix$1 + wrap$2(`(`, join$2(args$1, `, `), `)`)
        return argsLine.length > MAX_LINE_LENGTH && (argsLine = prefix$1 + wrap$2(
          `(
`,
          indent$1(join$2(
            args$1,
            `
`,
          )),
          `
)`,
        )),
          join$2([argsLine, join$2(directives, ` `), selectionSet], ` `)
      },
    },
    Argument: { leave: ({ name, value: value$2 }) => name + `: ` + value$2 },
    FragmentSpread: { leave: ({ name, directives }) => `...` + name + wrap$2(` `, join$2(directives, ` `)) },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) =>
        join$2([`...`, wrap$2(`on `, typeCondition), join$2(directives, ` `), selectionSet], ` `),
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) =>
        `fragment ${name}${wrap$2(`(`, join$2(variableDefinitions, `, `), `)`)} on ${typeCondition} ${
          wrap$2(``, join$2(directives, ` `), ` `)
        }` + selectionSet,
    },
    IntValue: { leave: ({ value: value$2 }) => value$2 },
    FloatValue: { leave: ({ value: value$2 }) => value$2 },
    StringValue: {
      leave: ({ value: value$2, block: isBlockString }) =>
        isBlockString ? printBlockString(value$2) : printString(value$2),
    },
    BooleanValue: { leave: ({ value: value$2 }) => value$2 ? `true` : `false` },
    NullValue: { leave: () => `null` },
    EnumValue: { leave: ({ value: value$2 }) => value$2 },
    ListValue: { leave: ({ values: values$6 }) => `[` + join$2(values$6, `, `) + `]` },
    ObjectValue: { leave: ({ fields }) => `{` + join$2(fields, `, `) + `}` },
    ObjectField: { leave: ({ name, value: value$2 }) => name + `: ` + value$2 },
    Directive: { leave: ({ name, arguments: args$1 }) => `@` + name + wrap$2(`(`, join$2(args$1, `, `), `)`) },
    NamedType: { leave: ({ name }) => name },
    ListType: { leave: ({ type: type$2 }) => `[` + type$2 + `]` },
    NonNullType: { leave: ({ type: type$2 }) => type$2 + `!` },
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + join$2([`schema`, join$2(directives, ` `), block(operationTypes)], ` `),
    },
    OperationTypeDefinition: { leave: ({ operation, type: type$2 }) => operation + `: ` + type$2 },
    ScalarTypeDefinition: {
      leave: ({ description, name, directives }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + join$2([`scalar`, name, join$2(directives, ` `)], ` `),
    },
    ObjectTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) =>
        wrap$2(
          ``,
          description,
          `
`,
        )
        + join$2([
          `type`,
          name,
          wrap$2(`implements `, join$2(interfaces, ` & `)),
          join$2(directives, ` `),
          block(fields),
        ], ` `),
    },
    FieldDefinition: {
      leave: ({ description, name, arguments: args$1, type: type$2, directives }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + name + (hasMultilineItems(args$1)
          ? wrap$2(
            `(
`,
            indent$1(join$2(
              args$1,
              `
`,
            )),
            `
)`,
          )
          : wrap$2(`(`, join$2(args$1, `, `), `)`))
        + `: ` + type$2 + wrap$2(` `, join$2(directives, ` `)),
    },
    InputValueDefinition: {
      leave: ({ description, name, type: type$2, defaultValue, directives }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + join$2([name + `: ` + type$2, wrap$2(`= `, defaultValue), join$2(directives, ` `)], ` `),
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) =>
        wrap$2(
          ``,
          description,
          `
`,
        )
        + join$2([
          `interface`,
          name,
          wrap$2(`implements `, join$2(interfaces, ` & `)),
          join$2(directives, ` `),
          block(fields),
        ], ` `),
    },
    UnionTypeDefinition: {
      leave: ({ description, name, directives, types }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + join$2([`union`, name, join$2(directives, ` `), wrap$2(`= `, join$2(types, ` | `))], ` `),
    },
    EnumTypeDefinition: {
      leave: ({ description, name, directives, values: values$6 }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + join$2([`enum`, name, join$2(directives, ` `), block(values$6)], ` `),
    },
    EnumValueDefinition: {
      leave: ({ description, name, directives }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + join$2([name, join$2(directives, ` `)], ` `),
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name, directives, fields }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + join$2([`input`, name, join$2(directives, ` `), block(fields)], ` `),
    },
    DirectiveDefinition: {
      leave: ({ description, name, arguments: args$1, repeatable, locations }) =>
        wrap$2(
          ``,
          description,
          `
`,
        ) + `directive @` + name + (hasMultilineItems(args$1)
          ? wrap$2(
            `(
`,
            indent$1(join$2(
              args$1,
              `
`,
            )),
            `
)`,
          )
          : wrap$2(`(`, join$2(args$1, `, `), `)`))
        + (repeatable ? ` repeatable` : ``) + ` on ` + join$2(locations, ` | `),
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) =>
        join$2([`extend schema`, join$2(directives, ` `), block(operationTypes)], ` `),
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join$2([`extend scalar`, name, join$2(directives, ` `)], ` `),
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) =>
        join$2([
          `extend type`,
          name,
          wrap$2(`implements `, join$2(interfaces, ` & `)),
          join$2(directives, ` `),
          block(fields),
        ], ` `),
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) =>
        join$2([
          `extend interface`,
          name,
          wrap$2(`implements `, join$2(interfaces, ` & `)),
          join$2(directives, ` `),
          block(fields),
        ], ` `),
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types }) =>
        join$2([`extend union`, name, join$2(directives, ` `), wrap$2(`= `, join$2(types, ` | `))], ` `),
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values: values$6 }) =>
        join$2([`extend enum`, name, join$2(directives, ` `), block(values$6)], ` `),
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) =>
        join$2([`extend input`, name, join$2(directives, ` `), block(fields)], ` `),
    },
  }
function join$2(maybeArray, separator = ``) {
  var _maybeArray$filter$jo
  return (_maybeArray$filter$jo = maybeArray?.filter(x$2 => x$2).join(separator)) ?? ``
}
function block(array$3) {
  return wrap$2(
    `{
`,
    indent$1(join$2(
      array$3,
      `
`,
    )),
    `
}`,
  )
}
function wrap$2(start$2, maybeString, end$2 = ``) {
  return maybeString != null && maybeString !== `` ? start$2 + maybeString + end$2 : ``
}
function indent$1(str) {
  return wrap$2(
    `  `,
    str.replace(
      /\n/g,
      `
  `,
    ),
  )
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some
  return (_maybeArray$some = maybeArray?.some(str =>
    str.includes(`
`)
  )) ?? !1
}
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null
    case Kind.INT:
      return parseInt(valueNode.value, 10)
    case Kind.FLOAT:
      return parseFloat(valueNode.value)
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value
    case Kind.LIST:
      return valueNode.values.map(node$1 => valueFromASTUntyped(node$1, variables))
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        field => field.name.value,
        field => valueFromASTUntyped(field.value, variables),
      )
    case Kind.VARIABLE:
      return variables?.[valueNode.name.value]
  }
}
function assertName(name) {
  if (
    name ?? devAssert(!1, `Must provide name.`),
      typeof name == `string` || devAssert(!1, `Expected name to be a string.`),
      name.length === 0
  ) throw new GraphQLError(`Expected name to be a non-empty string.`)
  for (let i$14 = 1; i$14 < name.length; ++i$14) {
    if (!isNameContinue(name.charCodeAt(i$14))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`)
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`)
  }
  return name
}
function assertEnumValueName(name) {
  if (name === `true` || name === `false` || name === `null`) {
    throw new GraphQLError(`Enum values cannot be named: ${name}`)
  }
  return assertName(name)
}
function isType(type$2) {
  return isScalarType(type$2) || isObjectType(type$2) || isInterfaceType(type$2) || isUnionType(type$2)
    || isEnumType(type$2) || isInputObjectType(type$2) || isListType(type$2) || isNonNullType(type$2)
}
function isScalarType(type$2) {
  return instanceOf(type$2, GraphQLScalarType)
}
function isObjectType(type$2) {
  return instanceOf(type$2, GraphQLObjectType)
}
function isInterfaceType(type$2) {
  return instanceOf(type$2, GraphQLInterfaceType)
}
function isUnionType(type$2) {
  return instanceOf(type$2, GraphQLUnionType)
}
function isEnumType(type$2) {
  return instanceOf(type$2, GraphQLEnumType)
}
function isInputObjectType(type$2) {
  return instanceOf(type$2, GraphQLInputObjectType)
}
function isListType(type$2) {
  return instanceOf(type$2, GraphQLList)
}
function isNonNullType(type$2) {
  return instanceOf(type$2, GraphQLNonNull)
}
function isInputType(type$2) {
  return isScalarType(type$2) || isEnumType(type$2) || isInputObjectType(type$2)
    || isWrappingType(type$2) && isInputType(type$2.ofType)
}
function isOutputType(type$2) {
  return isScalarType(type$2) || isObjectType(type$2) || isInterfaceType(type$2) || isUnionType(type$2)
    || isEnumType(type$2) || isWrappingType(type$2) && isOutputType(type$2.ofType)
}
function isLeafType(type$2) {
  return isScalarType(type$2) || isEnumType(type$2)
}
function isCompositeType(type$2) {
  return isObjectType(type$2) || isInterfaceType(type$2) || isUnionType(type$2)
}
function isAbstractType(type$2) {
  return isInterfaceType(type$2) || isUnionType(type$2)
}
var GraphQLList = class {
    constructor(ofType) {
      isType(ofType) || devAssert(!1, `Expected ${inspect(ofType)} to be a GraphQL type.`), this.ofType = ofType
    }
    get [Symbol.toStringTag]() {
      return `GraphQLList`
    }
    toString() {
      return `[` + String(this.ofType) + `]`
    }
    toJSON() {
      return this.toString()
    }
  },
  GraphQLNonNull = class {
    constructor(ofType) {
      isNullableType(ofType) || devAssert(!1, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`),
        this.ofType = ofType
    }
    get [Symbol.toStringTag]() {
      return `GraphQLNonNull`
    }
    toString() {
      return String(this.ofType) + `!`
    }
    toJSON() {
      return this.toString()
    }
  }
function isWrappingType(type$2) {
  return isListType(type$2) || isNonNullType(type$2)
}
function isNullableType(type$2) {
  return isType(type$2) && !isNonNullType(type$2)
}
function getNullableType(type$2) {
  if (type$2) return isNonNullType(type$2) ? type$2.ofType : type$2
}
function isNamedType(type$2) {
  return isScalarType(type$2) || isObjectType(type$2) || isInterfaceType(type$2) || isUnionType(type$2)
    || isEnumType(type$2) || isInputObjectType(type$2)
}
function getNamedType(type$2) {
  if (type$2) {
    let unwrappedType = type$2
    for (; isWrappingType(unwrappedType);) unwrappedType = unwrappedType.ofType
    return unwrappedType
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk == `function` ? thunk() : thunk
}
function resolveObjMapThunk(thunk) {
  return typeof thunk == `function` ? thunk() : thunk
}
var GraphQLScalarType = class {
    constructor(config) {
      var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN
      let parseValue = (_config$parseValue = config.parseValue) ?? identityFunc
      this.name = assertName(config.name),
        this.description = config.description,
        this.specifiedByURL = config.specifiedByURL,
        this.serialize = (_config$serialize = config.serialize) ?? identityFunc,
        this.parseValue = parseValue,
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral)
          ?? ((node$1, variables) => parseValue(valueFromASTUntyped(node$1, variables))),
        this.extensions = toObjMap(config.extensions),
        this.astNode = config.astNode,
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) ?? [],
        config.specifiedByURL == null || typeof config.specifiedByURL == `string`
        || devAssert(
          !1,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`,
        ),
        config.serialize == null || typeof config.serialize == `function`
        || devAssert(
          !1,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`,
        ),
        config.parseLiteral
        && (typeof config.parseValue == `function` && typeof config.parseLiteral == `function`
          || devAssert(!1, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`))
    }
    get [Symbol.toStringTag]() {
      return `GraphQLScalarType`
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        specifiedByURL: this.specifiedByURL,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
      }
    }
    toString() {
      return this.name
    }
    toJSON() {
      return this.toString()
    }
  },
  GraphQLObjectType = class {
    constructor(config) {
      var _config$extensionASTN2
      this.name = assertName(config.name),
        this.description = config.description,
        this.isTypeOf = config.isTypeOf,
        this.extensions = toObjMap(config.extensions),
        this.astNode = config.astNode,
        this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) ?? [],
        this._fields = () => defineFieldMap(config),
        this._interfaces = () => defineInterfaces(config),
        config.isTypeOf == null || typeof config.isTypeOf == `function`
        || devAssert(!1, `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`)
    }
    get [Symbol.toStringTag]() {
      return `GraphQLObjectType`
    }
    getFields() {
      return typeof this._fields == `function` && (this._fields = this._fields()), this._fields
    }
    getInterfaces() {
      return typeof this._interfaces == `function` && (this._interfaces = this._interfaces()), this._interfaces
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
      }
    }
    toString() {
      return this.name
    }
    toJSON() {
      return this.toString()
    }
  }
function defineInterfaces(config) {
  var _config$interfaces
  let interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) ?? [])
  return Array.isArray(interfaces)
    || devAssert(!1, `${config.name} interfaces must be an Array or a function which returns an Array.`),
    interfaces
}
function defineFieldMap(config) {
  let fieldMap = resolveObjMapThunk(config.fields)
  return isPlainObj(fieldMap)
    || devAssert(
      !1,
      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,
    ),
    mapValue(fieldMap, (fieldConfig, fieldName) => {
      var _fieldConfig$args
      isPlainObj(fieldConfig) || devAssert(!1, `${config.name}.${fieldName} field config must be an object.`),
        fieldConfig.resolve == null || typeof fieldConfig.resolve == `function`
        || devAssert(
          !1,
          `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${
            inspect(fieldConfig.resolve)
          }.`,
        )
      let argsConfig = (_fieldConfig$args = fieldConfig.args) ?? {}
      return isPlainObj(argsConfig)
        || devAssert(!1, `${config.name}.${fieldName} args must be an object with argument names as keys.`),
        {
          name: assertName(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          args: defineArguments(argsConfig),
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: toObjMap(fieldConfig.extensions),
          astNode: fieldConfig.astNode,
        }
    })
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode,
  }))
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj)
}
function fieldsToFieldsConfig(fields) {
  return mapValue(
    fields,
    field => ({
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode,
    }),
  )
}
function argsToArgsConfig(args$1) {
  return keyValMap(
    args$1,
    arg => arg.name,
    arg => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode,
    }),
  )
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0
}
var GraphQLInterfaceType = class {
    constructor(config) {
      var _config$extensionASTN3
      this.name = assertName(config.name),
        this.description = config.description,
        this.resolveType = config.resolveType,
        this.extensions = toObjMap(config.extensions),
        this.astNode = config.astNode,
        this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) ?? [],
        this._fields = defineFieldMap.bind(void 0, config),
        this._interfaces = defineInterfaces.bind(void 0, config),
        config.resolveType == null || typeof config.resolveType == `function`
        || devAssert(
          !1,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`,
        )
    }
    get [Symbol.toStringTag]() {
      return `GraphQLInterfaceType`
    }
    getFields() {
      return typeof this._fields == `function` && (this._fields = this._fields()), this._fields
    }
    getInterfaces() {
      return typeof this._interfaces == `function` && (this._interfaces = this._interfaces()), this._interfaces
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: fieldsToFieldsConfig(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
      }
    }
    toString() {
      return this.name
    }
    toJSON() {
      return this.toString()
    }
  },
  GraphQLUnionType = class {
    constructor(config) {
      var _config$extensionASTN4
      this.name = assertName(config.name),
        this.description = config.description,
        this.resolveType = config.resolveType,
        this.extensions = toObjMap(config.extensions),
        this.astNode = config.astNode,
        this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) ?? [],
        this._types = defineTypes.bind(void 0, config),
        config.resolveType == null || typeof config.resolveType == `function`
        || devAssert(
          !1,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`,
        )
    }
    get [Symbol.toStringTag]() {
      return `GraphQLUnionType`
    }
    getTypes() {
      return typeof this._types == `function` && (this._types = this._types()), this._types
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
      }
    }
    toString() {
      return this.name
    }
    toJSON() {
      return this.toString()
    }
  }
function defineTypes(config) {
  let types = resolveReadonlyArrayThunk(config.types)
  return Array.isArray(types)
    || devAssert(!1, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`),
    types
}
var GraphQLEnumType = class {
  constructor(config) {
    var _config$extensionASTN5
    this.name = assertName(config.name),
      this.description = config.description,
      this.extensions = toObjMap(config.extensions),
      this.astNode = config.astNode,
      this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) ?? [],
      this._values = typeof config.values == `function` ? config.values : defineEnumValues(this.name, config.values),
      this._valueLookup = null,
      this._nameLookup = null
  }
  get [Symbol.toStringTag]() {
    return `GraphQLEnumType`
  }
  getValues() {
    return typeof this._values == `function` && (this._values = defineEnumValues(this.name, this._values())),
      this._values
  }
  getValue(name) {
    return this._nameLookup === null && (this._nameLookup = keyMap(this.getValues(), value$2 => value$2.name)),
      this._nameLookup[name]
  }
  serialize(outputValue) {
    this._valueLookup === null
      && (this._valueLookup = new Map(this.getValues().map(enumValue$1 => [enumValue$1.value, enumValue$1])))
    let enumValue = this._valueLookup.get(outputValue)
    if (enumValue === void 0) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`)
    }
    return enumValue.name
  }
  parseValue(inputValue) {
    if (typeof inputValue != `string`) {
      let valueStr = inspect(inputValue)
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
      )
    }
    let enumValue = this.getValue(inputValue)
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue),
      )
    }
    return enumValue.value
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      let valueStr = print(valueNode)
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        { nodes: valueNode },
      )
    }
    let enumValue = this.getValue(valueNode.value)
    if (enumValue == null) {
      let valueStr = print(valueNode)
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        { nodes: valueNode },
      )
    }
    return enumValue.value
  }
  toConfig() {
    let values$6 = keyValMap(
      this.getValues(),
      value$2 => value$2.name,
      value$2 => ({
        description: value$2.description,
        value: value$2.value,
        deprecationReason: value$2.deprecationReason,
        extensions: value$2.extensions,
        astNode: value$2.astNode,
      }),
    )
    return {
      name: this.name,
      description: this.description,
      values: values$6,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
    }
  }
  toString() {
    return this.name
  }
  toJSON() {
    return this.toString()
  }
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  let allNames = enumType.getValues().map(value$2 => value$2.name),
    suggestedValues = suggestionList(unknownValueStr, allNames)
  return didYouMean(`the enum value`, suggestedValues)
}
function defineEnumValues(typeName, valueMap) {
  return isPlainObj(valueMap) || devAssert(!1, `${typeName} values must be an object with value names as keys.`),
    Object.entries(valueMap).map((
      [valueName, valueConfig],
    ) => (isPlainObj(valueConfig)
      || devAssert(
        !1,
        `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${
          inspect(valueConfig)
        }.`,
      ),
      {
        name: assertEnumValueName(valueName),
        description: valueConfig.description,
        value: valueConfig.value === void 0 ? valueName : valueConfig.value,
        deprecationReason: valueConfig.deprecationReason,
        extensions: toObjMap(valueConfig.extensions),
        astNode: valueConfig.astNode,
      })
    )
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf
    this.name = assertName(config.name),
      this.description = config.description,
      this.extensions = toObjMap(config.extensions),
      this.astNode = config.astNode,
      this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) ?? [],
      this.isOneOf = (_config$isOneOf = config.isOneOf) ?? !1,
      this._fields = defineInputFieldMap.bind(void 0, config)
  }
  get [Symbol.toStringTag]() {
    return `GraphQLInputObjectType`
  }
  getFields() {
    return typeof this._fields == `function` && (this._fields = this._fields()), this._fields
  }
  toConfig() {
    let fields = mapValue(
      this.getFields(),
      field => ({
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode,
      }),
    )
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf,
    }
  }
  toString() {
    return this.name
  }
  toJSON() {
    return this.toString()
  }
}
function defineInputFieldMap(config) {
  let fieldMap = resolveObjMapThunk(config.fields)
  return isPlainObj(fieldMap)
    || devAssert(
      !1,
      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,
    ),
    mapValue(
      fieldMap,
      (
        fieldConfig,
        fieldName,
      ) => (!(`resolve` in fieldConfig)
        || devAssert(
          !1,
          `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`,
        ),
        {
          name: assertName(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: toObjMap(fieldConfig.extensions),
          astNode: fieldConfig.astNode,
        }),
    )
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  return maybeSubType === superType
    ? !0
    : isNonNullType(superType)
    ? isNonNullType(maybeSubType) ? isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType) : !1
    : isNonNullType(maybeSubType)
    ? isTypeSubTypeOf(schema, maybeSubType.ofType, superType)
    : isListType(superType)
    ? isListType(maybeSubType) ? isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType) : !1
    : isListType(maybeSubType)
    ? !1
    : isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType))
      && schema.isSubType(superType, maybeSubType)
}
function doTypesOverlap(schema, typeA, typeB) {
  return typeA === typeB
    ? !0
    : isAbstractType(typeA)
    ? isAbstractType(typeB)
      ? schema.getPossibleTypes(typeA).some(type$2 => schema.isSubType(typeB, type$2))
      : schema.isSubType(typeA, typeB)
    : isAbstractType(typeB)
    ? schema.isSubType(typeB, typeA)
    : !1
}
const GRAPHQL_MAX_INT = 2147483647,
  GRAPHQL_MIN_INT = -2147483648,
  GraphQLInt = new GraphQLScalarType({
    name: `Int`,
    description:
      'The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.',
    serialize(outputValue) {
      let coercedValue = serializeObject(outputValue)
      if (typeof coercedValue == `boolean`) return coercedValue ? 1 : 0
      let num = coercedValue
      if (
        typeof coercedValue == `string` && coercedValue !== `` && (num = Number(coercedValue)),
          typeof num != `number` || !Number.isInteger(num)
      ) throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`)
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ` + inspect(coercedValue))
      }
      return num
    },
    parseValue(inputValue) {
      if (typeof inputValue != `number` || !Number.isInteger(inputValue)) {
        throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`)
      }
      if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
        throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`)
      }
      return inputValue
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.INT) {
        throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, { nodes: valueNode })
      }
      let num = parseInt(valueNode.value, 10)
      if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
        throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
          nodes: valueNode,
        })
      }
      return num
    },
  }),
  GraphQLFloat = new GraphQLScalarType({
    name: `Float`,
    description:
      'The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).',
    serialize(outputValue) {
      let coercedValue = serializeObject(outputValue)
      if (typeof coercedValue == `boolean`) return coercedValue ? 1 : 0
      let num = coercedValue
      if (
        typeof coercedValue == `string` && coercedValue !== `` && (num = Number(coercedValue)),
          typeof num != `number` || !Number.isFinite(num)
      ) throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`)
      return num
    },
    parseValue(inputValue) {
      if (typeof inputValue != `number` || !Number.isFinite(inputValue)) {
        throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`)
      }
      return inputValue
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
        throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode)
      }
      return parseFloat(valueNode.value)
    },
  }),
  GraphQLString = new GraphQLScalarType({
    name: `String`,
    description:
      'The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.',
    serialize(outputValue) {
      let coercedValue = serializeObject(outputValue)
      if (typeof coercedValue == `string`) return coercedValue
      if (typeof coercedValue == `boolean`) return coercedValue ? `true` : `false`
      if (typeof coercedValue == `number` && Number.isFinite(coercedValue)) return coercedValue.toString()
      throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`)
    },
    parseValue(inputValue) {
      if (typeof inputValue != `string`) {
        throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`)
      }
      return inputValue
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.STRING) {
        throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, { nodes: valueNode })
      }
      return valueNode.value
    },
  }),
  GraphQLBoolean = new GraphQLScalarType({
    name: `Boolean`,
    description: 'The `Boolean` scalar type represents `true` or `false`.',
    serialize(outputValue) {
      let coercedValue = serializeObject(outputValue)
      if (typeof coercedValue == `boolean`) return coercedValue
      if (Number.isFinite(coercedValue)) return coercedValue !== 0
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`)
    },
    parseValue(inputValue) {
      if (typeof inputValue != `boolean`) {
        throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`)
      }
      return inputValue
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.BOOLEAN) {
        throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {
          nodes: valueNode,
        })
      }
      return valueNode.value
    },
  }),
  GraphQLID = new GraphQLScalarType({
    name: `ID`,
    description:
      'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize(outputValue) {
      let coercedValue = serializeObject(outputValue)
      if (typeof coercedValue == `string`) return coercedValue
      if (Number.isInteger(coercedValue)) return String(coercedValue)
      throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`)
    },
    parseValue(inputValue) {
      if (typeof inputValue == `string`) return inputValue
      if (typeof inputValue == `number` && Number.isInteger(inputValue)) return inputValue.toString()
      throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`)
    },
    parseLiteral(valueNode) {
      if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
        throw new GraphQLError(`ID cannot represent a non-string and non-integer value: ` + print(valueNode), {
          nodes: valueNode,
        })
      }
      return valueNode.value
    },
  }),
  specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID])
function isSpecifiedScalarType(type$2) {
  return specifiedScalarTypes.some(({ name }) => type$2.name === name)
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf == `function`) {
      let valueOfResult = outputValue.valueOf()
      if (!isObjectLike(valueOfResult)) return valueOfResult
    }
    if (typeof outputValue.toJSON == `function`) return outputValue.toJSON()
  }
  return outputValue
}
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective)
}
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args
    this.name = assertName(config.name),
      this.description = config.description,
      this.locations = config.locations,
      this.isRepeatable = (_config$isRepeatable = config.isRepeatable) ?? !1,
      this.extensions = toObjMap(config.extensions),
      this.astNode = config.astNode,
      Array.isArray(config.locations) || devAssert(!1, `@${config.name} locations must be an Array.`)
    let args$1 = (_config$args = config.args) ?? {}
    isObjectLike(args$1) && !Array.isArray(args$1)
    || devAssert(!1, `@${config.name} args must be an object with argument names as keys.`),
      this.args = defineArguments(args$1)
  }
  get [Symbol.toStringTag]() {
    return `GraphQLDirective`
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode,
    }
  }
  toString() {
    return `@` + this.name
  }
  toJSON() {
    return this.toString()
  }
}
const GraphQLIncludeDirective = new GraphQLDirective({
    name: `include`,
    description: 'Directs the executor to include this field or fragment only when the `if` argument is true.',
    locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
    args: { if: { type: new GraphQLNonNull(GraphQLBoolean), description: `Included when true.` } },
  }),
  GraphQLSkipDirective = new GraphQLDirective({
    name: `skip`,
    description: 'Directs the executor to skip this field or fragment when the `if` argument is true.',
    locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
    args: { if: { type: new GraphQLNonNull(GraphQLBoolean), description: `Skipped when true.` } },
  }),
  DEFAULT_DEPRECATION_REASON = `No longer supported`,
  GraphQLDeprecatedDirective = new GraphQLDirective({
    name: `deprecated`,
    description: `Marks an element of a GraphQL schema as no longer supported.`,
    locations: [
      DirectiveLocation.FIELD_DEFINITION,
      DirectiveLocation.ARGUMENT_DEFINITION,
      DirectiveLocation.INPUT_FIELD_DEFINITION,
      DirectiveLocation.ENUM_VALUE,
    ],
    args: {
      reason: {
        type: GraphQLString,
        description:
          `Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).`,
        defaultValue: DEFAULT_DEPRECATION_REASON,
      },
    },
  }),
  GraphQLSpecifiedByDirective = new GraphQLDirective({
    name: `specifiedBy`,
    description: `Exposes a URL that specifies the behavior of this scalar.`,
    locations: [DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new GraphQLNonNull(GraphQLString),
        description: `The URL that specifies the behavior of this scalar.`,
      },
    },
  }),
  GraphQLOneOfDirective = new GraphQLDirective({
    name: `oneOf`,
    description: 'Indicates exactly one field must be supplied and this field must not be `null`.',
    locations: [DirectiveLocation.INPUT_OBJECT],
    args: {},
  }),
  specifiedDirectives = Object.freeze([
    GraphQLIncludeDirective,
    GraphQLSkipDirective,
    GraphQLDeprecatedDirective,
    GraphQLSpecifiedByDirective,
    GraphQLOneOfDirective,
  ])
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name)
}
function isIterableObject(maybeIterable) {
  return typeof maybeIterable == `object` && typeof maybeIterable?.[Symbol.iterator] == `function`
}
function astFromValue(value$2, type$2) {
  if (isNonNullType(type$2)) {
    let astValue = astFromValue(value$2, type$2.ofType)
    return astValue?.kind === Kind.NULL ? null : astValue
  }
  if (value$2 === null) return { kind: Kind.NULL }
  if (value$2 === void 0) return null
  if (isListType(type$2)) {
    let itemType = type$2.ofType
    if (isIterableObject(value$2)) {
      let valuesNodes = []
      for (let item of value$2) {
        let itemNode = astFromValue(item, itemType)
        itemNode != null && valuesNodes.push(itemNode)
      }
      return { kind: Kind.LIST, values: valuesNodes }
    }
    return astFromValue(value$2, itemType)
  }
  if (isInputObjectType(type$2)) {
    if (!isObjectLike(value$2)) return null
    let fieldNodes = []
    for (let field of Object.values(type$2.getFields())) {
      let fieldValue = astFromValue(value$2[field.name], field.type)
      fieldValue
        && fieldNodes.push({ kind: Kind.OBJECT_FIELD, name: { kind: Kind.NAME, value: field.name }, value: fieldValue })
    }
    return { kind: Kind.OBJECT, fields: fieldNodes }
  }
  if (isLeafType(type$2)) {
    let serialized = type$2.serialize(value$2)
    if (serialized == null) return null
    if (typeof serialized == `boolean`) return { kind: Kind.BOOLEAN, value: serialized }
    if (typeof serialized == `number` && Number.isFinite(serialized)) {
      let stringNum = String(serialized)
      return integerStringRegExp.test(stringNum)
        ? { kind: Kind.INT, value: stringNum }
        : { kind: Kind.FLOAT, value: stringNum }
    }
    if (typeof serialized == `string`) {
      return isEnumType(type$2)
        ? { kind: Kind.ENUM, value: serialized }
        : type$2 === GraphQLID && integerStringRegExp.test(serialized)
        ? { kind: Kind.INT, value: serialized }
        : { kind: Kind.STRING, value: serialized }
    }
    throw TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`)
  }
  invariant(!1, `Unexpected input type: ` + inspect(type$2))
}
const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/,
  __Schema = new GraphQLObjectType({
    name: `__Schema`,
    description:
      `A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.`,
    fields: () => ({
      description: { type: GraphQLString, resolve: schema => schema.description },
      types: {
        description: `A list of all types supported by this server.`,
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
        resolve(schema) {
          return Object.values(schema.getTypeMap())
        },
      },
      queryType: {
        description: `The type that query operations will be rooted at.`,
        type: new GraphQLNonNull(__Type),
        resolve: schema => schema.getQueryType(),
      },
      mutationType: {
        description: `If this server supports mutation, the type that mutation operations will be rooted at.`,
        type: __Type,
        resolve: schema => schema.getMutationType(),
      },
      subscriptionType: {
        description: `If this server support subscription, the type that subscription operations will be rooted at.`,
        type: __Type,
        resolve: schema => schema.getSubscriptionType(),
      },
      directives: {
        description: `A list of all directives supported by this server.`,
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
        resolve: schema => schema.getDirectives(),
      },
    }),
  }),
  __Directive = new GraphQLObjectType({
    name: `__Directive`,
    description:
      `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
    fields: () => ({
      name: { type: new GraphQLNonNull(GraphQLString), resolve: directive => directive.name },
      description: { type: GraphQLString, resolve: directive => directive.description },
      isRepeatable: { type: new GraphQLNonNull(GraphQLBoolean), resolve: directive => directive.isRepeatable },
      locations: {
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
        resolve: directive => directive.locations,
      },
      args: {
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
        args: { includeDeprecated: { type: GraphQLBoolean, defaultValue: !1 } },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter(arg => arg.deprecationReason == null)
        },
      },
    }),
  }),
  __DirectiveLocation = new GraphQLEnumType({
    name: `__DirectiveLocation`,
    description:
      `A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.`,
    values: {
      QUERY: { value: DirectiveLocation.QUERY, description: `Location adjacent to a query operation.` },
      MUTATION: { value: DirectiveLocation.MUTATION, description: `Location adjacent to a mutation operation.` },
      SUBSCRIPTION: {
        value: DirectiveLocation.SUBSCRIPTION,
        description: `Location adjacent to a subscription operation.`,
      },
      FIELD: { value: DirectiveLocation.FIELD, description: `Location adjacent to a field.` },
      FRAGMENT_DEFINITION: {
        value: DirectiveLocation.FRAGMENT_DEFINITION,
        description: `Location adjacent to a fragment definition.`,
      },
      FRAGMENT_SPREAD: {
        value: DirectiveLocation.FRAGMENT_SPREAD,
        description: `Location adjacent to a fragment spread.`,
      },
      INLINE_FRAGMENT: {
        value: DirectiveLocation.INLINE_FRAGMENT,
        description: `Location adjacent to an inline fragment.`,
      },
      VARIABLE_DEFINITION: {
        value: DirectiveLocation.VARIABLE_DEFINITION,
        description: `Location adjacent to a variable definition.`,
      },
      SCHEMA: { value: DirectiveLocation.SCHEMA, description: `Location adjacent to a schema definition.` },
      SCALAR: { value: DirectiveLocation.SCALAR, description: `Location adjacent to a scalar definition.` },
      OBJECT: { value: DirectiveLocation.OBJECT, description: `Location adjacent to an object type definition.` },
      FIELD_DEFINITION: {
        value: DirectiveLocation.FIELD_DEFINITION,
        description: `Location adjacent to a field definition.`,
      },
      ARGUMENT_DEFINITION: {
        value: DirectiveLocation.ARGUMENT_DEFINITION,
        description: `Location adjacent to an argument definition.`,
      },
      INTERFACE: { value: DirectiveLocation.INTERFACE, description: `Location adjacent to an interface definition.` },
      UNION: { value: DirectiveLocation.UNION, description: `Location adjacent to a union definition.` },
      ENUM: { value: DirectiveLocation.ENUM, description: `Location adjacent to an enum definition.` },
      ENUM_VALUE: {
        value: DirectiveLocation.ENUM_VALUE,
        description: `Location adjacent to an enum value definition.`,
      },
      INPUT_OBJECT: {
        value: DirectiveLocation.INPUT_OBJECT,
        description: `Location adjacent to an input object type definition.`,
      },
      INPUT_FIELD_DEFINITION: {
        value: DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: `Location adjacent to an input object field definition.`,
      },
    },
  }),
  __Type = new GraphQLObjectType({
    name: `__Type`,
    description:
      'The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.',
    fields: () => ({
      kind: {
        type: new GraphQLNonNull(__TypeKind),
        resolve(type$2) {
          if (isScalarType(type$2)) return TypeKind.SCALAR
          if (isObjectType(type$2)) return TypeKind.OBJECT
          if (isInterfaceType(type$2)) return TypeKind.INTERFACE
          if (isUnionType(type$2)) return TypeKind.UNION
          if (isEnumType(type$2)) return TypeKind.ENUM
          if (isInputObjectType(type$2)) return TypeKind.INPUT_OBJECT
          if (isListType(type$2)) return TypeKind.LIST
          if (isNonNullType(type$2)) return TypeKind.NON_NULL
          invariant(!1, `Unexpected type: "${inspect(type$2)}".`)
        },
      },
      name: { type: GraphQLString, resolve: type$2 => `name` in type$2 ? type$2.name : void 0 },
      description: { type: GraphQLString, resolve: type$2 => `description` in type$2 ? type$2.description : void 0 },
      specifiedByURL: { type: GraphQLString, resolve: obj => `specifiedByURL` in obj ? obj.specifiedByURL : void 0 },
      fields: {
        type: new GraphQLList(new GraphQLNonNull(__Field)),
        args: { includeDeprecated: { type: GraphQLBoolean, defaultValue: !1 } },
        resolve(type$2, { includeDeprecated }) {
          if (isObjectType(type$2) || isInterfaceType(type$2)) {
            let fields = Object.values(type$2.getFields())
            return includeDeprecated ? fields : fields.filter(field => field.deprecationReason == null)
          }
        },
      },
      interfaces: {
        type: new GraphQLList(new GraphQLNonNull(__Type)),
        resolve(type$2) {
          if (isObjectType(type$2) || isInterfaceType(type$2)) return type$2.getInterfaces()
        },
      },
      possibleTypes: {
        type: new GraphQLList(new GraphQLNonNull(__Type)),
        resolve(type$2, _args, _context, { schema }) {
          if (isAbstractType(type$2)) return schema.getPossibleTypes(type$2)
        },
      },
      enumValues: {
        type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
        args: { includeDeprecated: { type: GraphQLBoolean, defaultValue: !1 } },
        resolve(type$2, { includeDeprecated }) {
          if (isEnumType(type$2)) {
            let values$6 = type$2.getValues()
            return includeDeprecated ? values$6 : values$6.filter(field => field.deprecationReason == null)
          }
        },
      },
      inputFields: {
        type: new GraphQLList(new GraphQLNonNull(__InputValue)),
        args: { includeDeprecated: { type: GraphQLBoolean, defaultValue: !1 } },
        resolve(type$2, { includeDeprecated }) {
          if (isInputObjectType(type$2)) {
            let values$6 = Object.values(type$2.getFields())
            return includeDeprecated ? values$6 : values$6.filter(field => field.deprecationReason == null)
          }
        },
      },
      ofType: { type: __Type, resolve: type$2 => `ofType` in type$2 ? type$2.ofType : void 0 },
      isOneOf: {
        type: GraphQLBoolean,
        resolve: type$2 => {
          if (isInputObjectType(type$2)) return type$2.isOneOf
        },
      },
    }),
  }),
  __Field = new GraphQLObjectType({
    name: `__Field`,
    description:
      `Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.`,
    fields: () => ({
      name: { type: new GraphQLNonNull(GraphQLString), resolve: field => field.name },
      description: { type: GraphQLString, resolve: field => field.description },
      args: {
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
        args: { includeDeprecated: { type: GraphQLBoolean, defaultValue: !1 } },
        resolve(field, { includeDeprecated }) {
          return includeDeprecated ? field.args : field.args.filter(arg => arg.deprecationReason == null)
        },
      },
      type: { type: new GraphQLNonNull(__Type), resolve: field => field.type },
      isDeprecated: { type: new GraphQLNonNull(GraphQLBoolean), resolve: field => field.deprecationReason != null },
      deprecationReason: { type: GraphQLString, resolve: field => field.deprecationReason },
    }),
  }),
  __InputValue = new GraphQLObjectType({
    name: `__InputValue`,
    description:
      `Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.`,
    fields: () => ({
      name: { type: new GraphQLNonNull(GraphQLString), resolve: inputValue => inputValue.name },
      description: { type: GraphQLString, resolve: inputValue => inputValue.description },
      type: { type: new GraphQLNonNull(__Type), resolve: inputValue => inputValue.type },
      defaultValue: {
        type: GraphQLString,
        description: `A GraphQL-formatted string representing the default value for this input value.`,
        resolve(inputValue) {
          let { type: type$2, defaultValue } = inputValue, valueAST = astFromValue(defaultValue, type$2)
          return valueAST ? print(valueAST) : null
        },
      },
      isDeprecated: { type: new GraphQLNonNull(GraphQLBoolean), resolve: field => field.deprecationReason != null },
      deprecationReason: { type: GraphQLString, resolve: obj => obj.deprecationReason },
    }),
  }),
  __EnumValue = new GraphQLObjectType({
    name: `__EnumValue`,
    description:
      `One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.`,
    fields: () => ({
      name: { type: new GraphQLNonNull(GraphQLString), resolve: enumValue => enumValue.name },
      description: { type: GraphQLString, resolve: enumValue => enumValue.description },
      isDeprecated: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: enumValue => enumValue.deprecationReason != null,
      },
      deprecationReason: { type: GraphQLString, resolve: enumValue => enumValue.deprecationReason },
    }),
  })
var TypeKind
;(function(TypeKind$1) {
  TypeKind$1.SCALAR = `SCALAR`,
    TypeKind$1.OBJECT = `OBJECT`,
    TypeKind$1.INTERFACE = `INTERFACE`,
    TypeKind$1.UNION = `UNION`,
    TypeKind$1.ENUM = `ENUM`,
    TypeKind$1.INPUT_OBJECT = `INPUT_OBJECT`,
    TypeKind$1.LIST = `LIST`,
    TypeKind$1.NON_NULL = `NON_NULL`
})(TypeKind ||= {})
const __TypeKind = new GraphQLEnumType({
    name: `__TypeKind`,
    description: 'An enum describing what kind of type a given `__Type` is.',
    values: {
      SCALAR: { value: TypeKind.SCALAR, description: `Indicates this type is a scalar.` },
      OBJECT: {
        value: TypeKind.OBJECT,
        description: 'Indicates this type is an object. `fields` and `interfaces` are valid fields.',
      },
      INTERFACE: {
        value: TypeKind.INTERFACE,
        description:
          'Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.',
      },
      UNION: {
        value: TypeKind.UNION,
        description: 'Indicates this type is a union. `possibleTypes` is a valid field.',
      },
      ENUM: { value: TypeKind.ENUM, description: 'Indicates this type is an enum. `enumValues` is a valid field.' },
      INPUT_OBJECT: {
        value: TypeKind.INPUT_OBJECT,
        description: 'Indicates this type is an input object. `inputFields` is a valid field.',
      },
      LIST: { value: TypeKind.LIST, description: 'Indicates this type is a list. `ofType` is a valid field.' },
      NON_NULL: {
        value: TypeKind.NON_NULL,
        description: 'Indicates this type is a non-null. `ofType` is a valid field.',
      },
    },
  }),
  SchemaMetaFieldDef = {
    name: `__schema`,
    type: new GraphQLNonNull(__Schema),
    description: `Access the current type schema of this server.`,
    args: [],
    resolve: (_source, _args, _context, { schema }) => schema,
    deprecationReason: void 0,
    extensions: Object.create(null),
    astNode: void 0,
  },
  TypeMetaFieldDef = {
    name: `__type`,
    type: __Type,
    description: `Request the type information of a single type.`,
    args: [{
      name: `name`,
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: Object.create(null),
      astNode: void 0,
    }],
    resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
    deprecationReason: void 0,
    extensions: Object.create(null),
    astNode: void 0,
  },
  TypeNameMetaFieldDef = {
    name: `__typename`,
    type: new GraphQLNonNull(GraphQLString),
    description: `The name of the current Object type at runtime.`,
    args: [],
    resolve: (_source, _args, _context, { parentType }) => parentType.name,
    deprecationReason: void 0,
    extensions: Object.create(null),
    astNode: void 0,
  },
  introspectionTypes = Object.freeze([
    __Schema,
    __Directive,
    __DirectiveLocation,
    __Type,
    __Field,
    __InputValue,
    __EnumValue,
    __TypeKind,
  ])
function isIntrospectionType(type$2) {
  return introspectionTypes.some(({ name }) => type$2.name === name)
}
var GraphQLSchema = class {
  constructor(config) {
    var _config$extensionASTN, _config$directives
    this.__validationErrors = config.assumeValid === !0 ? [] : void 0,
      isObjectLike(config) || devAssert(!1, `Must provide configuration object.`),
      !config.types || Array.isArray(config.types)
      || devAssert(!1, `"types" must be Array if provided but got: ${inspect(config.types)}.`),
      !config.directives || Array.isArray(config.directives)
      || devAssert(!1, `"directives" must be Array if provided but got: ${inspect(config.directives)}.`),
      this.description = config.description,
      this.extensions = toObjMap(config.extensions),
      this.astNode = config.astNode,
      this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) ?? [],
      this._queryType = config.query,
      this._mutationType = config.mutation,
      this._subscriptionType = config.subscription,
      this._directives = (_config$directives = config.directives) ?? specifiedDirectives
    let allReferencedTypes = new Set(config.types)
    if (config.types != null) {
      for (let type$2 of config.types) {
        allReferencedTypes.delete(type$2), collectReferencedTypes(type$2, allReferencedTypes)
      }
    }
    this._queryType != null && collectReferencedTypes(this._queryType, allReferencedTypes),
      this._mutationType != null && collectReferencedTypes(this._mutationType, allReferencedTypes),
      this._subscriptionType != null && collectReferencedTypes(this._subscriptionType, allReferencedTypes)
    for (let directive of this._directives) {
      if (isDirective(directive)) for (let arg of directive.args) collectReferencedTypes(arg.type, allReferencedTypes)
    }
    collectReferencedTypes(__Schema, allReferencedTypes),
      this._typeMap = Object.create(null),
      this._subTypeMap = Object.create(null),
      this._implementationsMap = Object.create(null)
    for (let namedType of allReferencedTypes) {
      if (namedType == null) continue
      let typeName = namedType.name
      if (
        typeName || devAssert(!1, `One of the provided types for building the Schema is missing a name.`),
          this._typeMap[typeName] !== void 0
      ) throw Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`)
      if (this._typeMap[typeName] = namedType, isInterfaceType(namedType)) {
        for (let iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name]
            implementations === void 0
            && (implementations = this._implementationsMap[iface.name] = { objects: [], interfaces: [] }),
              implementations.interfaces.push(namedType)
          }
        }
      } else if (isObjectType(namedType)) {
        for (let iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name]
            implementations === void 0
            && (implementations = this._implementationsMap[iface.name] = { objects: [], interfaces: [] }),
              implementations.objects.push(namedType)
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return `GraphQLSchema`
  }
  getQueryType() {
    return this._queryType
  }
  getMutationType() {
    return this._mutationType
  }
  getSubscriptionType() {
    return this._subscriptionType
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType()
      case OperationTypeNode.MUTATION:
        return this.getMutationType()
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType()
    }
  }
  getTypeMap() {
    return this._typeMap
  }
  getType(name) {
    return this.getTypeMap()[name]
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects
  }
  getImplementations(interfaceType) {
    let implementations = this._implementationsMap[interfaceType.name]
    return implementations ?? { objects: [], interfaces: [] }
  }
  isSubType(abstractType, maybeSubType) {
    let map$20 = this._subTypeMap[abstractType.name]
    if (map$20 === void 0) {
      if (map$20 = Object.create(null), isUnionType(abstractType)) {
        for (let type$2 of abstractType.getTypes()) map$20[type$2.name] = !0
      } else {
        let implementations = this.getImplementations(abstractType)
        for (let type$2 of implementations.objects) map$20[type$2.name] = !0
        for (let type$2 of implementations.interfaces) map$20[type$2.name] = !0
      }
      this._subTypeMap[abstractType.name] = map$20
    }
    return map$20[maybeSubType.name] !== void 0
  }
  getDirectives() {
    return this._directives
  }
  getDirective(name) {
    return this.getDirectives().find(directive => directive.name === name)
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0,
    }
  }
}
function collectReferencedTypes(type$2, typeSet) {
  let namedType = getNamedType(type$2)
  if (!typeSet.has(namedType)) {
    if (typeSet.add(namedType), isUnionType(namedType)) {
      for (let memberType of namedType.getTypes()) collectReferencedTypes(memberType, typeSet)
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (let interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet)
      }
      for (let field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet)
        for (let arg of field.args) collectReferencedTypes(arg.type, typeSet)
      }
    } else if (isInputObjectType(namedType)) {
      for (let field of Object.values(namedType.getFields())) collectReferencedTypes(field.type, typeSet)
    }
  }
  return typeSet
}
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      let innerType = typeFromAST(schema, typeNode.type)
      return innerType && new GraphQLList(innerType)
    }
    case Kind.NON_NULL_TYPE: {
      let innerType = typeFromAST(schema, typeNode.type)
      return innerType && new GraphQLNonNull(innerType)
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value)
  }
}
var TypeInfo = class {
  constructor(schema, initialType, getFieldDefFn) {
    this._schema = schema,
      this._typeStack = [],
      this._parentTypeStack = [],
      this._inputTypeStack = [],
      this._fieldDefStack = [],
      this._defaultValueStack = [],
      this._directive = null,
      this._argument = null,
      this._enumValue = null,
      this._getFieldDef = getFieldDefFn ?? getFieldDef,
      initialType
      && (isInputType(initialType) && this._inputTypeStack.push(initialType),
        isCompositeType(initialType) && this._parentTypeStack.push(initialType),
        isOutputType(initialType) && this._typeStack.push(initialType))
  }
  get [Symbol.toStringTag]() {
    return `TypeInfo`
  }
  getType() {
    if (this._typeStack.length > 0) return this._typeStack[this._typeStack.length - 1]
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) return this._parentTypeStack[this._parentTypeStack.length - 1]
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) return this._inputTypeStack[this._inputTypeStack.length - 1]
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) return this._inputTypeStack[this._inputTypeStack.length - 2]
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) return this._fieldDefStack[this._fieldDefStack.length - 1]
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) return this._defaultValueStack[this._defaultValueStack.length - 1]
  }
  getDirective() {
    return this._directive
  }
  getArgument() {
    return this._argument
  }
  getEnumValue() {
    return this._enumValue
  }
  enter(node$1) {
    let schema = this._schema
    switch (node$1.kind) {
      case Kind.SELECTION_SET: {
        let namedType = getNamedType(this.getType())
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : void 0)
        break
      }
      case Kind.FIELD: {
        let parentType = this.getParentType(), fieldDef, fieldType
        parentType
        && (fieldDef = this._getFieldDef(schema, parentType, node$1), fieldDef && (fieldType = fieldDef.type)),
          this._fieldDefStack.push(fieldDef),
          this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0)
        break
      }
      case Kind.DIRECTIVE:
        this._directive = schema.getDirective(node$1.name.value)
        break
      case Kind.OPERATION_DEFINITION: {
        let rootType = schema.getRootType(node$1.operation)
        this._typeStack.push(isObjectType(rootType) ? rootType : void 0)
        break
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        let typeConditionAST = node$1.typeCondition,
          outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType())
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0)
        break
      }
      case Kind.VARIABLE_DEFINITION: {
        let inputType = typeFromAST(schema, node$1.type)
        this._inputTypeStack.push(isInputType(inputType) ? inputType : void 0)
        break
      }
      case Kind.ARGUMENT: {
        var _this$getDirective
        let argDef, argType, fieldOrDirective = (_this$getDirective = this.getDirective()) ?? this.getFieldDef()
        fieldOrDirective
        && (argDef = fieldOrDirective.args.find(arg => arg.name === node$1.name.value),
          argDef && (argType = argDef.type)),
          this._argument = argDef,
          this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0),
          this._inputTypeStack.push(isInputType(argType) ? argType : void 0)
        break
      }
      case Kind.LIST: {
        let listType = getNullableType(this.getInputType()),
          itemType = isListType(listType) ? listType.ofType : listType
        this._defaultValueStack.push(void 0), this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0)
        break
      }
      case Kind.OBJECT_FIELD: {
        let objectType = getNamedType(this.getInputType()), inputFieldType, inputField
        isInputObjectType(objectType)
        && (inputField = objectType.getFields()[node$1.name.value], inputField && (inputFieldType = inputField.type)),
          this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0),
          this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : void 0)
        break
      }
      case Kind.ENUM: {
        let enumType = getNamedType(this.getInputType()), enumValue
        isEnumType(enumType) && (enumValue = enumType.getValue(node$1.value)), this._enumValue = enumValue
        break
      }
      default:
    }
  }
  leave(node$1) {
    switch (node$1.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop()
        break
      case Kind.FIELD:
        this._fieldDefStack.pop(), this._typeStack.pop()
        break
      case Kind.DIRECTIVE:
        this._directive = null
        break
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop()
        break
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop()
        break
      case Kind.ARGUMENT:
        this._argument = null, this._defaultValueStack.pop(), this._inputTypeStack.pop()
        break
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop(), this._inputTypeStack.pop()
        break
      case Kind.ENUM:
        this._enumValue = null
        break
      default:
    }
  }
}
function getFieldDef(schema, parentType, fieldNode) {
  let name = fieldNode.name.value
  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) return SchemaMetaFieldDef
  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) return TypeMetaFieldDef
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) return TypeNameMetaFieldDef
  if (isObjectType(parentType) || isInterfaceType(parentType)) return parentType.getFields()[name]
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args$1) {
      let node$1 = args$1[0]
      typeInfo.enter(node$1)
      let fn = getEnterLeaveForKind(visitor, node$1.kind).enter
      if (fn) {
        let result = fn.apply(visitor, args$1)
        return result !== void 0 && (typeInfo.leave(node$1), isNode$1(result) && typeInfo.enter(result)), result
      }
    },
    leave(...args$1) {
      let node$1 = args$1[0], fn = getEnterLeaveForKind(visitor, node$1.kind).leave, result
      return fn && (result = fn.apply(visitor, args$1)), typeInfo.leave(node$1), result
    },
  }
}
function isExecutableDefinitionNode(node$1) {
  return node$1.kind === Kind.OPERATION_DEFINITION || node$1.kind === Kind.FRAGMENT_DEFINITION
}
function isTypeSystemDefinitionNode(node$1) {
  return node$1.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node$1)
    || node$1.kind === Kind.DIRECTIVE_DEFINITION
}
function isTypeDefinitionNode(node$1) {
  return node$1.kind === Kind.SCALAR_TYPE_DEFINITION || node$1.kind === Kind.OBJECT_TYPE_DEFINITION
    || node$1.kind === Kind.INTERFACE_TYPE_DEFINITION || node$1.kind === Kind.UNION_TYPE_DEFINITION
    || node$1.kind === Kind.ENUM_TYPE_DEFINITION || node$1.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION
}
function isTypeSystemExtensionNode(node$1) {
  return node$1.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node$1)
}
function isTypeExtensionNode(node$1) {
  return node$1.kind === Kind.SCALAR_TYPE_EXTENSION || node$1.kind === Kind.OBJECT_TYPE_EXTENSION
    || node$1.kind === Kind.INTERFACE_TYPE_EXTENSION || node$1.kind === Kind.UNION_TYPE_EXTENSION
    || node$1.kind === Kind.ENUM_TYPE_EXTENSION || node$1.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION
}
function ExecutableDefinitionsRule(context$2) {
  return {
    Document(node$1) {
      for (let definition$2 of node$1.definitions) {
        if (!isExecutableDefinitionNode(definition$2)) {
          let defName = definition$2.kind === Kind.SCHEMA_DEFINITION || definition$2.kind === Kind.SCHEMA_EXTENSION
            ? `schema`
            : `"` + definition$2.name.value + `"`
          context$2.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, { nodes: definition$2 }),
          )
        }
      }
      return !1
    },
  }
}
function FieldsOnCorrectTypeRule(context$2) {
  return {
    Field(node$1) {
      let type$2 = context$2.getParentType()
      if (type$2) {
        let fieldDef = context$2.getFieldDef()
        if (!fieldDef) {
          let schema = context$2.getSchema(),
            fieldName = node$1.name.value,
            suggestion = didYouMean(`to use an inline fragment on`, getSuggestedTypeNames(schema, type$2, fieldName))
          suggestion === `` && (suggestion = didYouMean(getSuggestedFieldNames(type$2, fieldName))),
            context$2.reportError(
              new GraphQLError(`Cannot query field "${fieldName}" on type "${type$2.name}".` + suggestion, {
                nodes: node$1,
              }),
            )
        }
      }
    },
  }
}
function getSuggestedTypeNames(schema, type$2, fieldName) {
  if (!isAbstractType(type$2)) return []
  let suggestedTypes = new Set(), usageCount = Object.create(null)
  for (let possibleType of schema.getPossibleTypes(type$2)) {
    if (!possibleType.getFields()[fieldName]) continue
    suggestedTypes.add(possibleType), usageCount[possibleType.name] = 1
    for (let possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI
      if (!possibleInterface.getFields()[fieldName]) continue
      suggestedTypes.add(possibleInterface),
        usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) ?? 0) + 1
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    let usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name]
    return usageCountDiff === 0
      ? isInterfaceType(typeA) && schema.isSubType(typeA, typeB)
        ? -1
        : isInterfaceType(typeB) && schema.isSubType(typeB, typeA)
        ? 1
        : naturalCompare(typeA.name, typeB.name)
      : usageCountDiff
  }).map(x$2 => x$2.name)
}
function getSuggestedFieldNames(type$2, fieldName) {
  if (isObjectType(type$2) || isInterfaceType(type$2)) {
    let possibleFieldNames = Object.keys(type$2.getFields())
    return suggestionList(fieldName, possibleFieldNames)
  }
  return []
}
function FragmentsOnCompositeTypesRule(context$2) {
  return {
    InlineFragment(node$1) {
      let typeCondition = node$1.typeCondition
      if (typeCondition) {
        let type$2 = typeFromAST(context$2.getSchema(), typeCondition)
        if (type$2 && !isCompositeType(type$2)) {
          let typeStr = print(typeCondition)
          context$2.reportError(
            new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, { nodes: typeCondition }),
          )
        }
      }
    },
    FragmentDefinition(node$1) {
      let type$2 = typeFromAST(context$2.getSchema(), node$1.typeCondition)
      if (type$2 && !isCompositeType(type$2)) {
        let typeStr = print(node$1.typeCondition)
        context$2.reportError(
          new GraphQLError(`Fragment "${node$1.name.value}" cannot condition on non composite type "${typeStr}".`, {
            nodes: node$1.typeCondition,
          }),
        )
      }
    },
  }
}
function KnownArgumentNamesRule(context$2) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(context$2),
    Argument(argNode) {
      let argDef = context$2.getArgument(), fieldDef = context$2.getFieldDef(), parentType = context$2.getParentType()
      if (!argDef && fieldDef && parentType) {
        let argName = argNode.name.value,
          knownArgsNames = fieldDef.args.map(arg => arg.name),
          suggestions = suggestionList(argName, knownArgsNames)
        context$2.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            { nodes: argNode },
          ),
        )
      }
    },
  }
}
function KnownArgumentNamesOnDirectivesRule(context$2) {
  let directiveArgs = Object.create(null),
    schema = context$2.getSchema(),
    definedDirectives = schema ? schema.getDirectives() : specifiedDirectives
  for (let directive of definedDirectives) directiveArgs[directive.name] = directive.args.map(arg => arg.name)
  let astDefinitions = context$2.getDocument().definitions
  for (let def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments
      let argsNodes = (_def$arguments = def.arguments) ?? []
      directiveArgs[def.name.value] = argsNodes.map(arg => arg.name.value)
    }
  }
  return {
    Directive(directiveNode) {
      let directiveName = directiveNode.name.value, knownArgs = directiveArgs[directiveName]
      if (directiveNode.arguments && knownArgs) {
        for (let argNode of directiveNode.arguments) {
          let argName = argNode.name.value
          if (!knownArgs.includes(argName)) {
            let suggestions = suggestionList(argName, knownArgs)
            context$2.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                { nodes: argNode },
              ),
            )
          }
        }
      }
      return !1
    },
  }
}
function KnownDirectivesRule(context$2) {
  let locationsMap = Object.create(null),
    schema = context$2.getSchema(),
    definedDirectives = schema ? schema.getDirectives() : specifiedDirectives
  for (let directive of definedDirectives) locationsMap[directive.name] = directive.locations
  let astDefinitions = context$2.getDocument().definitions
  for (let def of astDefinitions) {
    def.kind === Kind.DIRECTIVE_DEFINITION && (locationsMap[def.name.value] = def.locations.map(name => name.value))
  }
  return {
    Directive(node$1, _key, _parent, _path, ancestors) {
      let name = node$1.name.value, locations = locationsMap[name]
      if (!locations) {
        context$2.reportError(new GraphQLError(`Unknown directive "@${name}".`, { nodes: node$1 }))
        return
      }
      let candidateLocation = getDirectiveLocationForASTPath(ancestors)
      candidateLocation && !locations.includes(candidateLocation)
        && context$2.reportError(
          new GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, { nodes: node$1 }),
        )
    },
  }
}
function getDirectiveLocationForASTPath(ancestors) {
  let appliedTo = ancestors[ancestors.length - 1]
  switch (`kind` in appliedTo || invariant(!1), appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation)
    case Kind.FIELD:
      return DirectiveLocation.FIELD
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT
    case Kind.INPUT_VALUE_DEFINITION: {
      let parentNode = ancestors[ancestors.length - 3]
      return `kind` in parentNode || invariant(!1),
        parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION
          ? DirectiveLocation.INPUT_FIELD_DEFINITION
          : DirectiveLocation.ARGUMENT_DEFINITION
    }
    default:
      invariant(!1, `Unexpected kind: ` + inspect(appliedTo.kind))
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION
  }
}
function KnownFragmentNamesRule(context$2) {
  return {
    FragmentSpread(node$1) {
      let fragmentName = node$1.name.value, fragment = context$2.getFragment(fragmentName)
      fragment || context$2.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, { nodes: node$1.name }))
    },
  }
}
function KnownTypeNamesRule(context$2) {
  let schema = context$2.getSchema(),
    existingTypesMap = schema ? schema.getTypeMap() : Object.create(null),
    definedTypes = Object.create(null)
  for (let def of context$2.getDocument().definitions) isTypeDefinitionNode(def) && (definedTypes[def.name.value] = !0)
  let typeNames = [...Object.keys(existingTypesMap), ...Object.keys(definedTypes)]
  return {
    NamedType(node$1, _1, parent, _2, ancestors) {
      let typeName = node$1.name.value
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$
        let definitionNode = (_ancestors$ = ancestors[2]) ?? parent,
          isSDL = definitionNode != null && isSDLNode(definitionNode)
        if (isSDL && standardTypeNames.includes(typeName)) return
        let suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames)
        context$2.reportError(
          new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), { nodes: node$1 }),
        )
      }
    },
  }
}
const standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(type$2 => type$2.name)
function isSDLNode(value$2) {
  return `kind` in value$2 && (isTypeSystemDefinitionNode(value$2) || isTypeSystemExtensionNode(value$2))
}
function LoneAnonymousOperationRule(context$2) {
  let operationCount = 0
  return {
    Document(node$1) {
      operationCount = node$1.definitions.filter(definition$2 => definition$2.kind === Kind.OPERATION_DEFINITION).length
    },
    OperationDefinition(node$1) {
      !node$1.name && operationCount > 1
        && context$2.reportError(
          new GraphQLError(`This anonymous operation must be the only defined operation.`, { nodes: node$1 }),
        )
    },
  }
}
function LoneSchemaDefinitionRule(context$2) {
  var _ref, _ref2, _oldSchema$astNode
  let oldSchema = context$2.getSchema(),
    alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema?.astNode) ?? oldSchema?.getQueryType())
      ?? oldSchema?.getMutationType()) ?? oldSchema?.getSubscriptionType(),
    schemaDefinitionsCount = 0
  return {
    SchemaDefinition(node$1) {
      if (alreadyDefined) {
        context$2.reportError(
          new GraphQLError(`Cannot define a new schema within a schema extension.`, { nodes: node$1 }),
        )
        return
      }
      schemaDefinitionsCount > 0
      && context$2.reportError(new GraphQLError(`Must provide only one schema definition.`, { nodes: node$1 })),
        ++schemaDefinitionsCount
    },
  }
}
const MAX_LISTS_DEPTH = 3
function MaxIntrospectionDepthRule(context$2) {
  function checkDepth(node$1, visitedFragments = Object.create(null), depth = 0) {
    if (node$1.kind === Kind.FRAGMENT_SPREAD) {
      let fragmentName = node$1.name.value
      if (visitedFragments[fragmentName] === !0) return !1
      let fragment = context$2.getFragment(fragmentName)
      if (!fragment) return !1
      try {
        return visitedFragments[fragmentName] = !0, checkDepth(fragment, visitedFragments, depth)
      } finally {
        visitedFragments[fragmentName] = void 0
      }
    }
    if (
      node$1.kind === Kind.FIELD
      && (node$1.name.value === `fields` || node$1.name.value === `interfaces` || node$1.name.value === `possibleTypes`
        || node$1.name.value === `inputFields`)
      && (depth++, depth >= MAX_LISTS_DEPTH)
    ) return !0
    if (`selectionSet` in node$1 && node$1.selectionSet) {
      for (let child of node$1.selectionSet.selections) if (checkDepth(child, visitedFragments, depth)) return !0
    }
    return !1
  }
  return {
    Field(node$1) {
      if ((node$1.name.value === `__schema` || node$1.name.value === `__type`) && checkDepth(node$1)) {
        return context$2
          .reportError(new GraphQLError(`Maximum introspection depth exceeded`, { nodes: [node$1] })),
          !1
      }
    },
  }
}
function NoFragmentCyclesRule(context$2) {
  let visitedFrags = Object.create(null), spreadPath = [], spreadPathIndexByName = Object.create(null)
  return {
    OperationDefinition: () => !1,
    FragmentDefinition(node$1) {
      return detectCycleRecursive(node$1), !1
    },
  }
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) return
    let fragmentName = fragment.name.value
    visitedFrags[fragmentName] = !0
    let spreadNodes = context$2.getFragmentSpreads(fragment.selectionSet)
    if (spreadNodes.length !== 0) {
      spreadPathIndexByName[fragmentName] = spreadPath.length
      for (let spreadNode of spreadNodes) {
        let spreadName = spreadNode.name.value, cycleIndex = spreadPathIndexByName[spreadName]
        if (spreadPath.push(spreadNode), cycleIndex === void 0) {
          let spreadFragment = context$2.getFragment(spreadName)
          spreadFragment && detectCycleRecursive(spreadFragment)
        } else {
          let cyclePath = spreadPath.slice(cycleIndex),
            viaPath = cyclePath.slice(0, -1).map(s$14 => `"` + s$14.name.value + `"`).join(`, `)
          context$2.reportError(
            new GraphQLError(
              `Cannot spread fragment "${spreadName}" within itself` + (viaPath === `` ? `.` : ` via ${viaPath}.`),
              { nodes: cyclePath },
            ),
          )
        }
        spreadPath.pop()
      }
      spreadPathIndexByName[fragmentName] = void 0
    }
  }
}
function NoUndefinedVariablesRule(context$2) {
  let variableNameDefined = Object.create(null)
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = Object.create(null)
      },
      leave(operation) {
        let usages = context$2.getRecursiveVariableUsages(operation)
        for (let { node: node$1 } of usages) {
          let varName = node$1.name.value
          variableNameDefined[varName] !== !0
            && context$2.reportError(
              new GraphQLError(
                operation.name
                  ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".`
                  : `Variable "$${varName}" is not defined.`,
                { nodes: [node$1, operation] },
              ),
            )
        }
      },
    },
    VariableDefinition(node$1) {
      variableNameDefined[node$1.variable.name.value] = !0
    },
  }
}
function NoUnusedFragmentsRule(context$2) {
  let operationDefs = [], fragmentDefs = []
  return {
    OperationDefinition(node$1) {
      return operationDefs.push(node$1), !1
    },
    FragmentDefinition(node$1) {
      return fragmentDefs.push(node$1), !1
    },
    Document: {
      leave() {
        let fragmentNameUsed = Object.create(null)
        for (let operation of operationDefs) {
          for (let fragment of context$2.getRecursivelyReferencedFragments(operation)) {
            fragmentNameUsed[fragment.name.value] = !0
          }
        }
        for (let fragmentDef of fragmentDefs) {
          let fragName = fragmentDef.name.value
          fragmentNameUsed[fragName] !== !0
            && context$2.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, { nodes: fragmentDef }))
        }
      },
    },
  }
}
function NoUnusedVariablesRule(context$2) {
  let variableDefs = []
  return {
    OperationDefinition: {
      enter() {
        variableDefs = []
      },
      leave(operation) {
        let variableNameUsed = Object.create(null), usages = context$2.getRecursiveVariableUsages(operation)
        for (let { node: node$1 } of usages) variableNameUsed[node$1.name.value] = !0
        for (let variableDef of variableDefs) {
          let variableName = variableDef.variable.name.value
          variableNameUsed[variableName] !== !0
            && context$2.reportError(
              new GraphQLError(
                operation.name
                  ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".`
                  : `Variable "$${variableName}" is never used.`,
                { nodes: variableDef },
              ),
            )
        }
      },
    },
    VariableDefinition(def) {
      variableDefs.push(def)
    },
  }
}
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) }
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) }
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode
  }
}
function sortFields(fields) {
  return fields.map(fieldNode => ({ ...fieldNode, value: sortValueNode(fieldNode.value) })).sort((fieldA, fieldB) =>
    naturalCompare(fieldA.name.value, fieldB.name.value)
  )
}
function reasonMessage(reason) {
  return Array.isArray(reason)
    ? reason.map(([responseName, subReason]) =>
      `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(` and `)
    : reason
}
function OverlappingFieldsCanBeMergedRule(context$2) {
  let comparedFieldsAndFragmentPairs = new OrderedPairSet(),
    comparedFragmentPairs = new PairSet(),
    cachedFieldsAndFragmentNames = new Map()
  return {
    SelectionSet(selectionSet) {
      let conflicts = findConflictsWithinSelectionSet(
        context$2,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        context$2.getParentType(),
        selectionSet,
      )
      for (let [[responseName, reason], fields1, fields2] of conflicts) {
        let reasonMsg = reasonMessage(reason)
        context$2.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            { nodes: fields1.concat(fields2) },
          ),
        )
      }
    },
  }
}
function findConflictsWithinSelectionSet(
  context$2,
  cachedFieldsAndFragmentNames,
  comparedFieldsAndFragmentPairs,
  comparedFragmentPairs,
  parentType,
  selectionSet,
) {
  let conflicts = [],
    [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
      context$2,
      cachedFieldsAndFragmentNames,
      parentType,
      selectionSet,
    )
  if (
    collectConflictsWithin(
      context$2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      fieldMap,
    ), fragmentNames.length !== 0
  ) {
    for (let i$14 = 0; i$14 < fragmentNames.length; i$14++) {
      collectConflictsBetweenFieldsAndFragment(
        context$2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        !1,
        fieldMap,
        fragmentNames[i$14],
      )
      for (let j$1 = i$14 + 1; j$1 < fragmentNames.length; j$1++) {
        collectConflictsBetweenFragments(
          context$2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          !1,
          fragmentNames[i$14],
          fragmentNames[j$1],
        )
      }
    }
  }
  return conflicts
}
function collectConflictsBetweenFieldsAndFragment(
  context$2,
  conflicts,
  cachedFieldsAndFragmentNames,
  comparedFieldsAndFragmentPairs,
  comparedFragmentPairs,
  areMutuallyExclusive,
  fieldMap,
  fragmentName,
) {
  if (comparedFieldsAndFragmentPairs.has(fieldMap, fragmentName, areMutuallyExclusive)) return
  comparedFieldsAndFragmentPairs.add(fieldMap, fragmentName, areMutuallyExclusive)
  let fragment = context$2.getFragment(fragmentName)
  if (!fragment) return
  let [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context$2,
    cachedFieldsAndFragmentNames,
    fragment,
  )
  if (fieldMap !== fieldMap2) {
    collectConflictsBetween(
      context$2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      fieldMap2,
    )
    for (let referencedFragmentName of referencedFragmentNames) {
      collectConflictsBetweenFieldsAndFragment(
        context$2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap,
        referencedFragmentName,
      )
    }
  }
}
function collectConflictsBetweenFragments(
  context$2,
  conflicts,
  cachedFieldsAndFragmentNames,
  comparedFieldsAndFragmentPairs,
  comparedFragmentPairs,
  areMutuallyExclusive,
  fragmentName1,
  fragmentName2,
) {
  if (
    fragmentName1 === fragmentName2 || comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)
  ) return
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive)
  let fragment1 = context$2.getFragment(fragmentName1), fragment2 = context$2.getFragment(fragmentName2)
  if (!fragment1 || !fragment2) return
  let [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
      context$2,
      cachedFieldsAndFragmentNames,
      fragment1,
    ),
    [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
      context$2,
      cachedFieldsAndFragmentNames,
      fragment2,
    )
  collectConflictsBetween(
    context$2,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2,
  )
  for (let referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context$2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2,
    )
  }
  for (let referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context$2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2,
    )
  }
}
function findConflictsBetweenSubSelectionSets(
  context$2,
  cachedFieldsAndFragmentNames,
  comparedFieldsAndFragmentPairs,
  comparedFragmentPairs,
  areMutuallyExclusive,
  parentType1,
  selectionSet1,
  parentType2,
  selectionSet2,
) {
  let conflicts = [],
    [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
      context$2,
      cachedFieldsAndFragmentNames,
      parentType1,
      selectionSet1,
    ),
    [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
      context$2,
      cachedFieldsAndFragmentNames,
      parentType2,
      selectionSet2,
    )
  collectConflictsBetween(
    context$2,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2,
  )
  for (let fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context$2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2,
    )
  }
  for (let fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context$2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1,
    )
  }
  for (let fragmentName1 of fragmentNames1) {
    for (let fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context$2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2,
      )
    }
  }
  return conflicts
}
function collectConflictsWithin(
  context$2,
  conflicts,
  cachedFieldsAndFragmentNames,
  comparedFieldsAndFragmentPairs,
  comparedFragmentPairs,
  fieldMap,
) {
  for (let [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i$14 = 0; i$14 < fields.length; i$14++) {
        for (let j$1 = i$14 + 1; j$1 < fields.length; j$1++) {
          let conflict = findConflict(
            context$2,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            !1,
            responseName,
            fields[i$14],
            fields[j$1],
          )
          conflict && conflicts.push(conflict)
        }
      }
    }
  }
}
function collectConflictsBetween(
  context$2,
  conflicts,
  cachedFieldsAndFragmentNames,
  comparedFieldsAndFragmentPairs,
  comparedFragmentPairs,
  parentFieldsAreMutuallyExclusive,
  fieldMap1,
  fieldMap2,
) {
  for (let [responseName, fields1] of Object.entries(fieldMap1)) {
    let fields2 = fieldMap2[responseName]
    if (fields2) {
      for (let field1 of fields1) {
        for (let field2 of fields2) {
          let conflict = findConflict(
            context$2,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2,
          )
          conflict && conflicts.push(conflict)
        }
      }
    }
  }
}
function findConflict(
  context$2,
  cachedFieldsAndFragmentNames,
  comparedFieldsAndFragmentPairs,
  comparedFragmentPairs,
  parentFieldsAreMutuallyExclusive,
  responseName,
  field1,
  field2,
) {
  let [parentType1, node1, def1] = field1,
    [parentType2, node2, def2] = field2,
    areMutuallyExclusive = parentFieldsAreMutuallyExclusive
      || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2)
  if (!areMutuallyExclusive) {
    let name1 = node1.name.value, name2 = node2.name.value
    if (name1 !== name2) return [[responseName, `"${name1}" and "${name2}" are different fields`], [node1], [node2]]
    if (!sameArguments(node1, node2)) return [[responseName, `they have differing arguments`], [node1], [node2]]
  }
  let type1 = def1?.type, type2 = def2?.type
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [[responseName, `they return conflicting types "${inspect(type1)}" and "${inspect(type2)}"`], [node1], [
      node2,
    ]]
  }
  let selectionSet1 = node1.selectionSet, selectionSet2 = node2.selectionSet
  if (selectionSet1 && selectionSet2) {
    let conflicts = findConflictsBetweenSubSelectionSets(
      context$2,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2,
    )
    return subfieldConflicts(conflicts, responseName, node1, node2)
  }
}
function sameArguments(node1, node2) {
  let args1 = node1.arguments, args2 = node2.arguments
  if (args1 === void 0 || args1.length === 0) return args2 === void 0 || args2.length === 0
  if (args2 === void 0 || args2.length === 0 || args1.length !== args2.length) return !1
  let values2 = new Map(args2.map(({ name, value: value$2 }) => [name.value, value$2]))
  return args1.every(arg1 => {
    let value1 = arg1.value, value2 = values2.get(arg1.name.value)
    return value2 === void 0 ? !1 : stringifyValue(value1) === stringifyValue(value2)
  })
}
function stringifyValue(value$2) {
  return print(sortValueNode(value$2))
}
function doTypesConflict(type1, type2) {
  return isListType(type1)
    ? isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : !0
    : isListType(type2)
    ? !0
    : isNonNullType(type1)
    ? isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : !0
    : isNonNullType(type2)
    ? !0
    : isLeafType(type1) || isLeafType(type2)
    ? type1 !== type2
    : !1
}
function getFieldsAndFragmentNames(context$2, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  let cached$3 = cachedFieldsAndFragmentNames.get(selectionSet)
  if (cached$3) return cached$3
  let nodeAndDefs = Object.create(null), fragmentNames = Object.create(null)
  _collectFieldsAndFragmentNames(context$2, parentType, selectionSet, nodeAndDefs, fragmentNames)
  let result = [nodeAndDefs, Object.keys(fragmentNames)]
  return cachedFieldsAndFragmentNames.set(selectionSet, result), result
}
function getReferencedFieldsAndFragmentNames(context$2, cachedFieldsAndFragmentNames, fragment) {
  let cached$3 = cachedFieldsAndFragmentNames.get(fragment.selectionSet)
  if (cached$3) return cached$3
  let fragmentType = typeFromAST(context$2.getSchema(), fragment.typeCondition)
  return getFieldsAndFragmentNames(context$2, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet)
}
function _collectFieldsAndFragmentNames(context$2, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (let selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        let fieldName = selection.name.value, fieldDef
        ;(isObjectType(parentType) || isInterfaceType(parentType)) && (fieldDef = parentType.getFields()[fieldName])
        let responseName = selection.alias ? selection.alias.value : fieldName
        nodeAndDefs[responseName] || (nodeAndDefs[responseName] = []),
          nodeAndDefs[responseName].push([parentType, selection, fieldDef])
        break
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = !0
        break
      case Kind.INLINE_FRAGMENT: {
        let typeCondition = selection.typeCondition,
          inlineFragmentType = typeCondition ? typeFromAST(context$2.getSchema(), typeCondition) : parentType
        _collectFieldsAndFragmentNames(
          context$2,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames,
        )
        break
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [[responseName, conflicts.map(([reason]) => reason)], [
      node1,
      ...conflicts.map(([, fields1]) => fields1).flat(),
    ], [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]]
  }
}
var OrderedPairSet = class {
    constructor() {
      this._data = new Map()
    }
    has(a$22, b$3, weaklyPresent) {
      var _this$_data$get
      let result = (_this$_data$get = this._data.get(a$22))?.get(b$3)
      return result === void 0 ? !1 : weaklyPresent ? !0 : weaklyPresent === result
    }
    add(a$22, b$3, weaklyPresent) {
      let map$20 = this._data.get(a$22)
      map$20 === void 0 ? this._data.set(a$22, new Map([[b$3, weaklyPresent]])) : map$20.set(b$3, weaklyPresent)
    }
  },
  PairSet = class {
    constructor() {
      this._orderedPairSet = new OrderedPairSet()
    }
    has(a$22, b$3, weaklyPresent) {
      return a$22 < b$3
        ? this._orderedPairSet.has(a$22, b$3, weaklyPresent)
        : this._orderedPairSet.has(b$3, a$22, weaklyPresent)
    }
    add(a$22, b$3, weaklyPresent) {
      a$22 < b$3
        ? this._orderedPairSet.add(a$22, b$3, weaklyPresent)
        : this._orderedPairSet.add(b$3, a$22, weaklyPresent)
    }
  }
function PossibleFragmentSpreadsRule(context$2) {
  return {
    InlineFragment(node$1) {
      let fragType = context$2.getType(), parentType = context$2.getParentType()
      if (
        isCompositeType(fragType) && isCompositeType(parentType)
        && !doTypesOverlap(context$2.getSchema(), fragType, parentType)
      ) {
        let parentTypeStr = inspect(parentType), fragTypeStr = inspect(fragType)
        context$2.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            { nodes: node$1 },
          ),
        )
      }
    },
    FragmentSpread(node$1) {
      let fragName = node$1.name.value,
        fragType = getFragmentType(context$2, fragName),
        parentType = context$2.getParentType()
      if (fragType && parentType && !doTypesOverlap(context$2.getSchema(), fragType, parentType)) {
        let parentTypeStr = inspect(parentType), fragTypeStr = inspect(fragType)
        context$2.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            { nodes: node$1 },
          ),
        )
      }
    },
  }
}
function getFragmentType(context$2, name) {
  let frag = context$2.getFragment(name)
  if (frag) {
    let type$2 = typeFromAST(context$2.getSchema(), frag.typeCondition)
    if (isCompositeType(type$2)) return type$2
  }
}
function PossibleTypeExtensionsRule(context$2) {
  let schema = context$2.getSchema(), definedTypes = Object.create(null)
  for (let def of context$2.getDocument().definitions) isTypeDefinitionNode(def) && (definedTypes[def.name.value] = def)
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension,
  }
  function checkExtension(node$1) {
    let typeName = node$1.name.value,
      defNode = definedTypes[typeName],
      existingType = schema?.getType(typeName),
      expectedKind
    if (
      defNode
        ? expectedKind = defKindToExtKind[defNode.kind]
        : existingType && (expectedKind = typeToExtKind(existingType)), expectedKind
    ) {
      if (expectedKind !== node$1.kind) {
        let kindStr = extensionKindToTypeName(node$1.kind)
        context$2.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node$1] : node$1,
          }),
        )
      }
    } else {
      let allTypeNames = Object.keys({ ...definedTypes, ...schema?.getTypeMap() }),
        suggestedTypes = suggestionList(typeName, allTypeNames)
      context$2.reportError(
        new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), {
          nodes: node$1.name,
        }),
      )
    }
  }
}
const defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,
}
function typeToExtKind(type$2) {
  if (isScalarType(type$2)) return Kind.SCALAR_TYPE_EXTENSION
  if (isObjectType(type$2)) return Kind.OBJECT_TYPE_EXTENSION
  if (isInterfaceType(type$2)) return Kind.INTERFACE_TYPE_EXTENSION
  if (isUnionType(type$2)) return Kind.UNION_TYPE_EXTENSION
  if (isEnumType(type$2)) return Kind.ENUM_TYPE_EXTENSION
  if (isInputObjectType(type$2)) return Kind.INPUT_OBJECT_TYPE_EXTENSION
  invariant(!1, `Unexpected type: ` + inspect(type$2))
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return `scalar`
    case Kind.OBJECT_TYPE_EXTENSION:
      return `object`
    case Kind.INTERFACE_TYPE_EXTENSION:
      return `interface`
    case Kind.UNION_TYPE_EXTENSION:
      return `union`
    case Kind.ENUM_TYPE_EXTENSION:
      return `enum`
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return `input object`
    default:
      invariant(!1, `Unexpected kind: ` + inspect(kind))
  }
}
function ProvidedRequiredArgumentsRule(context$2) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(context$2),
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments
        let fieldDef = context$2.getFieldDef()
        if (!fieldDef) return !1
        let providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments)?.map(arg => arg.name.value))
        for (let argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            let argTypeStr = inspect(argDef.type)
            context$2.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                { nodes: fieldNode },
              ),
            )
          }
        }
      },
    },
  }
}
function ProvidedRequiredArgumentsOnDirectivesRule(context$2) {
  var _schema$getDirectives
  let requiredArgsMap = Object.create(null),
    schema = context$2.getSchema(),
    definedDirectives = (_schema$getDirectives = schema?.getDirectives()) ?? specifiedDirectives
  for (let directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), arg => arg.name)
  }
  let astDefinitions = context$2.getDocument().definitions
  for (let def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments
      let argNodes = (_def$arguments = def.arguments) ?? []
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), arg => arg.name.value)
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        let directiveName = directiveNode.name.value, requiredArgs = requiredArgsMap[directiveName]
        if (requiredArgs) {
          var _directiveNode$argume
          let argNodes = (_directiveNode$argume = directiveNode.arguments) ?? [],
            argNodeMap = new Set(argNodes.map(arg => arg.name.value))
          for (let [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              let argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type)
              context$2.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  { nodes: directiveNode },
                ),
              )
            }
          }
        }
      },
    },
  }
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null
}
function ScalarLeafsRule(context$2) {
  return {
    Field(node$1) {
      let type$2 = context$2.getType(), selectionSet = node$1.selectionSet
      if (type$2) {
        if (isLeafType(getNamedType(type$2))) {
          if (selectionSet) {
            let fieldName = node$1.name.value, typeStr = inspect(type$2)
            context$2.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                { nodes: selectionSet },
              ),
            )
          }
        } else if (selectionSet) {
          if (selectionSet.selections.length === 0) {
            let fieldName = node$1.name.value, typeStr = inspect(type$2)
            context$2.reportError(
              new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`, {
                nodes: node$1,
              }),
            )
          }
        } else {
          let fieldName = node$1.name.value, typeStr = inspect(type$2)
          context$2.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              { nodes: node$1 },
            ),
          )
        }
      }
    },
  }
}
function valueFromAST(valueNode, type$2, variables) {
  if (valueNode) {
    if (valueNode.kind === Kind.VARIABLE) {
      let variableName = valueNode.name.value
      if (variables == null || variables[variableName] === void 0) return
      let variableValue = variables[variableName]
      return variableValue === null && isNonNullType(type$2) ? void 0 : variableValue
    }
    if (isNonNullType(type$2)) {
      return valueNode.kind === Kind.NULL
        ? void 0
        : valueFromAST(valueNode, type$2.ofType, variables)
    }
    if (valueNode.kind === Kind.NULL) return null
    if (isListType(type$2)) {
      let itemType = type$2.ofType
      if (valueNode.kind === Kind.LIST) {
        let coercedValues = []
        for (let itemNode of valueNode.values) {
          if (isMissingVariable(itemNode, variables)) {
            if (isNonNullType(itemType)) return
            coercedValues.push(null)
          } else {
            let itemValue = valueFromAST(itemNode, itemType, variables)
            if (itemValue === void 0) return
            coercedValues.push(itemValue)
          }
        }
        return coercedValues
      }
      let coercedValue = valueFromAST(valueNode, itemType, variables)
      return coercedValue === void 0 ? void 0 : [coercedValue]
    }
    if (isInputObjectType(type$2)) {
      if (valueNode.kind !== Kind.OBJECT) return
      let coercedObj = Object.create(null), fieldNodes = keyMap(valueNode.fields, field => field.name.value)
      for (let field of Object.values(type$2.getFields())) {
        let fieldNode = fieldNodes[field.name]
        if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
          if (field.defaultValue !== void 0) coercedObj[field.name] = field.defaultValue
          else if (isNonNullType(field.type)) return
          continue
        }
        let fieldValue = valueFromAST(fieldNode.value, field.type, variables)
        if (fieldValue === void 0) return
        coercedObj[field.name] = fieldValue
      }
      if (type$2.isOneOf) {
        let keys$6 = Object.keys(coercedObj)
        if (keys$6.length !== 1 || coercedObj[keys$6[0]] === null) return
      }
      return coercedObj
    }
    if (isLeafType(type$2)) {
      let result
      try {
        result = type$2.parseLiteral(valueNode, variables)
      } catch {
        return
      }
      return result === void 0 ? void 0 : result
    }
    invariant(!1, `Unexpected input type: ` + inspect(type$2))
  }
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0)
}
function getArgumentValues(def, node$1, variableValues) {
  var _node$arguments
  let coercedValues = {},
    argumentNodes = (_node$arguments = node$1.arguments) ?? [],
    argNodeMap = keyMap(argumentNodes, arg => arg.name.value)
  for (let argDef of def.args) {
    let name = argDef.name, argType = argDef.type, argumentNode = argNodeMap[name]
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) coercedValues[name] = argDef.defaultValue
      else if (isNonNullType(argType)) {
        throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" was not provided.`, {
          nodes: node$1,
        })
      }
      continue
    }
    let valueNode = argumentNode.value, isNull$1 = valueNode.kind === Kind.NULL
    if (valueNode.kind === Kind.VARIABLE) {
      let variableName = valueNode.name.value
      if (variableValues == null || !hasOwnProperty$1(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) coercedValues[name] = argDef.defaultValue
        else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${
              inspect(argType)
            }" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            { nodes: valueNode },
          )
        }
        continue
      }
      isNull$1 = variableValues[variableName] == null
    }
    if (isNull$1 && isNonNullType(argType)) {
      throw new GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`, {
        nodes: valueNode,
      })
    }
    let coercedValue = valueFromAST(valueNode, argType, variableValues)
    if (coercedValue === void 0) {
      throw new GraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, { nodes: valueNode })
    }
    coercedValues[name] = coercedValue
  }
  return coercedValues
}
function getDirectiveValues(directiveDef, node$1, variableValues) {
  var _node$directives
  let directiveNode = (_node$directives = node$1.directives)?.find(directive =>
    directive.name.value === directiveDef.name
  )
  if (directiveNode) return getArgumentValues(directiveDef, directiveNode, variableValues)
}
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop)
}
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  let fields = new Map()
  return collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set()), fields
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (let selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) continue
        let name = getFieldEntryKey(selection), fieldList = fields.get(name)
        fieldList === void 0 ? fields.set(name, [selection]) : fieldList.push(selection)
        break
      }
      case Kind.INLINE_FRAGMENT:
        if (
          !shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)
        ) continue
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames,
        )
        break
      case Kind.FRAGMENT_SPREAD: {
        let fragName = selection.name.value
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) continue
        visitedFragmentNames.add(fragName)
        let fragment = fragments[fragName]
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) continue
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames,
        )
        break
      }
    }
  }
}
function shouldIncludeNode(variableValues, node$1) {
  let skip = getDirectiveValues(GraphQLSkipDirective, node$1, variableValues)
  if (skip?.if === !0) return !1
  let include = getDirectiveValues(GraphQLIncludeDirective, node$1, variableValues)
  return include?.if !== !1
}
function doesFragmentConditionMatch(schema, fragment, type$2) {
  let typeConditionNode = fragment.typeCondition
  if (!typeConditionNode) return !0
  let conditionalType = typeFromAST(schema, typeConditionNode)
  return conditionalType === type$2
    ? !0
    : isAbstractType(conditionalType)
    ? schema.isSubType(conditionalType, type$2)
    : !1
}
function getFieldEntryKey(node$1) {
  return node$1.alias ? node$1.alias.value : node$1.name.value
}
function SingleFieldSubscriptionsRule(context$2) {
  return {
    OperationDefinition(node$1) {
      if (node$1.operation === `subscription`) {
        let schema = context$2.getSchema(), subscriptionType = schema.getSubscriptionType()
        if (subscriptionType) {
          let operationName = node$1.name ? node$1.name.value : null,
            variableValues = Object.create(null),
            document$3 = context$2.getDocument(),
            fragments = Object.create(null)
          for (let definition$2 of document$3.definitions) {
            definition$2.kind === Kind.FRAGMENT_DEFINITION && (fragments[definition$2.name.value] = definition$2)
          }
          let fields = collectFields(schema, fragments, variableValues, subscriptionType, node$1.selectionSet)
          if (fields.size > 1) {
            let fieldSelectionLists = [...fields.values()],
              extraFieldSelectionLists = fieldSelectionLists.slice(1),
              extraFieldSelections = extraFieldSelectionLists.flat()
            context$2.reportError(
              new GraphQLError(
                operationName == null
                  ? `Anonymous Subscription must select only one top level field.`
                  : `Subscription "${operationName}" must select only one top level field.`,
                { nodes: extraFieldSelections },
              ),
            )
          }
          for (let fieldNodes of fields.values()) {
            let field = fieldNodes[0], fieldName = field.name.value
            fieldName.startsWith(`__`)
              && context$2.reportError(
                new GraphQLError(
                  operationName == null
                    ? `Anonymous Subscription must not select an introspection top level field.`
                    : `Subscription "${operationName}" must not select an introspection top level field.`,
                  { nodes: fieldNodes },
                ),
              )
          }
        }
      }
    },
  }
}
function groupBy(list$3, keyFn) {
  let result = new Map()
  for (let item of list$3) {
    let key$1 = keyFn(item), group = result.get(key$1)
    group === void 0 ? result.set(key$1, [item]) : group.push(item)
  }
  return result
}
function UniqueArgumentDefinitionNamesRule(context$2) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume
      let argumentNodes = (_directiveNode$argume = directiveNode.arguments) ?? []
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes)
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField,
  }
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields
    let typeName = typeNode.name.value, fieldNodes = (_typeNode$fields = typeNode.fields) ?? []
    for (let fieldDef of fieldNodes) {
      var _fieldDef$arguments
      let fieldName = fieldDef.name.value, argumentNodes = (_fieldDef$arguments = fieldDef.arguments) ?? []
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes)
    }
    return !1
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    let seenArgs = groupBy(argumentNodes, arg => arg.name.value)
    for (let [argName, argNodes] of seenArgs) {
      argNodes.length > 1
        && context$2.reportError(
          new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
            nodes: argNodes.map(node$1 => node$1.name),
          }),
        )
    }
    return !1
  }
}
function UniqueArgumentNamesRule(context$2) {
  return { Field: checkArgUniqueness, Directive: checkArgUniqueness }
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments
    let argumentNodes = (_parentNode$arguments = parentNode.arguments) ?? [],
      seenArgs = groupBy(argumentNodes, arg => arg.name.value)
    for (let [argName, argNodes] of seenArgs) {
      argNodes.length > 1
        && context$2.reportError(
          new GraphQLError(`There can be only one argument named "${argName}".`, {
            nodes: argNodes.map(node$1 => node$1.name),
          }),
        )
    }
  }
}
function UniqueDirectiveNamesRule(context$2) {
  let knownDirectiveNames = Object.create(null), schema = context$2.getSchema()
  return {
    DirectiveDefinition(node$1) {
      let directiveName = node$1.name.value
      if (schema != null && schema.getDirective(directiveName)) {
        context$2.reportError(
          new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
            nodes: node$1.name,
          }),
        )
        return
      }
      return knownDirectiveNames[directiveName]
        ? context$2.reportError(
          new GraphQLError(`There can be only one directive named "@${directiveName}".`, {
            nodes: [knownDirectiveNames[directiveName], node$1.name],
          }),
        )
        : knownDirectiveNames[directiveName] = node$1.name,
        !1
    },
  }
}
function UniqueDirectivesPerLocationRule(context$2) {
  let uniqueDirectiveMap = Object.create(null),
    schema = context$2.getSchema(),
    definedDirectives = schema ? schema.getDirectives() : specifiedDirectives
  for (let directive of definedDirectives) uniqueDirectiveMap[directive.name] = !directive.isRepeatable
  let astDefinitions = context$2.getDocument().definitions
  for (let def of astDefinitions) {
    def.kind === Kind.DIRECTIVE_DEFINITION && (uniqueDirectiveMap[def.name.value] = !def.repeatable)
  }
  let schemaDirectives = Object.create(null), typeDirectivesMap = Object.create(null)
  return {
    enter(node$1) {
      if (!(`directives` in node$1) || !node$1.directives) return
      let seenDirectives
      if (node$1.kind === Kind.SCHEMA_DEFINITION || node$1.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives
      } else if (isTypeDefinitionNode(node$1) || isTypeExtensionNode(node$1)) {
        let typeName = node$1.name.value
        seenDirectives = typeDirectivesMap[typeName],
          seenDirectives === void 0 && (typeDirectivesMap[typeName] = seenDirectives = Object.create(null))
      } else seenDirectives = Object.create(null)
      for (let directive of node$1.directives) {
        let directiveName = directive.name.value
        uniqueDirectiveMap[directiveName]
          && (seenDirectives[directiveName]
            ? context$2.reportError(
              new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                nodes: [seenDirectives[directiveName], directive],
              }),
            )
            : seenDirectives[directiveName] = directive)
      }
    },
  }
}
function UniqueEnumValueNamesRule(context$2) {
  let schema = context$2.getSchema(),
    existingTypeMap = schema ? schema.getTypeMap() : Object.create(null),
    knownValueNames = Object.create(null)
  return { EnumTypeDefinition: checkValueUniqueness, EnumTypeExtension: checkValueUniqueness }
  function checkValueUniqueness(node$1) {
    var _node$values
    let typeName = node$1.name.value
    knownValueNames[typeName] || (knownValueNames[typeName] = Object.create(null))
    let valueNodes = (_node$values = node$1.values) ?? [], valueNames = knownValueNames[typeName]
    for (let valueDef of valueNodes) {
      let valueName = valueDef.name.value, existingType = existingTypeMap[typeName]
      isEnumType(existingType) && existingType.getValue(valueName)
        ? context$2.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            { nodes: valueDef.name },
          ),
        )
        : valueNames[valueName]
        ? context$2.reportError(
          new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
            nodes: [valueNames[valueName], valueDef.name],
          }),
        )
        : valueNames[valueName] = valueDef.name
    }
    return !1
  }
}
function UniqueFieldDefinitionNamesRule(context$2) {
  let schema = context$2.getSchema(),
    existingTypeMap = schema ? schema.getTypeMap() : Object.create(null),
    knownFieldNames = Object.create(null)
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness,
  }
  function checkFieldUniqueness(node$1) {
    var _node$fields
    let typeName = node$1.name.value
    knownFieldNames[typeName] || (knownFieldNames[typeName] = Object.create(null))
    let fieldNodes = (_node$fields = node$1.fields) ?? [], fieldNames = knownFieldNames[typeName]
    for (let fieldDef of fieldNodes) {
      let fieldName = fieldDef.name.value
      hasField(existingTypeMap[typeName], fieldName)
        ? context$2.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            { nodes: fieldDef.name },
          ),
        )
        : fieldNames[fieldName]
        ? context$2.reportError(
          new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
            nodes: [fieldNames[fieldName], fieldDef.name],
          }),
        )
        : fieldNames[fieldName] = fieldDef.name
    }
    return !1
  }
}
function hasField(type$2, fieldName) {
  return isObjectType(type$2) || isInterfaceType(type$2) || isInputObjectType(type$2)
    ? type$2.getFields()[fieldName] != null
    : !1
}
function UniqueFragmentNamesRule(context$2) {
  let knownFragmentNames = Object.create(null)
  return {
    OperationDefinition: () => !1,
    FragmentDefinition(node$1) {
      let fragmentName = node$1.name.value
      return knownFragmentNames[fragmentName]
        ? context$2.reportError(
          new GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
            nodes: [knownFragmentNames[fragmentName], node$1.name],
          }),
        )
        : knownFragmentNames[fragmentName] = node$1.name,
        !1
    },
  }
}
function UniqueInputFieldNamesRule(context$2) {
  let knownNameStack = [], knownNames = Object.create(null)
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames), knownNames = Object.create(null)
      },
      leave() {
        let prevKnownNames = knownNameStack.pop()
        prevKnownNames || invariant(!1), knownNames = prevKnownNames
      },
    },
    ObjectField(node$1) {
      let fieldName = node$1.name.value
      knownNames[fieldName]
        ? context$2.reportError(
          new GraphQLError(`There can be only one input field named "${fieldName}".`, {
            nodes: [knownNames[fieldName], node$1.name],
          }),
        )
        : knownNames[fieldName] = node$1.name
    },
  }
}
function UniqueOperationNamesRule(context$2) {
  let knownOperationNames = Object.create(null)
  return {
    OperationDefinition(node$1) {
      let operationName = node$1.name
      return operationName
        && (knownOperationNames[operationName.value]
          ? context$2.reportError(
            new GraphQLError(`There can be only one operation named "${operationName.value}".`, {
              nodes: [knownOperationNames[operationName.value], operationName],
            }),
          )
          : knownOperationNames[operationName.value] = operationName),
        !1
    },
    FragmentDefinition: () => !1,
  }
}
function UniqueOperationTypesRule(context$2) {
  let schema = context$2.getSchema(),
    definedOperationTypes = Object.create(null),
    existingOperationTypes = schema
      ? { query: schema.getQueryType(), mutation: schema.getMutationType(), subscription: schema.getSubscriptionType() }
      : {}
  return { SchemaDefinition: checkOperationTypes, SchemaExtension: checkOperationTypes }
  function checkOperationTypes(node$1) {
    var _node$operationTypes
    let operationTypesNodes = (_node$operationTypes = node$1.operationTypes) ?? []
    for (let operationType of operationTypesNodes) {
      let operation = operationType.operation, alreadyDefinedOperationType = definedOperationTypes[operation]
      existingOperationTypes[operation]
        ? context$2.reportError(
          new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
            nodes: operationType,
          }),
        )
        : alreadyDefinedOperationType
        ? context$2.reportError(
          new GraphQLError(`There can be only one ${operation} type in schema.`, {
            nodes: [alreadyDefinedOperationType, operationType],
          }),
        )
        : definedOperationTypes[operation] = operationType
    }
    return !1
  }
}
function UniqueTypeNamesRule(context$2) {
  let knownTypeNames = Object.create(null), schema = context$2.getSchema()
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName,
  }
  function checkTypeName(node$1) {
    let typeName = node$1.name.value
    if (schema != null && schema.getType(typeName)) {
      context$2.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          { nodes: node$1.name },
        ),
      )
      return
    }
    return knownTypeNames[typeName]
      ? context$2.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node$1.name],
        }),
      )
      : knownTypeNames[typeName] = node$1.name,
      !1
  }
}
function UniqueVariableNamesRule(context$2) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab
      let variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) ?? [],
        seenVariableDefinitions = groupBy(variableDefinitions, node$1 => node$1.variable.name.value)
      for (let [variableName, variableNodes] of seenVariableDefinitions) {
        variableNodes.length > 1
          && context$2.reportError(
            new GraphQLError(`There can be only one variable named "$${variableName}".`, {
              nodes: variableNodes.map(node$1 => node$1.variable.name),
            }),
          )
      }
    },
  }
}
function ValuesOfCorrectTypeRule(context$2) {
  let variableDefinitions = {}
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {}
      },
    },
    VariableDefinition(definition$2) {
      variableDefinitions[definition$2.variable.name.value] = definition$2
    },
    ListValue(node$1) {
      let type$2 = getNullableType(context$2.getParentInputType())
      if (!isListType(type$2)) return isValidValueNode(context$2, node$1), !1
    },
    ObjectValue(node$1) {
      let type$2 = getNamedType(context$2.getInputType())
      if (!isInputObjectType(type$2)) return isValidValueNode(context$2, node$1), !1
      let fieldNodeMap = keyMap(node$1.fields, field => field.name.value)
      for (let fieldDef of Object.values(type$2.getFields())) {
        let fieldNode = fieldNodeMap[fieldDef.name]
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          let typeStr = inspect(fieldDef.type)
          context$2.reportError(
            new GraphQLError(
              `Field "${type$2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              { nodes: node$1 },
            ),
          )
        }
      }
      type$2.isOneOf && validateOneOfInputObject(context$2, node$1, type$2, fieldNodeMap, variableDefinitions)
    },
    ObjectField(node$1) {
      let parentType = getNamedType(context$2.getParentInputType()), fieldType = context$2.getInputType()
      if (!fieldType && isInputObjectType(parentType)) {
        let suggestions = suggestionList(node$1.name.value, Object.keys(parentType.getFields()))
        context$2.reportError(
          new GraphQLError(
            `Field "${node$1.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            { nodes: node$1 },
          ),
        )
      }
    },
    NullValue(node$1) {
      let type$2 = context$2.getInputType()
      isNonNullType(type$2)
        && context$2.reportError(
          new GraphQLError(`Expected value of type "${inspect(type$2)}", found ${print(node$1)}.`, { nodes: node$1 }),
        )
    },
    EnumValue: node$1 => isValidValueNode(context$2, node$1),
    IntValue: node$1 => isValidValueNode(context$2, node$1),
    FloatValue: node$1 => isValidValueNode(context$2, node$1),
    StringValue: node$1 => isValidValueNode(context$2, node$1),
    BooleanValue: node$1 => isValidValueNode(context$2, node$1),
  }
}
function isValidValueNode(context$2, node$1) {
  let locationType = context$2.getInputType()
  if (!locationType) return
  let type$2 = getNamedType(locationType)
  if (!isLeafType(type$2)) {
    let typeStr = inspect(locationType)
    context$2.reportError(
      new GraphQLError(`Expected value of type "${typeStr}", found ${print(node$1)}.`, { nodes: node$1 }),
    )
    return
  }
  try {
    let parseResult = type$2.parseLiteral(node$1, void 0)
    if (parseResult === void 0) {
      let typeStr = inspect(locationType)
      context$2.reportError(
        new GraphQLError(`Expected value of type "${typeStr}", found ${print(node$1)}.`, { nodes: node$1 }),
      )
    }
  } catch (error) {
    let typeStr = inspect(locationType)
    error instanceof GraphQLError
      ? context$2.reportError(error)
      : context$2.reportError(
        new GraphQLError(`Expected value of type "${typeStr}", found ${print(node$1)}; ` + error.message, {
          nodes: node$1,
          originalError: error,
        }),
      )
  }
}
function validateOneOfInputObject(context$2, node$1, type$2, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$
  let keys$6 = Object.keys(fieldNodeMap), isNotExactlyOneField = keys$6.length !== 1
  if (isNotExactlyOneField) {
    context$2.reportError(
      new GraphQLError(`OneOf Input Object "${type$2.name}" must specify exactly one key.`, { nodes: [node$1] }),
    )
    return
  }
  let value$2 = (_fieldNodeMap$keys$ = fieldNodeMap[keys$6[0]])?.value,
    isNullLiteral = !value$2 || value$2.kind === Kind.NULL,
    isVariable$1 = value$2?.kind === Kind.VARIABLE
  if (isNullLiteral) {
    context$2.reportError(
      new GraphQLError(`Field "${type$2.name}.${keys$6[0]}" must be non-null.`, { nodes: [node$1] }),
    )
    return
  }
  if (isVariable$1) {
    let variableName = value$2.name.value,
      definition$2 = variableDefinitions[variableName],
      isNullableVariable = definition$2.type.kind !== Kind.NON_NULL_TYPE
    isNullableVariable
      && context$2.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type$2.name}".`,
          { nodes: [node$1] },
        ),
      )
  }
}
function VariablesAreInputTypesRule(context$2) {
  return {
    VariableDefinition(node$1) {
      let type$2 = typeFromAST(context$2.getSchema(), node$1.type)
      if (type$2 !== void 0 && !isInputType(type$2)) {
        let variableName = node$1.variable.name.value, typeName = print(node$1.type)
        context$2.reportError(
          new GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, {
            nodes: node$1.type,
          }),
        )
      }
    },
  }
}
function VariablesInAllowedPositionRule(context$2) {
  let varDefMap = Object.create(null)
  return {
    OperationDefinition: {
      enter() {
        varDefMap = Object.create(null)
      },
      leave(operation) {
        let usages = context$2.getRecursiveVariableUsages(operation)
        for (let { node: node$1, type: type$2, defaultValue, parentType } of usages) {
          let varName = node$1.name.value, varDef = varDefMap[varName]
          if (varDef && type$2) {
            let schema = context$2.getSchema(), varType = typeFromAST(schema, varDef.type)
            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type$2, defaultValue)) {
              let varTypeStr = inspect(varType), typeStr = inspect(type$2)
              context$2.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  { nodes: [varDef, node$1] },
                ),
              )
            }
            isInputObjectType(parentType) && parentType.isOneOf && isNullableType(varType)
              && context$2.reportError(
                new GraphQLError(
                  `Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`,
                  { nodes: [varDef, node$1] },
                ),
              )
          }
        }
      },
    },
    VariableDefinition(node$1) {
      varDefMap[node$1.variable.name.value] = node$1
    },
  }
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    let hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL,
      hasLocationDefaultValue = locationDefaultValue !== void 0
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) return !1
    let nullableLocationType = locationType.ofType
    return isTypeSubTypeOf(schema, varType, nullableLocationType)
  }
  return isTypeSubTypeOf(schema, varType, locationType)
}
const recommendedRules = Object.freeze([MaxIntrospectionDepthRule]),
  specifiedRules = Object.freeze([
    ExecutableDefinitionsRule,
    UniqueOperationNamesRule,
    LoneAnonymousOperationRule,
    SingleFieldSubscriptionsRule,
    KnownTypeNamesRule,
    FragmentsOnCompositeTypesRule,
    VariablesAreInputTypesRule,
    ScalarLeafsRule,
    FieldsOnCorrectTypeRule,
    UniqueFragmentNamesRule,
    KnownFragmentNamesRule,
    NoUnusedFragmentsRule,
    PossibleFragmentSpreadsRule,
    NoFragmentCyclesRule,
    UniqueVariableNamesRule,
    NoUndefinedVariablesRule,
    NoUnusedVariablesRule,
    KnownDirectivesRule,
    UniqueDirectivesPerLocationRule,
    KnownArgumentNamesRule,
    UniqueArgumentNamesRule,
    ValuesOfCorrectTypeRule,
    ProvidedRequiredArgumentsRule,
    VariablesInAllowedPositionRule,
    OverlappingFieldsCanBeMergedRule,
    UniqueInputFieldNamesRule,
    ...recommendedRules,
  ]),
  specifiedSDLRules = Object.freeze([
    LoneSchemaDefinitionRule,
    UniqueOperationTypesRule,
    UniqueTypeNamesRule,
    UniqueEnumValueNamesRule,
    UniqueFieldDefinitionNamesRule,
    UniqueArgumentDefinitionNamesRule,
    UniqueDirectiveNamesRule,
    KnownTypeNamesRule,
    KnownDirectivesRule,
    UniqueDirectivesPerLocationRule,
    PossibleTypeExtensionsRule,
    KnownArgumentNamesOnDirectivesRule,
    UniqueArgumentNamesRule,
    UniqueInputFieldNamesRule,
    ProvidedRequiredArgumentsOnDirectivesRule,
  ])
var ASTValidationContext = class {
    constructor(ast, onError$2) {
      this._ast = ast,
        this._fragments = void 0,
        this._fragmentSpreads = new Map(),
        this._recursivelyReferencedFragments = new Map(),
        this._onError = onError$2
    }
    get [Symbol.toStringTag]() {
      return `ASTValidationContext`
    }
    reportError(error) {
      this._onError(error)
    }
    getDocument() {
      return this._ast
    }
    getFragment(name) {
      let fragments
      if (this._fragments) fragments = this._fragments
      else {
        fragments = Object.create(null)
        for (let defNode of this.getDocument().definitions) {
          defNode.kind === Kind.FRAGMENT_DEFINITION && (fragments[defNode.name.value] = defNode)
        }
        this._fragments = fragments
      }
      return fragments[name]
    }
    getFragmentSpreads(node$1) {
      let spreads = this._fragmentSpreads.get(node$1)
      if (!spreads) {
        spreads = []
        let setsToVisit = [node$1], set$6
        for (; set$6 = setsToVisit.pop();) {
          for (let selection of set$6.selections) {
            selection.kind === Kind.FRAGMENT_SPREAD
              ? spreads.push(selection)
              : selection.selectionSet && setsToVisit.push(selection.selectionSet)
          }
        }
        this._fragmentSpreads.set(node$1, spreads)
      }
      return spreads
    }
    getRecursivelyReferencedFragments(operation) {
      let fragments = this._recursivelyReferencedFragments.get(operation)
      if (!fragments) {
        fragments = []
        let collectedNames = Object.create(null), nodesToVisit = [operation.selectionSet], node$1
        for (; node$1 = nodesToVisit.pop();) {
          for (let spread of this.getFragmentSpreads(node$1)) {
            let fragName = spread.name.value
            if (collectedNames[fragName] !== !0) {
              collectedNames[fragName] = !0
              let fragment = this.getFragment(fragName)
              fragment && (fragments.push(fragment), nodesToVisit.push(fragment.selectionSet))
            }
          }
        }
        this._recursivelyReferencedFragments.set(operation, fragments)
      }
      return fragments
    }
  },
  SDLValidationContext = class extends ASTValidationContext {
    constructor(ast, schema, onError$2) {
      super(ast, onError$2), this._schema = schema
    }
    get [Symbol.toStringTag]() {
      return `SDLValidationContext`
    }
    getSchema() {
      return this._schema
    }
  },
  ValidationContext = class extends ASTValidationContext {
    constructor(schema, ast, typeInfo, onError$2) {
      super(ast, onError$2),
        this._schema = schema,
        this._typeInfo = typeInfo,
        this._variableUsages = new Map(),
        this._recursiveVariableUsages = new Map()
    }
    get [Symbol.toStringTag]() {
      return `ValidationContext`
    }
    getSchema() {
      return this._schema
    }
    getVariableUsages(node$1) {
      let usages = this._variableUsages.get(node$1)
      if (!usages) {
        let newUsages = [], typeInfo = new TypeInfo(this._schema)
        visit$1(
          node$1,
          visitWithTypeInfo(typeInfo, {
            VariableDefinition: () => !1,
            Variable(variable) {
              newUsages.push({
                node: variable,
                type: typeInfo.getInputType(),
                defaultValue: typeInfo.getDefaultValue(),
                parentType: typeInfo.getParentInputType(),
              })
            },
          }),
        ),
          usages = newUsages,
          this._variableUsages.set(node$1, usages)
      }
      return usages
    }
    getRecursiveVariableUsages(operation) {
      let usages = this._recursiveVariableUsages.get(operation)
      if (!usages) {
        usages = this.getVariableUsages(operation)
        for (let frag of this.getRecursivelyReferencedFragments(operation)) {
          usages = usages.concat(this.getVariableUsages(frag))
        }
        this._recursiveVariableUsages.set(operation, usages)
      }
      return usages
    }
    getType() {
      return this._typeInfo.getType()
    }
    getParentType() {
      return this._typeInfo.getParentType()
    }
    getInputType() {
      return this._typeInfo.getInputType()
    }
    getParentInputType() {
      return this._typeInfo.getParentInputType()
    }
    getFieldDef() {
      return this._typeInfo.getFieldDef()
    }
    getDirective() {
      return this._typeInfo.getDirective()
    }
    getArgument() {
      return this._typeInfo.getArgument()
    }
    getEnumValue() {
      return this._typeInfo.getEnumValue()
    }
  }
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  let errors = [],
    context$2 = new SDLValidationContext(documentAST, schemaToExtend, error => {
      errors.push(error)
    }),
    visitors = rules.map(rule => rule(context$2))
  return visit$1(documentAST, visitInParallel(visitors)), errors
}
function assertValidSDL(documentAST) {
  let errors = validateSDL(documentAST)
  if (errors.length !== 0) {
    throw Error(
      errors.map(error => error.message).join(`

`),
    )
  }
}
function extendSchemaImpl(schemaConfig, documentAST, options$2) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid
  let typeDefs = [], typeExtensionsMap = Object.create(null), directiveDefs = [], schemaDef, schemaExtensions = []
  for (let def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) schemaDef = def
    else if (def.kind === Kind.SCHEMA_EXTENSION) schemaExtensions.push(def)
    else if (isTypeDefinitionNode(def)) typeDefs.push(def)
    else if (isTypeExtensionNode(def)) {
      let extendedTypeName = def.name.value, existingTypeExtensions = typeExtensionsMap[extendedTypeName]
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def]
    } else def.kind === Kind.DIRECTIVE_DEFINITION && directiveDefs.push(def)
  }
  if (
    Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0
    && schemaExtensions.length === 0 && schemaDef == null
  ) return schemaConfig
  let typeMap = Object.create(null)
  for (let existingType of schemaConfig.types) typeMap[existingType.name] = extendNamedType(existingType)
  for (let typeNode of typeDefs) {
    var _stdTypeMap$name
    let name = typeNode.name.value
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) ?? buildType(typeNode)
  }
  let operationTypes = {
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions),
  }
  return {
    description: (_schemaDef = schemaDef) == null ? void 0 : (_schemaDef$descriptio = _schemaDef.description)?.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [...schemaConfig.directives.map(replaceDirective), ...directiveDefs.map(buildDirective)],
    extensions: Object.create(null),
    astNode: (_schemaDef2 = schemaDef) ?? schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options$2?.assumeValid) ?? !1,
  }
  function replaceType(type$2) {
    return isListType(type$2)
      ? new GraphQLList(replaceType(type$2.ofType))
      : isNonNullType(type$2)
      ? new GraphQLNonNull(replaceType(type$2.ofType))
      : replaceNamedType(type$2)
  }
  function replaceNamedType(type$2) {
    return typeMap[type$2.name]
  }
  function replaceDirective(directive) {
    let config = directive.toConfig()
    return new GraphQLDirective({ ...config, args: mapValue(config.args, extendArg) })
  }
  function extendNamedType(type$2) {
    if (isIntrospectionType(type$2) || isSpecifiedScalarType(type$2)) return type$2
    if (isScalarType(type$2)) return extendScalarType(type$2)
    if (isObjectType(type$2)) return extendObjectType(type$2)
    if (isInterfaceType(type$2)) return extendInterfaceType(type$2)
    if (isUnionType(type$2)) return extendUnionType(type$2)
    if (isEnumType(type$2)) return extendEnumType(type$2)
    if (isInputObjectType(type$2)) return extendInputObjectType(type$2)
    invariant(!1, `Unexpected type: ` + inspect(type$2))
  }
  function extendInputObjectType(type$2) {
    var _typeExtensionsMap$co
    let config = type$2.toConfig(), extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) ?? []
    return new GraphQLInputObjectType({
      ...config,
      fields: () => ({
        ...mapValue(config.fields, field => ({ ...field, type: replaceType(field.type) })),
        ...buildInputFieldMap(extensions),
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions),
    })
  }
  function extendEnumType(type$2) {
    var _typeExtensionsMap$ty
    let config = type$2.toConfig(), extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type$2.name]) ?? []
    return new GraphQLEnumType({
      ...config,
      values: { ...config.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config.extensionASTNodes.concat(extensions),
    })
  }
  function extendScalarType(type$2) {
    var _typeExtensionsMap$co2
    let config = type$2.toConfig(),
      extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) ?? [],
      specifiedByURL = config.specifiedByURL
    for (let extensionNode of extensions) {
      var _getSpecifiedByURL
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) ?? specifiedByURL
    }
    return new GraphQLScalarType({
      ...config,
      specifiedByURL,
      extensionASTNodes: config.extensionASTNodes.concat(extensions),
    })
  }
  function extendObjectType(type$2) {
    var _typeExtensionsMap$co3
    let config = type$2.toConfig(), extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) ?? []
    return new GraphQLObjectType({
      ...config,
      interfaces: () => [...type$2.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],
      fields: () => ({ ...mapValue(config.fields, extendField), ...buildFieldMap(extensions) }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions),
    })
  }
  function extendInterfaceType(type$2) {
    var _typeExtensionsMap$co4
    let config = type$2.toConfig(), extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) ?? []
    return new GraphQLInterfaceType({
      ...config,
      interfaces: () => [...type$2.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],
      fields: () => ({ ...mapValue(config.fields, extendField), ...buildFieldMap(extensions) }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions),
    })
  }
  function extendUnionType(type$2) {
    var _typeExtensionsMap$co5
    let config = type$2.toConfig(), extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) ?? []
    return new GraphQLUnionType({
      ...config,
      types: () => [...type$2.getTypes().map(replaceNamedType), ...buildUnionTypes(extensions)],
      extensionASTNodes: config.extensionASTNodes.concat(extensions),
    })
  }
  function extendField(field) {
    return { ...field, type: replaceType(field.type), args: field.args && mapValue(field.args, extendArg) }
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) }
  }
  function getOperationTypes(nodes) {
    let opTypes = {}
    for (let node$1 of nodes) {
      var _node$operationTypes
      let operationTypesNodes = (_node$operationTypes = node$1.operationTypes) ?? []
      for (let operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType$1(operationType.type)
      }
    }
    return opTypes
  }
  function getNamedType$1(node$1) {
    var _stdTypeMap$name2
    let name = node$1.name.value, type$2 = (_stdTypeMap$name2 = stdTypeMap[name]) ?? typeMap[name]
    if (type$2 === void 0) throw Error(`Unknown type: "${name}".`)
    return type$2
  }
  function getWrappedType(node$1) {
    return node$1.kind === Kind.LIST_TYPE
      ? new GraphQLList(getWrappedType(node$1.type))
      : node$1.kind === Kind.NON_NULL_TYPE
      ? new GraphQLNonNull(getWrappedType(node$1.type))
      : getNamedType$1(node$1)
  }
  function buildDirective(node$1) {
    var _node$description
    return new GraphQLDirective({
      name: node$1.name.value,
      description: (_node$description = node$1.description)?.value,
      locations: node$1.locations.map(({ value: value$2 }) => value$2),
      isRepeatable: node$1.repeatable,
      args: buildArgumentMap(node$1.arguments),
      astNode: node$1,
    })
  }
  function buildFieldMap(nodes) {
    let fieldConfigMap = Object.create(null)
    for (let node$1 of nodes) {
      var _node$fields
      let nodeFields = (_node$fields = node$1.fields) ?? []
      for (let field of nodeFields) {
        var _field$description
        fieldConfigMap[field.name.value] = {
          type: getWrappedType(field.type),
          description: (_field$description = field.description)?.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field,
        }
      }
    }
    return fieldConfigMap
  }
  function buildArgumentMap(args$1) {
    let argsNodes = args$1 ?? [], argConfigMap = Object.create(null)
    for (let arg of argsNodes) {
      var _arg$description
      let type$2 = getWrappedType(arg.type)
      argConfigMap[arg.name.value] = {
        type: type$2,
        description: (_arg$description = arg.description)?.value,
        defaultValue: valueFromAST(arg.defaultValue, type$2),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg,
      }
    }
    return argConfigMap
  }
  function buildInputFieldMap(nodes) {
    let inputFieldMap = Object.create(null)
    for (let node$1 of nodes) {
      var _node$fields2
      let fieldsNodes = (_node$fields2 = node$1.fields) ?? []
      for (let field of fieldsNodes) {
        var _field$description2
        let type$2 = getWrappedType(field.type)
        inputFieldMap[field.name.value] = {
          type: type$2,
          description: (_field$description2 = field.description)?.value,
          defaultValue: valueFromAST(field.defaultValue, type$2),
          deprecationReason: getDeprecationReason(field),
          astNode: field,
        }
      }
    }
    return inputFieldMap
  }
  function buildEnumValueMap(nodes) {
    let enumValueMap = Object.create(null)
    for (let node$1 of nodes) {
      var _node$values
      let valuesNodes = (_node$values = node$1.values) ?? []
      for (let value$2 of valuesNodes) {
        var _value$description
        enumValueMap[value$2.name.value] = {
          description: (_value$description = value$2.description)?.value,
          deprecationReason: getDeprecationReason(value$2),
          astNode: value$2,
        }
      }
    }
    return enumValueMap
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap(node$1 => {
      var _node$interfaces$map, _node$interfaces
      return (_node$interfaces$map = (_node$interfaces = node$1.interfaces)?.map(getNamedType$1)) ?? []
    })
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap(node$1 => {
      var _node$types$map, _node$types
      return (_node$types$map = (_node$types = node$1.types)?.map(getNamedType$1)) ?? []
    })
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na
    let name = astNode.name.value, extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) ?? []
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description
        let allNodes = [astNode, ...extensionASTNodes]
        return new GraphQLObjectType({
          name,
          description: (_astNode$description = astNode.description)?.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes,
        })
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2
        let allNodes = [astNode, ...extensionASTNodes]
        return new GraphQLInterfaceType({
          name,
          description: (_astNode$description2 = astNode.description)?.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes,
        })
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3
        let allNodes = [astNode, ...extensionASTNodes]
        return new GraphQLEnumType({
          name,
          description: (_astNode$description3 = astNode.description)?.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes,
        })
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4
        let allNodes = [astNode, ...extensionASTNodes]
        return new GraphQLUnionType({
          name,
          description: (_astNode$description4 = astNode.description)?.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes,
        })
      }
      case Kind.SCALAR_TYPE_DEFINITION:
        var _astNode$description5
        return new GraphQLScalarType({
          name,
          description: (_astNode$description5 = astNode.description)?.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes,
        })
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6
        let allNodes = [astNode, ...extensionASTNodes]
        return new GraphQLInputObjectType({
          name,
          description: (_astNode$description6 = astNode.description)?.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes,
          isOneOf: isOneOf(astNode),
        })
      }
    }
  }
}
const stdTypeMap = keyMap([...specifiedScalarTypes, ...introspectionTypes], type$2 => type$2.name)
function getDeprecationReason(node$1) {
  let deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node$1)
  return deprecated?.reason
}
function getSpecifiedByURL(node$1) {
  let specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node$1)
  return specifiedBy?.url
}
function isOneOf(node$1) {
  return !!getDirectiveValues(GraphQLOneOfDirective, node$1)
}
function buildASTSchema(documentAST, options$2) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(!1, `Must provide valid Document AST.`),
    options$2?.assumeValid !== !0 && options$2?.assumeValidSDL !== !0 && assertValidSDL(documentAST)
  let emptySchemaConfig = {
      description: void 0,
      types: [],
      directives: [],
      extensions: Object.create(null),
      extensionASTNodes: [],
      assumeValid: !1,
    },
    config = extendSchemaImpl(emptySchemaConfig, documentAST, options$2)
  if (config.astNode == null) {
    for (let type$2 of config.types) {
      switch (type$2.name) {
        case `Query`:
          config.query = type$2
          break
        case `Mutation`:
          config.mutation = type$2
          break
        case `Subscription`:
          config.subscription = type$2
          break
      }
    }
  }
  let directives = [
    ...config.directives,
    ...specifiedDirectives.filter(stdDirective =>
      config.directives.every(directive => directive.name !== stdDirective.name)
    ),
  ]
  return new GraphQLSchema({ ...config, directives })
}
function printSchema(schema) {
  return printFilteredSchema(schema, n$19 => !isSpecifiedDirective(n$19), isDefinedType)
}
function isDefinedType(type$2) {
  return !isSpecifiedScalarType(type$2) && !isIntrospectionType(type$2)
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
  let directives = schema.getDirectives().filter(directiveFilter),
    types = Object.values(schema.getTypeMap()).filter(typeFilter)
  return [
    printSchemaDefinition(schema),
    ...directives.map(directive => printDirective(directive)),
    ...types.map(type$2 => printType(type$2)),
  ].filter(Boolean).join(`

`)
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) return
  let operationTypes = [], queryType = schema.getQueryType()
  queryType && operationTypes.push(`  query: ${queryType.name}`)
  let mutationType = schema.getMutationType()
  mutationType && operationTypes.push(`  mutation: ${mutationType.name}`)
  let subscriptionType = schema.getSubscriptionType()
  return subscriptionType && operationTypes.push(`  subscription: ${subscriptionType.name}`),
    printDescription(schema) + `schema {\n${
      operationTypes.join(`
`)
    }\n}`
}
function isSchemaOfCommonNames(schema) {
  let queryType = schema.getQueryType()
  if (queryType && queryType.name !== `Query`) return !1
  let mutationType = schema.getMutationType()
  if (mutationType && mutationType.name !== `Mutation`) return !1
  let subscriptionType = schema.getSubscriptionType()
  return !(subscriptionType && subscriptionType.name !== `Subscription`)
}
function printType(type$2) {
  if (isScalarType(type$2)) return printScalar(type$2)
  if (isObjectType(type$2)) return printObject(type$2)
  if (isInterfaceType(type$2)) return printInterface(type$2)
  if (isUnionType(type$2)) return printUnion(type$2)
  if (isEnumType(type$2)) return printEnum(type$2)
  if (isInputObjectType(type$2)) return printInputObject(type$2)
  invariant(!1, `Unexpected type: ` + inspect(type$2))
}
function printScalar(type$2) {
  return printDescription(type$2) + `scalar ${type$2.name}` + printSpecifiedByURL(type$2)
}
function printImplementedInterfaces(type$2) {
  let interfaces = type$2.getInterfaces()
  return interfaces.length ? ` implements ` + interfaces.map(i$14 => i$14.name).join(` & `) : ``
}
function printObject(type$2) {
  return printDescription(type$2) + `type ${type$2.name}` + printImplementedInterfaces(type$2) + printFields(type$2)
}
function printInterface(type$2) {
  return printDescription(type$2) + `interface ${type$2.name}` + printImplementedInterfaces(type$2)
    + printFields(type$2)
}
function printUnion(type$2) {
  let types = type$2.getTypes(), possibleTypes = types.length ? ` = ` + types.join(` | `) : ``
  return printDescription(type$2) + `union ` + type$2.name + possibleTypes
}
function printEnum(type$2) {
  let values$6 = type$2.getValues().map((value$2, i$14) =>
    printDescription(value$2, `  `, !i$14) + `  ` + value$2.name + printDeprecated(value$2.deprecationReason)
  )
  return printDescription(type$2) + `enum ${type$2.name}` + printBlock(values$6)
}
function printInputObject(type$2) {
  let fields = Object.values(type$2.getFields()).map((f$14, i$14) =>
    printDescription(f$14, `  `, !i$14) + `  ` + printInputValue(f$14)
  )
  return printDescription(type$2) + `input ${type$2.name}` + (type$2.isOneOf ? ` @oneOf` : ``) + printBlock(fields)
}
function printFields(type$2) {
  let fields = Object.values(type$2.getFields()).map((f$14, i$14) =>
    printDescription(f$14, `  `, !i$14) + `  ` + f$14.name + printArgs(f$14.args, `  `) + `: ` + String(f$14.type)
    + printDeprecated(f$14.deprecationReason)
  )
  return printBlock(fields)
}
function printBlock(items) {
  return items.length === 0 ? `` : ` {
` + items.join(`
`)
    + `
}`
}
function printArgs(args$1, indentation = ``) {
  return args$1.length === 0
    ? ``
    : args$1.every(arg => !arg.description)
    ? `(` + args$1.map(printInputValue).join(`, `) + `)`
    : `(
`
      + args$1.map((arg, i$14) =>
        printDescription(arg, `  ` + indentation, !i$14) + `  ` + indentation + printInputValue(arg)
      ).join(`
`) + `
` + indentation + `)`
}
function printInputValue(arg) {
  let defaultAST = astFromValue(arg.defaultValue, arg.type), argDecl = arg.name + `: ` + String(arg.type)
  return defaultAST && (argDecl += ` = ${print(defaultAST)}`), argDecl + printDeprecated(arg.deprecationReason)
}
function printDirective(directive) {
  return printDescription(directive) + `directive @` + directive.name + printArgs(directive.args)
    + (directive.isRepeatable ? ` repeatable` : ``) + ` on ` + directive.locations.join(` | `)
}
function printDeprecated(reason) {
  if (reason == null) return ``
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    let astValue = print({ kind: Kind.STRING, value: reason })
    return ` @deprecated(reason: ${astValue})`
  }
  return ` @deprecated`
}
function printSpecifiedByURL(scalar) {
  if (scalar.specifiedByURL == null) return ``
  let astValue = print({ kind: Kind.STRING, value: scalar.specifiedByURL })
  return ` @specifiedBy(url: ${astValue})`
}
function printDescription(def, indentation = ``, firstInBlock = !0) {
  let { description } = def
  if (description == null) return ``
  let blockString = print({ kind: Kind.STRING, value: description, block: isPrintableAsBlockString(description) }),
    prefix$1 = indentation && !firstInBlock
      ? `
` + indentation
      : indentation
  return prefix$1 + blockString.replace(
    /\n/g,
    `
` + indentation,
  ) + `
`
}
const scriptRel = `modulepreload`,
  assetsURL = function(dep) {
    return `/` + dep
  },
  seen = {},
  __vitePreload = function(baseModule, deps, importerUrl) {
    let promise$2 = Promise.resolve()
    if (deps && deps.length > 0) {
      let links = document.getElementsByTagName(`link`),
        cspNonceMeta = document.querySelector(`meta[property=csp-nonce]`),
        cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute(`nonce`)
      function allSettled(promises$2) {
        return Promise.all(
          promises$2.map(p$1$1 =>
            Promise.resolve(p$1$1).then(
              value$1$1 => ({ status: `fulfilled`, value: value$1$1 }),
              reason => ({ status: `rejected`, reason }),
            )
          ),
        )
      }
      promise$2 = allSettled(deps.map(dep => {
        if (dep = assetsURL(dep, importerUrl), dep in seen) return
        seen[dep] = !0
        let isCss = dep.endsWith(`.css`),
          cssSelector = isCss ? `[rel="stylesheet"]` : ``,
          isBaseRelative = !!importerUrl
        if (isBaseRelative) {
          for (let i$1$1 = links.length - 1; i$1$1 >= 0; i$1$1--) {
            let link$1$1 = links[i$1$1]
            if (link$1$1.href === dep && (!isCss || link$1$1.rel === `stylesheet`)) return
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return
        let link$2 = document.createElement(`link`)
        if (
          link$2.rel = isCss ? `stylesheet` : scriptRel,
            isCss || (link$2.as = `script`),
            link$2.crossOrigin = ``,
            link$2.href = dep,
            cspNonce && link$2.setAttribute(`nonce`, cspNonce),
            document.head.appendChild(link$2),
            isCss
        ) {
          return new Promise((res, rej) => {
            link$2.addEventListener(`load`, res),
              link$2.addEventListener(`error`, () => rej(Error(`Unable to preload CSS for ${dep}`)))
          })
        }
      }))
    }
    function handlePreloadError(err$2) {
      let e$1$1 = new Event(`vite:preloadError`, { cancelable: !0 })
      if (e$1$1.payload = err$2, window.dispatchEvent(e$1$1), !e$1$1.defaultPrevented) throw err$2
    }
    return promise$2.then(res => {
      for (let item of res || []) {
        if (item.status !== `rejected`) continue
        handlePreloadError(item.reason)
      }
      return baseModule().catch(handlePreloadError)
    })
  },
  neverCase = value$2 => {
    never({ type: `case`, value: value$2 })
  },
  never = context$2 => {
    throw Error(`Something that should be impossible happened`, { cause: context$2 })
  },
  curry = fn => {
    let fn_ = fn, curried = arg1 => arg2 => fn_(arg1, arg2)
    return curried
  },
  flipCurried = fn => {
    let flipped = arg1 => arg2 => fn(arg2)(arg1)
    return flipped
  },
  includesUnknown = (array$3, value$2) => array$3.includes(value$2),
  join$1 = (values$6, separator) => values$6.join(separator),
  joinOn = curry(join$1),
  joinWith = flipCurried(joinOn),
  merge$1 = (array1, array2) => array1.concat(array2),
  mergeOn = curry(merge$1),
  title = str => str.replaceAll(/[-_]/g, ` `).replace(/\b\w/g, l$9 => l$9.toUpperCase()),
  NotFound$1 = { code: 404, description: `Not Found` },
  notFound = new Response(NotFound$1.description, { status: NotFound$1.code }),
  ObjPartition = (obj, keys$6) =>
    keys$6.reduce(
      (acc, key$1) => (key$1 in acc.omitted && (delete acc.omitted[key$1], acc.picked[key$1] = obj[key$1]), acc),
      { omitted: { ...obj }, picked: {} },
    ),
  Level = Literal(`BREAKING`, `DANGEROUS`, `NON_BREAKING`),
  Criticality = Struct({ level: Level, reason: optional(String$) }).annotations({
    identifier: `Criticality`,
    title: `Change Criticality`,
    description: `The criticality assessment of a GraphQL schema change`,
  }),
  make$16 = Criticality.make,
  is$24 = is$25(Criticality),
  isBreaking$1 = criticality => criticality.level === `BREAKING`,
  isDangerous$1 = criticality => criticality.level === `DANGEROUS`,
  isSafe$1 = criticality => criticality.level === `NON_BREAKING`,
  decode$25 = decode$26(Criticality),
  encode$24 = encode$25(Criticality),
  equivalence$19 = equivalence$20(Criticality),
  ChangeBase$1 = Struct({ message: String$, path: optional(String$), criticality: Criticality }),
  TypeAdded = TaggedStruct(`TYPE_ADDED`, { ...ChangeBase$1.fields, name: String$ }),
  TypeRemoved = TaggedStruct(`TYPE_REMOVED`, { ...ChangeBase$1.fields, name: String$ }),
  TypeKindChanged = TaggedStruct(`TYPE_KIND_CHANGED`, {
    ...ChangeBase$1.fields,
    name: String$,
    oldKind: String$,
    newKind: String$,
  }),
  TypeDescriptionChanged = TaggedStruct(`TYPE_DESCRIPTION_CHANGED`, {
    ...ChangeBase$1.fields,
    name: String$,
    oldDescription: optional(String$),
    newDescription: optional(String$),
  }),
  TypeDescriptionAdded = TaggedStruct(`TYPE_DESCRIPTION_ADDED`, {
    ...ChangeBase$1.fields,
    name: String$,
    description: String$,
  }),
  TypeDescriptionRemoved = TaggedStruct(`TYPE_DESCRIPTION_REMOVED`, { ...ChangeBase$1.fields, name: String$ }),
  FieldAdded = TaggedStruct(`FIELD_ADDED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    isDeprecated: Boolean$,
    isSafe: Boolean$,
  }),
  FieldRemoved = TaggedStruct(`FIELD_REMOVED`, { ...ChangeBase$1.fields, typeName: String$, fieldName: String$ }),
  FieldTypeChanged = TaggedStruct(`FIELD_TYPE_CHANGED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    oldType: String$,
    newType: String$,
    isSafe: Boolean$,
  }),
  FieldDeprecationAdded = TaggedStruct(`FIELD_DEPRECATION_ADDED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    reason: optional(String$),
  }),
  FieldDeprecationRemoved = TaggedStruct(`FIELD_DEPRECATION_REMOVED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
  }),
  FieldDeprecationReasonChanged = TaggedStruct(`FIELD_DEPRECATION_REASON_CHANGED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    oldReason: optional(String$),
    newReason: optional(String$),
  }),
  FieldDeprecationReasonAdded = TaggedStruct(`FIELD_DEPRECATION_REASON_ADDED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    reason: String$,
  }),
  FieldDeprecationReasonRemoved = TaggedStruct(`FIELD_DEPRECATION_REASON_REMOVED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
  }),
  FieldDescriptionChanged = TaggedStruct(`FIELD_DESCRIPTION_CHANGED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    oldDescription: optional(String$),
    newDescription: optional(String$),
  }),
  FieldDescriptionAdded = TaggedStruct(`FIELD_DESCRIPTION_ADDED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    description: String$,
  }),
  FieldDescriptionRemoved = TaggedStruct(`FIELD_DESCRIPTION_REMOVED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
  }),
  FieldArgumentAdded = TaggedStruct(`FIELD_ARGUMENT_ADDED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    argumentName: String$,
    type: String$,
    defaultValue: optional(Unknown),
  }),
  FieldArgumentRemoved = TaggedStruct(`FIELD_ARGUMENT_REMOVED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    argumentName: String$,
  }),
  FieldArgumentTypeChanged = TaggedStruct(`FIELD_ARGUMENT_TYPE_CHANGED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    argumentName: String$,
    oldType: String$,
    newType: String$,
  }),
  FieldArgumentDescriptionChanged = TaggedStruct(`FIELD_ARGUMENT_DESCRIPTION_CHANGED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    argumentName: String$,
    oldDescription: optional(String$),
    newDescription: optional(String$),
  }),
  FieldArgumentDefaultChanged = TaggedStruct(`FIELD_ARGUMENT_DEFAULT_CHANGED`, {
    ...ChangeBase$1.fields,
    typeName: String$,
    fieldName: String$,
    argumentName: String$,
    oldDefault: optional(Unknown),
    newDefault: optional(Unknown),
  }),
  EnumValueAdded = TaggedStruct(`ENUM_VALUE_ADDED`, {
    ...ChangeBase$1.fields,
    enumName: String$,
    value: String$,
    isDeprecated: Boolean$,
  }),
  EnumValueRemoved = TaggedStruct(`ENUM_VALUE_REMOVED`, { ...ChangeBase$1.fields, enumName: String$, value: String$ }),
  EnumValueDescriptionChanged = TaggedStruct(`ENUM_VALUE_DESCRIPTION_CHANGED`, {
    ...ChangeBase$1.fields,
    enumName: String$,
    value: String$,
    oldDescription: optional(String$),
    newDescription: optional(String$),
  }),
  EnumValueDeprecationAdded = TaggedStruct(`ENUM_VALUE_DEPRECATION_ADDED`, {
    ...ChangeBase$1.fields,
    enumName: String$,
    value: String$,
    reason: optional(String$),
  }),
  EnumValueDeprecationRemoved = TaggedStruct(`ENUM_VALUE_DEPRECATION_REMOVED`, {
    ...ChangeBase$1.fields,
    enumName: String$,
    value: String$,
  }),
  EnumValueDeprecationReasonChanged = TaggedStruct(`ENUM_VALUE_DEPRECATION_REASON_CHANGED`, {
    ...ChangeBase$1.fields,
    enumName: String$,
    value: String$,
    oldReason: optional(String$),
    newReason: optional(String$),
  }),
  EnumValueDeprecationReasonAdded = TaggedStruct(`ENUM_VALUE_DEPRECATION_REASON_ADDED`, {
    ...ChangeBase$1.fields,
    enumName: String$,
    value: String$,
    reason: String$,
  }),
  EnumValueDeprecationReasonRemoved = TaggedStruct(`ENUM_VALUE_DEPRECATION_REASON_REMOVED`, {
    ...ChangeBase$1.fields,
    enumName: String$,
    value: String$,
  }),
  InputFieldAdded = TaggedStruct(`INPUT_FIELD_ADDED`, {
    ...ChangeBase$1.fields,
    inputName: String$,
    fieldName: String$,
    isNullable: Boolean$,
  }),
  InputFieldRemoved = TaggedStruct(`INPUT_FIELD_REMOVED`, {
    ...ChangeBase$1.fields,
    inputName: String$,
    fieldName: String$,
  }),
  InputFieldTypeChanged = TaggedStruct(`INPUT_FIELD_TYPE_CHANGED`, {
    ...ChangeBase$1.fields,
    inputName: String$,
    fieldName: String$,
    oldType: String$,
    newType: String$,
  }),
  InputFieldDescriptionAdded = TaggedStruct(`INPUT_FIELD_DESCRIPTION_ADDED`, {
    ...ChangeBase$1.fields,
    inputName: String$,
    fieldName: String$,
    description: String$,
  }),
  InputFieldDescriptionRemoved = TaggedStruct(`INPUT_FIELD_DESCRIPTION_REMOVED`, {
    ...ChangeBase$1.fields,
    inputName: String$,
    fieldName: String$,
  }),
  InputFieldDescriptionChanged = TaggedStruct(`INPUT_FIELD_DESCRIPTION_CHANGED`, {
    ...ChangeBase$1.fields,
    inputName: String$,
    fieldName: String$,
    oldDescription: optional(String$),
    newDescription: optional(String$),
  }),
  InputFieldDefaultValueChanged = TaggedStruct(`INPUT_FIELD_DEFAULT_VALUE_CHANGED`, {
    ...ChangeBase$1.fields,
    inputName: String$,
    fieldName: String$,
    oldDefault: optional(Unknown),
    newDefault: optional(Unknown),
  }),
  UnionMemberAdded = TaggedStruct(`UNION_MEMBER_ADDED`, {
    ...ChangeBase$1.fields,
    unionName: String$,
    memberName: String$,
  }),
  UnionMemberRemoved = TaggedStruct(`UNION_MEMBER_REMOVED`, {
    ...ChangeBase$1.fields,
    unionName: String$,
    memberName: String$,
  }),
  ObjectTypeInterfaceAdded = TaggedStruct(`OBJECT_TYPE_INTERFACE_ADDED`, {
    ...ChangeBase$1.fields,
    objectName: String$,
    interfaceName: String$,
  }),
  ObjectTypeInterfaceRemoved = TaggedStruct(`OBJECT_TYPE_INTERFACE_REMOVED`, {
    ...ChangeBase$1.fields,
    objectName: String$,
    interfaceName: String$,
  }),
  DirectiveAdded = TaggedStruct(`DIRECTIVE_ADDED`, {
    ...ChangeBase$1.fields,
    name: String$,
    locations: Array$(String$),
  }),
  DirectiveRemoved = TaggedStruct(`DIRECTIVE_REMOVED`, { ...ChangeBase$1.fields, name: String$ }),
  DirectiveDescriptionChanged = TaggedStruct(`DIRECTIVE_DESCRIPTION_CHANGED`, {
    ...ChangeBase$1.fields,
    name: String$,
    oldDescription: optional(String$),
    newDescription: optional(String$),
  }),
  DirectiveLocationAdded = TaggedStruct(`DIRECTIVE_LOCATION_ADDED`, {
    ...ChangeBase$1.fields,
    name: String$,
    location: String$,
  }),
  DirectiveLocationRemoved = TaggedStruct(`DIRECTIVE_LOCATION_REMOVED`, {
    ...ChangeBase$1.fields,
    name: String$,
    location: String$,
  }),
  DirectiveArgumentAdded = TaggedStruct(`DIRECTIVE_ARGUMENT_ADDED`, {
    ...ChangeBase$1.fields,
    directiveName: String$,
    argumentName: String$,
    type: String$,
  }),
  DirectiveArgumentRemoved = TaggedStruct(`DIRECTIVE_ARGUMENT_REMOVED`, {
    ...ChangeBase$1.fields,
    directiveName: String$,
    argumentName: String$,
  }),
  DirectiveArgumentDescriptionChanged = TaggedStruct(`DIRECTIVE_ARGUMENT_DESCRIPTION_CHANGED`, {
    ...ChangeBase$1.fields,
    directiveName: String$,
    argumentName: String$,
    oldDescription: optional(String$),
    newDescription: optional(String$),
  }),
  DirectiveArgumentDefaultValueChanged = TaggedStruct(`DIRECTIVE_ARGUMENT_DEFAULT_VALUE_CHANGED`, {
    ...ChangeBase$1.fields,
    directiveName: String$,
    argumentName: String$,
    oldDefault: optional(Unknown),
    newDefault: optional(Unknown),
  }),
  DirectiveArgumentTypeChanged = TaggedStruct(`DIRECTIVE_ARGUMENT_TYPE_CHANGED`, {
    ...ChangeBase$1.fields,
    directiveName: String$,
    argumentName: String$,
    oldType: String$,
    newType: String$,
  }),
  SchemaQueryTypeChanged = TaggedStruct(`SCHEMA_QUERY_TYPE_CHANGED`, {
    ...ChangeBase$1.fields,
    oldType: optional(String$),
    newType: optional(String$),
  }),
  SchemaMutationTypeChanged = TaggedStruct(`SCHEMA_MUTATION_TYPE_CHANGED`, {
    ...ChangeBase$1.fields,
    oldType: optional(String$),
    newType: optional(String$),
  }),
  SchemaSubscriptionTypeChanged = TaggedStruct(`SCHEMA_SUBSCRIPTION_TYPE_CHANGED`, {
    ...ChangeBase$1.fields,
    oldType: optional(String$),
    newType: optional(String$),
  }),
  Change = Union(
    TypeAdded,
    TypeRemoved,
    TypeKindChanged,
    TypeDescriptionChanged,
    TypeDescriptionAdded,
    TypeDescriptionRemoved,
    FieldAdded,
    FieldRemoved,
    FieldTypeChanged,
    FieldDeprecationAdded,
    FieldDeprecationRemoved,
    FieldDeprecationReasonChanged,
    FieldDeprecationReasonAdded,
    FieldDeprecationReasonRemoved,
    FieldDescriptionChanged,
    FieldDescriptionAdded,
    FieldDescriptionRemoved,
    FieldArgumentAdded,
    FieldArgumentRemoved,
    FieldArgumentTypeChanged,
    FieldArgumentDescriptionChanged,
    FieldArgumentDefaultChanged,
    EnumValueAdded,
    EnumValueRemoved,
    EnumValueDescriptionChanged,
    EnumValueDeprecationAdded,
    EnumValueDeprecationRemoved,
    EnumValueDeprecationReasonChanged,
    EnumValueDeprecationReasonAdded,
    EnumValueDeprecationReasonRemoved,
    InputFieldAdded,
    InputFieldRemoved,
    InputFieldTypeChanged,
    InputFieldDescriptionAdded,
    InputFieldDescriptionRemoved,
    InputFieldDescriptionChanged,
    InputFieldDefaultValueChanged,
    UnionMemberAdded,
    UnionMemberRemoved,
    ObjectTypeInterfaceAdded,
    ObjectTypeInterfaceRemoved,
    DirectiveAdded,
    DirectiveRemoved,
    DirectiveDescriptionChanged,
    DirectiveLocationAdded,
    DirectiveLocationRemoved,
    DirectiveArgumentAdded,
    DirectiveArgumentRemoved,
    DirectiveArgumentDescriptionChanged,
    DirectiveArgumentDefaultValueChanged,
    DirectiveArgumentTypeChanged,
    SchemaQueryTypeChanged,
    SchemaMutationTypeChanged,
    SchemaSubscriptionTypeChanged,
  ).annotations({ identifier: `Change`, title: `Schema Change`, description: `A change detected between two schemas` }),
  is$23 = is$25(Change),
  isTypeAdded = is$25(TypeAdded),
  isTypeRemoved = is$25(TypeRemoved),
  isFieldAdded = is$25(FieldAdded),
  isFieldRemoved = is$25(FieldRemoved),
  isBreaking = change => isBreaking$1(change.criticality),
  isDangerous = change => isDangerous$1(change.criticality),
  isSafe = change => isSafe$1(change.criticality),
  decode$24 = decode$26(Change),
  encode$23 = encode$25(Change),
  equivalence$18 = equivalence$20(Change),
  getType = change => {
    let tag$3 = change._tag
    if (tag$3 === `TYPE_ADDED` || tag$3 === `TYPE_REMOVED` || tag$3 === `TYPE_KIND_CHANGED`) return `TypeOperation`
    if (
      tag$3 === `TYPE_DESCRIPTION_CHANGED` || tag$3 === `TYPE_DESCRIPTION_ADDED` || tag$3 === `TYPE_DESCRIPTION_REMOVED`
    ) return `TypeDescription`
    if (tag$3 === `FIELD_ADDED` || tag$3 === `FIELD_REMOVED` || tag$3 === `FIELD_TYPE_CHANGED`) return `FieldOperation`
    if (
      tag$3 === `FIELD_DESCRIPTION_CHANGED` || tag$3 === `FIELD_DESCRIPTION_ADDED`
      || tag$3 === `FIELD_DESCRIPTION_REMOVED`
    ) return `FieldDescription`
    if (tag$3 === `FIELD_DEPRECATION_ADDED` || tag$3 === `FIELD_DEPRECATION_REMOVED`) return `FieldDeprecation`
    if (
      tag$3 === `FIELD_DEPRECATION_REASON_CHANGED` || tag$3 === `FIELD_DEPRECATION_REASON_ADDED`
      || tag$3 === `FIELD_DEPRECATION_REASON_REMOVED`
    ) return `FieldDeprecationReason`
    if (tag$3 === `FIELD_ARGUMENT_ADDED` || tag$3 === `FIELD_ARGUMENT_REMOVED`) return `FieldArgument`
    if (tag$3 === `FIELD_ARGUMENT_TYPE_CHANGED` || tag$3 === `FIELD_ARGUMENT_DEFAULT_CHANGED`) {
      return `FieldArgumentOperation`
    }
    if (tag$3 === `FIELD_ARGUMENT_DESCRIPTION_CHANGED`) return `FieldArgumentDescription`
    if (tag$3 === `ENUM_VALUE_ADDED` || tag$3 === `ENUM_VALUE_REMOVED`) return `EnumValueOperation`
    if (tag$3 === `ENUM_VALUE_DESCRIPTION_CHANGED`) return `EnumValueDescription`
    if (
      tag$3 === `ENUM_VALUE_DEPRECATION_REASON_CHANGED` || tag$3 === `ENUM_VALUE_DEPRECATION_REASON_ADDED`
      || tag$3 === `ENUM_VALUE_DEPRECATION_REASON_REMOVED`
    ) return `EnumValueDeprecationReason`
    if (tag$3 === `INPUT_FIELD_ADDED` || tag$3 === `INPUT_FIELD_REMOVED` || tag$3 === `INPUT_FIELD_TYPE_CHANGED`) {
      return `InputFieldOperation`
    }
    if (
      tag$3 === `INPUT_FIELD_DESCRIPTION_ADDED` || tag$3 === `INPUT_FIELD_DESCRIPTION_REMOVED`
      || tag$3 === `INPUT_FIELD_DESCRIPTION_CHANGED`
    ) return `InputFieldDescription`
    if (tag$3 === `INPUT_FIELD_DEFAULT_VALUE_CHANGED`) return `InputFieldDefaultValue`
    if (tag$3 === `UNION_MEMBER_ADDED` || tag$3 === `UNION_MEMBER_REMOVED`) return `UnionMemberOperation`
    if (tag$3 === `OBJECT_TYPE_INTERFACE_ADDED` || tag$3 === `OBJECT_TYPE_INTERFACE_REMOVED`) {
      return `ObjectTypeInterfaceOperation`
    }
    if (tag$3 === `DIRECTIVE_ADDED` || tag$3 === `DIRECTIVE_REMOVED`) return `DirectiveOperation`
    if (tag$3 === `DIRECTIVE_DESCRIPTION_CHANGED`) return `DirectiveDescription`
    if (tag$3 === `DIRECTIVE_LOCATION_ADDED` || tag$3 === `DIRECTIVE_LOCATION_REMOVED`) {
      return `DirectiveLocationOperation`
    }
    if (tag$3 === `DIRECTIVE_ARGUMENT_ADDED` || tag$3 === `DIRECTIVE_ARGUMENT_REMOVED`) return `DirectiveArgument`
    if (tag$3 === `DIRECTIVE_ARGUMENT_TYPE_CHANGED` || tag$3 === `DIRECTIVE_ARGUMENT_DEFAULT_VALUE_CHANGED`) {
      return `DirectiveArgumentOperation`
    }
    if (tag$3 === `DIRECTIVE_ARGUMENT_DESCRIPTION_CHANGED`) return `DirectiveArgumentDescription`
    if (
      tag$3 === `SCHEMA_QUERY_TYPE_CHANGED` || tag$3 === `SCHEMA_MUTATION_TYPE_CHANGED`
      || tag$3 === `SCHEMA_SUBSCRIPTION_TYPE_CHANGED`
    ) return `SchemaRootType`
    throw Error(`Unknown change type: ${tag$3}`)
  },
  DateOnly = String$.pipe(
    pattern(/^\d{4}-\d{2}-\d{2}$/),
    annotations({
      identifier: `DateOnly`,
      title: `Date Only`,
      description: `A date-only value in YYYY-MM-DD format`,
      examples: [`2024-01-15`, `2023-12-31`],
    }),
    brand(`DateOnly`),
  ),
  make$15 = DateOnly.make,
  order$7 = mapInput(string$3, date$1 => date$1),
  min$6 = min$9(order$7),
  max$6 = max$11(order$7),
  lessThan$5 = lessThan$12(order$7),
  greaterThan$5 = greaterThan$9(order$7),
  equivalence$17 = equivalence$20(DateOnly),
  is$22 = is$25(DateOnly),
  decode$23 = decode$26(DateOnly),
  decodeSync$17 = decodeSync$18(DateOnly),
  encode$22 = encode$25(DateOnly),
  toDate = date$1 => new Date(date$1 + `T00:00:00.000Z`),
  Revision = TaggedStruct(`Revision`, { date: DateOnly, changes: Array$(Change) }).annotations({
    identifier: `Revision`,
    title: `Revision`,
    description: `A revision in the schema history`,
  }),
  make$14 = Revision.make,
  is$21 = is$25(Revision),
  order$6 = reverse$3(mapInput(order$7, revision => revision.date)),
  min$5 = min$9(order$6),
  max$5 = max$11(order$6),
  lessThan$4 = lessThan$12(order$6),
  greaterThan$4 = greaterThan$9(order$6),
  decode$22 = decode$26(Revision),
  decodeSync$16 = decodeSync$18(Revision),
  encode$21 = encode$25(Revision),
  equivalence$16 = equivalence$20(Revision),
  GraphQLIsDocumentNode = input => typeof input == `object` && !!input && `kind` in input && input.kind === `Document`,
  graphqlAst = declare(GraphQLIsDocumentNode, {
    identifier: `GraphQLDocumentNode`,
    title: `GraphQL AST`,
    description: `GraphQL Abstract Syntax Tree`,
  }),
  SchemaDefinition = transformOrFail(graphqlAst, instanceOf$1(GraphQLSchema), {
    strict: !0,
    decode: (ast, options$2, astSchema) => {
      try {
        let schema = buildASTSchema(ast)
        return succeed(schema)
      } catch (error) {
        return fail(new Type$1(astSchema, ast, `Invalid GraphQL AST: ${error}`))
      }
    },
    encode: (schema, options$2, astSchema) => {
      try {
        let sdl$1 = printSchema(schema), ast = parse$2(sdl$1)
        return succeed(ast)
      } catch (error) {
        return fail(new Type$1(astSchema, schema, `Failed to serialize schema: ${error}`))
      }
    },
  }).annotations({
    identifier: `SchemaDefinition`,
    title: `Schema Definition`,
    description: `A GraphQL schema definition`,
    equivalence: () => (a$22, b$3) => printSchema(a$22) === printSchema(b$3),
  }),
  sdlToAst = transformOrFail(String$, graphqlAst, {
    strict: !0,
    decode: (sdl$1, _$1, astSchema) => {
      try {
        let ast = parse$2(sdl$1)
        return succeed(ast)
      } catch (error) {
        return fail(new Type$1(astSchema, sdl$1, `Invalid SDL syntax: ${error}`))
      }
    },
    encode: ast => succeed(printSchema(buildASTSchema(ast))),
  }),
  sdlSchema = compose(sdlToAst, SchemaDefinition).annotations({
    identifier: `SDLSchema`,
    title: `SDL Schema`,
    description: `SDL string representation of a GraphQL schema`,
  }),
  sdl = { decode: decodeSync$18(sdlSchema), encode: encodeSync$4(sdlSchema) },
  is$20 = is$25(SchemaDefinition),
  decode$21 = decode$26(SchemaDefinition),
  decodeSync$15 = decodeSync$18(SchemaDefinition),
  encode$20 = encode$25(SchemaDefinition),
  equivalence$15 = equivalence$20(SchemaDefinition),
  Unversioned$1 = TaggedStruct(`SchemaUnversioned`, { revisions: Array$(Revision), definition: SchemaDefinition })
    .annotations({
      identifier: `SchemaUnversioned`,
      title: `Unversioned Schema`,
      description: `A GraphQL schema without semantic versioning`,
      adt: { name: `Schema` },
    }),
  make$13 = Unversioned$1.make,
  is$19 = is$25(Unversioned$1),
  order$5 = mapInput(string$3, schema => schema.revisions[0]?.date ?? ``),
  min$4 = min$9(order$5),
  max$4 = max$11(order$5),
  lessThan$3 = lessThan$12(order$5),
  greaterThan$3 = greaterThan$9(order$5),
  decode$20 = decode$26(Unversioned$1),
  encode$19 = encode$25(Unversioned$1),
  equivalence$14 = equivalence$20(Unversioned$1)
function fastSplit(str, delim, limit = -1, onPart) {
  let i$14 = 0, p$25 = 0, l$9 = delim.length, parts$1 = []
  for (; i$14 !== -1;) {
    i$14 = str.indexOf(delim, p$25)
    let part = i$14 === -1 || parts$1.length === limit - 1 ? str.substring(p$25) : str.substring(p$25, i$14)
    if (parts$1.push(onPart?.(part, parts$1, i$14) ?? part), parts$1.length === limit) return parts$1
    p$25 = i$14 + l$9
  }
  return parts$1
}
const { captureStackTrace } = Error
function create$1(cls, defaultFrom, message, cause$2, from = defaultFrom) {
  let er = new cls(message, cause$2 ? { cause: cause$2 } : void 0)
  return captureStackTrace?.(er, from), er
}
function typeError(message, cause$2, from) {
  return create$1(TypeError, typeError, message, cause$2, from)
}
function syntaxError(message, cause$2, from) {
  return create$1(SyntaxError, syntaxError, message, cause$2, from)
}
const maybeNumber = s$14 => {
    if (!/^[0-9]+$/.test(s$14)) return s$14
    let n$19 = Number(s$14)
    return n$19 <= 2 ** 53 - 1 ? n$19 : s$14
  },
  safeNumber = (s$14, version, field) => {
    let n$19 = Number(s$14)
    if (n$19 > 2 ** 53 - 1) throw invalidVersion(version, `invalid ${field}, must be <= ${2 ** 53 - 1}`)
    return n$19
  },
  re$1 = {
    prefix: /^[ v=]+/,
    main: /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)/,
    prerelease: /-([0-9a-zA-Z_.-]+)(?:$|\+)/,
    build: /\+([0-9a-zA-Z_.-]+)$/,
    full: /^[ v=]*(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-([0-9a-zA-Z_.-]+))?(?:\+([0-9a-zA-Z_.-]+))?$/,
  },
  invalidVersion = (version, message) => {
    let er = syntaxError(`invalid version: ${message}`, { version }, Version$1)
    return er
  }
var Version$1 = class Version$1 {
  raw
  major
  minor
  patch
  prerelease
  build
  toString() {
    return `${this.major}.${this.minor}.${this.patch}${this.prerelease ? `-` + this.prerelease.join(`.`) : ``}${
      this.build ? `+` + this.build.join(`.`) : ``
    }`
  }
  static parse(version) {
    if (version = version.replace(re$1.prefix, ``).trim(), version.length > 256) {
      throw invalidVersion(version, `must be less than 256 characters`)
    }
    let parsed = re$1.full.exec(version)
    if (!parsed) {
      let main = re$1.main.exec(version)
      throw main
        ? invalidVersion(version, `invalid build or patch section`)
        : invalidVersion(version, `no Major.minor.patch tuple present`)
    }
    let [_$1, major_, minor_, patch_, prerelease, build] = parsed,
      major = safeNumber(major_, version, `major`),
      minor = safeNumber(minor_, version, `minor`),
      patch$12 = safeNumber(patch_, version, `patch`)
    return new Version$1(version, major, minor, patch$12, prerelease, build)
  }
  constructor(version, major, minor, patch$12, prerelease, build) {
    this.raw = version,
      this.major = major,
      this.minor = minor,
      this.patch = patch$12,
      prerelease && (this.prerelease = fastSplit(prerelease, `.`, -1, c$3 => {
        if (!c$3) throw invalidVersion(version, `invalid prerelease, empty identifiers not allowed`)
        return maybeNumber(c$3)
      })),
      build && (this.build = fastSplit(build, `.`, -1, c$3 => {
        if (!c$3) throw invalidVersion(version, `invalid build metadata, empty identifiers not allowed`)
      }))
  }
  compare(v$4) {
    if (this.major > v$4.major) return 1
    if (this.major < v$4.major) return -1
    if (this.minor > v$4.minor) return 1
    if (this.minor < v$4.minor) return -1
    if (this.patch > v$4.patch) return 1
    if (this.patch < v$4.patch) return -1
    if (!v$4.prerelease?.length) return this.prerelease?.length ? -1 : 0
    if (!this.prerelease?.length) return 1
    let len = Math.max(this.prerelease.length, v$4.prerelease.length), me = this.prerelease, thee = v$4.prerelease
    for (let i$14 = 0; i$14 < len; i$14++) {
      let m$12 = me[i$14], t$18 = thee[i$14]
      if (m$12 !== t$18) {
        return t$18 === void 0
          ? 1
          : m$12 === void 0
          ? -1
          : typeof m$12 == typeof t$18
          ? m$12 > t$18 ? 1 : -1
          : typeof m$12 == `string`
          ? 1
          : -1
      }
    }
    return 0
  }
  rcompare(v$4) {
    return -1 * this.compare(v$4)
  }
  greaterThan(v$4) {
    return this.compare(v$4) === 1
  }
  greaterThanEqual(v$4) {
    return this.compare(v$4) > -1
  }
  lessThan(v$4) {
    return this.compare(v$4) === -1
  }
  lessThanEqual(v$4) {
    return this.compare(v$4) < 1
  }
  equals(v$4) {
    return this.compare(v$4) === 0
  }
  tupleEquals(v$4) {
    return this.major === v$4.major && this.minor === v$4.minor && this.patch === v$4.patch
  }
  satisfies(r$26) {
    return r$26.test(this)
  }
  inc(part, prereleaseIdentifier) {
    switch (part) {
      case `premajor`:
        this.prerelease = void 0, this.patch = 0, this.minor = 0, this.major++, this.inc(`pre`, prereleaseIdentifier)
        break
      case `preminor`:
        this.prerelease = void 0, this.patch = 0, this.minor++, this.inc(`pre`, prereleaseIdentifier)
        break
      case `prepatch`:
        this.prerelease = void 0, this.inc(`patch`), this.inc(`pre`, prereleaseIdentifier)
        break
      case `prerelease`:
        this.prerelease?.length || this.inc(`patch`, prereleaseIdentifier), this.inc(`pre`, prereleaseIdentifier)
        break
      case `pre`: {
        if (!prereleaseIdentifier) {
          if (!this.prerelease?.length) {
            this.prerelease = [0]
            break
          }
          let last$3 = this.prerelease[this.prerelease.length - 1]
          typeof last$3 == `number` ? this.prerelease[this.prerelease.length - 1] = last$3 + 1 : this.prerelease.push(0)
          break
        }
        if (!this.prerelease?.length) {
          this.prerelease = [prereleaseIdentifier]
          break
        }
        let i$14 = this.prerelease.indexOf(maybeNumber(prereleaseIdentifier))
        if (i$14 === -1) {
          this.prerelease = [prereleaseIdentifier]
          break
        }
        let baseValue = this.prerelease[i$14 + 1]
        if (typeof baseValue == `number`) {
          this.prerelease[i$14 + 1] = baseValue + 1
          break
        }
        if (i$14 === this.prerelease.length - 1) {
          this.prerelease.push(0)
          break
        }
        this.prerelease.splice(i$14 + 1, 0, 0)
        break
      }
      case `major`:
        ;(!this.prerelease?.length || this.minor || this.patch) && this.major++,
          this.prerelease = void 0,
          this.patch = 0,
          this.minor = 0
        break
      case `minor`:
        ;(!this.prerelease?.length || this.patch) && this.minor++, this.prerelease = void 0, this.patch = 0
        break
      case `patch`:
        this.prerelease?.length || this.patch++, this.prerelease = void 0
        break
      default:
        throw typeError(`Invalid increment identifier`, {
          version: this,
          found: part,
          validOptions: [`major`, `minor`, `patch`, `premajor`, `preminor`, `prepatch`, `prerelease`, `pre`],
        }, this.inc)
    }
    return this.raw = this.toString(), this
  }
}
const OfficialRelease = TaggedStruct(`SemverOfficialRelease`, {
    major: Number$,
    minor: Number$,
    patch: Number$,
    build: optional(Array$(String$)),
    version: instanceOf$1(Version$1),
  }).annotations({
    identifier: `OfficialRelease`,
    title: `Official Release`,
    description: `A semantic version that is an official release (no pre-release identifiers)`,
  }),
  make$12 = OfficialRelease.make,
  is$18 = is$25(OfficialRelease),
  decode$19 = decode$26(OfficialRelease),
  decodeSync$14 = decodeSync$18(OfficialRelease),
  encode$18 = encode$25(OfficialRelease),
  equivalence$13 = equivalence$20(OfficialRelease),
  PreRelease = TaggedStruct(`SemverPreRelease`, {
    major: Number$,
    minor: Number$,
    patch: Number$,
    prerelease: NonEmptyArray(Union(String$, Number$)),
    build: optional(Array$(String$)),
    version: instanceOf$1(Version$1),
  }).annotations({
    identifier: `PreRelease`,
    title: `Pre-Release`,
    description: `A semantic version with pre-release identifiers`,
  }),
  make$11 = PreRelease.make,
  is$17 = is$25(PreRelease),
  decode$18 = decode$26(PreRelease),
  decodeSync$13 = decodeSync$18(PreRelease),
  encode$17 = encode$25(PreRelease),
  equivalence$12 = equivalence$20(PreRelease),
  SemverUnion = Union(OfficialRelease, PreRelease).annotations({
    identifier: `Semver`,
    title: `Semantic Version`,
    description: `A semantic version following SemVer specification`,
  }),
  Semver$1 = transformOrFail(String$, SemverUnion, {
    strict: !0,
    decode: (value$2, _$1, ast) => {
      try {
        let version = Version$1.parse(value$2),
          base = {
            major: version.major,
            minor: version.minor,
            patch: version.patch,
            build: version.build && version.build.length > 0 ? version.build : void 0,
            version,
          }
        return version.prerelease && version.prerelease.length > 0
          ? succeed({ _tag: `SemverPreRelease`, ...base, prerelease: version.prerelease })
          : succeed({ _tag: `SemverOfficialRelease`, ...base })
      } catch (error) {
        return fail(new Type$1(ast, value$2, `Invalid semver: ${error}`))
      }
    },
    encode: semver => succeed(semver.version.toString()),
  }),
  order$4 = make$60((a$22, b$3) => a$22.version.compare(b$3.version)),
  min$3 = min$9(order$4),
  max$3 = max$11(order$4),
  lessThan$2 = lessThan$12(order$4),
  greaterThan$2 = greaterThan$9(order$4),
  equivalence$11 = make$61((a$22, b$3) => a$22.version.compare(b$3.version) === 0),
  is$16 = is$25(Semver$1),
  decode$17 = decode$26(Semver$1),
  decodeSync$12 = decodeSync$18(Semver$1),
  encode$16 = encode$25(Semver$1),
  fromString$1 = decodeSync$18(Semver$1)
var Custom = class extends TaggedClass()(`VersionCustom`, { value: String$ }) {}
const make$10 = Custom.make,
  is$15 = is$25(Custom),
  decode$16 = decode$26(Custom),
  decodeSync$11 = decodeSync$18(Custom),
  encode$15 = encode$25(Custom),
  equivalence$10 = equivalence$20(Custom)
var Date$1 = class extends TaggedClass()(`VersionDate`, { value: DateOnly }) {}
const make$9 = Date$1.make,
  is$14 = is$25(Date$1),
  decode$15 = decode$26(Date$1),
  decodeSync$10 = decodeSync$18(Date$1),
  encode$14 = encode$25(Date$1),
  equivalence$9 = equivalence$20(Date$1)
var Integer = class extends TaggedClass()(`VersionInteger`, { value: Number$ }) {}
const make$8 = Integer.make,
  is$13 = is$25(Integer),
  decode$14 = decode$26(Integer),
  decodeSync$9 = decodeSync$18(Integer),
  encode$13 = encode$25(Integer),
  equivalence$8 = equivalence$20(Integer)
var Semver = class extends TaggedClass()(`VersionSemver`, { value: String$ }) {}
const make$7 = Semver.make,
  is$12 = is$25(Semver),
  decode$13 = decode$26(Semver),
  decodeSync$8 = decodeSync$18(Semver),
  encode$12 = encode$25(Semver),
  equivalence$7 = equivalence$20(Semver),
  VersionUnion = Union(Integer, Semver, Date$1, Custom),
  Version = transformOrFail(Union(String$, Number$), VersionUnion, {
    strict: !0,
    decode: (input, _$1, ast) => {
      if (typeof input == `number` && Number.isInteger(input)) return succeed(new Integer({ value: input }))
      if (typeof input == `string`) {
        let parsed = Number(input)
        if (Number.isInteger(parsed) && parsed.toString() === input) return succeed(new Integer({ value: parsed }))
      }
      if (typeof input == `string`) {
        try {
          return decodeSync$12(input), succeed(new Semver({ value: input }))
        } catch {}
        try {
          let dateOnly = decodeSync$17(input)
          return succeed(new Date$1({ value: dateOnly }))
        } catch {}
        return succeed(new Custom({ value: input }))
      }
      return fail(new Type$1(ast, input))
    },
    encode: version => {
      switch (version._tag) {
        case `VersionInteger`:
          return succeed(version.value)
        case `VersionSemver`:
          return succeed(version.value)
        case `VersionDate`:
          return succeed(version.value)
        case `VersionCustom`:
          return succeed(version.value)
      }
    },
  }),
  order$3 = make$60((a$22, b$3) => {
    if (a$22._tag !== b$3._tag) {
      let typeOrder = { VersionInteger: 0, VersionSemver: 1, VersionDate: 2, VersionCustom: 3 },
        diff$10 = typeOrder[a$22._tag] - typeOrder[b$3._tag]
      return diff$10 < 0 ? -1 : diff$10 > 0 ? 1 : 0
    }
    switch (a$22._tag) {
      case `VersionInteger`:
        return number$2(a$22.value, b$3.value)
      case `VersionSemver`: {
        let semverA = decodeSync$12(a$22.value), semverB = decodeSync$12(b$3.value)
        return order$4(semverA, semverB)
      }
      case `VersionDate`:
        return order$7(a$22.value, b$3.value)
      case `VersionCustom`:
        return string$3(a$22.value, b$3.value)
    }
  }),
  min$2 = min$9(order$3),
  max$2 = max$11(order$3),
  lessThan$1 = lessThan$12(order$3),
  greaterThan$1 = greaterThan$9(order$3),
  equivalence$6 = make$61((a$22, b$3) => {
    if (a$22._tag !== b$3._tag) return !1
    switch (a$22._tag) {
      case `VersionInteger`:
        return a$22.value === b$3.value
      case `VersionSemver`: {
        let semverA = decodeSync$12(a$22.value), semverB = decodeSync$12(b$3.value)
        return equivalence$11(semverA, semverB)
      }
      case `VersionDate`:
        return equivalence$17(a$22.value, b$3.value)
      case `VersionCustom`:
        return a$22.value === b$3.value
    }
  }),
  is$11 = is$25(Version),
  decode$12 = decode$26(Version),
  decodeSync$7 = decodeSync$18(Version),
  encode$11 = encode$25(Version),
  fromString = decodeSync$18(Version),
  encodeSync$3 = version => {
    switch (version._tag) {
      case `VersionInteger`:
        return version.value.toString()
      case `VersionSemver`:
        return version.value
      case `VersionDate`:
        return version.value
      case `VersionCustom`:
        return version.value
    }
  },
  Versioned$1 = TaggedStruct(`SchemaVersioned`, {
    version: Version,
    branchPoint: NullOr(Struct({ schema: suspend(() => Versioned$1), revision: Revision })),
    revisions: Array$(Revision),
    definition: SchemaDefinition,
  }),
  make$6 = Versioned$1.make,
  is$10 = is$25(Versioned$1),
  order$2 = mapInput(order$3, schema => schema.version),
  min$1 = min$9(order$2),
  max$1 = max$11(order$2),
  lessThan = lessThan$12(order$2),
  greaterThan = greaterThan$9(order$2),
  decode$11 = decode$26(Versioned$1),
  encode$10 = encode$25(Versioned$1),
  equivalence$5 = equivalence$20(Versioned$1),
  Schema$1 = Union(Versioned$1, Unversioned$1),
  is$9 = is$25(Schema$1),
  decode$10 = decode$26(Schema$1),
  encode$9 = encode$25(Schema$1),
  equivalence$4 = equivalence$20(Schema$1),
  getVersion = schema =>
    value(schema).pipe(tagsExhaustive({ SchemaUnversioned: () => void 0, SchemaVersioned: s$14 => s$14.version })),
  route = config => {
    let { schema, loader: loader$3, handle: handle$2, ...routeConfig } = config,
      routeId,
      routeIdIndexPart = config.index ? `@index` : ``
    if (
      typeof routeConfig.id == `string`
        ? routeId = routeConfig.id
        : routeConfig.id === !0 && routeConfig.path
          && (routeId = routeConfig.path === `/` ? routeConfig.path : routeConfig.path.replace(/\/$/, ``),
            routeId += routeIdIndexPart), !schema
    ) return { ...routeConfig, ...routeId && { id: routeId }, handle: handle$2, loader: loader$3 }
    let route$1 = { ...routeConfig, ...routeId && { id: routeId }, handle: { ...handle$2, schema, schemaId: routeId } }
    return loader$3 && (route$1.loader = async args$1 => {
      let result = loader$3(args$1), decodedData
      decodedData = isEffect(result) ? await runPromise(result) : await result
      let encodedData = encodeSync$4(schema)(decodedData)
      return encodedData
    }),
      route$1
  }
function a$4(r$26) {
  let { m: t$18, mx: m$12, my: o$18, mt: p$25, mr: n$19, mb: s$14, ml: e$26, ...i$14 } = r$26
  return { m: t$18, mx: m$12, my: o$18, mt: p$25, mr: n$19, mb: s$14, ml: e$26, rest: i$14 }
}
var require_classnames = __commonJSMin((exports, module) => {
  /*!
Copyright (c) 2018 Jed Watson.
Licensed under the MIT License (MIT), see
http://jedwatson.github.io/classnames
  */
  ;(function() {
    'use strict'
    var hasOwn$1 = {}.hasOwnProperty
    function classNames() {
      for (var classes = ``, i$14 = 0; i$14 < arguments.length; i$14++) {
        var arg = arguments[i$14]
        arg && (classes = appendClass(classes, parseValue(arg)))
      }
      return classes
    }
    function parseValue(arg) {
      if (typeof arg == `string` || typeof arg == `number`) return arg
      if (typeof arg != `object`) return ``
      if (Array.isArray(arg)) return classNames.apply(null, arg)
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes(`[native code]`)) {
        return arg.toString()
      }
      var classes = ``
      for (var key$1 in arg) hasOwn$1.call(arg, key$1) && arg[key$1] && (classes = appendClass(classes, key$1))
      return classes
    }
    function appendClass(value$2, newClass) {
      return newClass ? value$2 ? value$2 + ` ` + newClass : value$2 + newClass : value$2
    }
    module !== void 0 && module.exports
      ? (classNames.default = classNames, module.exports = classNames)
      : typeof define == `function` && typeof define.amd == `object` && define.amd
      ? define(`classnames`, [], function() {
        return classNames
      })
      : window.classNames = classNames
  })()
})
const e$24 = [`initial`, `xs`, `sm`, `md`, `lg`, `xl`]
function e$25(n$19, r$26) {
  return Object.prototype.hasOwnProperty.call(n$19, r$26)
}
function i$13(e$26) {
  return typeof e$26 == `object` && Object.keys(e$26).some(s$14 => e$24.includes(s$14))
}
function R$3({ className: r$26, customProperties: n$19, ...t$18 }) {
  let p$25 = g$1({ allowArbitraryValues: !0, className: r$26, ...t$18 }),
    e$26 = m$11({ customProperties: n$19, ...t$18 })
  return [p$25, e$26]
}
function g$1(
  { allowArbitraryValues: r$26, value: n$19, className: t$18, propValues: p$25, parseValue: e$26 = s$15 => s$15 },
) {
  let s$14 = []
  if (n$19) {
    if (typeof n$19 == `string` && p$25.includes(n$19)) return l$8(t$18, n$19, e$26)
    if (i$13(n$19)) {
      let i$14 = n$19
      for (let o$18 in i$14) {
        if (!e$25(i$14, o$18) || !e$24.includes(o$18)) continue
        let u$7 = i$14[o$18]
        if (u$7 !== void 0) {
          if (p$25.includes(u$7)) {
            let f$14 = l$8(t$18, u$7, e$26), v$4 = o$18 === `initial` ? f$14 : `${o$18}:${f$14}`
            s$14.push(v$4)
          } else if (r$26) {
            let f$14 = o$18 === `initial` ? t$18 : `${o$18}:${t$18}`
            s$14.push(f$14)
          }
        }
      }
      return s$14.join(` `)
    }
    if (r$26) return t$18
  }
}
function l$8(r$26, n$19, t$18) {
  let p$25 = r$26 ? `-` : ``,
    e$26 = t$18(n$19),
    s$14 = e$26?.startsWith(`-`),
    i$14 = s$14 ? `-` : ``,
    o$18 = s$14 ? e$26?.substring(1) : e$26
  return `${i$14}${r$26}${p$25}${o$18}`
}
function m$11({ customProperties: r$26, value: n$19, propValues: t$18, parseValue: p$25 = e$27 => e$27 }) {
  let e$26 = {}
  if (!(!n$19 || typeof n$19 == `string` && t$18.includes(n$19))) {
    if (typeof n$19 == `string` && (e$26 = Object.fromEntries(r$26.map(s$14 => [s$14, n$19]))), i$13(n$19)) {
      let s$14 = n$19
      for (let i$14 in s$14) {
        if (!e$25(s$14, i$14) || !e$24.includes(i$14)) continue
        let o$18 = s$14[i$14]
        if (!t$18.includes(o$18)) {
          for (let u$7 of r$26) e$26 = { [i$14 === `initial` ? u$7 : `${u$7}-${i$14}`]: o$18, ...e$26 }
        }
      }
    }
    for (let s$14 in e$26) {
      let i$14 = e$26[s$14]
      i$14 !== void 0 && (e$26[s$14] = p$25(i$14))
    }
    return e$26
  }
}
function l$2(...t$18) {
  let e$26 = {}
  for (let n$19 of t$18) n$19 && (e$26 = { ...e$26, ...n$19 })
  return Object.keys(e$26).length ? e$26 : void 0
}
var import_classnames$29 = __toESM(require_classnames())
function N$1(...r$26) {
  return Object.assign({}, ...r$26)
}
function v$1(r$26, ...m$12) {
  let t$18, l$9, a$22 = { ...r$26 }, f$14 = N$1(...m$12)
  for (let n$19 in f$14) {
    let s$14 = a$22[n$19], e$26 = f$14[n$19]
    if (
      e$26.default !== void 0 && s$14 === void 0 && (s$14 = e$26.default),
        e$26.type === `enum` && ![e$26.default, ...e$26.values].includes(s$14) && !i$13(s$14) && (s$14 = e$26.default),
        a$22[n$19] = s$14,
        `className` in e$26 && e$26.className
    ) {
      delete a$22[n$19]
      let u$7 = `responsive` in e$26
      if (!s$14 || i$13(s$14) && !u$7) continue
      if (
        i$13(s$14)
        && (e$26.default !== void 0 && s$14.initial === void 0 && (s$14.initial = e$26.default),
          e$26.type === `enum`
          && ([e$26.default, ...e$26.values].includes(s$14.initial) || (s$14.initial = e$26.default))),
          e$26.type === `enum`
      ) {
        let i$14 = g$1({
          allowArbitraryValues: !1,
          value: s$14,
          className: e$26.className,
          propValues: e$26.values,
          parseValue: e$26.parseValue,
        })
        t$18 = (0, import_classnames$29.default)(t$18, i$14)
        continue
      }
      if (e$26.type === `string` || e$26.type === `enum | string`) {
        let i$14 = e$26.type === `string` ? [] : e$26.values,
          [d$7, y$3] = R$3({
            className: e$26.className,
            customProperties: e$26.customProperties,
            propValues: i$14,
            parseValue: e$26.parseValue,
            value: s$14,
          })
        l$9 = l$2(l$9, y$3), t$18 = (0, import_classnames$29.default)(t$18, d$7)
        continue
      }
      if (e$26.type === `boolean` && s$14) {
        t$18 = (0, import_classnames$29.default)(t$18, e$26.className)
        continue
      }
    }
  }
  return a$22.className = (0, import_classnames$29.default)(t$18, r$26.className),
    a$22.style = l$2(l$9, r$26.style),
    a$22
}
const e$23 = [`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `-1`, `-2`, `-3`, `-4`, `-5`, `-6`, `-7`, `-8`, `-9`],
  r$4 = {
    m: { type: `enum | string`, values: e$23, responsive: !0, className: `rt-r-m`, customProperties: [`--m`] },
    mx: {
      type: `enum | string`,
      values: e$23,
      responsive: !0,
      className: `rt-r-mx`,
      customProperties: [`--ml`, `--mr`],
    },
    my: {
      type: `enum | string`,
      values: e$23,
      responsive: !0,
      className: `rt-r-my`,
      customProperties: [`--mt`, `--mb`],
    },
    mt: { type: `enum | string`, values: e$23, responsive: !0, className: `rt-r-mt`, customProperties: [`--mt`] },
    mr: { type: `enum | string`, values: e$23, responsive: !0, className: `rt-r-mr`, customProperties: [`--mr`] },
    mb: { type: `enum | string`, values: e$23, responsive: !0, className: `rt-r-mb`, customProperties: [`--mb`] },
    ml: { type: `enum | string`, values: e$23, responsive: !0, className: `rt-r-ml`, customProperties: [`--ml`] },
  }
var import_classnames$28 = __toESM(require_classnames())
const r$25 = r$4.m.values
function S$1(s$14) {
  let [e$26, t$18] = R$3({ className: `rt-r-m`, customProperties: [`--margin`], propValues: r$25, value: s$14.m }),
    [a$22, o$18] = R$3({
      className: `rt-r-mx`,
      customProperties: [`--margin-left`, `--margin-right`],
      propValues: r$25,
      value: s$14.mx,
    }),
    [l$9, i$14] = R$3({
      className: `rt-r-my`,
      customProperties: [`--margin-top`, `--margin-bottom`],
      propValues: r$25,
      value: s$14.my,
    }),
    [p$25, u$7] = R$3({ className: `rt-r-mt`, customProperties: [`--margin-top`], propValues: r$25, value: s$14.mt }),
    [n$19, c$3] = R$3({ className: `rt-r-mr`, customProperties: [`--margin-right`], propValues: r$25, value: s$14.mr }),
    [g$3, P$5] = R$3({ className: `rt-r-mb`, customProperties: [`--margin-bottom`], propValues: r$25, value: s$14.mb }),
    [N$2, C$4] = R$3({ className: `rt-r-ml`, customProperties: [`--margin-left`], propValues: r$25, value: s$14.ml })
  return [
    (0, import_classnames$28.default)(e$26, a$22, l$9, p$25, n$19, g$3, N$2),
    l$2(t$18, o$18, i$14, u$7, c$3, P$5, C$4),
  ]
}
function a$10(e$26) {
  switch (e$26) {
    case `tomato`:
    case `red`:
    case `ruby`:
    case `crimson`:
    case `pink`:
    case `plum`:
    case `purple`:
    case `violet`:
      return `mauve`
    case `iris`:
    case `indigo`:
    case `blue`:
    case `sky`:
    case `cyan`:
      return `slate`
    case `teal`:
    case `jade`:
    case `mint`:
    case `green`:
      return `sage`
    case `grass`:
    case `lime`:
      return `olive`
    case `yellow`:
    case `amber`:
    case `orange`:
    case `brown`:
    case `gold`:
    case `bronze`:
      return `sand`
    case `gray`:
      return `gray`
  }
}
function d$2(i$14, e$26) {
  let { asChild: r$26, children: c$3 } = i$14
  if (!r$26) return typeof e$26 == `function` ? e$26(c$3) : e$26
  let t$18 = import_react.Children.only(c$3)
  return import_react.cloneElement(t$18, { children: typeof e$26 == `function` ? e$26(t$18.props.children) : e$26 })
}
function s$6(e$26, t$18) {
  if (e$26 !== void 0) {
    return typeof e$26 == `string`
      ? t$18(e$26)
      : Object.fromEntries(Object.entries(e$26).map(([n$19, o$18]) => [n$19, t$18(o$18)]))
  }
}
function p$12(e$26) {
  return e$26 === `3` ? `3` : `2`
}
function r$8(e$26) {
  switch (e$26) {
    case `1`:
      return `1`
    case `2`:
    case `3`:
      return `2`
    case `4`:
      return `3`
  }
}
const a$2 = t$18 => {
    if (!import_react.isValidElement(t$18)) {
      throw Error(
        `Expected a single React Element child, but got: ${
          import_react.Children.toArray(t$18).map(e$26 =>
            typeof e$26 == `object` && `type` in e$26 && typeof e$26.type == `string` ? e$26.type : typeof e$26
          ).join(`, `)
        }`,
      )
    }
    return t$18
  },
  o$8 = { asChild: { type: `boolean` } },
  o$9 =
    `gray.gold.bronze.brown.yellow.amber.orange.tomato.red.ruby.crimson.pink.plum.purple.violet.iris.indigo.blue.cyan.teal.jade.green.grass.lime.mint.sky`
      .split(`.`),
  e$10 = [`auto`, `gray`, `mauve`, `slate`, `sage`, `olive`, `sand`],
  r$10 = { color: { type: `enum`, values: o$9, default: void 0 } },
  s$11 = { color: { type: `enum`, values: o$9, default: `` } },
  e$22 = [`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  p$20 = {
    gap: { type: `enum | string`, className: `rt-r-gap`, customProperties: [`--gap`], values: e$22, responsive: !0 },
    gapX: {
      type: `enum | string`,
      className: `rt-r-cg`,
      customProperties: [`--column-gap`],
      values: e$22,
      responsive: !0,
    },
    gapY: {
      type: `enum | string`,
      className: `rt-r-rg`,
      customProperties: [`--row-gap`],
      values: e$22,
      responsive: !0,
    },
  },
  e$7 = {
    height: { type: `string`, className: `rt-r-h`, customProperties: [`--height`], responsive: !0 },
    minHeight: { type: `string`, className: `rt-r-min-h`, customProperties: [`--min-height`], responsive: !0 },
    maxHeight: { type: `string`, className: `rt-r-max-h`, customProperties: [`--max-height`], responsive: !0 },
  },
  o$10 = { highContrast: { type: `boolean`, className: `rt-high-contrast`, default: void 0 } },
  e$21 = [`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  p$15 = {
    p: { type: `enum | string`, className: `rt-r-p`, customProperties: [`--p`], values: e$21, responsive: !0 },
    px: {
      type: `enum | string`,
      className: `rt-r-px`,
      customProperties: [`--pl`, `--pr`],
      values: e$21,
      responsive: !0,
    },
    py: {
      type: `enum | string`,
      className: `rt-r-py`,
      customProperties: [`--pt`, `--pb`],
      values: e$21,
      responsive: !0,
    },
    pt: { type: `enum | string`, className: `rt-r-pt`, customProperties: [`--pt`], values: e$21, responsive: !0 },
    pr: { type: `enum | string`, className: `rt-r-pr`, customProperties: [`--pr`], values: e$21, responsive: !0 },
    pb: { type: `enum | string`, className: `rt-r-pb`, customProperties: [`--pb`], values: e$21, responsive: !0 },
    pl: { type: `enum | string`, className: `rt-r-pl`, customProperties: [`--pl`], values: e$21, responsive: !0 },
  },
  t$8 = {
    width: { type: `string`, className: `rt-r-w`, customProperties: [`--width`], responsive: !0 },
    minWidth: { type: `string`, className: `rt-r-min-w`, customProperties: [`--min-width`], responsive: !0 },
    maxWidth: { type: `string`, className: `rt-r-max-w`, customProperties: [`--max-width`], responsive: !0 },
  },
  r$24 = [`visible`, `hidden`, `clip`, `scroll`, `auto`],
  i$12 = [`static`, `relative`, `absolute`, `fixed`, `sticky`],
  e$20 = [`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `-1`, `-2`, `-3`, `-4`, `-5`, `-6`, `-7`, `-8`, `-9`],
  p$24 = [`0`, `1`],
  n$18 = [`0`, `1`],
  u$3 = {
    ...p$15,
    ...t$8,
    ...e$7,
    position: { type: `enum`, className: `rt-r-position`, values: i$12, responsive: !0 },
    inset: {
      type: `enum | string`,
      className: `rt-r-inset`,
      customProperties: [`--inset`],
      values: e$20,
      responsive: !0,
    },
    top: { type: `enum | string`, className: `rt-r-top`, customProperties: [`--top`], values: e$20, responsive: !0 },
    right: {
      type: `enum | string`,
      className: `rt-r-right`,
      customProperties: [`--right`],
      values: e$20,
      responsive: !0,
    },
    bottom: {
      type: `enum | string`,
      className: `rt-r-bottom`,
      customProperties: [`--bottom`],
      values: e$20,
      responsive: !0,
    },
    left: { type: `enum | string`, className: `rt-r-left`, customProperties: [`--left`], values: e$20, responsive: !0 },
    overflow: { type: `enum`, className: `rt-r-overflow`, values: r$24, responsive: !0 },
    overflowX: { type: `enum`, className: `rt-r-ox`, values: r$24, responsive: !0 },
    overflowY: { type: `enum`, className: `rt-r-oy`, values: r$24, responsive: !0 },
    flexBasis: { type: `string`, className: `rt-r-fb`, customProperties: [`--flex-basis`], responsive: !0 },
    flexShrink: {
      type: `enum | string`,
      className: `rt-r-fs`,
      customProperties: [`--flex-shrink`],
      values: p$24,
      responsive: !0,
    },
    flexGrow: {
      type: `enum | string`,
      className: `rt-r-fg`,
      customProperties: [`--flex-grow`],
      values: n$18,
      responsive: !0,
    },
    gridArea: { type: `string`, className: `rt-r-ga`, customProperties: [`--grid-area`], responsive: !0 },
    gridColumn: { type: `string`, className: `rt-r-gc`, customProperties: [`--grid-column`], responsive: !0 },
    gridColumnStart: {
      type: `string`,
      className: `rt-r-gcs`,
      customProperties: [`--grid-column-start`],
      responsive: !0,
    },
    gridColumnEnd: { type: `string`, className: `rt-r-gce`, customProperties: [`--grid-column-end`], responsive: !0 },
    gridRow: { type: `string`, className: `rt-r-gr`, customProperties: [`--grid-row`], responsive: !0 },
    gridRowStart: { type: `string`, className: `rt-r-grs`, customProperties: [`--grid-row-start`], responsive: !0 },
    gridRowEnd: { type: `string`, className: `rt-r-gre`, customProperties: [`--grid-row-end`], responsive: !0 },
  },
  e$19 = [`normal`, `start`, `end`, `both`],
  r$11 = { trim: { type: `enum`, className: `rt-r-lt`, values: e$19, responsive: !0 } },
  e$11 = [`none`, `small`, `medium`, `large`, `full`],
  r$16 = { radius: { type: `enum`, values: e$11, default: void 0 } },
  e$18 = [`left`, `center`, `right`],
  t$10 = { align: { type: `enum`, className: `rt-r-ta`, values: e$18, responsive: !0 } },
  e$17 = [`wrap`, `nowrap`, `pretty`, `balance`],
  r$12 = { wrap: { type: `enum`, className: `rt-r-tw`, values: e$17, responsive: !0 } },
  e$12 = { truncate: { type: `boolean`, className: `rt-truncate` } },
  e$16 = [`light`, `regular`, `medium`, `bold`],
  t$11 = { weight: { type: `enum`, className: `rt-r-weight`, values: e$16, responsive: !0 } },
  t$17 = [`1`, `2`, `3`],
  a$21 = [`solid`, `soft`, `surface`, `outline`],
  p$14 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: t$17, default: `1`, responsive: !0 },
    variant: { type: `enum`, className: `rt-variant`, values: a$21, default: `soft` },
    ...s$11,
    ...o$10,
    ...r$16,
  },
  s$13 = [`div`, `span`],
  o$16 = [`none`, `inline`, `inline-block`, `block`, `contents`],
  p$13 = {
    as: { type: `enum`, values: s$13, default: `div` },
    ...o$8,
    display: { type: `enum`, className: `rt-r-display`, values: o$16, responsive: !0 },
  },
  t$16 = [`1`, `2`, `3`, `4`],
  a$20 = [`classic`, `solid`, `soft`, `surface`, `outline`, `ghost`],
  i$6 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: t$16, default: `2`, responsive: !0 },
    variant: { type: `enum`, className: `rt-variant`, values: a$20, default: `solid` },
    ...s$11,
    ...o$10,
    ...r$16,
    loading: { type: `boolean`, className: `rt-loading`, default: !1 },
  },
  t$15 = [`1`, `2`, `3`],
  r$23 = [`soft`, `surface`, `outline`],
  a$7 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: t$15, default: `2`, responsive: !0 },
    variant: { type: `enum`, className: `rt-variant`, values: r$23, default: `soft` },
    ...s$11,
    ...o$10,
  },
  e$15 = [`1`, `2`, `3`, `4`, `5`],
  r$22 = [`surface`, `classic`, `ghost`],
  a$6 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: e$15, default: `1`, responsive: !0 },
    variant: { type: `enum`, className: `rt-variant`, values: r$22, default: `surface` },
  },
  a$19 = [`div`, `span`],
  n$17 = [`none`, `inline-grid`, `grid`],
  p$23 = [`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  u$6 = [`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  i$11 = [`row`, `column`, `dense`, `row-dense`, `column-dense`],
  l$7 = [`start`, `center`, `end`, `baseline`, `stretch`],
  f$12 = [`start`, `center`, `end`, `between`],
  s$4 = {
    as: { type: `enum`, values: a$19, default: `div` },
    ...o$8,
    display: { type: `enum`, className: `rt-r-display`, values: n$17, responsive: !0 },
    areas: { type: `string`, className: `rt-r-gta`, customProperties: [`--grid-template-areas`], responsive: !0 },
    columns: {
      type: `enum | string`,
      className: `rt-r-gtc`,
      customProperties: [`--grid-template-columns`],
      values: p$23,
      parseValue: r$21,
      responsive: !0,
    },
    rows: {
      type: `enum | string`,
      className: `rt-r-gtr`,
      customProperties: [`--grid-template-rows`],
      values: u$6,
      parseValue: r$21,
      responsive: !0,
    },
    flow: { type: `enum`, className: `rt-r-gaf`, values: i$11, responsive: !0 },
    align: { type: `enum`, className: `rt-r-ai`, values: l$7, responsive: !0 },
    justify: { type: `enum`, className: `rt-r-jc`, values: f$12, parseValue: m$10, responsive: !0 },
    ...p$20,
  }
function r$21(e$26) {
  return s$4.columns.values.includes(e$26) ? e$26 : e$26?.match(/^\d+$/) ? `repeat(${e$26}, minmax(0, 1fr))` : e$26
}
function m$10(e$26) {
  return e$26 === `between` ? `space-between` : e$26
}
const a$18 = [`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  i$10 = [`solid`, `soft`, `outline`, `ghost`],
  f$7 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: a$18, responsive: !0 },
    variant: { type: `enum`, className: `rt-variant`, values: i$10, default: `soft` },
    ...t$11,
    ...s$11,
    ...o$10,
    ...e$12,
    ...r$12,
  },
  r$20 = [`1`, `2`, `3`, `4`],
  t$14 = [`none`, `initial`],
  p$22 = [`left`, `center`, `right`],
  n$8 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: r$20, default: `4`, responsive: !0 },
    display: { type: `enum`, className: `rt-r-display`, values: t$14, parseValue: a$17, responsive: !0 },
    align: { type: `enum`, className: `rt-r-ai`, values: p$22, parseValue: i$9, responsive: !0 },
  }
function a$17(e$26) {
  return e$26 === `initial` ? `flex` : e$26
}
function i$9(e$26) {
  return e$26 === `left` ? `start` : e$26 === `right` ? `end` : e$26
}
const s$12 = [`start`, `center`, `end`, `baseline`, `stretch`],
  i$8 = [`horizontal`, `vertical`],
  a$16 = [`1`, `2`, `3`],
  n$7 = {
    orientation: { type: `enum`, className: `rt-r-orientation`, values: i$8, default: `horizontal`, responsive: !0 },
    size: { type: `enum`, className: `rt-r-size`, values: a$16, default: `2`, responsive: !0 },
    trim: { ...r$11.trim, className: `rt-r-trim` },
  },
  p$11 = { align: { type: `enum`, className: `rt-r-ai`, values: s$12, responsive: !0 } },
  m$5 = { ...t$8, ...r$10, ...o$10 },
  t$5 = { ...o$8, ...e$12, ...r$12 },
  t$13 = [`div`, `span`],
  p$21 = [`none`, `inline-flex`, `flex`],
  a$15 = [`row`, `column`, `row-reverse`, `column-reverse`],
  o$15 = [`start`, `center`, `end`, `baseline`, `stretch`],
  n$16 = [`start`, `center`, `end`, `between`],
  l$6 = [`nowrap`, `wrap`, `wrap-reverse`],
  u$5 = {
    as: { type: `enum`, values: t$13, default: `div` },
    ...o$8,
    display: { type: `enum`, className: `rt-r-display`, values: p$21, responsive: !0 },
    direction: { type: `enum`, className: `rt-r-fd`, values: a$15, responsive: !0 },
    align: { type: `enum`, className: `rt-r-ai`, values: o$15, responsive: !0 },
    justify: { type: `enum`, className: `rt-r-jc`, values: n$16, parseValue: f$11, responsive: !0 },
    wrap: { type: `enum`, className: `rt-r-fw`, values: l$6, responsive: !0 },
    ...p$20,
  }
function f$11(e$26) {
  return e$26 === `between` ? `space-between` : e$26
}
const m$9 = [`h1`, `h2`, `h3`, `h4`, `h5`, `h6`],
  a$14 = [`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  n$12 = {
    as: { type: `enum`, values: m$9, default: `h1` },
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: a$14, default: `6`, responsive: !0 },
    ...t$11,
    ...t$10,
    ...r$11,
    ...e$12,
    ...r$12,
    ...r$10,
    ...o$10,
  },
  n$15 = [`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  f$10 = [`auto`, `always`, `hover`, `none`],
  m$4 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: n$15, responsive: !0 },
    ...t$11,
    ...r$11,
    ...e$12,
    ...r$12,
    underline: { type: `enum`, className: `rt-underline`, values: f$10, default: `auto` },
    ...s$11,
    ...o$10,
  },
  p$19 = [`1`, `2`, `3`, `4`],
  r$5 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: p$19, default: `2`, responsive: !0 },
    width: t$8.width,
    minWidth: t$8.minWidth,
    maxWidth: { ...t$8.maxWidth, default: `480px` },
    ...e$7,
  },
  p$10 = { ...o$8, ...e$12, ...r$12 },
  r$19 = [`1`, `2`, `3`],
  o$14 = [`vertical`, `horizontal`, `both`],
  t$6 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: r$19, default: `1`, responsive: !0 },
    ...r$16,
    scrollbars: { type: `enum`, values: o$14, default: `both` },
  },
  p$18 = [`1`, `2`, `3`, `4`],
  o$13 = [`none`, `initial`],
  t$4 = {
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: p$18, default: `3`, responsive: !0 },
    display: { type: `enum`, className: `rt-r-display`, values: o$13, parseValue: r$18, responsive: !0 },
  }
function r$18(e$26) {
  return e$26 === `initial` ? `block` : e$26
}
const r$17 = [`1`, `2`, `3`],
  o$6 = { size: { type: `enum`, className: `rt-r-size`, values: r$17, default: `2`, responsive: !0 } },
  a$13 = [`classic`, `surface`, `soft`, `ghost`],
  i$3 = {
    variant: { type: `enum`, className: `rt-variant`, values: a$13, default: `surface` },
    ...r$10,
    ...r$16,
    placeholder: { type: `string` },
  },
  n$14 = [`solid`, `soft`],
  p$9 = { variant: { type: `enum`, className: `rt-variant`, values: n$14, default: `solid` }, ...r$10, ...o$10 },
  e$14 = [`horizontal`, `vertical`],
  r$15 = [`1`, `2`, `3`, `4`],
  t$2 = {
    orientation: { type: `enum`, className: `rt-r-orientation`, values: e$14, default: `horizontal`, responsive: !0 },
    size: { type: `enum`, className: `rt-r-size`, values: r$15, default: `1`, responsive: !0 },
    color: { ...r$10.color, default: `gray` },
    decorative: { type: `boolean`, default: !0 },
  },
  e$13 = [`1`, `2`, `3`],
  s$9 = {
    size: { type: `enum`, className: `rt-r-size`, values: e$13, default: `2`, responsive: !0 },
    loading: { type: `boolean`, default: !0 },
  },
  p$8 = { ...o$8, ...e$12, ...r$12 },
  r$14 = [`1`, `2`],
  t$12 = [`nowrap`, `wrap`, `wrap-reverse`],
  o$12 = [`start`, `center`, `end`],
  p$7 = {
    size: { type: `enum`, className: `rt-r-size`, values: r$14, default: `2`, responsive: !0 },
    wrap: { type: `enum`, className: `rt-r-fw`, values: t$12, responsive: !0 },
    justify: { type: `enum`, className: `rt-r-jc`, values: o$12, responsive: !0 },
    ...r$10,
    ...o$10,
  },
  r$13 = [`1`, `2`, `3`],
  a$12 = [`surface`, `ghost`],
  o$11 = [`auto`, `fixed`],
  n$1 = {
    size: { type: `enum`, className: `rt-r-size`, values: r$13, default: `2`, responsive: !0 },
    variant: { type: `enum`, className: `rt-variant`, values: a$12, default: `ghost` },
    layout: { type: `enum`, className: `rt-r-tl`, values: o$11, responsive: !0 },
  },
  i$7 = [`start`, `center`, `end`, `baseline`],
  u$1 = { align: { type: `enum`, className: `rt-r-va`, values: i$7, parseValue: l$5, responsive: !0 } }
function l$5(e$26) {
  return { baseline: `baseline`, start: `top`, center: `middle`, end: `bottom` }[e$26]
}
const p$17 = [`start`, `center`, `end`],
  f$2 = {
    justify: { type: `enum`, className: `rt-r-ta`, values: p$17, parseValue: c$2, responsive: !0 },
    ...t$8,
    ...p$15,
  }
function c$2(e$26) {
  return { start: `left`, center: `center`, end: `right` }[e$26]
}
const m$8 = [`span`, `div`, `label`, `p`],
  a$11 = [`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`],
  n$11 = {
    as: { type: `enum`, values: m$8, default: `span` },
    ...o$8,
    size: { type: `enum`, className: `rt-r-size`, values: a$11, responsive: !0 },
    ...t$11,
    ...t$10,
    ...r$11,
    ...e$12,
    ...r$12,
    ...r$10,
    ...o$10,
  },
  p$16 = [`inherit`, `light`, `dark`],
  t$9 = [`solid`, `translucent`],
  n$13 = [`90%`, `95%`, `100%`, `105%`, `110%`],
  s$10 = {
    ...o$8,
    hasBackground: { type: `boolean`, default: !0 },
    appearance: { type: `enum`, values: p$16, default: `inherit` },
    accentColor: { type: `enum`, values: o$9, default: `indigo` },
    grayColor: { type: `enum`, values: e$10, default: `auto` },
    panelBackground: { type: `enum`, values: t$9, default: `translucent` },
    radius: { type: `enum`, values: e$11, default: `medium` },
    scaling: { type: `enum`, values: n$13, default: `100%` },
  },
  e$6 = {
    content: { type: `ReactNode`, required: !0 },
    width: t$8.width,
    minWidth: t$8.minWidth,
    maxWidth: { ...t$8.maxWidth, default: `360px` },
  },
  toPx = value$2 => typeof value$2 == `number` ? `${value$2}px` : value$2,
  generateCSSVars = props => {
    let vars = {}
    return props.maxWidth !== void 0
      && (typeof props.maxWidth == `object`
        ? (props.maxWidth.initial !== void 0 && (vars[`--swiss-max`] = toPx(props.maxWidth.initial)),
          props.maxWidth.xs !== void 0 && (vars[`--swiss-max-xs`] = toPx(props.maxWidth.xs)),
          props.maxWidth.sm !== void 0 && (vars[`--swiss-max-sm`] = toPx(props.maxWidth.sm)),
          props.maxWidth.md !== void 0 && (vars[`--swiss-max-md`] = toPx(props.maxWidth.md)),
          props.maxWidth.lg !== void 0 && (vars[`--swiss-max-lg`] = toPx(props.maxWidth.lg)),
          props.maxWidth.xl !== void 0 && (vars[`--swiss-max-xl`] = toPx(props.maxWidth.xl)))
        : vars[`--swiss-max`] = toPx(props.maxWidth)),
      props.gutter !== void 0
      && (typeof props.gutter == `object`
        ? (props.gutter.initial !== void 0 && (vars[`--swiss-gutter`] = props.gutter.initial),
          props.gutter.xs !== void 0 && (vars[`--swiss-gutter-xs`] = props.gutter.xs),
          props.gutter.sm !== void 0 && (vars[`--swiss-gutter-sm`] = props.gutter.sm),
          props.gutter.md !== void 0 && (vars[`--swiss-gutter-md`] = props.gutter.md),
          props.gutter.lg !== void 0 && (vars[`--swiss-gutter-lg`] = props.gutter.lg),
          props.gutter.xl !== void 0 && (vars[`--swiss-gutter-xl`] = props.gutter.xl))
        : vars[`--swiss-gutter`] = props.gutter),
      props.margins !== void 0
      && (typeof props.margins == `object`
        ? (props.margins.initial !== void 0 && (vars[`--swiss-margins`] = props.margins.initial),
          props.margins.xs !== void 0 && (vars[`--swiss-margins-xs`] = props.margins.xs),
          props.margins.sm !== void 0 && (vars[`--swiss-margins-sm`] = props.margins.sm),
          props.margins.md !== void 0 && (vars[`--swiss-margins-md`] = props.margins.md),
          props.margins.lg !== void 0 && (vars[`--swiss-margins-lg`] = props.margins.lg),
          props.margins.xl !== void 0 && (vars[`--swiss-margins-xl`] = props.margins.xl))
        : vars[`--swiss-margins`] = props.margins),
      props.columns !== void 0
      && (typeof props.columns == `object`
        ? (props.columns.initial !== void 0 && (vars[`--swiss-columns`] = String(props.columns.initial)),
          props.columns.xs !== void 0 && (vars[`--swiss-columns-xs`] = String(props.columns.xs)),
          props.columns.sm !== void 0 && (vars[`--swiss-columns-sm`] = String(props.columns.sm)),
          props.columns.md !== void 0 && (vars[`--swiss-columns-md`] = String(props.columns.md)),
          props.columns.lg !== void 0 && (vars[`--swiss-columns-lg`] = String(props.columns.lg)),
          props.columns.xl !== void 0 && (vars[`--swiss-columns-xl`] = String(props.columns.xl)))
        : vars[`--swiss-columns`] = String(props.columns)),
      vars
  },
  generateDataAttributes = props => {
    let attrs = {}
    return props.span !== void 0
      && (typeof props.span == `object`
        ? (props.span.initial !== void 0 && (attrs[`data-span`] = props.span.initial),
          props.span.xs !== void 0 && (attrs[`data-span-xs`] = props.span.xs),
          props.span.sm !== void 0 && (attrs[`data-span-sm`] = props.span.sm),
          props.span.md !== void 0 && (attrs[`data-span-md`] = props.span.md),
          props.span.lg !== void 0 && (attrs[`data-span-lg`] = props.span.lg),
          props.span.xl !== void 0 && (attrs[`data-span-xl`] = props.span.xl))
        : attrs[`data-span`] = props.span),
      props.cols !== void 0
      && (typeof props.cols == `object`
        ? (props.cols.initial !== void 0 && (attrs[`data-cols`] = String(props.cols.initial)),
          props.cols.xs !== void 0 && (attrs[`data-cols-xs`] = String(props.cols.xs)),
          props.cols.sm !== void 0 && (attrs[`data-cols-sm`] = String(props.cols.sm)),
          props.cols.md !== void 0 && (attrs[`data-cols-md`] = String(props.cols.md)),
          props.cols.lg !== void 0 && (attrs[`data-cols-lg`] = String(props.cols.lg)),
          props.cols.xl !== void 0 && (attrs[`data-cols-xl`] = String(props.cols.xl)))
        : attrs[`data-cols`] = String(props.cols)),
      attrs
  },
  cx = (...classes) => classes.filter(Boolean).join(` `),
  extractLayoutProps = props => {
    let extracted = v$1(props, u$3, r$4)
    return extracted
  }
var import_jsx_runtime = __toESM(require_jsx_runtime())
const Grid = import_react.forwardRef(
  (
    {
      children: children$3,
      maxWidth = 1440,
      gutter,
      margins,
      columns = 12,
      debug = !1,
      className: userClassName,
      style: userStyle,
      ...props
    },
    ref,
  ) => {
    let { className: layoutClassName, style: layoutStyle, ...restProps } = extractLayoutProps(props),
      cssVars = import_react.useMemo(() =>
        generateCSSVars({
          maxWidth,
          ...gutter !== void 0 && { gutter },
          ...margins !== void 0 && { margins },
          columns,
        }), [maxWidth, gutter, margins, columns])
    return (0, import_jsx_runtime.jsx)(`div`, {
      ref,
      className: cx(`swiss-grid`, debug && `swiss-grid--debug`, layoutClassName, userClassName),
      style: { ...cssVars, ...layoutStyle, ...userStyle },
      ...restProps,
      children: children$3,
    })
  },
)
Grid.displayName = `Swiss.Grid`
function setRef(ref, value$2) {
  if (typeof ref == `function`) return ref(value$2)
  ref != null && (ref.current = value$2)
}
function composeRefs(...refs) {
  return node$1 => {
    let hasCleanup = !1,
      cleanups = refs.map(ref => {
        let cleanup = setRef(ref, node$1)
        return !hasCleanup && typeof cleanup == `function` && (hasCleanup = !0), cleanup
      })
    if (hasCleanup) {
      return () => {
        for (let i$14 = 0; i$14 < cleanups.length; i$14++) {
          let cleanup = cleanups[i$14]
          typeof cleanup == `function` ? cleanup() : setRef(refs[i$14], null)
        }
      }
    }
  }
}
function useComposedRefs(...refs) {
  return import_react.useCallback(composeRefs(...refs), refs)
}
function createSlot(ownerName) {
  let SlotClone = createSlotClone(ownerName),
    Slot2 = import_react.forwardRef((props, forwardedRef) => {
      let { children: children$3, ...slotProps } = props,
        childrenArray = import_react.Children.toArray(children$3),
        slottable = childrenArray.find(isSlottable)
      if (slottable) {
        let newElement = slottable.props.children,
          newChildren = childrenArray.map(child =>
            child === slottable
              ? import_react.Children.count(newElement) > 1
                ? import_react.Children.only(null)
                : import_react.isValidElement(newElement)
                ? newElement.props.children
                : null
              : child
          )
        return (0, import_jsx_runtime.jsx)(SlotClone, {
          ...slotProps,
          ref: forwardedRef,
          children: import_react.isValidElement(newElement)
            ? import_react.cloneElement(newElement, void 0, newChildren)
            : null,
        })
      }
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: children$3 })
    })
  return Slot2.displayName = `${ownerName}.Slot`, Slot2
}
var Slot$2 = createSlot(`Slot`)
function createSlotClone(ownerName) {
  let SlotClone = import_react.forwardRef((props, forwardedRef) => {
    let { children: children$3, ...slotProps } = props
    if (import_react.isValidElement(children$3)) {
      let childrenRef = getElementRef$1(children$3), props2 = mergeProps$1(slotProps, children$3.props)
      return children$3.type !== import_react.Fragment
        && (props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef),
        import_react.cloneElement(children$3, props2)
    }
    return import_react.Children.count(children$3) > 1 ? import_react.Children.only(null) : null
  })
  return SlotClone.displayName = `${ownerName}.SlotClone`, SlotClone
}
var SLOTTABLE_IDENTIFIER = Symbol(`radix.slottable`)
function createSlottable(ownerName) {
  let Slottable2 = ({ children: children$3 }) =>
    (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children$3 })
  return Slottable2.displayName = `${ownerName}.Slottable`, Slottable2.__radixId = SLOTTABLE_IDENTIFIER, Slottable2
}
var Slottable$1 = createSlottable(`Slottable`)
function isSlottable(child) {
  return import_react.isValidElement(child) && typeof child.type == `function` && `__radixId` in child.type
    && child.type.__radixId === SLOTTABLE_IDENTIFIER
}
function mergeProps$1(slotProps, childProps) {
  let overrideProps = { ...childProps }
  for (let propName in childProps) {
    let slotPropValue = slotProps[propName],
      childPropValue = childProps[propName],
      isHandler = /^on[A-Z]/.test(propName)
    isHandler
      ? slotPropValue && childPropValue
        ? overrideProps[propName] = (...args$1) => {
          let result = childPropValue(...args$1)
          return slotPropValue(...args$1), result
        }
        : slotPropValue && (overrideProps[propName] = slotPropValue)
      : propName === `style`
      ? overrideProps[propName] = { ...slotPropValue, ...childPropValue }
      : propName === `className`
        && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(` `))
  }
  return { ...slotProps, ...overrideProps }
}
function getElementRef$1(element$2) {
  let getter = Object.getOwnPropertyDescriptor(element$2.props, `ref`)?.get,
    mayWarn = getter && `isReactWarning` in getter && getter.isReactWarning
  return mayWarn
    ? element$2.ref
    : (getter = Object.getOwnPropertyDescriptor(element$2, `ref`)?.get,
      mayWarn = getter && `isReactWarning` in getter && getter.isReactWarning,
      mayWarn ? element$2.props.ref : element$2.props.ref || element$2.ref)
}
const Body = import_react.forwardRef(
  (
    {
      children: children$3,
      asChild = !1,
      subgrid = !1,
      flow: flow$2,
      className: userClassName,
      style: userStyle,
      ...props
    },
    ref,
  ) => {
    let Comp = asChild ? Slot$2 : `div`,
      { className: layoutClassName, style: layoutStyle, ...restProps } = extractLayoutProps(props),
      combinedStyle = import_react.useMemo(() => {
        let style$1 = { ...layoutStyle }
        if (subgrid) {
          style$1.display = `grid`, style$1.gridTemplateColumns = `subgrid`
          let effectiveFlow = flow$2 || `row`
          style$1.gridAutoFlow = effectiveFlow === `row` ? `column` : `row`
        }
        return { ...style$1, ...userStyle }
      }, [layoutStyle, subgrid, flow$2, userStyle])
    return (0, import_jsx_runtime.jsx)(Comp, {
      ref,
      className: cx(`swiss-item`, layoutClassName, userClassName),
      'data-span': `body`,
      style: combinedStyle,
      ...restProps,
      children: children$3,
    })
  },
)
Body.displayName = `Swiss.Body`
const Viewport$2 = import_react.forwardRef(
  (
    {
      children: children$3,
      asChild = !1,
      subgrid = !1,
      flow: flow$2,
      className: userClassName,
      style: userStyle,
      ...props
    },
    ref,
  ) => {
    let Comp = asChild ? Slot$2 : `div`,
      { className: layoutClassName, style: layoutStyle, ...restProps } = extractLayoutProps(props),
      combinedStyle = import_react.useMemo(() => {
        let style$1 = { ...layoutStyle }
        if (subgrid) {
          style$1.display = `grid`, style$1.gridTemplateColumns = `subgrid`
          let effectiveFlow = flow$2 || `row`
          style$1.gridAutoFlow = effectiveFlow === `row` ? `column` : `row`
        }
        return { ...style$1, ...userStyle }
      }, [layoutStyle, subgrid, flow$2, userStyle])
    return (0, import_jsx_runtime.jsx)(Comp, {
      ref,
      className: cx(`swiss-item`, layoutClassName, userClassName),
      'data-span': `viewport`,
      style: combinedStyle,
      ...restProps,
      children: children$3,
    })
  },
)
Viewport$2.displayName = `Swiss.Viewport`
const Extended = import_react.forwardRef(
  (
    {
      children: children$3,
      asChild = !1,
      subgrid = !1,
      flow: flow$2,
      className: userClassName,
      style: userStyle,
      ...props
    },
    ref,
  ) => {
    let Comp = asChild ? Slot$2 : `div`,
      { className: layoutClassName, style: layoutStyle, ...restProps } = extractLayoutProps(props),
      combinedStyle = import_react.useMemo(() => {
        let style$1 = { ...layoutStyle }
        if (subgrid) {
          style$1.display = `grid`, style$1.gridTemplateColumns = `subgrid`
          let effectiveFlow = flow$2 || `row`
          style$1.gridAutoFlow = effectiveFlow === `row` ? `column` : `row`
        }
        return { ...style$1, ...userStyle }
      }, [layoutStyle, subgrid, flow$2, userStyle])
    return (0, import_jsx_runtime.jsx)(Comp, {
      ref,
      className: cx(`swiss-item`, layoutClassName, userClassName),
      'data-span': `extended`,
      style: combinedStyle,
      ...restProps,
      children: children$3,
    })
  },
)
Extended.displayName = `Swiss.Extended`
const Item$4 = import_react.forwardRef(
  (
    {
      children: children$3,
      asChild = !1,
      subgrid = !1,
      flow: flow$2,
      span: span$1 = `body`,
      cols,
      start: start$2,
      className: userClassName,
      style: userStyle,
      ...props
    },
    ref,
  ) => {
    let Comp = asChild ? Slot$2 : `div`,
      { className: layoutClassName, style: layoutStyle, ...restProps } = extractLayoutProps(props),
      processedCols = import_react.useMemo(() => {
        if (cols === void 0) return
        let combineStartAndCols = (startVal, colsVal) =>
          typeof colsVal == `string`
            ? colsVal
            : typeof colsVal == `number` && startVal !== void 0
            ? `${startVal} / span ${colsVal}`
            : typeof colsVal == `number`
            ? `span ${colsVal}`
            : colsVal
        if (typeof cols == `object` && !Array.isArray(cols)) {
          let processed = {},
            startResponsive = start$2 !== void 0 && typeof start$2 == `object` && !Array.isArray(start$2)
          for (let [breakpoint, value$2] of Object.entries(cols)) {
            if (value$2 !== void 0) {
              let startVal = startResponsive ? start$2[breakpoint] : start$2
              processed[breakpoint] = combineStartAndCols(startVal, value$2)
            }
          }
          return processed
        }
        return combineStartAndCols(start$2, cols)
      }, [cols, start$2]),
      dataAttrs = import_react.useMemo(() => cols === void 0 ? generateDataAttributes({ span: span$1 }) : {}, [
        span$1,
        cols,
      ]),
      combinedStyle = import_react.useMemo(() => {
        let style$1 = { ...layoutStyle }
        if (
          processedCols !== void 0 && (typeof processedCols == `object`
            ? processedCols.initial && (style$1.gridColumn = processedCols.initial)
            : style$1.gridColumn = processedCols), subgrid
        ) {
          style$1.display = `grid`, style$1.gridTemplateColumns = `subgrid`
          let effectiveFlow = flow$2 || `row`
          style$1.gridAutoFlow = effectiveFlow === `row` ? `column` : `row`
        }
        return { ...style$1, ...userStyle }
      }, [layoutStyle, processedCols, subgrid, flow$2, userStyle])
    return (0, import_jsx_runtime.jsx)(Comp, {
      ref,
      className: cx(`swiss-item`, layoutClassName, userClassName),
      ...dataAttrs,
      style: combinedStyle,
      ...restProps,
      children: children$3,
    })
  },
)
Item$4.displayName = `Swiss.Item`
var import_react_dom$3 = __toESM(require_react_dom(), 1),
  NODES = [
    `a`,
    `button`,
    `div`,
    `form`,
    `h2`,
    `h3`,
    `img`,
    `input`,
    `label`,
    `li`,
    `nav`,
    `ol`,
    `p`,
    `select`,
    `span`,
    `svg`,
    `ul`,
  ],
  Primitive = NODES.reduce((primitive, node$1) => {
    let Slot$3 = createSlot(`Primitive.${node$1}`),
      Node$2 = import_react.forwardRef((props, forwardedRef) => {
        let { asChild, ...primitiveProps } = props, Comp = asChild ? Slot$3 : node$1
        return typeof window < `u` && (window[Symbol.for(`radix-ui`)] = !0),
          (0, import_jsx_runtime.jsx)(Comp, { ...primitiveProps, ref: forwardedRef })
      })
    return Node$2.displayName = `Primitive.${node$1}`, { ...primitive, [node$1]: Node$2 }
  }, {})
function dispatchDiscreteCustomEvent(target, event) {
  target && import_react_dom$3.flushSync(() => target.dispatchEvent(event))
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
    position: `absolute`,
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: `hidden`,
    clip: `rect(0, 0, 0, 0)`,
    whiteSpace: `nowrap`,
    wordWrap: `normal`,
  }),
  NAME$1 = `VisuallyHidden`,
  VisuallyHidden = import_react.forwardRef((props, forwardedRef) =>
    (0, import_jsx_runtime.jsx)(Primitive.span, {
      ...props,
      ref: forwardedRef,
      style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
    })
  )
VisuallyHidden.displayName = NAME$1
var Root$3 = VisuallyHidden
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = []
  function createContext3(rootComponentName, defaultContext) {
    let BaseContext = import_react.createContext(defaultContext), index$4 = defaultContexts.length
    defaultContexts = [...defaultContexts, defaultContext]
    let Provider$2 = props => {
      let { scope: scope$2, children: children$3, ...context$2 } = props,
        Context = scope$2?.[scopeName]?.[index$4] || BaseContext,
        value$2 = import_react.useMemo(() => context$2, Object.values(context$2))
      return (0, import_jsx_runtime.jsx)(Context.Provider, { value: value$2, children: children$3 })
    }
    Provider$2.displayName = rootComponentName + `Provider`
    function useContext2(consumerName, scope$2) {
      let Context = scope$2?.[scopeName]?.[index$4] || BaseContext, context$2 = import_react.useContext(Context)
      if (context$2) return context$2
      if (defaultContext !== void 0) return defaultContext
      throw Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``)
    }
    return [Provider$2, useContext2]
  }
  let createScope = () => {
    let scopeContexts = defaultContexts.map(defaultContext => import_react.createContext(defaultContext))
    return function(scope$2) {
      let contexts = scope$2?.[scopeName] || scopeContexts
      return import_react.useMemo(() => ({ [`__scope${scopeName}`]: { ...scope$2, [scopeName]: contexts } }), [
        scope$2,
        contexts,
      ])
    }
  }
  return createScope.scopeName = scopeName,
    [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)]
}
function composeContextScopes(...scopes) {
  let baseScope = scopes[0]
  if (scopes.length === 1) return baseScope
  let createScope = () => {
    let scopeHooks = scopes.map(createScope2 => ({ useScope: createScope2(), scopeName: createScope2.scopeName }))
    return function(overrideScopes) {
      let nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        let scopeProps = useScope(overrideScopes), currentScope = scopeProps[`__scope${scopeName}`]
        return { ...nextScopes2, ...currentScope }
      }, {})
      return import_react.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes])
    }
  }
  return createScope.scopeName = baseScope.scopeName, createScope
}
function createCollection(name) {
  let PROVIDER_NAME$1 = name + `CollectionProvider`,
    [createCollectionContext, createCollectionScope$2] = createContextScope(PROVIDER_NAME$1),
    [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME$1, {
      collectionRef: { current: null },
      itemMap: new Map(),
    }),
    CollectionProvider = props => {
      let { scope: scope$2, children: children$3 } = props,
        ref = import_react.useRef(null),
        itemMap = import_react.useRef(new Map()).current
      return (0, import_jsx_runtime.jsx)(CollectionProviderImpl, {
        scope: scope$2,
        itemMap,
        collectionRef: ref,
        children: children$3,
      })
    }
  CollectionProvider.displayName = PROVIDER_NAME$1
  let COLLECTION_SLOT_NAME = name + `CollectionSlot`,
    CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME),
    CollectionSlot = import_react.forwardRef((props, forwardedRef) => {
      let { scope: scope$2, children: children$3 } = props,
        context$2 = useCollectionContext(COLLECTION_SLOT_NAME, scope$2),
        composedRefs = useComposedRefs(forwardedRef, context$2.collectionRef)
      return (0, import_jsx_runtime.jsx)(CollectionSlotImpl, { ref: composedRefs, children: children$3 })
    })
  CollectionSlot.displayName = COLLECTION_SLOT_NAME
  let ITEM_SLOT_NAME = name + `CollectionItemSlot`,
    ITEM_DATA_ATTR = `data-radix-collection-item`,
    CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME),
    CollectionItemSlot = import_react.forwardRef((props, forwardedRef) => {
      let { scope: scope$2, children: children$3, ...itemData } = props,
        ref = import_react.useRef(null),
        composedRefs = useComposedRefs(forwardedRef, ref),
        context$2 = useCollectionContext(ITEM_SLOT_NAME, scope$2)
      return import_react.useEffect(() => (context$2.itemMap.set(ref, { ref, ...itemData }), () =>
        void context$2.itemMap.delete(ref))
      ),
        (0, import_jsx_runtime.jsx)(CollectionItemSlotImpl, {
          [ITEM_DATA_ATTR]: ``,
          ref: composedRefs,
          children: children$3,
        })
    })
  CollectionItemSlot.displayName = ITEM_SLOT_NAME
  function useCollection$2(scope$2) {
    let context$2 = useCollectionContext(name + `CollectionConsumer`, scope$2),
      getItems = import_react.useCallback(() => {
        let collectionNode = context$2.collectionRef.current
        if (!collectionNode) return []
        let orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`)),
          items = Array.from(context$2.itemMap.values()),
          orderedItems = items.sort((a$22, b$3) =>
            orderedNodes.indexOf(a$22.ref.current) - orderedNodes.indexOf(b$3.ref.current)
          )
        return orderedItems
      }, [context$2.collectionRef, context$2.itemMap])
    return getItems
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection$2,
    createCollectionScope$2,
  ]
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
  return function(event) {
    if (originalEventHandler?.(event), checkForDefaultPrevented === !1 || !event.defaultPrevented) {
      return ourEventHandler?.(event)
    }
  }
}
var useLayoutEffect2 = globalThis?.document ? import_react.useLayoutEffect : () => {},
  useInsertionEffect = import_react.useInsertionEffect || useLayoutEffect2
function useControllableState({ prop, defaultProp, onChange = () => {}, caller }) {
  let [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({ defaultProp, onChange }),
    isControlled = prop !== void 0,
    value$2 = isControlled ? prop : uncontrolledProp
  {
    let isControlledRef = import_react.useRef(prop !== void 0)
    import_react.useEffect(() => {
      let wasControlled = isControlledRef.current
      if (wasControlled !== isControlled) {
        let from = wasControlled ? `controlled` : `uncontrolled`, to = isControlled ? `controlled` : `uncontrolled`
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`,
        )
      }
      isControlledRef.current = isControlled
    }, [isControlled, caller])
  }
  let setValue = import_react.useCallback(nextValue => {
    if (isControlled) {
      let value2 = isFunction(nextValue) ? nextValue(prop) : nextValue
      value2 !== prop && onChangeRef.current?.(value2)
    } else setUncontrolledProp(nextValue)
  }, [isControlled, prop, setUncontrolledProp, onChangeRef])
  return [value$2, setValue]
}
function useUncontrolledState({ defaultProp, onChange }) {
  let [value$2, setValue] = import_react.useState(defaultProp),
    prevValueRef = import_react.useRef(value$2),
    onChangeRef = import_react.useRef(onChange)
  return useInsertionEffect(() => {
    onChangeRef.current = onChange
  }, [onChange]),
    import_react.useEffect(() => {
      prevValueRef.current !== value$2 && (onChangeRef.current?.(value$2), prevValueRef.current = value$2)
    }, [value$2, prevValueRef]),
    [value$2, setValue, onChangeRef]
}
function isFunction(value$2) {
  return typeof value$2 == `function`
}
var SYNC_STATE = Symbol(`RADIX:SYNC_STATE`)
function useStateMachine$1(initialState$1, machine) {
  return import_react.useReducer((state, event) => {
    let nextState = machine[state][event]
    return nextState ?? state
  }, initialState$1)
}
var Presence = props => {
  let { present, children: children$3 } = props,
    presence = usePresence(present),
    child = typeof children$3 == `function`
      ? children$3({ present: presence.isPresent })
      : import_react.Children.only(children$3),
    ref = useComposedRefs(presence.ref, getElementRef(child)),
    forceMount = typeof children$3 == `function`
  return forceMount || presence.isPresent ? import_react.cloneElement(child, { ref }) : null
}
Presence.displayName = `Presence`
function usePresence(present) {
  let [node$1, setNode] = import_react.useState(),
    stylesRef = import_react.useRef(null),
    prevPresentRef = import_react.useRef(present),
    prevAnimationNameRef = import_react.useRef(`none`),
    initialState$1 = present ? `mounted` : `unmounted`,
    [state, send] = useStateMachine$1(initialState$1, {
      mounted: { UNMOUNT: `unmounted`, ANIMATION_OUT: `unmountSuspended` },
      unmountSuspended: { MOUNT: `mounted`, ANIMATION_END: `unmounted` },
      unmounted: { MOUNT: `mounted` },
    })
  return import_react.useEffect(() => {
    let currentAnimationName = getAnimationName(stylesRef.current)
    prevAnimationNameRef.current = state === `mounted` ? currentAnimationName : `none`
  }, [state]),
    useLayoutEffect2(() => {
      let styles = stylesRef.current, wasPresent = prevPresentRef.current, hasPresentChanged = wasPresent !== present
      if (hasPresentChanged) {
        let prevAnimationName = prevAnimationNameRef.current, currentAnimationName = getAnimationName(styles)
        if (present) send(`MOUNT`)
        else if (currentAnimationName === `none` || styles?.display === `none`) send(`UNMOUNT`)
        else {
          let isAnimating = prevAnimationName !== currentAnimationName
          send(wasPresent && isAnimating ? `ANIMATION_OUT` : `UNMOUNT`)
        }
        prevPresentRef.current = present
      }
    }, [present, send]),
    useLayoutEffect2(() => {
      if (node$1) {
        let timeoutId,
          ownerWindow = node$1.ownerDocument.defaultView ?? window,
          handleAnimationEnd = event => {
            let currentAnimationName = getAnimationName(stylesRef.current),
              isCurrentAnimation = currentAnimationName.includes(event.animationName)
            if (event.target === node$1 && isCurrentAnimation && (send(`ANIMATION_END`), !prevPresentRef.current)) {
              let currentFillMode = node$1.style.animationFillMode
              node$1.style.animationFillMode = `forwards`,
                timeoutId = ownerWindow.setTimeout(() => {
                  node$1.style.animationFillMode === `forwards` && (node$1.style.animationFillMode = currentFillMode)
                })
            }
          },
          handleAnimationStart = event => {
            event.target === node$1 && (prevAnimationNameRef.current = getAnimationName(stylesRef.current))
          }
        return node$1.addEventListener(`animationstart`, handleAnimationStart),
          node$1.addEventListener(`animationcancel`, handleAnimationEnd),
          node$1.addEventListener(`animationend`, handleAnimationEnd),
          () => {
            ownerWindow.clearTimeout(timeoutId),
              node$1.removeEventListener(`animationstart`, handleAnimationStart),
              node$1.removeEventListener(`animationcancel`, handleAnimationEnd),
              node$1.removeEventListener(`animationend`, handleAnimationEnd)
          }
      } else send(`ANIMATION_END`)
    }, [node$1, send]),
    {
      isPresent: [`mounted`, `unmountSuspended`].includes(state),
      ref: import_react.useCallback(node2 => {
        stylesRef.current = node2 ? getComputedStyle(node2) : null, setNode(node2)
      }, []),
    }
}
function getAnimationName(styles) {
  return styles?.animationName || `none`
}
function getElementRef(element$2) {
  let getter = Object.getOwnPropertyDescriptor(element$2.props, `ref`)?.get,
    mayWarn = getter && `isReactWarning` in getter && getter.isReactWarning
  return mayWarn
    ? element$2.ref
    : (getter = Object.getOwnPropertyDescriptor(element$2, `ref`)?.get,
      mayWarn = getter && `isReactWarning` in getter && getter.isReactWarning,
      mayWarn ? element$2.props.ref : element$2.props.ref || element$2.ref)
}
var useReactId = import_react.useId || (() => void 0), count$1 = 0
function useId(deterministicId) {
  let [id$2, setId] = import_react.useState(useReactId())
  return useLayoutEffect2(() => {
    deterministicId || setId(reactId => reactId ?? String(count$1++))
  }, [deterministicId]),
    deterministicId || (id$2 ? `radix-${id$2}` : ``)
}
var DirectionContext = import_react.createContext(void 0),
  DirectionProvider = props => {
    let { dir, children: children$3 } = props
    return (0, import_jsx_runtime.jsx)(DirectionContext.Provider, { value: dir, children: children$3 })
  }
function useDirection(localDir) {
  let globalDir = import_react.useContext(DirectionContext)
  return localDir || globalDir || `ltr`
}
var Provider$1 = DirectionProvider
function useCallbackRef(callback) {
  let callbackRef = import_react.useRef(callback)
  return import_react.useEffect(() => {
    callbackRef.current = callback
  }),
    import_react.useMemo(() => (...args$1) => callbackRef.current?.(...args$1), [])
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  let onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp)
  import_react.useEffect(() => {
    let handleKeyDown = event => {
      event.key === `Escape` && onEscapeKeyDown(event)
    }
    return ownerDocument.addEventListener(`keydown`, handleKeyDown, { capture: !0 }),
      () => ownerDocument.removeEventListener(`keydown`, handleKeyDown, { capture: !0 })
  }, [onEscapeKeyDown, ownerDocument])
}
var DISMISSABLE_LAYER_NAME = `DismissableLayer`,
  CONTEXT_UPDATE = `dismissableLayer.update`,
  POINTER_DOWN_OUTSIDE = `dismissableLayer.pointerDownOutside`,
  FOCUS_OUTSIDE = `dismissableLayer.focusOutside`,
  originalBodyPointerEvents,
  DismissableLayerContext = import_react.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  DismissableLayer = import_react.forwardRef((props, forwardedRef) => {
    let {
        disableOutsidePointerEvents = !1,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        ...layerProps
      } = props,
      context$2 = import_react.useContext(DismissableLayerContext),
      [node$1, setNode] = import_react.useState(null),
      ownerDocument = node$1?.ownerDocument ?? globalThis?.document,
      [, force] = import_react.useState({}),
      composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2)),
      layers = Array.from(context$2.layers),
      [highestLayerWithOutsidePointerEventsDisabled] = [...context$2.layersWithOutsidePointerEventsDisabled].slice(-1),
      highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled),
      index$4 = node$1 ? layers.indexOf(node$1) : -1,
      isBodyPointerEventsDisabled = context$2.layersWithOutsidePointerEventsDisabled.size > 0,
      isPointerEventsEnabled = index$4 >= highestLayerWithOutsidePointerEventsDisabledIndex,
      pointerDownOutside = usePointerDownOutside(event => {
        let target = event.target,
          isPointerDownOnBranch = [...context$2.branches].some(branch => branch.contains(target))
        !isPointerEventsEnabled || isPointerDownOnBranch
          || (onPointerDownOutside?.(event), onInteractOutside?.(event), event.defaultPrevented || onDismiss?.())
      }, ownerDocument),
      focusOutside = useFocusOutside(event => {
        let target = event.target, isFocusInBranch = [...context$2.branches].some(branch => branch.contains(target))
        isFocusInBranch
          || (onFocusOutside?.(event), onInteractOutside?.(event), event.defaultPrevented || onDismiss?.())
      }, ownerDocument)
    return useEscapeKeydown(event => {
      let isHighestLayer = index$4 === context$2.layers.size - 1
      isHighestLayer
        && (onEscapeKeyDown?.(event), !event.defaultPrevented && onDismiss && (event.preventDefault(), onDismiss()))
    }, ownerDocument),
      import_react.useEffect(() => {
        if (node$1) {
          return disableOutsidePointerEvents
            && (context$2.layersWithOutsidePointerEventsDisabled.size === 0
              && (originalBodyPointerEvents = ownerDocument.body.style.pointerEvents,
                ownerDocument.body.style.pointerEvents = `none`),
              context$2.layersWithOutsidePointerEventsDisabled.add(node$1)),
            context$2.layers.add(node$1),
            dispatchUpdate(),
            () => {
              disableOutsidePointerEvents && context$2.layersWithOutsidePointerEventsDisabled.size === 1
                && (ownerDocument.body.style.pointerEvents = originalBodyPointerEvents)
            }
        }
      }, [node$1, ownerDocument, disableOutsidePointerEvents, context$2]),
      import_react.useEffect(() => () => {
        node$1
          && (context$2.layers.delete(node$1),
            context$2.layersWithOutsidePointerEventsDisabled.delete(node$1),
            dispatchUpdate())
      }, [node$1, context$2]),
      import_react.useEffect(() => {
        let handleUpdate = () => force({})
        return document.addEventListener(CONTEXT_UPDATE, handleUpdate),
          () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate)
      }, []),
      (0, import_jsx_runtime.jsx)(Primitive.div, {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? `auto` : `none` : void 0,
          ...props.style,
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture),
      })
  })
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME
var BRANCH_NAME = `DismissableLayerBranch`,
  DismissableLayerBranch = import_react.forwardRef((props, forwardedRef) => {
    let context$2 = import_react.useContext(DismissableLayerContext),
      ref = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref)
    return import_react.useEffect(() => {
      let node$1 = ref.current
      if (node$1) {
        return context$2.branches.add(node$1), () => {
          context$2.branches.delete(node$1)
        }
      }
    }, [context$2.branches]),
      (0, import_jsx_runtime.jsx)(Primitive.div, { ...props, ref: composedRefs })
  })
DismissableLayerBranch.displayName = BRANCH_NAME
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  let handlePointerDownOutside = useCallbackRef(onPointerDownOutside),
    isPointerInsideReactTreeRef = import_react.useRef(!1),
    handleClickRef = import_react.useRef(() => {})
  return import_react.useEffect(() => {
    let handlePointerDown = event => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function() {
            handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, { discrete: !0 })
          }
          var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2
          let eventDetail = { originalEvent: event }
          event.pointerType === `touch`
            ? (ownerDocument.removeEventListener(`click`, handleClickRef.current),
              handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2,
              ownerDocument.addEventListener(`click`, handleClickRef.current, { once: !0 }))
            : handleAndDispatchPointerDownOutsideEvent2()
        } else ownerDocument.removeEventListener(`click`, handleClickRef.current)
        isPointerInsideReactTreeRef.current = !1
      },
      timerId = window.setTimeout(() => {
        ownerDocument.addEventListener(`pointerdown`, handlePointerDown)
      }, 0)
    return () => {
      window.clearTimeout(timerId),
        ownerDocument.removeEventListener(`pointerdown`, handlePointerDown),
        ownerDocument.removeEventListener(`click`, handleClickRef.current)
    }
  }, [ownerDocument, handlePointerDownOutside]),
    { onPointerDownCapture: () => isPointerInsideReactTreeRef.current = !0 }
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  let handleFocusOutside = useCallbackRef(onFocusOutside), isFocusInsideReactTreeRef = import_react.useRef(!1)
  return import_react.useEffect(() => {
    let handleFocus = event => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        let eventDetail = { originalEvent: event }
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, { discrete: !1 })
      }
    }
    return ownerDocument.addEventListener(`focusin`, handleFocus),
      () => ownerDocument.removeEventListener(`focusin`, handleFocus)
  }, [ownerDocument, handleFocusOutside]),
    {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = !0,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = !1,
    }
}
function dispatchUpdate() {
  let event = new CustomEvent(CONTEXT_UPDATE)
  document.dispatchEvent(event)
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  let target = detail.originalEvent.target, event = new CustomEvent(name, { bubbles: !1, cancelable: !0, detail })
  handler && target.addEventListener(name, handler, { once: !0 }),
    discrete ? dispatchDiscreteCustomEvent(target, event) : target.dispatchEvent(event)
}
var AUTOFOCUS_ON_MOUNT = `focusScope.autoFocusOnMount`,
  AUTOFOCUS_ON_UNMOUNT = `focusScope.autoFocusOnUnmount`,
  EVENT_OPTIONS$1 = { bubbles: !1, cancelable: !0 },
  FOCUS_SCOPE_NAME = `FocusScope`,
  FocusScope = import_react.forwardRef((props, forwardedRef) => {
    let {
        loop: loop$2 = !1,
        trapped = !1,
        onMountAutoFocus: onMountAutoFocusProp,
        onUnmountAutoFocus: onUnmountAutoFocusProp,
        ...scopeProps
      } = props,
      [container, setContainer] = import_react.useState(null),
      onMountAutoFocus = useCallbackRef(onMountAutoFocusProp),
      onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp),
      lastFocusedElementRef = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, node$1 => setContainer(node$1)),
      focusScope = import_react.useRef({
        paused: !1,
        pause() {
          this.paused = !0
        },
        resume() {
          this.paused = !1
        },
      }).current
    import_react.useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = function(event) {
            if (focusScope.paused || !container) return
            let target = event.target
            container.contains(target)
              ? lastFocusedElementRef.current = target
              : focus(lastFocusedElementRef.current, { select: !0 })
          },
          handleFocusOut2 = function(event) {
            if (focusScope.paused || !container) return
            let relatedTarget = event.relatedTarget
            relatedTarget !== null
              && (container.contains(relatedTarget) || focus(lastFocusedElementRef.current, { select: !0 }))
          },
          handleMutations2 = function(mutations) {
            let focusedElement = document.activeElement
            if (focusedElement === document.body) {
              for (let mutation of mutations) mutation.removedNodes.length > 0 && focus(container)
            }
          }
        var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2
        document.addEventListener(`focusin`, handleFocusIn2), document.addEventListener(`focusout`, handleFocusOut2)
        let mutationObserver = new MutationObserver(handleMutations2)
        return container && mutationObserver.observe(container, { childList: !0, subtree: !0 }), () => {
          document.removeEventListener(`focusin`, handleFocusIn2),
            document.removeEventListener(`focusout`, handleFocusOut2),
            mutationObserver.disconnect()
        }
      }
    }, [trapped, container, focusScope.paused]),
      import_react.useEffect(() => {
        if (container) {
          focusScopesStack.add(focusScope)
          let previouslyFocusedElement = document.activeElement,
            hasFocusedCandidate = container.contains(previouslyFocusedElement)
          if (!hasFocusedCandidate) {
            let mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1)
            container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus),
              container.dispatchEvent(mountEvent),
              mountEvent.defaultPrevented
              || (focusFirst$1(removeLinks(getTabbableCandidates(container)), { select: !0 }),
                document.activeElement === previouslyFocusedElement && focus(container))
          }
          return () => {
            container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus),
              setTimeout(() => {
                let unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1)
                container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus),
                  container.dispatchEvent(unmountEvent),
                  unmountEvent.defaultPrevented || focus(previouslyFocusedElement ?? document.body, { select: !0 }),
                  container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus),
                  focusScopesStack.remove(focusScope)
              }, 0)
          }
        }
      }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope])
    let handleKeyDown = import_react.useCallback(event => {
      if (!loop$2 && !trapped || focusScope.paused) return
      let isTabKey = event.key === `Tab` && !event.altKey && !event.ctrlKey && !event.metaKey,
        focusedElement = document.activeElement
      if (isTabKey && focusedElement) {
        let container2 = event.currentTarget,
          [first$2, last$3] = getTabbableEdges(container2),
          hasTabbableElementsInside = first$2 && last$3
        hasTabbableElementsInside
          ? !event.shiftKey && focusedElement === last$3
            ? (event.preventDefault(), loop$2 && focus(first$2, { select: !0 }))
            : event.shiftKey && focusedElement === first$2
              && (event.preventDefault(), loop$2 && focus(last$3, { select: !0 }))
          : focusedElement === container2 && event.preventDefault()
      }
    }, [loop$2, trapped, focusScope.paused])
    return (0, import_jsx_runtime.jsx)(Primitive.div, {
      tabIndex: -1,
      ...scopeProps,
      ref: composedRefs,
      onKeyDown: handleKeyDown,
    })
  })
FocusScope.displayName = FOCUS_SCOPE_NAME
function focusFirst$1(candidates, { select = !1 } = {}) {
  let previouslyFocusedElement = document.activeElement
  for (let candidate of candidates) {
    if (focus(candidate, { select }), document.activeElement !== previouslyFocusedElement) return
  }
}
function getTabbableEdges(container) {
  let candidates = getTabbableCandidates(container),
    first$2 = findVisible(candidates, container),
    last$3 = findVisible(candidates.reverse(), container)
  return [first$2, last$3]
}
function getTabbableCandidates(container) {
  let nodes = [],
    walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: node$1 => {
        let isHiddenInput = node$1.tagName === `INPUT` && node$1.type === `hidden`
        return node$1.disabled || node$1.hidden || isHiddenInput
          ? NodeFilter.FILTER_SKIP
          : node$1.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP
      },
    })
  for (; walker.nextNode();) nodes.push(walker.currentNode)
  return nodes
}
function findVisible(elements, container) {
  for (let element$2 of elements) if (!isHidden(element$2, { upTo: container })) return element$2
}
function isHidden(node$1, { upTo }) {
  if (getComputedStyle(node$1).visibility === `hidden`) return !0
  for (; node$1;) {
    if (upTo !== void 0 && node$1 === upTo) return !1
    if (getComputedStyle(node$1).display === `none`) return !0
    node$1 = node$1.parentElement
  }
  return !1
}
function isSelectableInput(element$2) {
  return element$2 instanceof HTMLInputElement && `select` in element$2
}
function focus(element$2, { select = !1 } = {}) {
  if (element$2 && element$2.focus) {
    let previouslyFocusedElement = document.activeElement
    element$2.focus({ preventScroll: !0 }),
      element$2 !== previouslyFocusedElement && isSelectableInput(element$2) && select && element$2.select()
  }
}
var focusScopesStack = createFocusScopesStack()
function createFocusScopesStack() {
  let stack = []
  return {
    add(focusScope) {
      let activeFocusScope = stack[0]
      focusScope !== activeFocusScope && activeFocusScope?.pause(),
        stack = arrayRemove(stack, focusScope),
        stack.unshift(focusScope)
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope), stack[0]?.resume()
    },
  }
}
function arrayRemove(array$3, item) {
  let updatedArray = [...array$3], index$4 = updatedArray.indexOf(item)
  return index$4 !== -1 && updatedArray.splice(index$4, 1), updatedArray
}
function removeLinks(items) {
  return items.filter(item => item.tagName !== `A`)
}
var import_react_dom$2 = __toESM(require_react_dom(), 1),
  PORTAL_NAME$3 = `Portal`,
  Portal = import_react.forwardRef((props, forwardedRef) => {
    let { container: containerProp, ...portalProps } = props, [mounted, setMounted] = import_react.useState(!1)
    useLayoutEffect2(() => setMounted(!0), [])
    let container = containerProp || mounted && globalThis?.document?.body
    return container
      ? import_react_dom$2.createPortal(
        (0, import_jsx_runtime.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }),
        container,
      )
      : null
  })
Portal.displayName = PORTAL_NAME$3
var count = 0
function useFocusGuards() {
  import_react.useEffect(() => {
    let edgeGuards = document.querySelectorAll(`[data-radix-focus-guard]`)
    return document.body.insertAdjacentElement(`afterbegin`, edgeGuards[0] ?? createFocusGuard()),
      document.body.insertAdjacentElement(`beforeend`, edgeGuards[1] ?? createFocusGuard()),
      count++,
      () => {
        count === 1 && document.querySelectorAll(`[data-radix-focus-guard]`).forEach(node$1 => node$1.remove()), count--
      }
  }, [])
}
function createFocusGuard() {
  let element$2 = document.createElement(`span`)
  return element$2.setAttribute(`data-radix-focus-guard`, ``),
    element$2.tabIndex = 0,
    element$2.style.outline = `none`,
    element$2.style.opacity = `0`,
    element$2.style.position = `fixed`,
    element$2.style.pointerEvents = `none`,
    element$2
}
var __assign = function() {
  return __assign = Object.assign || function(t$18) {
    for (var s$14, i$14 = 1, n$19 = arguments.length; i$14 < n$19; i$14++) {
      for (var p$25 in s$14 = arguments[i$14], s$14) {
        Object.prototype.hasOwnProperty.call(s$14, p$25) && (t$18[p$25] = s$14[p$25])
      }
    }
    return t$18
  },
    __assign.apply(this, arguments)
}
function __rest(s$14, e$26) {
  var t$18 = {}
  for (var p$25 in s$14) {
    Object.prototype.hasOwnProperty.call(s$14, p$25) && e$26.indexOf(p$25) < 0 && (t$18[p$25] = s$14[p$25])
  }
  if (s$14 != null && typeof Object.getOwnPropertySymbols == `function`) {
    for (var i$14 = 0, p$25 = Object.getOwnPropertySymbols(s$14); i$14 < p$25.length; i$14++) {
      e$26.indexOf(p$25[i$14]) < 0 && Object.prototype.propertyIsEnumerable.call(s$14, p$25[i$14])
        && (t$18[p$25[i$14]] = s$14[p$25[i$14]])
    }
  }
  return t$18
}
function __spreadArray(to, from, pack$1) {
  if (pack$1 || arguments.length === 2) {
    for (var i$14 = 0, l$9 = from.length, ar; i$14 < l$9; i$14++) {
      ;(ar || !(i$14 in from)) && (ar ||= Array.prototype.slice.call(from, 0, i$14), ar[i$14] = from[i$14])
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from))
}
var zeroRightClassName = `right-scroll-bar-position`,
  fullWidthClassName = `width-before-scroll-bar`,
  noScrollbarsClassName = `with-scroll-bars-hidden`,
  removedBarSizeVariable = `--removed-body-scroll-bar-size`
function assignRef(ref, value$2) {
  return typeof ref == `function` ? ref(value$2) : ref && (ref.current = value$2), ref
}
function useCallbackRef$1(initialValue, callback) {
  var ref = (0, import_react.useState)(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value
        },
        set current(value$2) {
          var last$3 = ref.value
          last$3 !== value$2 && (ref.value = value$2, ref.callback(value$2, last$3))
        },
      },
    }
  })[0]
  return ref.callback = callback, ref.facade
}
var useIsomorphicLayoutEffect = typeof window < `u` ? import_react.useLayoutEffect : import_react.useEffect,
  currentValues = new WeakMap()
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef$1(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue)
    })
  })
  return useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef)
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue), nextRefs_1 = new Set(refs), current_1 = callbackRef.current
      prevRefs_1.forEach(function(ref) {
        nextRefs_1.has(ref) || assignRef(ref, null)
      }),
        nextRefs_1.forEach(function(ref) {
          prevRefs_1.has(ref) || assignRef(ref, current_1)
        })
    }
    currentValues.set(callbackRef, refs)
  }, [refs]),
    callbackRef
}
function ItoI(a$22) {
  return a$22
}
function innerCreateMedium(defaults, middleware) {
  middleware === void 0 && (middleware = ItoI)
  var buffer = [],
    assigned = !1,
    medium = {
      read: function() {
        if (assigned) {
          throw Error(
            'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.',
          )
        }
        return buffer.length ? buffer[buffer.length - 1] : defaults
      },
      useMedium: function(data) {
        var item = middleware(data, assigned)
        return buffer.push(item), function() {
          buffer = buffer.filter(function(x$2) {
            return x$2 !== item
          })
        }
      },
      assignSyncMedium: function(cb) {
        for (assigned = !0; buffer.length;) {
          var cbs = buffer
          buffer = [], cbs.forEach(cb)
        }
        buffer = {
          push: function(x$2) {
            return cb(x$2)
          },
          filter: function() {
            return buffer
          },
        }
      },
      assignMedium: function(cb) {
        assigned = !0
        var pendingQueue = []
        if (buffer.length) {
          var cbs = buffer
          buffer = [], cbs.forEach(cb), pendingQueue = buffer
        }
        var executeQueue = function() {
            var cbs$1 = pendingQueue
            pendingQueue = [], cbs$1.forEach(cb)
          },
          cycle = function() {
            return Promise.resolve().then(executeQueue)
          }
        cycle(),
          buffer = {
            push: function(x$2) {
              pendingQueue.push(x$2), cycle()
            },
            filter: function(filter$9) {
              return pendingQueue = pendingQueue.filter(filter$9), buffer
            },
          }
      },
    }
  return medium
}
function createSidecarMedium(options$2) {
  options$2 === void 0 && (options$2 = {})
  var medium = innerCreateMedium(null)
  return medium.options = __assign({ async: !0, ssr: !1 }, options$2), medium
}
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, [`sideCar`])
  if (!sideCar) throw Error('Sidecar: please provide `sideCar` property to import the right car')
  var Target = sideCar.read()
  if (!Target) throw Error(`Sidecar medium not found`)
  return import_react.createElement(Target, __assign({}, rest))
}
SideCar.isSideCarExport = !0
function exportSidecar(medium, exported) {
  return medium.useMedium(exported), SideCar
}
var effectCar = createSidecarMedium(),
  nothing = function() {},
  RemoveScroll = import_react.forwardRef(function(props, parentRef) {
    var ref = import_react.useRef(null),
      _a = import_react.useState({ onScrollCapture: nothing, onWheelCapture: nothing, onTouchMoveCapture: nothing }),
      callbacks = _a[0],
      setCallbacks = _a[1],
      forwardProps = props.forwardProps,
      children$3 = props.children,
      className = props.className,
      removeScrollBar = props.removeScrollBar,
      enabled$1 = props.enabled,
      shards = props.shards,
      sideCar = props.sideCar,
      noRelative = props.noRelative,
      noIsolation = props.noIsolation,
      inert = props.inert,
      allowPinchZoom = props.allowPinchZoom,
      _b = props.as,
      Container = _b === void 0 ? `div` : _b,
      gapMode = props.gapMode,
      rest = __rest(props, [
        `forwardProps`,
        `children`,
        `className`,
        `removeScrollBar`,
        `enabled`,
        `shards`,
        `sideCar`,
        `noRelative`,
        `noIsolation`,
        `inert`,
        `allowPinchZoom`,
        `as`,
        `gapMode`,
      ]),
      SideCar$1 = sideCar,
      containerRef = useMergeRefs([ref, parentRef]),
      containerProps = __assign(__assign({}, rest), callbacks)
    return import_react.createElement(
      import_react.Fragment,
      null,
      enabled$1
        && import_react.createElement(SideCar$1, {
          sideCar: effectCar,
          removeScrollBar,
          shards,
          noRelative,
          noIsolation,
          inert,
          setCallbacks,
          allowPinchZoom: !!allowPinchZoom,
          lockRef: ref,
          gapMode,
        }),
      forwardProps
        ? import_react.cloneElement(
          import_react.Children.only(children$3),
          __assign(__assign({}, containerProps), { ref: containerRef }),
        )
        : import_react.createElement(
          Container,
          __assign({}, containerProps, { className, ref: containerRef }),
          children$3,
        ),
    )
  })
RemoveScroll.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 },
  RemoveScroll.classNames = { fullWidth: fullWidthClassName, zeroRight: zeroRightClassName }
var currentNonce,
  getNonce = function() {
    if (currentNonce) return currentNonce
    if (typeof __webpack_nonce__ < `u`) return __webpack_nonce__
  }
function makeStyleTag() {
  if (!document) return null
  var tag$3 = document.createElement(`style`)
  tag$3.type = `text/css`
  var nonce = getNonce()
  return nonce && tag$3.setAttribute(`nonce`, nonce), tag$3
}
function injectStyles(tag$3, css) {
  tag$3.styleSheet ? tag$3.styleSheet.cssText = css : tag$3.appendChild(document.createTextNode(css))
}
function insertStyleTag(tag$3) {
  var head$5 = document.head || document.getElementsByTagName(`head`)[0]
  head$5.appendChild(tag$3)
}
var stylesheetSingleton = function() {
    var counter$5 = 0, stylesheet = null
    return {
      add: function(style$1) {
        counter$5 == 0 && (stylesheet = makeStyleTag())
        && (injectStyles(stylesheet, style$1), insertStyleTag(stylesheet)), counter$5++
      },
      remove: function() {
        counter$5--,
          !counter$5 && stylesheet
          && (stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet), stylesheet = null)
      },
    }
  },
  styleHookSingleton = function() {
    var sheet = stylesheetSingleton()
    return function(styles, isDynamic) {
      import_react.useEffect(function() {
        return sheet.add(styles), function() {
          sheet.remove()
        }
      }, [styles && isDynamic])
    }
  },
  styleSingleton = function() {
    var useStyle = styleHookSingleton(),
      Sheet = function(_a) {
        var styles = _a.styles, dynamic = _a.dynamic
        return useStyle(styles, dynamic), null
      }
    return Sheet
  },
  zeroGap = { left: 0, top: 0, right: 0, gap: 0 },
  parse$1 = function(x$2) {
    return parseInt(x$2 || ``, 10) || 0
  },
  getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body),
      left$2 = cs[gapMode === `padding` ? `paddingLeft` : `marginLeft`],
      top = cs[gapMode === `padding` ? `paddingTop` : `marginTop`],
      right$2 = cs[gapMode === `padding` ? `paddingRight` : `marginRight`]
    return [parse$1(left$2), parse$1(top), parse$1(right$2)]
  },
  getGapWidth = function(gapMode) {
    if (gapMode === void 0 && (gapMode = `margin`), typeof window > `u`) return zeroGap
    var offsets = getOffset(gapMode),
      documentWidth = document.documentElement.clientWidth,
      windowWidth = window.innerWidth
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),
    }
  },
  Style = styleSingleton(),
  lockAttribute = `data-scroll-locked`,
  getStyles = function(_a, allowRelative, gapMode, important) {
    var left$2 = _a.left, top = _a.top, right$2 = _a.right, gap = _a.gap
    return gapMode === void 0 && (gapMode = `margin`),
      `
  .${noScrollbarsClassName} {
   overflow: hidden ${important};
   padding-right: ${gap}px ${important};
  }
  body[${lockAttribute}] {
    overflow: hidden ${important};
    overscroll-behavior: contain;
    ${
        [
          allowRelative && `position: relative ${important};`,
          gapMode === `margin` && `
    padding-left: ${left$2}px;
    padding-top: ${top}px;
    padding-right: ${right$2}px;
    margin-left:0;
    margin-top:0;
    margin-right: ${gap}px ${important};
    `,
          gapMode === `padding` && `padding-right: ${gap}px ${important};`,
        ].filter(Boolean).join(``)
      }
  }
  
  .${zeroRightClassName} {
    right: ${gap}px ${important};
  }
  
  .${fullWidthClassName} {
    margin-right: ${gap}px ${important};
  }
  
  .${zeroRightClassName} .${zeroRightClassName} {
    right: 0 ${important};
  }
  
  .${fullWidthClassName} .${fullWidthClassName} {
    margin-right: 0 ${important};
  }
  
  body[${lockAttribute}] {
    ${removedBarSizeVariable}: ${gap}px;
  }
`
  },
  getCurrentUseCounter = function() {
    var counter$5 = parseInt(document.body.getAttribute(lockAttribute) || `0`, 10)
    return isFinite(counter$5) ? counter$5 : 0
  },
  useLockAttribute = function() {
    import_react.useEffect(function() {
      return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
        var newCounter = getCurrentUseCounter() - 1
        newCounter <= 0
          ? document.body.removeAttribute(lockAttribute)
          : document.body.setAttribute(lockAttribute, newCounter.toString())
      }
    }, [])
  },
  RemoveScrollBar = function(_a) {
    var noRelative = _a.noRelative,
      noImportant = _a.noImportant,
      _b = _a.gapMode,
      gapMode = _b === void 0 ? `margin` : _b
    useLockAttribute()
    var gap = import_react.useMemo(function() {
      return getGapWidth(gapMode)
    }, [gapMode])
    return import_react.createElement(Style, {
      styles: getStyles(gap, !noRelative, gapMode, noImportant ? `` : `!important`),
    })
  },
  passiveSupported = !1
if (typeof window < `u`) {
  try {
    var options = Object.defineProperty({}, `passive`, {
      get: function() {
        return passiveSupported = !0, !0
      },
    })
    window.addEventListener(`test`, options, options), window.removeEventListener(`test`, options, options)
  } catch {
    passiveSupported = !1
  }
}
var nonPassive = passiveSupported ? { passive: !1 } : !1,
  alwaysContainsScroll = function(node$1) {
    return node$1.tagName === `TEXTAREA`
  },
  elementCanBeScrolled = function(node$1, overflow) {
    if (!(node$1 instanceof Element)) return !1
    var styles = window.getComputedStyle(node$1)
    return styles[overflow] !== `hidden`
      && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node$1) && styles[overflow] === `visible`)
  },
  elementCouldBeVScrolled = function(node$1) {
    return elementCanBeScrolled(node$1, `overflowY`)
  },
  elementCouldBeHScrolled = function(node$1) {
    return elementCanBeScrolled(node$1, `overflowX`)
  },
  locationCouldBeScrolled = function(axis, node$1) {
    var ownerDocument = node$1.ownerDocument, current = node$1
    do {
      typeof ShadowRoot < `u` && current instanceof ShadowRoot && (current = current.host)
      var isScrollable = elementCouldBeScrolled(axis, current)
      if (isScrollable) {
        var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2]
        if (scrollHeight > clientHeight) return !0
      }
      current = current.parentNode
    } while (current && current !== ownerDocument.body)
    return !1
  },
  getVScrollVariables = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight
    return [scrollTop, scrollHeight, clientHeight]
  },
  getHScrollVariables = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth
    return [scrollLeft, scrollWidth, clientWidth]
  },
  elementCouldBeScrolled = function(axis, node$1) {
    return axis === `v` ? elementCouldBeVScrolled(node$1) : elementCouldBeHScrolled(node$1)
  },
  getScrollVariables = function(axis, node$1) {
    return axis === `v` ? getVScrollVariables(node$1) : getHScrollVariables(node$1)
  },
  getDirectionFactor = function(axis, direction) {
    return axis === `h` && direction === `rtl` ? -1 : 1
  },
  handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction),
      delta = directionFactor * sourceDelta,
      target = event.target,
      targetInLock = endTarget.contains(target),
      shouldCancelScroll = !1,
      isDeltaPositive = delta > 0,
      availableScroll = 0,
      availableScrollTop = 0
    do {
      if (!target) break
      var _a = getScrollVariables(axis, target),
        position$2 = _a[0],
        scroll_1 = _a[1],
        capacity = _a[2],
        elementScroll = scroll_1 - capacity - directionFactor * position$2
      ;(position$2 || elementScroll) && elementCouldBeScrolled(axis, target)
        && (availableScroll += elementScroll, availableScrollTop += position$2)
      var parent_1 = target.parentNode
      target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1
    } while (
      !targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target)
    )
    return (isDeltaPositive
        && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)
      || !isDeltaPositive
        && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop))
      && (shouldCancelScroll = !0),
      shouldCancelScroll
  },
  getTouchXY = function(event) {
    return `changedTouches` in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0]
  },
  getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY]
  },
  extractRef = function(ref) {
    return ref && `current` in ref ? ref.current : ref
  },
  deltaCompare = function(x$2, y$3) {
    return x$2[0] === y$3[0] && x$2[1] === y$3[1]
  },
  generateStyle = function(id$2) {
    return `
  .block-interactivity-${id$2} {pointer-events: none;}
  .allow-interactivity-${id$2} {pointer-events: all;}
`
  },
  idCounter = 0,
  lockStack = []
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = import_react.useRef([]),
    touchStartRef = import_react.useRef([0, 0]),
    activeAxis = import_react.useRef(),
    id$2 = import_react.useState(idCounter++)[0],
    Style$1 = import_react.useState(styleSingleton)[0],
    lastProps = import_react.useRef(props)
  import_react.useEffect(function() {
    lastProps.current = props
  }, [props]),
    import_react.useEffect(function() {
      if (props.inert) {
        document.body.classList.add(`block-interactivity-${id$2}`)
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), !0).filter(Boolean)
        return allow_1.forEach(function(el) {
          return el.classList.add(`allow-interactivity-${id$2}`)
        }),
          function() {
            document.body.classList.remove(`block-interactivity-${id$2}`),
              allow_1.forEach(function(el) {
                return el.classList.remove(`allow-interactivity-${id$2}`)
              })
          }
      }
    }, [props.inert, props.lockRef.current, props.shards])
  var shouldCancelEvent = import_react.useCallback(function(event, parent) {
      if (`touches` in event && event.touches.length === 2 || event.type === `wheel` && event.ctrlKey) {
        return !lastProps.current.allowPinchZoom
      }
      var touch = getTouchXY(event),
        touchStart = touchStartRef.current,
        deltaX = `deltaX` in event ? event.deltaX : touchStart[0] - touch[0],
        deltaY = `deltaY` in event ? event.deltaY : touchStart[1] - touch[1],
        currentAxis,
        target = event.target,
        moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? `h` : `v`
      if (`touches` in event && moveDirection === `h` && target.type === `range`) return !1
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)
      if (!canBeScrolledInMainDirection) return !0
      if (
        canBeScrolledInMainDirection
          ? currentAxis = moveDirection
          : (currentAxis = moveDirection === `v` ? `h` : `v`,
            canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)),
          !canBeScrolledInMainDirection
      ) return !1
      if (
        !activeAxis.current && `changedTouches` in event && (deltaX || deltaY) && (activeAxis.current = currentAxis),
          !currentAxis
      ) return !0
      var cancelingAxis = activeAxis.current || currentAxis
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === `h` ? deltaX : deltaY, !0)
    }, []),
    shouldPrevent = import_react.useCallback(function(_event) {
      var event = _event
      if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Style$1)) {
        var delta = `deltaY` in event ? getDeltaXY(event) : getTouchXY(event),
          sourceEvent = shouldPreventQueue.current.filter(function(e$26) {
            return e$26.name === event.type && (e$26.target === event.target || event.target === e$26.shadowParent)
              && deltaCompare(e$26.delta, delta)
          })[0]
        if (sourceEvent && sourceEvent.should) {
          event.cancelable && event.preventDefault()
          return
        }
        if (!sourceEvent) {
          var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node$1) {
              return node$1.contains(event.target)
            }),
            shouldStop = shardNodes.length > 0
              ? shouldCancelEvent(event, shardNodes[0])
              : !lastProps.current.noIsolation
          shouldStop && event.cancelable && event.preventDefault()
        }
      }
    }, []),
    shouldCancel = import_react.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) }
      shouldPreventQueue.current.push(event),
        setTimeout(function() {
          shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e$26) {
            return e$26 !== event
          })
        }, 1)
    }, []),
    scrollTouchStart = import_react.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event), activeAxis.current = void 0
    }, []),
    scrollWheel = import_react.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current))
    }, []),
    scrollTouchMove = import_react.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current))
    }, [])
  import_react.useEffect(function() {
    return lockStack.push(Style$1),
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove,
      }),
      document.addEventListener(`wheel`, shouldPrevent, nonPassive),
      document.addEventListener(`touchmove`, shouldPrevent, nonPassive),
      document.addEventListener(`touchstart`, scrollTouchStart, nonPassive),
      function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style$1
        }),
          document.removeEventListener(`wheel`, shouldPrevent, nonPassive),
          document.removeEventListener(`touchmove`, shouldPrevent, nonPassive),
          document.removeEventListener(`touchstart`, scrollTouchStart, nonPassive)
      }
  }, [])
  var removeScrollBar = props.removeScrollBar, inert = props.inert
  return import_react.createElement(
    import_react.Fragment,
    null,
    inert ? import_react.createElement(Style$1, { styles: generateStyle(id$2) }) : null,
    removeScrollBar
      ? import_react.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode })
      : null,
  )
}
function getOutermostShadowParent(node$1) {
  for (var shadowParent = null; node$1 !== null;) {
    node$1 instanceof ShadowRoot && (shadowParent = node$1.host, node$1 = node$1.host), node$1 = node$1.parentNode
  }
  return shadowParent
}
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar),
  ReactRemoveScroll = import_react.forwardRef(function(props, ref) {
    return import_react.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }))
  })
ReactRemoveScroll.classNames = RemoveScroll.classNames
var Combination_default = ReactRemoveScroll,
  getDefaultParent = function(originalTarget) {
    if (typeof document > `u`) return null
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget
    return sampleTarget.ownerDocument.body
  },
  counterMap = new WeakMap(),
  uncontrolledNodes = new WeakMap(),
  markerMap = {},
  lockCount = 0,
  unwrapHost = function(node$1) {
    return node$1 && (node$1.host || unwrapHost(node$1.parentNode))
  },
  correctTargets = function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target)) return target
      var correctedTarget = unwrapHost(target)
      return correctedTarget && parent.contains(correctedTarget)
        ? correctedTarget
        : (console.error(`aria-hidden`, target, `in not contained inside`, parent, `. Doing nothing`), null)
    }).filter(function(x$2) {
      return !!x$2
    })
  },
  applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget])
    markerMap[markerName] || (markerMap[markerName] = new WeakMap())
    var markerCounter = markerMap[markerName],
      hiddenNodes = [],
      elementsToKeep = new Set(),
      elementsToStop = new Set(targets),
      keep = function(el) {
        !el || elementsToKeep.has(el) || (elementsToKeep.add(el), keep(el.parentNode))
      }
    targets.forEach(keep)
    var deep = function(parent) {
      !parent || elementsToStop.has(parent) || Array.prototype.forEach.call(parent.children, function(node$1) {
        if (elementsToKeep.has(node$1)) deep(node$1)
        else {try {
            var attr = node$1.getAttribute(controlAttribute),
              alreadyHidden = attr !== null && attr !== `false`,
              counterValue = (counterMap.get(node$1) || 0) + 1,
              markerValue = (markerCounter.get(node$1) || 0) + 1
            counterMap.set(node$1, counterValue),
              markerCounter.set(node$1, markerValue),
              hiddenNodes.push(node$1),
              counterValue === 1 && alreadyHidden && uncontrolledNodes.set(node$1, !0),
              markerValue === 1 && node$1.setAttribute(markerName, `true`),
              alreadyHidden || node$1.setAttribute(controlAttribute, `true`)
          } catch (e$26) {
            console.error(`aria-hidden: cannot operate on `, node$1, e$26)
          }}
      })
    }
    return deep(parentNode), elementsToKeep.clear(), lockCount++, function() {
      hiddenNodes.forEach(function(node$1) {
        var counterValue = counterMap.get(node$1) - 1, markerValue = markerCounter.get(node$1) - 1
        counterMap.set(node$1, counterValue),
          markerCounter.set(node$1, markerValue),
          counterValue
          || (uncontrolledNodes.has(node$1) || node$1.removeAttribute(controlAttribute),
            uncontrolledNodes.delete(node$1)),
          markerValue || node$1.removeAttribute(markerName)
      }),
        lockCount--,
        lockCount
        || (counterMap = new WeakMap(), counterMap = new WeakMap(), uncontrolledNodes = new WeakMap(), markerMap = {})
    }
  },
  hideOthers = function(originalTarget, parentNode, markerName) {
    markerName === void 0 && (markerName = `data-aria-hidden`)
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]),
      activeParentNode = parentNode || getDefaultParent(originalTarget)
    return activeParentNode
      ? (targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll(`[aria-live], script`))),
        applyAttributeToOthers(targets, activeParentNode, markerName, `aria-hidden`))
      : function() {
        return null
      }
  }
function usePrevious(value$2) {
  let ref = import_react.useRef({ value: value$2, previous: value$2 })
  return import_react.useMemo(
    () => (ref.current.value !== value$2 && (ref.current.previous = ref.current.value, ref.current.value = value$2),
      ref.current.previous),
    [value$2],
  )
}
function useSize(element$2) {
  let [size$14, setSize] = import_react.useState(void 0)
  return useLayoutEffect2(() => {
    if (element$2) {
      setSize({ width: element$2.offsetWidth, height: element$2.offsetHeight })
      let resizeObserver = new ResizeObserver(entries$2 => {
        if (!Array.isArray(entries$2) || !entries$2.length) return
        let entry = entries$2[0], width, height
        if (`borderBoxSize` in entry) {
          let borderSizeEntry = entry.borderBoxSize,
            borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry
          width = borderSize.inlineSize, height = borderSize.blockSize
        } else width = element$2.offsetWidth, height = element$2.offsetHeight
        setSize({ width, height })
      })
      return resizeObserver.observe(element$2, { box: `border-box` }), () => resizeObserver.unobserve(element$2)
    } else setSize(void 0)
  }, [element$2]),
    size$14
}
const sides = [`top`, `right`, `bottom`, `left`],
  min = Math.min,
  max = Math.max,
  round = Math.round,
  floor = Math.floor,
  createCoords = v$4 => ({ x: v$4, y: v$4 }),
  oppositeSideMap = { left: `right`, right: `left`, bottom: `top`, top: `bottom` },
  oppositeAlignmentMap = { start: `end`, end: `start` }
function clamp$1(start$2, value$2, end$2) {
  return max(start$2, min(value$2, end$2))
}
function evaluate(value$2, param) {
  return typeof value$2 == `function` ? value$2(param) : value$2
}
function getSide(placement) {
  return placement.split(`-`)[0]
}
function getAlignment(placement) {
  return placement.split(`-`)[1]
}
function getOppositeAxis(axis) {
  return axis === `x` ? `y` : `x`
}
function getAxisLength(axis) {
  return axis === `y` ? `height` : `width`
}
const yAxisSides = new Set([`top`, `bottom`])
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? `y` : `x`
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement))
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1)
  let alignment = getAlignment(placement),
    alignmentAxis = getAlignmentAxis(placement),
    length$1 = getAxisLength(alignmentAxis),
    mainAlignmentSide = alignmentAxis === `x`
      ? alignment === (rtl ? `end` : `start`) ? `right` : `left`
      : alignment === `start`
      ? `bottom`
      : `top`
  return rects.reference[length$1] > rects.floating[length$1]
    && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)),
    [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)]
}
function getExpandedPlacements(placement) {
  let oppositePlacement = getOppositePlacement(placement)
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)]
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment])
}
const lrPlacement = [`left`, `right`],
  rlPlacement = [`right`, `left`],
  tbPlacement = [`top`, `bottom`],
  btPlacement = [`bottom`, `top`]
function getSideList(side, isStart, rtl) {
  switch (side) {
    case `top`:
    case `bottom`:
      return rtl ? isStart ? rlPlacement : lrPlacement : isStart ? lrPlacement : rlPlacement
    case `left`:
    case `right`:
      return isStart ? tbPlacement : btPlacement
    default:
      return []
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  let alignment = getAlignment(placement), list$3 = getSideList(getSide(placement), direction === `start`, rtl)
  return alignment
    && (list$3 = list$3.map(side => side + `-` + alignment),
      flipAlignment && (list$3 = list$3.concat(list$3.map(getOppositeAlignmentPlacement)))),
    list$3
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side])
}
function expandPaddingObject(padding) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...padding }
}
function getPaddingObject(padding) {
  return typeof padding == `number`
    ? { top: padding, right: padding, bottom: padding, left: padding }
    : expandPaddingObject(padding)
}
function rectToClientRect(rect) {
  let { x: x$2, y: y$3, width, height } = rect
  return { width, height, top: y$3, left: x$2, right: x$2 + width, bottom: y$3 + height, x: x$2, y: y$3 }
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let { reference: reference$1, floating } = _ref,
    sideAxis = getSideAxis(placement),
    alignmentAxis = getAlignmentAxis(placement),
    alignLength = getAxisLength(alignmentAxis),
    side = getSide(placement),
    isVertical = sideAxis === `y`,
    commonX = reference$1.x + reference$1.width / 2 - floating.width / 2,
    commonY = reference$1.y + reference$1.height / 2 - floating.height / 2,
    commonAlign = reference$1[alignLength] / 2 - floating[alignLength] / 2,
    coords
  switch (side) {
    case `top`:
      coords = { x: commonX, y: reference$1.y - floating.height }
      break
    case `bottom`:
      coords = { x: commonX, y: reference$1.y + reference$1.height }
      break
    case `right`:
      coords = { x: reference$1.x + reference$1.width, y: commonY }
      break
    case `left`:
      coords = { x: reference$1.x - floating.width, y: commonY }
      break
    default:
      coords = { x: reference$1.x, y: reference$1.y }
  }
  switch (getAlignment(placement)) {
    case `start`:
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1)
      break
    case `end`:
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1)
      break
  }
  return coords
}
const computePosition$1 = async (reference$1, floating, config) => {
  let { placement = `bottom`, strategy = `absolute`, middleware = [], platform: platform$1 } = config,
    validMiddleware = middleware.filter(Boolean),
    rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(floating)),
    rects = await platform$1.getElementRects({ reference: reference$1, floating, strategy }),
    { x: x$2, y: y$3 } = computeCoordsFromPlacement(rects, placement, rtl),
    statefulPlacement = placement,
    middlewareData = {},
    resetCount = 0
  for (let i$14 = 0; i$14 < validMiddleware.length; i$14++) {
    let { name, fn } = validMiddleware[i$14],
      { x: nextX, y: nextY, data, reset } = await fn({
        x: x$2,
        y: y$3,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform$1,
        elements: { reference: reference$1, floating },
      })
    x$2 = nextX ?? x$2,
      y$3 = nextY ?? y$3,
      middlewareData = { ...middlewareData, [name]: { ...middlewareData[name], ...data } },
      reset && resetCount <= 50
      && (resetCount++,
        typeof reset == `object` && (reset.placement && (statefulPlacement = reset.placement),
          reset.rects
          && (rects = reset.rects === !0
            ? await platform$1.getElementRects({ reference: reference$1, floating, strategy })
            : reset.rects),
          { x: x$2, y: y$3 } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)),
        i$14 = -1)
  }
  return { x: x$2, y: y$3, placement: statefulPlacement, strategy, middlewareData }
}
async function detectOverflow$1(state, options$2) {
  var _await$platform$isEle
  options$2 === void 0 && (options$2 = {})
  let { x: x$2, y: y$3, platform: platform$1, rects, elements, strategy } = state,
    {
      boundary = `clippingAncestors`,
      rootBoundary = `viewport`,
      elementContext = `floating`,
      altBoundary = !1,
      padding = 0,
    } = evaluate(options$2, state),
    paddingObject = getPaddingObject(padding),
    altContext = elementContext === `floating` ? `reference` : `floating`,
    element$2 = elements[altBoundary ? altContext : elementContext],
    clippingClientRect = rectToClientRect(
      await platform$1.getClippingRect({
        element:
          (_await$platform$isEle = await (platform$1.isElement == null ? void 0 : platform$1.isElement(element$2)))
              ?? !0
            ? element$2
            : element$2.contextElement || await (platform$1.getDocumentElement == null
              ? void 0
              : platform$1.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy,
      }),
    ),
    rect = elementContext === `floating`
      ? { x: x$2, y: y$3, width: rects.floating.width, height: rects.floating.height }
      : rects.reference,
    offsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(elements.floating)),
    offsetScale = await (platform$1.isElement == null ? void 0 : platform$1.isElement(offsetParent))
        && await (platform$1.getScale == null ? void 0 : platform$1.getScale(offsetParent)) || { x: 1, y: 1 },
    elementClientRect = rectToClientRect(
      platform$1.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await platform$1.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements,
          rect,
          offsetParent,
          strategy,
        })
        : rect,
    )
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x,
  }
}
const arrow$2 = options$2 => ({
    name: `arrow`,
    options: options$2,
    async fn(state) {
      let { x: x$2, y: y$3, placement, rects, platform: platform$1, elements, middlewareData } = state,
        { element: element$2, padding = 0 } = evaluate(options$2, state) || {}
      if (element$2 == null) return {}
      let paddingObject = getPaddingObject(padding),
        coords = { x: x$2, y: y$3 },
        axis = getAlignmentAxis(placement),
        length$1 = getAxisLength(axis),
        arrowDimensions = await platform$1.getDimensions(element$2),
        isYAxis = axis === `y`,
        minProp = isYAxis ? `top` : `left`,
        maxProp = isYAxis ? `bottom` : `right`,
        clientProp = isYAxis ? `clientHeight` : `clientWidth`,
        endDiff = rects.reference[length$1] + rects.reference[axis] - coords[axis] - rects.floating[length$1],
        startDiff = coords[axis] - rects.reference[axis],
        arrowOffsetParent = await (platform$1.getOffsetParent == null ? void 0 : platform$1.getOffsetParent(element$2)),
        clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0
      ;(!clientSize || !await (platform$1.isElement == null ? void 0 : platform$1.isElement(arrowOffsetParent)))
        && (clientSize = elements.floating[clientProp] || rects.floating[length$1])
      let centerToReference = endDiff / 2 - startDiff / 2,
        largestPossiblePadding = clientSize / 2 - arrowDimensions[length$1] / 2 - 1,
        minPadding = min(paddingObject[minProp], largestPossiblePadding),
        maxPadding = min(paddingObject[maxProp], largestPossiblePadding),
        min$1$1 = minPadding,
        max$12 = clientSize - arrowDimensions[length$1] - maxPadding,
        center = clientSize / 2 - arrowDimensions[length$1] / 2 + centerToReference,
        offset$3 = clamp$1(min$1$1, center, max$12),
        shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset$3
          && rects.reference[length$1] / 2 - (center < min$1$1 ? minPadding : maxPadding)
                - arrowDimensions[length$1] / 2 < 0,
        alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max$12 : 0
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset$3,
          centerOffset: center - offset$3 - alignmentOffset,
          ...shouldAddOffset && { alignmentOffset },
        },
        reset: shouldAddOffset,
      }
    },
  }),
  flip$2 = function(options$2) {
    return options$2 === void 0 && (options$2 = {}), {
      name: `flip`,
      options: options$2,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip
        let { placement, middlewareData, rects, initialPlacement, platform: platform$1, elements } = state,
          {
            mainAxis: checkMainAxis = !0,
            crossAxis: checkCrossAxis = !0,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = `bestFit`,
            fallbackAxisSideDirection = `none`,
            flipAlignment = !0,
            ...detectOverflowOptions
          } = evaluate(options$2, state)
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) return {}
        let side = getSide(placement),
          initialSideAxis = getSideAxis(initialPlacement),
          isBasePlacement = getSide(initialPlacement) === initialPlacement,
          rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating)),
          fallbackPlacements = specifiedFallbackPlacements
            || (isBasePlacement || !flipAlignment
              ? [getOppositePlacement(initialPlacement)]
              : getExpandedPlacements(initialPlacement)),
          hasFallbackAxisSideDirection = fallbackAxisSideDirection !== `none`
        !specifiedFallbackPlacements && hasFallbackAxisSideDirection
          && fallbackPlacements.push(
            ...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl),
          )
        let placements$1 = [initialPlacement, ...fallbackPlacements],
          overflow = await detectOverflow$1(state, detectOverflowOptions),
          overflows = [],
          overflowsData = (_middlewareData$flip = middlewareData.flip)?.overflows || []
        if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
          let sides$1 = getAlignmentSides(placement, rects, rtl)
          overflows.push(overflow[sides$1[0]], overflow[sides$1[1]])
        }
        if (overflowsData = [...overflowsData, { placement, overflows }], !overflows.every(side$1 => side$1 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter
          let nextIndex = ((_middlewareData$flip2 = middlewareData.flip)?.index || 0) + 1,
            nextPlacement = placements$1[nextIndex]
          if (nextPlacement) {
            let ignoreCrossAxisOverflow = checkCrossAxis === `alignment`
              ? initialSideAxis !== getSideAxis(nextPlacement)
              : !1
            if (
              !ignoreCrossAxisOverflow
              || overflowsData.every(d$7 => d$7.overflows[0] > 0 && getSideAxis(d$7.placement) === initialSideAxis)
            ) return { data: { index: nextIndex, overflows: overflowsData }, reset: { placement: nextPlacement } }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter(d$7 =>
            d$7.overflows[0] <= 0
          ).sort((a$22, b$3) =>
            a$22.overflows[1] - b$3.overflows[1]
          )[0])?.placement
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case `bestFit`: {
                var _overflowsData$filter2
                let placement$1 = (_overflowsData$filter2 = overflowsData.filter(d$7 => {
                  if (hasFallbackAxisSideDirection) {
                    let currentSideAxis = getSideAxis(d$7.placement)
                    return currentSideAxis === initialSideAxis || currentSideAxis === `y`
                  }
                  return !0
                }).map(d$7 => [
                  d$7.placement,
                  d$7.overflows.filter(overflow$1 => overflow$1 > 0).reduce((acc, overflow$1) => acc + overflow$1, 0),
                ]).sort((a$22, b$3) => a$22[1] - b$3[1])[0])?.[0]
                placement$1 && (resetPlacement = placement$1)
                break
              }
              case `initialPlacement`:
                resetPlacement = initialPlacement
                break
            }
          }
          if (placement !== resetPlacement) return { reset: { placement: resetPlacement } }
        }
        return {}
      },
    }
  }
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width,
  }
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0)
}
const hide$2 = function(options$2) {
    return options$2 === void 0 && (options$2 = {}), {
      name: `hide`,
      options: options$2,
      async fn(state) {
        let { rects } = state, { strategy = `referenceHidden`, ...detectOverflowOptions } = evaluate(options$2, state)
        switch (strategy) {
          case `referenceHidden`: {
            let overflow = await detectOverflow$1(state, { ...detectOverflowOptions, elementContext: `reference` }),
              offsets = getSideOffsets(overflow, rects.reference)
            return { data: { referenceHiddenOffsets: offsets, referenceHidden: isAnySideFullyClipped(offsets) } }
          }
          case `escaped`: {
            let overflow = await detectOverflow$1(state, { ...detectOverflowOptions, altBoundary: !0 }),
              offsets = getSideOffsets(overflow, rects.floating)
            return { data: { escapedOffsets: offsets, escaped: isAnySideFullyClipped(offsets) } }
          }
          default:
            return {}
        }
      },
    }
  },
  originSides = new Set([`left`, `top`])
async function convertValueToCoords(state, options$2) {
  let { placement, platform: platform$1, elements } = state,
    rtl = await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating)),
    side = getSide(placement),
    alignment = getAlignment(placement),
    isVertical = getSideAxis(placement) === `y`,
    mainAxisMulti = originSides.has(side) ? -1 : 1,
    crossAxisMulti = rtl && isVertical ? -1 : 1,
    rawValue = evaluate(options$2, state),
    { mainAxis, crossAxis, alignmentAxis } = typeof rawValue == `number`
      ? { mainAxis: rawValue, crossAxis: 0, alignmentAxis: null }
      : { mainAxis: rawValue.mainAxis || 0, crossAxis: rawValue.crossAxis || 0, alignmentAxis: rawValue.alignmentAxis }
  return alignment && typeof alignmentAxis == `number`
    && (crossAxis = alignment === `end` ? alignmentAxis * -1 : alignmentAxis),
    isVertical
      ? { x: crossAxis * crossAxisMulti, y: mainAxis * mainAxisMulti }
      : { x: mainAxis * mainAxisMulti, y: crossAxis * crossAxisMulti }
}
const offset$2 = function(options$2) {
    return options$2 === void 0 && (options$2 = 0), {
      name: `offset`,
      options: options$2,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow
        let { x: x$2, y: y$3, placement, middlewareData } = state,
          diffCoords = await convertValueToCoords(state, options$2)
        return placement === (_middlewareData$offse = middlewareData.offset)?.placement
            && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset
          ? {}
          : { x: x$2 + diffCoords.x, y: y$3 + diffCoords.y, data: { ...diffCoords, placement } }
      },
    }
  },
  shift$2 = function(options$2) {
    return options$2 === void 0 && (options$2 = {}), {
      name: `shift`,
      options: options$2,
      async fn(state) {
        let { x: x$2, y: y$3, placement } = state,
          {
            mainAxis: checkMainAxis = !0,
            crossAxis: checkCrossAxis = !1,
            limiter = {
              fn: _ref => {
                let { x: x$3, y: y$4 } = _ref
                return { x: x$3, y: y$4 }
              },
            },
            ...detectOverflowOptions
          } = evaluate(options$2, state),
          coords = { x: x$2, y: y$3 },
          overflow = await detectOverflow$1(state, detectOverflowOptions),
          crossAxis = getSideAxis(getSide(placement)),
          mainAxis = getOppositeAxis(crossAxis),
          mainAxisCoord = coords[mainAxis],
          crossAxisCoord = coords[crossAxis]
        if (checkMainAxis) {
          let minSide = mainAxis === `y` ? `top` : `left`,
            maxSide = mainAxis === `y` ? `bottom` : `right`,
            min$10 = mainAxisCoord + overflow[minSide],
            max$12 = mainAxisCoord - overflow[maxSide]
          mainAxisCoord = clamp$1(min$10, mainAxisCoord, max$12)
        }
        if (checkCrossAxis) {
          let minSide = crossAxis === `y` ? `top` : `left`,
            maxSide = crossAxis === `y` ? `bottom` : `right`,
            min$10 = crossAxisCoord + overflow[minSide],
            max$12 = crossAxisCoord - overflow[maxSide]
          crossAxisCoord = clamp$1(min$10, crossAxisCoord, max$12)
        }
        let limitedCoords = limiter.fn({ ...state, [mainAxis]: mainAxisCoord, [crossAxis]: crossAxisCoord })
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x$2,
            y: limitedCoords.y - y$3,
            enabled: { [mainAxis]: checkMainAxis, [crossAxis]: checkCrossAxis },
          },
        }
      },
    }
  },
  limitShift$2 = function(options$2) {
    return options$2 === void 0 && (options$2 = {}), {
      options: options$2,
      fn(state) {
        let { x: x$2, y: y$3, placement, rects, middlewareData } = state,
          { offset: offset$3 = 0, mainAxis: checkMainAxis = !0, crossAxis: checkCrossAxis = !0 } = evaluate(
            options$2,
            state,
          ),
          coords = { x: x$2, y: y$3 },
          crossAxis = getSideAxis(placement),
          mainAxis = getOppositeAxis(crossAxis),
          mainAxisCoord = coords[mainAxis],
          crossAxisCoord = coords[crossAxis],
          rawOffset = evaluate(offset$3, state),
          computedOffset = typeof rawOffset == `number`
            ? { mainAxis: rawOffset, crossAxis: 0 }
            : { mainAxis: 0, crossAxis: 0, ...rawOffset }
        if (checkMainAxis) {
          let len = mainAxis === `y` ? `height` : `width`,
            limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis,
            limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis
          mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax)
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2
          let len = mainAxis === `y` ? `width` : `height`,
            isOriginSide = originSides.has(getSide(placement)),
            limitMin = rects.reference[crossAxis] - rects.floating[len]
              + (isOriginSide && (_middlewareData$offse = middlewareData.offset)?.[crossAxis] || 0)
              + (isOriginSide ? 0 : computedOffset.crossAxis),
            limitMax = rects.reference[crossAxis] + rects.reference[len]
              + (isOriginSide ? 0 : (_middlewareData$offse2 = middlewareData.offset)?.[crossAxis] || 0)
              - (isOriginSide ? computedOffset.crossAxis : 0)
          crossAxisCoord < limitMin
            ? crossAxisCoord = limitMin
            : crossAxisCoord > limitMax && (crossAxisCoord = limitMax)
        }
        return { [mainAxis]: mainAxisCoord, [crossAxis]: crossAxisCoord }
      },
    }
  },
  size$2 = function(options$2) {
    return options$2 === void 0 && (options$2 = {}), {
      name: `size`,
      options: options$2,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2
        let { placement, rects, platform: platform$1, elements } = state,
          { apply = () => {}, ...detectOverflowOptions } = evaluate(options$2, state),
          overflow = await detectOverflow$1(state, detectOverflowOptions),
          side = getSide(placement),
          alignment = getAlignment(placement),
          isYAxis = getSideAxis(placement) === `y`,
          { width, height } = rects.floating,
          heightSide,
          widthSide
        side === `top` || side === `bottom`
          ? (heightSide = side,
            widthSide = alignment === (await (platform$1.isRTL == null ? void 0 : platform$1.isRTL(elements.floating))
                ? `start`
                : `end`)
              ? `left`
              : `right`)
          : (widthSide = side, heightSide = alignment === `end` ? `top` : `bottom`)
        let maximumClippingHeight = height - overflow.top - overflow.bottom,
          maximumClippingWidth = width - overflow.left - overflow.right,
          overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight),
          overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth),
          noShift = !state.middlewareData.shift,
          availableHeight = overflowAvailableHeight,
          availableWidth = overflowAvailableWidth
        if (
          (_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x
          && (availableWidth = maximumClippingWidth),
            (_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y
            && (availableHeight = maximumClippingHeight),
            noShift && !alignment
        ) {
          let xMin = max(overflow.left, 0),
            xMax = max(overflow.right, 0),
            yMin = max(overflow.top, 0),
            yMax = max(overflow.bottom, 0)
          isYAxis
            ? availableWidth = width
              - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right))
            : availableHeight = height
              - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom))
        }
        await apply({ ...state, availableWidth, availableHeight })
        let nextDimensions = await platform$1.getDimensions(elements.floating)
        return width !== nextDimensions.width || height !== nextDimensions.height ? { reset: { rects: !0 } } : {}
      },
    }
  }
function hasWindow() {
  return typeof window < `u`
}
function getNodeName(node$1) {
  return isNode(node$1) ? (node$1.nodeName || ``).toLowerCase() : `#document`
}
function getWindow(node$1) {
  var _node$ownerDocument
  return (node$1 == null || (_node$ownerDocument = node$1.ownerDocument) == null
    ? void 0
    : _node$ownerDocument.defaultView) || window
}
function getDocumentElement(node$1) {
  var _ref
  return (_ref = (isNode(node$1) ? node$1.ownerDocument : node$1.document) || window.document)?.documentElement
}
function isNode(value$2) {
  return hasWindow() ? value$2 instanceof Node || value$2 instanceof getWindow(value$2).Node : !1
}
function isElement(value$2) {
  return hasWindow() ? value$2 instanceof Element || value$2 instanceof getWindow(value$2).Element : !1
}
function isHTMLElement(value$2) {
  return hasWindow() ? value$2 instanceof HTMLElement || value$2 instanceof getWindow(value$2).HTMLElement : !1
}
function isShadowRoot(value$2) {
  return !hasWindow() || typeof ShadowRoot > `u`
    ? !1
    : value$2 instanceof ShadowRoot || value$2 instanceof getWindow(value$2).ShadowRoot
}
const invalidOverflowDisplayValues = new Set([`inline`, `contents`])
function isOverflowElement(element$2) {
  let { overflow, overflowX, overflowY, display } = getComputedStyle$1(element$2)
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX)
    && !invalidOverflowDisplayValues.has(display)
}
const tableElements = new Set([`table`, `td`, `th`])
function isTableElement(element$2) {
  return tableElements.has(getNodeName(element$2))
}
const topLayerSelectors = [`:popover-open`, `:modal`]
function isTopLayer(element$2) {
  return topLayerSelectors.some(selector => {
    try {
      return element$2.matches(selector)
    } catch {
      return !1
    }
  })
}
const transformProperties = [`transform`, `translate`, `scale`, `rotate`, `perspective`],
  willChangeValues = [`transform`, `translate`, `scale`, `rotate`, `perspective`, `filter`],
  containValues = [`paint`, `layout`, `strict`, `content`]
function isContainingBlock(elementOrCss) {
  let webkit = isWebKit(), css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss
  return transformProperties.some(value$2 => css[value$2] ? css[value$2] !== `none` : !1)
    || (css.containerType ? css.containerType !== `normal` : !1)
    || !webkit && (css.backdropFilter ? css.backdropFilter !== `none` : !1)
    || !webkit && (css.filter ? css.filter !== `none` : !1)
    || willChangeValues.some(value$2 => (css.willChange || ``).includes(value$2))
    || containValues.some(value$2 => (css.contain || ``).includes(value$2))
}
function getContainingBlock(element$2) {
  let currentNode = getParentNode(element$2)
  for (; isHTMLElement(currentNode) && !isLastTraversableNode(currentNode);) {
    if (isContainingBlock(currentNode)) return currentNode
    if (isTopLayer(currentNode)) return null
    currentNode = getParentNode(currentNode)
  }
  return null
}
function isWebKit() {
  return typeof CSS > `u` || !CSS.supports ? !1 : CSS.supports(`-webkit-backdrop-filter`, `none`)
}
const lastTraversableNodeNames = new Set([`html`, `body`, `#document`])
function isLastTraversableNode(node$1) {
  return lastTraversableNodeNames.has(getNodeName(node$1))
}
function getComputedStyle$1(element$2) {
  return getWindow(element$2).getComputedStyle(element$2)
}
function getNodeScroll(element$2) {
  return isElement(element$2)
    ? { scrollLeft: element$2.scrollLeft, scrollTop: element$2.scrollTop }
    : { scrollLeft: element$2.scrollX, scrollTop: element$2.scrollY }
}
function getParentNode(node$1) {
  if (getNodeName(node$1) === `html`) return node$1
  let result = node$1.assignedSlot || node$1.parentNode || isShadowRoot(node$1) && node$1.host
    || getDocumentElement(node$1)
  return isShadowRoot(result) ? result.host : result
}
function getNearestOverflowAncestor(node$1) {
  let parentNode = getParentNode(node$1)
  return isLastTraversableNode(parentNode)
    ? node$1.ownerDocument ? node$1.ownerDocument.body : node$1.body
    : isHTMLElement(parentNode) && isOverflowElement(parentNode)
    ? parentNode
    : getNearestOverflowAncestor(parentNode)
}
function getOverflowAncestors(node$1, list$3, traverseIframes) {
  var _node$ownerDocument2
  list$3 === void 0 && (list$3 = []), traverseIframes === void 0 && (traverseIframes = !0)
  let scrollableAncestor = getNearestOverflowAncestor(node$1),
    isBody = scrollableAncestor === (_node$ownerDocument2 = node$1.ownerDocument)?.body,
    win = getWindow(scrollableAncestor)
  if (isBody) {
    let frameElement = getFrameElement(win)
    return list$3.concat(
      win,
      win.visualViewport || [],
      isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
      frameElement && traverseIframes ? getOverflowAncestors(frameElement) : [],
    )
  }
  return list$3.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes))
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null
}
function getCssDimensions(element$2) {
  let css = getComputedStyle$1(element$2),
    width = parseFloat(css.width) || 0,
    height = parseFloat(css.height) || 0,
    hasOffset = isHTMLElement(element$2),
    offsetWidth = hasOffset ? element$2.offsetWidth : width,
    offsetHeight = hasOffset ? element$2.offsetHeight : height,
    shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight
  return shouldFallback && (width = offsetWidth, height = offsetHeight), { width, height, $: shouldFallback }
}
function unwrapElement(element$2) {
  return isElement(element$2) ? element$2 : element$2.contextElement
}
function getScale(element$2) {
  let domElement = unwrapElement(element$2)
  if (!isHTMLElement(domElement)) return createCoords(1)
  let rect = domElement.getBoundingClientRect(),
    { width, height, $: $$1 } = getCssDimensions(domElement),
    x$2 = ($$1 ? round(rect.width) : rect.width) / width,
    y$3 = ($$1 ? round(rect.height) : rect.height) / height
  return (!x$2 || !Number.isFinite(x$2)) && (x$2 = 1), (!y$3 || !Number.isFinite(y$3)) && (y$3 = 1), { x: x$2, y: y$3 }
}
const noOffsets = createCoords(0)
function getVisualOffsets(element$2) {
  let win = getWindow(element$2)
  return !isWebKit() || !win.visualViewport
    ? noOffsets
    : { x: win.visualViewport.offsetLeft, y: win.visualViewport.offsetTop }
}
function shouldAddVisualOffsets(element$2, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1),
    !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element$2) ? !1 : isFixed
}
function getBoundingClientRect(element$2, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1)
  let clientRect = element$2.getBoundingClientRect(), domElement = unwrapElement(element$2), scale = createCoords(1)
  includeScale
    && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element$2))
  let visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent)
      ? getVisualOffsets(domElement)
      : createCoords(0),
    x$2 = (clientRect.left + visualOffsets.x) / scale.x,
    y$3 = (clientRect.top + visualOffsets.y) / scale.y,
    width = clientRect.width / scale.x,
    height = clientRect.height / scale.y
  if (domElement) {
    let win = getWindow(domElement),
      offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent,
      currentWin = win,
      currentIFrame = getFrameElement(currentWin)
    for (; currentIFrame && offsetParent && offsetWin !== currentWin;) {
      let iframeScale = getScale(currentIFrame),
        iframeRect = currentIFrame.getBoundingClientRect(),
        css = getComputedStyle$1(currentIFrame),
        left$2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x,
        top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y
      x$2 *= iframeScale.x,
        y$3 *= iframeScale.y,
        width *= iframeScale.x,
        height *= iframeScale.y,
        x$2 += left$2,
        y$3 += top,
        currentWin = getWindow(currentIFrame),
        currentIFrame = getFrameElement(currentWin)
    }
  }
  return rectToClientRect({ width, height, x: x$2, y: y$3 })
}
function getWindowScrollBarX(element$2, rect) {
  let leftScroll = getNodeScroll(element$2).scrollLeft
  return rect ? rect.left + leftScroll : getBoundingClientRect(getDocumentElement(element$2)).left + leftScroll
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  ignoreScrollbarX === void 0 && (ignoreScrollbarX = !1)
  let htmlRect = documentElement.getBoundingClientRect(),
    x$2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : getWindowScrollBarX(documentElement, htmlRect)),
    y$3 = htmlRect.top + scroll.scrollTop
  return { x: x$2, y: y$3 }
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let { elements, rect, offsetParent, strategy } = _ref,
    isFixed = strategy === `fixed`,
    documentElement = getDocumentElement(offsetParent),
    topLayer = elements ? isTopLayer(elements.floating) : !1
  if (offsetParent === documentElement || topLayer && isFixed) return rect
  let scroll = { scrollLeft: 0, scrollTop: 0 },
    scale = createCoords(1),
    offsets = createCoords(0),
    isOffsetParentAnElement = isHTMLElement(offsetParent)
  if (
    (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    && ((getNodeName(offsetParent) !== `body` || isOverflowElement(documentElement))
      && (scroll = getNodeScroll(offsetParent)),
      isHTMLElement(offsetParent))
  ) {
    let offsetRect = getBoundingClientRect(offsetParent)
    scale = getScale(offsetParent),
      offsets.x = offsetRect.x + offsetParent.clientLeft,
      offsets.y = offsetRect.y + offsetParent.clientTop
  }
  let htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed
    ? getHTMLOffset(documentElement, scroll, !0)
    : createCoords(0)
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y,
  }
}
function getClientRects(element$2) {
  return Array.from(element$2.getClientRects())
}
function getDocumentRect(element$2) {
  let html$6 = getDocumentElement(element$2),
    scroll = getNodeScroll(element$2),
    body$2 = element$2.ownerDocument.body,
    width = max(html$6.scrollWidth, html$6.clientWidth, body$2.scrollWidth, body$2.clientWidth),
    height = max(html$6.scrollHeight, html$6.clientHeight, body$2.scrollHeight, body$2.clientHeight),
    x$2 = -scroll.scrollLeft + getWindowScrollBarX(element$2),
    y$3 = -scroll.scrollTop
  return getComputedStyle$1(body$2).direction === `rtl` && (x$2 += max(html$6.clientWidth, body$2.clientWidth) - width),
    { width, height, x: x$2, y: y$3 }
}
function getViewportRect(element$2, strategy) {
  let win = getWindow(element$2),
    html$6 = getDocumentElement(element$2),
    visualViewport = win.visualViewport,
    width = html$6.clientWidth,
    height = html$6.clientHeight,
    x$2 = 0,
    y$3 = 0
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height
    let visualViewportBased = isWebKit()
    ;(!visualViewportBased || visualViewportBased && strategy === `fixed`)
      && (x$2 = visualViewport.offsetLeft, y$3 = visualViewport.offsetTop)
  }
  return { width, height, x: x$2, y: y$3 }
}
const absoluteOrFixed = new Set([`absolute`, `fixed`])
function getInnerBoundingClientRect(element$2, strategy) {
  let clientRect = getBoundingClientRect(element$2, !0, strategy === `fixed`),
    top = clientRect.top + element$2.clientTop,
    left$2 = clientRect.left + element$2.clientLeft,
    scale = isHTMLElement(element$2) ? getScale(element$2) : createCoords(1),
    width = element$2.clientWidth * scale.x,
    height = element$2.clientHeight * scale.y,
    x$2 = left$2 * scale.x,
    y$3 = top * scale.y
  return { width, height, x: x$2, y: y$3 }
}
function getClientRectFromClippingAncestor(element$2, clippingAncestor, strategy) {
  let rect
  if (clippingAncestor === `viewport`) rect = getViewportRect(element$2, strategy)
  else if (clippingAncestor === `document`) rect = getDocumentRect(getDocumentElement(element$2))
  else if (isElement(clippingAncestor)) rect = getInnerBoundingClientRect(clippingAncestor, strategy)
  else {
    let visualOffsets = getVisualOffsets(element$2)
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height,
    }
  }
  return rectToClientRect(rect)
}
function hasFixedPositionAncestor(element$2, stopNode) {
  let parentNode = getParentNode(element$2)
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)
    ? !1
    : getComputedStyle$1(parentNode).position === `fixed` || hasFixedPositionAncestor(parentNode, stopNode)
}
function getClippingElementAncestors(element$2, cache) {
  let cachedResult = cache.get(element$2)
  if (cachedResult) return cachedResult
  let result = getOverflowAncestors(element$2, [], !1).filter(el => isElement(el) && getNodeName(el) !== `body`),
    currentContainingBlockComputedStyle = null,
    elementIsFixed = getComputedStyle$1(element$2).position === `fixed`,
    currentNode = elementIsFixed ? getParentNode(element$2) : element$2
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode);) {
    let computedStyle = getComputedStyle$1(currentNode), currentNodeIsContaining = isContainingBlock(currentNode)
    !currentNodeIsContaining && computedStyle.position === `fixed` && (currentContainingBlockComputedStyle = null)
    let shouldDropCurrentNode = elementIsFixed
      ? !currentNodeIsContaining && !currentContainingBlockComputedStyle
      : !currentNodeIsContaining && computedStyle.position === `static` && !!currentContainingBlockComputedStyle
          && absoluteOrFixed.has(currentContainingBlockComputedStyle.position)
        || isOverflowElement(currentNode) && !currentNodeIsContaining
          && hasFixedPositionAncestor(element$2, currentNode)
    shouldDropCurrentNode
      ? result = result.filter(ancestor => ancestor !== currentNode)
      : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode)
  }
  return cache.set(element$2, result), result
}
function getClippingRect(_ref) {
  let { element: element$2, boundary, rootBoundary, strategy } = _ref,
    elementClippingAncestors = boundary === `clippingAncestors`
      ? isTopLayer(element$2) ? [] : getClippingElementAncestors(element$2, this._c)
      : [].concat(boundary),
    clippingAncestors = [...elementClippingAncestors, rootBoundary],
    firstClippingAncestor = clippingAncestors[0],
    clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      let rect = getClientRectFromClippingAncestor(element$2, clippingAncestor, strategy)
      return accRect.top = max(rect.top, accRect.top),
        accRect.right = min(rect.right, accRect.right),
        accRect.bottom = min(rect.bottom, accRect.bottom),
        accRect.left = max(rect.left, accRect.left),
        accRect
    }, getClientRectFromClippingAncestor(element$2, firstClippingAncestor, strategy))
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top,
  }
}
function getDimensions(element$2) {
  let { width, height } = getCssDimensions(element$2)
  return { width, height }
}
function getRectRelativeToOffsetParent(element$2, offsetParent, strategy) {
  let isOffsetParentAnElement = isHTMLElement(offsetParent),
    documentElement = getDocumentElement(offsetParent),
    isFixed = strategy === `fixed`,
    rect = getBoundingClientRect(element$2, !0, isFixed, offsetParent),
    scroll = { scrollLeft: 0, scrollTop: 0 },
    offsets = createCoords(0)
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement)
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (
      (getNodeName(offsetParent) !== `body` || isOverflowElement(documentElement))
      && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement
    ) {
      let offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent)
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop
    } else documentElement && setLeftRTLScrollbarOffset()
  }
  isFixed && !isOffsetParentAnElement && documentElement && setLeftRTLScrollbarOffset()
  let htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed
      ? getHTMLOffset(documentElement, scroll)
      : createCoords(0),
    x$2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x,
    y$3 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y
  return { x: x$2, y: y$3, width: rect.width, height: rect.height }
}
function isStaticPositioned(element$2) {
  return getComputedStyle$1(element$2).position === `static`
}
function getTrueOffsetParent(element$2, polyfill) {
  if (!isHTMLElement(element$2) || getComputedStyle$1(element$2).position === `fixed`) return null
  if (polyfill) return polyfill(element$2)
  let rawOffsetParent = element$2.offsetParent
  return getDocumentElement(element$2) === rawOffsetParent && (rawOffsetParent = rawOffsetParent.ownerDocument.body),
    rawOffsetParent
}
function getOffsetParent(element$2, polyfill) {
  let win = getWindow(element$2)
  if (isTopLayer(element$2)) return win
  if (!isHTMLElement(element$2)) {
    let svgOffsetParent = getParentNode(element$2)
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent);) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) return svgOffsetParent
      svgOffsetParent = getParentNode(svgOffsetParent)
    }
    return win
  }
  let offsetParent = getTrueOffsetParent(element$2, polyfill)
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent);) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill)
  }
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent)
      && !isContainingBlock(offsetParent)
    ? win
    : offsetParent || getContainingBlock(element$2) || win
}
const getElementRects = async function(data) {
  let getOffsetParentFn = this.getOffsetParent || getOffsetParent,
    getDimensionsFn = this.getDimensions,
    floatingDimensions = await getDimensionsFn(data.floating)
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: { x: 0, y: 0, width: floatingDimensions.width, height: floatingDimensions.height },
  }
}
function isRTL(element$2) {
  return getComputedStyle$1(element$2).direction === `rtl`
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL,
}
function rectsAreEqual(a$22, b$3) {
  return a$22.x === b$3.x && a$22.y === b$3.y && a$22.width === b$3.width && a$22.height === b$3.height
}
function observeMove(element$2, onMove) {
  let io = null, timeoutId, root$5 = getDocumentElement(element$2)
  function cleanup() {
    var _io
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup()
    let elementRectForRootMargin = element$2.getBoundingClientRect(),
      { left: left$2, top, width, height } = elementRectForRootMargin
    if (skip || onMove(), !width || !height) return
    let insetTop = floor(top),
      insetRight = floor(root$5.clientWidth - (left$2 + width)),
      insetBottom = floor(root$5.clientHeight - (top + height)),
      insetLeft = floor(left$2),
      rootMargin = -insetTop + `px ` + -insetRight + `px ` + -insetBottom + `px ` + -insetLeft + `px`,
      options$2 = { rootMargin, threshold: max(0, min(1, threshold)) || 1 },
      isFirstUpdate = !0
    function handleObserve(entries$2) {
      let ratio = entries$2[0].intersectionRatio
      if (ratio !== threshold) {
        if (!isFirstUpdate) return refresh()
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7)
        }, 1e3)
      }
      ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element$2.getBoundingClientRect()) && refresh(),
        isFirstUpdate = !1
    }
    try {
      io = new IntersectionObserver(handleObserve, { ...options$2, root: root$5.ownerDocument })
    } catch {
      io = new IntersectionObserver(handleObserve, options$2)
    }
    io.observe(element$2)
  }
  return refresh(!0), cleanup
}
function autoUpdate(reference$1, floating, update$5, options$2) {
  options$2 === void 0 && (options$2 = {})
  let {
      ancestorScroll = !0,
      ancestorResize = !0,
      elementResize = typeof ResizeObserver == `function`,
      layoutShift = typeof IntersectionObserver == `function`,
      animationFrame = !1,
    } = options$2,
    referenceEl = unwrapElement(reference$1),
    ancestors = ancestorScroll || ancestorResize
      ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)]
      : []
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener(`scroll`, update$5, { passive: !0 }),
      ancestorResize && ancestor.addEventListener(`resize`, update$5)
  })
  let cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update$5) : null,
    reobserveFrame = -1,
    resizeObserver = null
  elementResize && (resizeObserver = new ResizeObserver(_ref => {
    let [firstEntry] = _ref
    firstEntry && firstEntry.target === referenceEl && resizeObserver
    && (resizeObserver.unobserve(floating),
      cancelAnimationFrame(reobserveFrame),
      reobserveFrame = requestAnimationFrame(() => {
        var _resizeObserver
        ;(_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating)
      })), update$5()
  }),
    referenceEl && !animationFrame && resizeObserver.observe(referenceEl),
    resizeObserver.observe(floating))
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference$1) : null
  animationFrame && frameLoop()
  function frameLoop() {
    let nextRefRect = getBoundingClientRect(reference$1)
    prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect) && update$5(),
      prevRefRect = nextRefRect,
      frameId = requestAnimationFrame(frameLoop)
  }
  return update$5(), () => {
    var _resizeObserver2
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener(`scroll`, update$5),
        ancestorResize && ancestor.removeEventListener(`resize`, update$5)
    }),
      cleanupIo?.(),
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(),
      resizeObserver = null,
      animationFrame && cancelAnimationFrame(frameId)
  }
}
const offset$1 = offset$2,
  shift$1 = shift$2,
  flip$1 = flip$2,
  size$1 = size$2,
  hide$1 = hide$2,
  arrow$1 = arrow$2,
  limitShift$1 = limitShift$2,
  computePosition = (reference$1, floating, options$2) => {
    let cache = new Map(),
      mergedOptions = { platform, ...options$2 },
      platformWithCache = { ...mergedOptions.platform, _c: cache }
    return computePosition$1(reference$1, floating, { ...mergedOptions, platform: platformWithCache })
  }
var import_react_dom$1 = __toESM(require_react_dom(), 1),
  isClient = typeof document < `u`,
  noop = function() {},
  index$2 = isClient ? import_react.useLayoutEffect : noop
function deepEqual(a$22, b$3) {
  if (a$22 === b$3) return !0
  if (typeof a$22 != typeof b$3) return !1
  if (typeof a$22 == `function` && a$22.toString() === b$3.toString()) return !0
  let length$1, i$14, keys$6
  if (a$22 && b$3 && typeof a$22 == `object`) {
    if (Array.isArray(a$22)) {
      if (length$1 = a$22.length, length$1 !== b$3.length) return !1
      for (i$14 = length$1; i$14-- !== 0;) if (!deepEqual(a$22[i$14], b$3[i$14])) return !1
      return !0
    }
    if (keys$6 = Object.keys(a$22), length$1 = keys$6.length, length$1 !== Object.keys(b$3).length) return !1
    for (i$14 = length$1; i$14-- !== 0;) if (!{}.hasOwnProperty.call(b$3, keys$6[i$14])) return !1
    for (i$14 = length$1; i$14-- !== 0;) {
      let key$1 = keys$6[i$14]
      if (!(key$1 === `_owner` && a$22.$$typeof) && !deepEqual(a$22[key$1], b$3[key$1])) return !1
    }
    return !0
  }
  return a$22 !== a$22 && b$3 !== b$3
}
function getDPR(element$2) {
  if (typeof window > `u`) return 1
  let win = element$2.ownerDocument.defaultView || window
  return win.devicePixelRatio || 1
}
function roundByDPR(element$2, value$2) {
  let dpr = getDPR(element$2)
  return Math.round(value$2 * dpr) / dpr
}
function useLatestRef(value$2) {
  let ref = import_react.useRef(value$2)
  return index$2(() => {
    ref.current = value$2
  }),
    ref
}
function useFloating(options$2) {
  options$2 === void 0 && (options$2 = {})
  let {
      placement = `bottom`,
      strategy = `absolute`,
      middleware = [],
      platform: platform$1,
      elements: { reference: externalReference, floating: externalFloating } = {},
      transform: transform$3 = !0,
      whileElementsMounted,
      open,
    } = options$2,
    [data, setData] = import_react.useState({ x: 0, y: 0, strategy, placement, middlewareData: {}, isPositioned: !1 }),
    [latestMiddleware, setLatestMiddleware] = import_react.useState(middleware)
  deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware)
  let [_reference, _setReference] = import_react.useState(null),
    [_floating, _setFloating] = import_react.useState(null),
    setReference = import_react.useCallback(node$1 => {
      node$1 !== referenceRef.current && (referenceRef.current = node$1, _setReference(node$1))
    }, []),
    setFloating = import_react.useCallback(node$1 => {
      node$1 !== floatingRef.current && (floatingRef.current = node$1, _setFloating(node$1))
    }, []),
    referenceEl = externalReference || _reference,
    floatingEl = externalFloating || _floating,
    referenceRef = import_react.useRef(null),
    floatingRef = import_react.useRef(null),
    dataRef = import_react.useRef(data),
    hasWhileElementsMounted = whileElementsMounted != null,
    whileElementsMountedRef = useLatestRef(whileElementsMounted),
    platformRef = useLatestRef(platform$1),
    openRef = useLatestRef(open),
    update$5 = import_react.useCallback(() => {
      if (!referenceRef.current || !floatingRef.current) return
      let config = { placement, strategy, middleware: latestMiddleware }
      platformRef.current && (config.platform = platformRef.current),
        computePosition(referenceRef.current, floatingRef.current, config).then(data$1 => {
          let fullData = { ...data$1, isPositioned: openRef.current !== !1 }
          isMountedRef.current && !deepEqual(dataRef.current, fullData)
            && (dataRef.current = fullData,
              import_react_dom$1.flushSync(() => {
                setData(fullData)
              }))
        })
    }, [latestMiddleware, placement, strategy, platformRef, openRef])
  index$2(() => {
    open === !1 && dataRef.current.isPositioned
      && (dataRef.current.isPositioned = !1, setData(data$1 => ({ ...data$1, isPositioned: !1 })))
  }, [open])
  let isMountedRef = import_react.useRef(!1)
  index$2(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1
  }), []),
    index$2(() => {
      if (
        referenceEl && (referenceRef.current = referenceEl),
          floatingEl && (floatingRef.current = floatingEl),
          referenceEl && floatingEl
      ) {
        if (whileElementsMountedRef.current) return whileElementsMountedRef.current(referenceEl, floatingEl, update$5)
        update$5()
      }
    }, [referenceEl, floatingEl, update$5, whileElementsMountedRef, hasWhileElementsMounted])
  let refs = import_react.useMemo(
      () => ({ reference: referenceRef, floating: floatingRef, setReference, setFloating }),
      [setReference, setFloating],
    ),
    elements = import_react.useMemo(() => ({ reference: referenceEl, floating: floatingEl }), [
      referenceEl,
      floatingEl,
    ]),
    floatingStyles = import_react.useMemo(() => {
      let initialStyles = { position: strategy, left: 0, top: 0 }
      if (!elements.floating) return initialStyles
      let x$2 = roundByDPR(elements.floating, data.x), y$3 = roundByDPR(elements.floating, data.y)
      return transform$3
        ? {
          ...initialStyles,
          transform: `translate(` + x$2 + `px, ` + y$3 + `px)`,
          ...getDPR(elements.floating) >= 1.5 && { willChange: `transform` },
        }
        : { position: strategy, left: x$2, top: y$3 }
    }, [strategy, transform$3, elements.floating, data.x, data.y])
  return import_react.useMemo(() => ({ ...data, update: update$5, refs, elements, floatingStyles }), [
    data,
    update$5,
    refs,
    elements,
    floatingStyles,
  ])
}
const arrow$1$1 = options$2 => {
    function isRef(value$2) {
      return {}.hasOwnProperty.call(value$2, `current`)
    }
    return {
      name: `arrow`,
      options: options$2,
      fn(state) {
        let { element: element$2, padding } = typeof options$2 == `function` ? options$2(state) : options$2
        return element$2 && isRef(element$2)
          ? element$2.current == null ? {} : arrow$1({ element: element$2.current, padding }).fn(state)
          : element$2
          ? arrow$1({ element: element$2, padding }).fn(state)
          : {}
      },
    }
  },
  offset = (options$2, deps) => ({ ...offset$1(options$2), options: [options$2, deps] }),
  shift = (options$2, deps) => ({ ...shift$1(options$2), options: [options$2, deps] }),
  limitShift = (options$2, deps) => ({ ...limitShift$1(options$2), options: [options$2, deps] }),
  flip = (options$2, deps) => ({ ...flip$1(options$2), options: [options$2, deps] }),
  size = (options$2, deps) => ({ ...size$1(options$2), options: [options$2, deps] }),
  hide = (options$2, deps) => ({ ...hide$1(options$2), options: [options$2, deps] }),
  arrow = (options$2, deps) => ({ ...arrow$1$1(options$2), options: [options$2, deps] })
var NAME = `Arrow`,
  Arrow$1 = import_react.forwardRef((props, forwardedRef) => {
    let { children: children$3, width = 10, height = 5, ...arrowProps } = props
    return (0, import_jsx_runtime.jsx)(Primitive.svg, {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: `0 0 30 10`,
      preserveAspectRatio: `none`,
      children: props.asChild ? children$3 : (0, import_jsx_runtime.jsx)(`polygon`, { points: `0,0 30,0 15,10` }),
    })
  })
Arrow$1.displayName = NAME
var Root$2 = Arrow$1,
  POPPER_NAME = `Popper`,
  [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME),
  [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME),
  Popper = props => {
    let { __scopePopper, children: children$3 } = props, [anchor, setAnchor] = import_react.useState(null)
    return (0, import_jsx_runtime.jsx)(PopperProvider, {
      scope: __scopePopper,
      anchor,
      onAnchorChange: setAnchor,
      children: children$3,
    })
  }
Popper.displayName = POPPER_NAME
var ANCHOR_NAME$1 = `PopperAnchor`,
  PopperAnchor = import_react.forwardRef((props, forwardedRef) => {
    let { __scopePopper, virtualRef, ...anchorProps } = props,
      context$2 = usePopperContext(ANCHOR_NAME$1, __scopePopper),
      ref = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref)
    return import_react.useEffect(() => {
      context$2.onAnchorChange(virtualRef?.current || ref.current)
    }),
      virtualRef ? null : (0, import_jsx_runtime.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs })
  })
PopperAnchor.displayName = ANCHOR_NAME$1
var CONTENT_NAME$4 = `PopperContent`,
  [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$4),
  PopperContent = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopePopper,
        side = `bottom`,
        sideOffset = 0,
        align = `center`,
        alignOffset = 0,
        arrowPadding = 0,
        avoidCollisions = !0,
        collisionBoundary = [],
        collisionPadding: collisionPaddingProp = 0,
        sticky = `partial`,
        hideWhenDetached = !1,
        updatePositionStrategy = `optimized`,
        onPlaced,
        ...contentProps
      } = props,
      context$2 = usePopperContext(CONTENT_NAME$4, __scopePopper),
      [content$2, setContent] = import_react.useState(null),
      composedRefs = useComposedRefs(forwardedRef, node$1 => setContent(node$1)),
      [arrow$3, setArrow] = import_react.useState(null),
      arrowSize = useSize(arrow$3),
      arrowWidth = arrowSize?.width ?? 0,
      arrowHeight = arrowSize?.height ?? 0,
      desiredPlacement = side + (align === `center` ? `` : `-` + align),
      collisionPadding = typeof collisionPaddingProp == `number`
        ? collisionPaddingProp
        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp },
      boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary],
      hasExplicitBoundaries = boundary.length > 0,
      detectOverflowOptions = {
        padding: collisionPadding,
        boundary: boundary.filter(isNotNull),
        altBoundary: hasExplicitBoundaries,
      },
      { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
        strategy: `fixed`,
        placement: desiredPlacement,
        whileElementsMounted: (...args$1) => {
          let cleanup = autoUpdate(...args$1, { animationFrame: updatePositionStrategy === `always` })
          return cleanup
        },
        elements: { reference: context$2.anchor },
        middleware: [
          offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
          avoidCollisions
          && shift({
            mainAxis: !0,
            crossAxis: !1,
            limiter: sticky === `partial` ? limitShift() : void 0,
            ...detectOverflowOptions,
          }),
          avoidCollisions && flip({ ...detectOverflowOptions }),
          size({
            ...detectOverflowOptions,
            apply: ({ elements, rects, availableWidth, availableHeight }) => {
              let { width: anchorWidth, height: anchorHeight } = rects.reference, contentStyle = elements.floating.style
              contentStyle.setProperty(`--radix-popper-available-width`, `${availableWidth}px`),
                contentStyle.setProperty(`--radix-popper-available-height`, `${availableHeight}px`),
                contentStyle.setProperty(`--radix-popper-anchor-width`, `${anchorWidth}px`),
                contentStyle.setProperty(`--radix-popper-anchor-height`, `${anchorHeight}px`)
            },
          }),
          arrow$3 && arrow({ element: arrow$3, padding: arrowPadding }),
          transformOrigin({ arrowWidth, arrowHeight }),
          hideWhenDetached && hide({ strategy: `referenceHidden`, ...detectOverflowOptions }),
        ],
      }),
      [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement),
      handlePlaced = useCallbackRef(onPlaced)
    useLayoutEffect2(() => {
      isPositioned && handlePlaced?.()
    }, [isPositioned, handlePlaced])
    let arrowX = middlewareData.arrow?.x,
      arrowY = middlewareData.arrow?.y,
      cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0,
      [contentZIndex, setContentZIndex] = import_react.useState()
    return useLayoutEffect2(() => {
      content$2 && setContentZIndex(window.getComputedStyle(content$2).zIndex)
    }, [content$2]),
      (0, import_jsx_runtime.jsx)(`div`, {
        ref: refs.setFloating,
        'data-radix-popper-content-wrapper': ``,
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : `translate(0, -200%)`,
          minWidth: `max-content`,
          zIndex: contentZIndex,
          '--radix-popper-transform-origin': [middlewareData.transformOrigin?.x, middlewareData.transformOrigin?.y]
            .join(` `),
          ...middlewareData.hide?.referenceHidden && { visibility: `hidden`, pointerEvents: `none` },
        },
        dir: props.dir,
        children: (0, import_jsx_runtime.jsx)(PopperContentProvider, {
          scope: __scopePopper,
          placedSide,
          onArrowChange: setArrow,
          arrowX,
          arrowY,
          shouldHideArrow: cannotCenterArrow,
          children: (0, import_jsx_runtime.jsx)(Primitive.div, {
            'data-side': placedSide,
            'data-align': placedAlign,
            ...contentProps,
            ref: composedRefs,
            style: { ...contentProps.style, animation: isPositioned ? void 0 : `none` },
          }),
        }),
      })
  })
PopperContent.displayName = CONTENT_NAME$4
var ARROW_NAME$3 = `PopperArrow`,
  OPPOSITE_SIDE = { top: `bottom`, right: `left`, bottom: `top`, left: `right` },
  PopperArrow = import_react.forwardRef(function(props, forwardedRef) {
    let { __scopePopper, ...arrowProps } = props,
      contentContext = useContentContext(ARROW_NAME$3, __scopePopper),
      baseSide = OPPOSITE_SIDE[contentContext.placedSide]
    return (0, import_jsx_runtime.jsx)(`span`, {
      ref: contentContext.onArrowChange,
      style: {
        position: `absolute`,
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: { top: ``, right: `0 0`, bottom: `center 0`, left: `100% 0` }[contentContext.placedSide],
        transform: {
          top: `translateY(100%)`,
          right: `translateY(50%) rotate(90deg) translateX(-50%)`,
          bottom: `rotate(180deg)`,
          left: `translateY(50%) rotate(-90deg) translateX(50%)`,
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? `hidden` : void 0,
      },
      children: (0, import_jsx_runtime.jsx)(Root$2, {
        ...arrowProps,
        ref: forwardedRef,
        style: { ...arrowProps.style, display: `block` },
      }),
    })
  })
PopperArrow.displayName = ARROW_NAME$3
function isNotNull(value$2) {
  return value$2 !== null
}
var transformOrigin = options$2 => ({
  name: `transformOrigin`,
  options: options$2,
  fn(data) {
    let { placement, rects, middlewareData } = data,
      cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0,
      isArrowHidden = cannotCenterArrow,
      arrowWidth = isArrowHidden ? 0 : options$2.arrowWidth,
      arrowHeight = isArrowHidden ? 0 : options$2.arrowHeight,
      [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement),
      noArrowAlign = { start: `0%`, center: `50%`, end: `100%` }[placedAlign],
      arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2,
      arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2,
      x$2 = ``,
      y$3 = ``
    return placedSide === `bottom`
      ? (x$2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`, y$3 = `${-arrowHeight}px`)
      : placedSide === `top`
      ? (x$2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`, y$3 = `${rects.floating.height + arrowHeight}px`)
      : placedSide === `right`
      ? (x$2 = `${-arrowHeight}px`, y$3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`)
      : placedSide === `left`
        && (x$2 = `${rects.floating.width + arrowHeight}px`, y$3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`),
      { data: { x: x$2, y: y$3 } }
  },
})
function getSideAndAlignFromPlacement(placement) {
  let [side, align = `center`] = placement.split(`-`)
  return [side, align]
}
var Root2$3 = Popper,
  Anchor = PopperAnchor,
  Content$1 = PopperContent,
  Arrow = PopperArrow,
  ENTRY_FOCUS = `rovingFocusGroup.onEntryFocus`,
  EVENT_OPTIONS = { bubbles: !1, cancelable: !0 },
  GROUP_NAME$1 = `RovingFocusGroup`,
  [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(GROUP_NAME$1),
  [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(GROUP_NAME$1, [
    createCollectionScope$1,
  ]),
  [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$1),
  RovingFocusGroup = import_react.forwardRef((props, forwardedRef) =>
    (0, import_jsx_runtime.jsx)(Collection$1.Provider, {
      scope: props.__scopeRovingFocusGroup,
      children: (0, import_jsx_runtime.jsx)(Collection$1.Slot, {
        scope: props.__scopeRovingFocusGroup,
        children: (0, import_jsx_runtime.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }),
      }),
    })
  )
RovingFocusGroup.displayName = GROUP_NAME$1
var RovingFocusGroupImpl = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopeRovingFocusGroup,
        orientation,
        loop: loop$2 = !1,
        dir,
        currentTabStopId: currentTabStopIdProp,
        defaultCurrentTabStopId,
        onCurrentTabStopIdChange,
        onEntryFocus,
        preventScrollOnEntryFocus = !1,
        ...groupProps
      } = props,
      ref = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref),
      direction = useDirection(dir),
      [currentTabStopId, setCurrentTabStopId] = useControllableState({
        prop: currentTabStopIdProp,
        defaultProp: defaultCurrentTabStopId ?? null,
        onChange: onCurrentTabStopIdChange,
        caller: GROUP_NAME$1,
      }),
      [isTabbingBackOut, setIsTabbingBackOut] = import_react.useState(!1),
      handleEntryFocus = useCallbackRef(onEntryFocus),
      getItems = useCollection$1(__scopeRovingFocusGroup),
      isClickFocusRef = import_react.useRef(!1),
      [focusableItemsCount, setFocusableItemsCount] = import_react.useState(0)
    return import_react.useEffect(() => {
      let node$1 = ref.current
      if (node$1) {
        return node$1.addEventListener(ENTRY_FOCUS, handleEntryFocus),
          () => node$1.removeEventListener(ENTRY_FOCUS, handleEntryFocus)
      }
    }, [handleEntryFocus]),
      (0, import_jsx_runtime.jsx)(RovingFocusProvider, {
        scope: __scopeRovingFocusGroup,
        orientation,
        dir: direction,
        loop: loop$2,
        currentTabStopId,
        onItemFocus: import_react.useCallback(tabStopId => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),
        onItemShiftTab: import_react.useCallback(() => setIsTabbingBackOut(!0), []),
        onFocusableItemAdd: import_react.useCallback(() => setFocusableItemsCount(prevCount => prevCount + 1), []),
        onFocusableItemRemove: import_react.useCallback(() => setFocusableItemsCount(prevCount => prevCount - 1), []),
        children: (0, import_jsx_runtime.jsx)(Primitive.div, {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          'data-orientation': orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: `none`, ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = !0
          }),
          onFocus: composeEventHandlers(props.onFocus, event => {
            let isKeyboardFocus = !isClickFocusRef.current
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              let entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS)
              if (event.currentTarget.dispatchEvent(entryFocusEvent), !entryFocusEvent.defaultPrevented) {
                let items = getItems().filter(item => item.focusable),
                  activeItem = items.find(item => item.active),
                  currentItem = items.find(item => item.id === currentTabStopId),
                  candidateItems = [activeItem, currentItem, ...items].filter(Boolean),
                  candidateNodes = candidateItems.map(item => item.ref.current)
                focusFirst(candidateNodes, preventScrollOnEntryFocus)
              }
            }
            isClickFocusRef.current = !1
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(!1)),
        }),
      })
  }),
  ITEM_NAME$1 = `RovingFocusGroupItem`,
  RovingFocusGroupItem = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopeRovingFocusGroup,
        focusable = !0,
        active: active$1 = !1,
        tabStopId,
        children: children$3,
        ...itemProps
      } = props,
      autoId = useId(),
      id$2 = tabStopId || autoId,
      context$2 = useRovingFocusContext(ITEM_NAME$1, __scopeRovingFocusGroup),
      isCurrentTabStop = context$2.currentTabStopId === id$2,
      getItems = useCollection$1(__scopeRovingFocusGroup),
      { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context$2
    return import_react.useEffect(() => {
      if (focusable) return onFocusableItemAdd(), () => onFocusableItemRemove()
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]),
      (0, import_jsx_runtime.jsx)(Collection$1.ItemSlot, {
        scope: __scopeRovingFocusGroup,
        id: id$2,
        focusable,
        active: active$1,
        children: (0, import_jsx_runtime.jsx)(Primitive.span, {
          tabIndex: isCurrentTabStop ? 0 : -1,
          'data-orientation': context$2.orientation,
          ...itemProps,
          ref: forwardedRef,
          onMouseDown: composeEventHandlers(props.onMouseDown, event => {
            focusable ? context$2.onItemFocus(id$2) : event.preventDefault()
          }),
          onFocus: composeEventHandlers(props.onFocus, () => context$2.onItemFocus(id$2)),
          onKeyDown: composeEventHandlers(props.onKeyDown, event => {
            if (event.key === `Tab` && event.shiftKey) {
              context$2.onItemShiftTab()
              return
            }
            if (event.target !== event.currentTarget) return
            let focusIntent = getFocusIntent(event, context$2.orientation, context$2.dir)
            if (focusIntent !== void 0) {
              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return
              event.preventDefault()
              let items = getItems().filter(item => item.focusable),
                candidateNodes = items.map(item => item.ref.current)
              if (focusIntent === `last`) candidateNodes.reverse()
              else if (focusIntent === `prev` || focusIntent === `next`) {
                focusIntent === `prev` && candidateNodes.reverse()
                let currentIndex = candidateNodes.indexOf(event.currentTarget)
                candidateNodes = context$2.loop
                  ? wrapArray$1(candidateNodes, currentIndex + 1)
                  : candidateNodes.slice(currentIndex + 1)
              }
              setTimeout(() => focusFirst(candidateNodes))
            }
          }),
          children: typeof children$3 == `function`
            ? children$3({ isCurrentTabStop, hasTabStop: currentTabStopId != null })
            : children$3,
        }),
      })
  })
RovingFocusGroupItem.displayName = ITEM_NAME$1
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: `prev`,
  ArrowUp: `prev`,
  ArrowRight: `next`,
  ArrowDown: `next`,
  PageUp: `first`,
  Home: `first`,
  PageDown: `last`,
  End: `last`,
}
function getDirectionAwareKey(key$1, dir) {
  return dir === `rtl` ? key$1 === `ArrowLeft` ? `ArrowRight` : key$1 === `ArrowRight` ? `ArrowLeft` : key$1 : key$1
}
function getFocusIntent(event, orientation, dir) {
  let key$1 = getDirectionAwareKey(event.key, dir)
  if (
    !(orientation === `vertical` && [`ArrowLeft`, `ArrowRight`].includes(key$1))
    && !(orientation === `horizontal` && [`ArrowUp`, `ArrowDown`].includes(key$1))
  ) return MAP_KEY_TO_FOCUS_INTENT[key$1]
}
function focusFirst(candidates, preventScroll = !1) {
  let PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement
  for (let candidate of candidates) {
    if (
      candidate === PREVIOUSLY_FOCUSED_ELEMENT
      || (candidate.focus({ preventScroll }), document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
    ) return
  }
}
function wrapArray$1(array$3, startIndex) {
  return array$3.map((_$1, index$4) => array$3[(startIndex + index$4) % array$3.length])
}
var Root$1 = RovingFocusGroup, Item$3 = RovingFocusGroupItem
function clamp(value$2, [min$10, max$12]) {
  return Math.min(max$12, Math.max(min$10, value$2))
}
var POPOVER_NAME = `Popover`,
  [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [createPopperScope]),
  usePopperScope$2 = createPopperScope(),
  [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME),
  Popover = props => {
    let { __scopePopover, children: children$3, open: openProp, defaultOpen, onOpenChange, modal = !1 } = props,
      popperScope = usePopperScope$2(__scopePopover),
      triggerRef = import_react.useRef(null),
      [hasCustomAnchor, setHasCustomAnchor] = import_react.useState(!1),
      [open, setOpen] = useControllableState({
        prop: openProp,
        defaultProp: defaultOpen ?? !1,
        onChange: onOpenChange,
        caller: POPOVER_NAME,
      })
    return (0, import_jsx_runtime.jsx)(Root2$3, {
      ...popperScope,
      children: (0, import_jsx_runtime.jsx)(PopoverProvider, {
        scope: __scopePopover,
        contentId: useId(),
        triggerRef,
        open,
        onOpenChange: setOpen,
        onOpenToggle: import_react.useCallback(() => setOpen(prevOpen => !prevOpen), [setOpen]),
        hasCustomAnchor,
        onCustomAnchorAdd: import_react.useCallback(() => setHasCustomAnchor(!0), []),
        onCustomAnchorRemove: import_react.useCallback(() => setHasCustomAnchor(!1), []),
        modal,
        children: children$3,
      }),
    })
  }
Popover.displayName = POPOVER_NAME
var ANCHOR_NAME = `PopoverAnchor`,
  PopoverAnchor = import_react.forwardRef((props, forwardedRef) => {
    let { __scopePopover, ...anchorProps } = props,
      context$2 = usePopoverContext(ANCHOR_NAME, __scopePopover),
      popperScope = usePopperScope$2(__scopePopover),
      { onCustomAnchorAdd, onCustomAnchorRemove } = context$2
    return import_react.useEffect(() => (onCustomAnchorAdd(), () => onCustomAnchorRemove()), [
      onCustomAnchorAdd,
      onCustomAnchorRemove,
    ]),
      (0, import_jsx_runtime.jsx)(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef })
  })
PopoverAnchor.displayName = ANCHOR_NAME
var TRIGGER_NAME$3 = `PopoverTrigger`,
  PopoverTrigger = import_react.forwardRef((props, forwardedRef) => {
    let { __scopePopover, ...triggerProps } = props,
      context$2 = usePopoverContext(TRIGGER_NAME$3, __scopePopover),
      popperScope = usePopperScope$2(__scopePopover),
      composedTriggerRef = useComposedRefs(forwardedRef, context$2.triggerRef),
      trigger = (0, import_jsx_runtime.jsx)(Primitive.button, {
        type: `button`,
        'aria-haspopup': `dialog`,
        'aria-expanded': context$2.open,
        'aria-controls': context$2.contentId,
        'data-state': getState(context$2.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context$2.onOpenToggle),
      })
    return context$2.hasCustomAnchor
      ? trigger
      : (0, import_jsx_runtime.jsx)(Anchor, { asChild: !0, ...popperScope, children: trigger })
  })
PopoverTrigger.displayName = TRIGGER_NAME$3
var PORTAL_NAME$2 = `PopoverPortal`,
  [PortalProvider$1, usePortalContext$1] = createPopoverContext(PORTAL_NAME$2, { forceMount: void 0 }),
  PopoverPortal = props => {
    let { __scopePopover, forceMount, children: children$3, container } = props,
      context$2 = usePopoverContext(PORTAL_NAME$2, __scopePopover)
    return (0, import_jsx_runtime.jsx)(PortalProvider$1, {
      scope: __scopePopover,
      forceMount,
      children: (0, import_jsx_runtime.jsx)(Presence, {
        present: forceMount || context$2.open,
        children: (0, import_jsx_runtime.jsx)(Portal, { asChild: !0, container, children: children$3 }),
      }),
    })
  }
PopoverPortal.displayName = PORTAL_NAME$2
var CONTENT_NAME$3 = `PopoverContent`,
  PopoverContent = import_react.forwardRef((props, forwardedRef) => {
    let portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopePopover),
      { forceMount = portalContext.forceMount, ...contentProps } = props,
      context$2 = usePopoverContext(CONTENT_NAME$3, props.__scopePopover)
    return (0, import_jsx_runtime.jsx)(Presence, {
      present: forceMount || context$2.open,
      children: context$2.modal
        ? (0, import_jsx_runtime.jsx)(PopoverContentModal, { ...contentProps, ref: forwardedRef })
        : (0, import_jsx_runtime.jsx)(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }),
    })
  })
PopoverContent.displayName = CONTENT_NAME$3
var Slot$1 = createSlot(`PopoverContent.RemoveScroll`),
  PopoverContentModal = import_react.forwardRef((props, forwardedRef) => {
    let context$2 = usePopoverContext(CONTENT_NAME$3, props.__scopePopover),
      contentRef = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, contentRef),
      isRightClickOutsideRef = import_react.useRef(!1)
    return import_react.useEffect(() => {
      let content$2 = contentRef.current
      if (content$2) return hideOthers(content$2)
    }, []),
      (0, import_jsx_runtime.jsx)(Combination_default, {
        as: Slot$1,
        allowPinchZoom: !0,
        children: (0, import_jsx_runtime.jsx)(PopoverContentImpl, {
          ...props,
          ref: composedRefs,
          trapFocus: context$2.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, event => {
            event.preventDefault(), isRightClickOutsideRef.current || context$2.triggerRef.current?.focus()
          }),
          onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, event => {
            let originalEvent = event.detail.originalEvent,
              ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0,
              isRightClick = originalEvent.button === 2 || ctrlLeftClick
            isRightClickOutsideRef.current = isRightClick
          }, { checkForDefaultPrevented: !1 }),
          onFocusOutside: composeEventHandlers(props.onFocusOutside, event => event.preventDefault(), {
            checkForDefaultPrevented: !1,
          }),
        }),
      })
  }),
  PopoverContentNonModal = import_react.forwardRef((props, forwardedRef) => {
    let context$2 = usePopoverContext(CONTENT_NAME$3, props.__scopePopover),
      hasInteractedOutsideRef = import_react.useRef(!1),
      hasPointerDownOutsideRef = import_react.useRef(!1)
    return (0, import_jsx_runtime.jsx)(PopoverContentImpl, {
      ...props,
      ref: forwardedRef,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: event => {
        props.onCloseAutoFocus?.(event),
          event.defaultPrevented
          || (hasInteractedOutsideRef.current || context$2.triggerRef.current?.focus(), event.preventDefault()),
          hasInteractedOutsideRef.current = !1,
          hasPointerDownOutsideRef.current = !1
      },
      onInteractOutside: event => {
        props.onInteractOutside?.(event),
          event.defaultPrevented
          || (hasInteractedOutsideRef.current = !0,
            event.detail.originalEvent.type === `pointerdown` && (hasPointerDownOutsideRef.current = !0))
        let target = event.target, targetIsTrigger = context$2.triggerRef.current?.contains(target)
        targetIsTrigger && event.preventDefault(),
          event.detail.originalEvent.type === `focusin` && hasPointerDownOutsideRef.current && event.preventDefault()
      },
    })
  }),
  PopoverContentImpl = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopePopover,
        trapFocus,
        onOpenAutoFocus,
        onCloseAutoFocus,
        disableOutsidePointerEvents,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        ...contentProps
      } = props,
      context$2 = usePopoverContext(CONTENT_NAME$3, __scopePopover),
      popperScope = usePopperScope$2(__scopePopover)
    return useFocusGuards(),
      (0, import_jsx_runtime.jsx)(FocusScope, {
        asChild: !0,
        loop: !0,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: (0, import_jsx_runtime.jsx)(DismissableLayer, {
          asChild: !0,
          disableOutsidePointerEvents,
          onInteractOutside,
          onEscapeKeyDown,
          onPointerDownOutside,
          onFocusOutside,
          onDismiss: () => context$2.onOpenChange(!1),
          children: (0, import_jsx_runtime.jsx)(Content$1, {
            'data-state': getState(context$2.open),
            role: `dialog`,
            id: context$2.contentId,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              '--radix-popover-content-transform-origin': `var(--radix-popper-transform-origin)`,
              '--radix-popover-content-available-width': `var(--radix-popper-available-width)`,
              '--radix-popover-content-available-height': `var(--radix-popper-available-height)`,
              '--radix-popover-trigger-width': `var(--radix-popper-anchor-width)`,
              '--radix-popover-trigger-height': `var(--radix-popper-anchor-height)`,
            },
          }),
        }),
      })
  }),
  CLOSE_NAME = `PopoverClose`,
  PopoverClose = import_react.forwardRef((props, forwardedRef) => {
    let { __scopePopover, ...closeProps } = props, context$2 = usePopoverContext(CLOSE_NAME, __scopePopover)
    return (0, import_jsx_runtime.jsx)(Primitive.button, {
      type: `button`,
      ...closeProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => context$2.onOpenChange(!1)),
    })
  })
PopoverClose.displayName = CLOSE_NAME
var ARROW_NAME$2 = `PopoverArrow`,
  PopoverArrow = import_react.forwardRef((props, forwardedRef) => {
    let { __scopePopover, ...arrowProps } = props, popperScope = usePopperScope$2(__scopePopover)
    return (0, import_jsx_runtime.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef })
  })
PopoverArrow.displayName = ARROW_NAME$2
function getState(open) {
  return open ? `open` : `closed`
}
var Root2$2 = Popover,
  Anchor2 = PopoverAnchor,
  Trigger$3 = PopoverTrigger,
  Portal$3 = PopoverPortal,
  Content2$2 = PopoverContent,
  Close = PopoverClose
function useStateMachine(initialState$1, machine) {
  return import_react.useReducer((state, event) => {
    let nextState = machine[state][event]
    return nextState ?? state
  }, initialState$1)
}
var SCROLL_AREA_NAME = `ScrollArea`,
  [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME),
  [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME),
  ScrollArea = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeScrollArea, type: type$2 = `hover`, dir, scrollHideDelay = 600, ...scrollAreaProps } = props,
      [scrollArea, setScrollArea] = import_react.useState(null),
      [viewport, setViewport] = import_react.useState(null),
      [content$2, setContent] = import_react.useState(null),
      [scrollbarX, setScrollbarX] = import_react.useState(null),
      [scrollbarY, setScrollbarY] = import_react.useState(null),
      [cornerWidth, setCornerWidth] = import_react.useState(0),
      [cornerHeight, setCornerHeight] = import_react.useState(0),
      [scrollbarXEnabled, setScrollbarXEnabled] = import_react.useState(!1),
      [scrollbarYEnabled, setScrollbarYEnabled] = import_react.useState(!1),
      composedRefs = useComposedRefs(forwardedRef, node$1 => setScrollArea(node$1)),
      direction = useDirection(dir)
    return (0, import_jsx_runtime.jsx)(ScrollAreaProvider, {
      scope: __scopeScrollArea,
      type: type$2,
      dir: direction,
      scrollHideDelay,
      scrollArea,
      viewport,
      onViewportChange: setViewport,
      content: content$2,
      onContentChange: setContent,
      scrollbarX,
      onScrollbarXChange: setScrollbarX,
      scrollbarXEnabled,
      onScrollbarXEnabledChange: setScrollbarXEnabled,
      scrollbarY,
      onScrollbarYChange: setScrollbarY,
      scrollbarYEnabled,
      onScrollbarYEnabledChange: setScrollbarYEnabled,
      onCornerWidthChange: setCornerWidth,
      onCornerHeightChange: setCornerHeight,
      children: (0, import_jsx_runtime.jsx)(Primitive.div, {
        dir: direction,
        ...scrollAreaProps,
        ref: composedRefs,
        style: {
          position: `relative`,
          '--radix-scroll-area-corner-width': cornerWidth + `px`,
          '--radix-scroll-area-corner-height': cornerHeight + `px`,
          ...props.style,
        },
      }),
    })
  })
ScrollArea.displayName = SCROLL_AREA_NAME
var VIEWPORT_NAME$1 = `ScrollAreaViewport`,
  ScrollAreaViewport = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeScrollArea, children: children$3, nonce, ...viewportProps } = props,
      context$2 = useScrollAreaContext(VIEWPORT_NAME$1, __scopeScrollArea),
      ref = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref, context$2.onViewportChange)
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsx)(`style`, {
          dangerouslySetInnerHTML: {
            __html:
              `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`,
          },
          nonce,
        }),
        (0, import_jsx_runtime.jsx)(Primitive.div, {
          'data-radix-scroll-area-viewport': ``,
          ...viewportProps,
          ref: composedRefs,
          style: {
            overflowX: context$2.scrollbarXEnabled ? `scroll` : `hidden`,
            overflowY: context$2.scrollbarYEnabled ? `scroll` : `hidden`,
            ...props.style,
          },
          children: (0, import_jsx_runtime.jsx)(`div`, {
            ref: context$2.onContentChange,
            style: { minWidth: `100%`, display: `table` },
            children: children$3,
          }),
        }),
      ],
    })
  })
ScrollAreaViewport.displayName = VIEWPORT_NAME$1
var SCROLLBAR_NAME = `ScrollAreaScrollbar`,
  ScrollAreaScrollbar = import_react.forwardRef((props, forwardedRef) => {
    let { forceMount, ...scrollbarProps } = props,
      context$2 = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea),
      { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context$2,
      isHorizontal = props.orientation === `horizontal`
    return import_react.useEffect(
      () => (isHorizontal ? onScrollbarXEnabledChange(!0) : onScrollbarYEnabledChange(!0), () => {
        isHorizontal ? onScrollbarXEnabledChange(!1) : onScrollbarYEnabledChange(!1)
      }),
      [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange],
    ),
      context$2.type === `hover`
        ? (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount })
        : context$2.type === `scroll`
        ? (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount })
        : context$2.type === `auto`
        ? (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount })
        : context$2.type === `always`
        ? (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef })
        : null
  })
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME
var ScrollAreaScrollbarHover = import_react.forwardRef((props, forwardedRef) => {
    let { forceMount, ...scrollbarProps } = props,
      context$2 = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea),
      [visible, setVisible] = import_react.useState(!1)
    return import_react.useEffect(() => {
      let scrollArea = context$2.scrollArea, hideTimer = 0
      if (scrollArea) {
        let handlePointerEnter = () => {
            window.clearTimeout(hideTimer), setVisible(!0)
          },
          handlePointerLeave = () => {
            hideTimer = window.setTimeout(() => setVisible(!1), context$2.scrollHideDelay)
          }
        return scrollArea.addEventListener(`pointerenter`, handlePointerEnter),
          scrollArea.addEventListener(`pointerleave`, handlePointerLeave),
          () => {
            window.clearTimeout(hideTimer),
              scrollArea.removeEventListener(`pointerenter`, handlePointerEnter),
              scrollArea.removeEventListener(`pointerleave`, handlePointerLeave)
          }
      }
    }, [context$2.scrollArea, context$2.scrollHideDelay]),
      (0, import_jsx_runtime.jsx)(Presence, {
        present: forceMount || visible,
        children: (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarAuto, {
          'data-state': visible ? `visible` : `hidden`,
          ...scrollbarProps,
          ref: forwardedRef,
        }),
      })
  }),
  ScrollAreaScrollbarScroll = import_react.forwardRef((props, forwardedRef) => {
    let { forceMount, ...scrollbarProps } = props,
      context$2 = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea),
      isHorizontal = props.orientation === `horizontal`,
      debounceScrollEnd = useDebounceCallback(() => send(`SCROLL_END`), 100),
      [state, send] = useStateMachine(`hidden`, {
        hidden: { SCROLL: `scrolling` },
        scrolling: { SCROLL_END: `idle`, POINTER_ENTER: `interacting` },
        interacting: { SCROLL: `interacting`, POINTER_LEAVE: `idle` },
        idle: { HIDE: `hidden`, SCROLL: `scrolling`, POINTER_ENTER: `interacting` },
      })
    return import_react.useEffect(() => {
      if (state === `idle`) {
        let hideTimer = window.setTimeout(() => send(`HIDE`), context$2.scrollHideDelay)
        return () => window.clearTimeout(hideTimer)
      }
    }, [state, context$2.scrollHideDelay, send]),
      import_react.useEffect(() => {
        let viewport = context$2.viewport, scrollDirection = isHorizontal ? `scrollLeft` : `scrollTop`
        if (viewport) {
          let prevScrollPos = viewport[scrollDirection],
            handleScroll$1 = () => {
              let scrollPos = viewport[scrollDirection], hasScrollInDirectionChanged = prevScrollPos !== scrollPos
              hasScrollInDirectionChanged && (send(`SCROLL`), debounceScrollEnd()), prevScrollPos = scrollPos
            }
          return viewport.addEventListener(`scroll`, handleScroll$1),
            () => viewport.removeEventListener(`scroll`, handleScroll$1)
        }
      }, [context$2.viewport, isHorizontal, send, debounceScrollEnd]),
      (0, import_jsx_runtime.jsx)(Presence, {
        present: forceMount || state !== `hidden`,
        children: (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
          'data-state': state === `hidden` ? `hidden` : `visible`,
          ...scrollbarProps,
          ref: forwardedRef,
          onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send(`POINTER_ENTER`)),
          onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send(`POINTER_LEAVE`)),
        }),
      })
  }),
  ScrollAreaScrollbarAuto = import_react.forwardRef((props, forwardedRef) => {
    let context$2 = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea),
      { forceMount, ...scrollbarProps } = props,
      [visible, setVisible] = import_react.useState(!1),
      isHorizontal = props.orientation === `horizontal`,
      handleResize = useDebounceCallback(() => {
        if (context$2.viewport) {
          let isOverflowX = context$2.viewport.offsetWidth < context$2.viewport.scrollWidth,
            isOverflowY = context$2.viewport.offsetHeight < context$2.viewport.scrollHeight
          setVisible(isHorizontal ? isOverflowX : isOverflowY)
        }
      }, 10)
    return useResizeObserver(context$2.viewport, handleResize),
      useResizeObserver(context$2.content, handleResize),
      (0, import_jsx_runtime.jsx)(Presence, {
        present: forceMount || visible,
        children: (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarVisible, {
          'data-state': visible ? `visible` : `hidden`,
          ...scrollbarProps,
          ref: forwardedRef,
        }),
      })
  }),
  ScrollAreaScrollbarVisible = import_react.forwardRef((props, forwardedRef) => {
    let { orientation = `vertical`, ...scrollbarProps } = props,
      context$2 = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea),
      thumbRef = import_react.useRef(null),
      pointerOffsetRef = import_react.useRef(0),
      [sizes, setSizes] = import_react.useState({
        content: 0,
        viewport: 0,
        scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 },
      }),
      thumbRatio = getThumbRatio(sizes.viewport, sizes.content),
      commonProps = {
        ...scrollbarProps,
        sizes,
        onSizesChange: setSizes,
        hasThumb: thumbRatio > 0 && thumbRatio < 1,
        onThumbChange: thumb => thumbRef.current = thumb,
        onThumbPointerUp: () => pointerOffsetRef.current = 0,
        onThumbPointerDown: pointerPos => pointerOffsetRef.current = pointerPos,
      }
    function getScrollPosition(pointerPos, dir) {
      return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir)
    }
    return orientation === `horizontal`
      ? (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarX, {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context$2.viewport && thumbRef.current) {
            let scrollPos = context$2.viewport.scrollLeft,
              offset$3 = getThumbOffsetFromScroll(scrollPos, sizes, context$2.dir)
            thumbRef.current.style.transform = `translate3d(${offset$3}px, 0, 0)`
          }
        },
        onWheelScroll: scrollPos => {
          context$2.viewport && (context$2.viewport.scrollLeft = scrollPos)
        },
        onDragScroll: pointerPos => {
          context$2.viewport && (context$2.viewport.scrollLeft = getScrollPosition(pointerPos, context$2.dir))
        },
      })
      : orientation === `vertical`
      ? (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarY, {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context$2.viewport && thumbRef.current) {
            let scrollPos = context$2.viewport.scrollTop, offset$3 = getThumbOffsetFromScroll(scrollPos, sizes)
            thumbRef.current.style.transform = `translate3d(0, ${offset$3}px, 0)`
          }
        },
        onWheelScroll: scrollPos => {
          context$2.viewport && (context$2.viewport.scrollTop = scrollPos)
        },
        onDragScroll: pointerPos => {
          context$2.viewport && (context$2.viewport.scrollTop = getScrollPosition(pointerPos))
        },
      })
      : null
  }),
  ScrollAreaScrollbarX = import_react.forwardRef((props, forwardedRef) => {
    let { sizes, onSizesChange, ...scrollbarProps } = props,
      context$2 = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea),
      [computedStyle, setComputedStyle] = import_react.useState(),
      ref = import_react.useRef(null),
      composeRefs$1 = useComposedRefs(forwardedRef, ref, context$2.onScrollbarXChange)
    return import_react.useEffect(() => {
      ref.current && setComputedStyle(getComputedStyle(ref.current))
    }, [ref]),
      (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarImpl, {
        'data-orientation': `horizontal`,
        ...scrollbarProps,
        ref: composeRefs$1,
        sizes,
        style: {
          bottom: 0,
          left: context$2.dir === `rtl` ? `var(--radix-scroll-area-corner-width)` : 0,
          right: context$2.dir === `ltr` ? `var(--radix-scroll-area-corner-width)` : 0,
          '--radix-scroll-area-thumb-width': getThumbSize(sizes) + `px`,
          ...props.style,
        },
        onThumbPointerDown: pointerPos => props.onThumbPointerDown(pointerPos.x),
        onDragScroll: pointerPos => props.onDragScroll(pointerPos.x),
        onWheelScroll: (event, maxScrollPos) => {
          if (context$2.viewport) {
            let scrollPos = context$2.viewport.scrollLeft + event.deltaX
            props.onWheelScroll(scrollPos),
              isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault()
          }
        },
        onResize: () => {
          ref.current && context$2.viewport && computedStyle
            && onSizesChange({
              content: context$2.viewport.scrollWidth,
              viewport: context$2.viewport.offsetWidth,
              scrollbar: {
                size: ref.current.clientWidth,
                paddingStart: toInt(computedStyle.paddingLeft),
                paddingEnd: toInt(computedStyle.paddingRight),
              },
            })
        },
      })
  }),
  ScrollAreaScrollbarY = import_react.forwardRef((props, forwardedRef) => {
    let { sizes, onSizesChange, ...scrollbarProps } = props,
      context$2 = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea),
      [computedStyle, setComputedStyle] = import_react.useState(),
      ref = import_react.useRef(null),
      composeRefs$1 = useComposedRefs(forwardedRef, ref, context$2.onScrollbarYChange)
    return import_react.useEffect(() => {
      ref.current && setComputedStyle(getComputedStyle(ref.current))
    }, [ref]),
      (0, import_jsx_runtime.jsx)(ScrollAreaScrollbarImpl, {
        'data-orientation': `vertical`,
        ...scrollbarProps,
        ref: composeRefs$1,
        sizes,
        style: {
          top: 0,
          right: context$2.dir === `ltr` ? 0 : void 0,
          left: context$2.dir === `rtl` ? 0 : void 0,
          bottom: `var(--radix-scroll-area-corner-height)`,
          '--radix-scroll-area-thumb-height': getThumbSize(sizes) + `px`,
          ...props.style,
        },
        onThumbPointerDown: pointerPos => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: pointerPos => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context$2.viewport) {
            let scrollPos = context$2.viewport.scrollTop + event.deltaY
            props.onWheelScroll(scrollPos),
              isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault()
          }
        },
        onResize: () => {
          ref.current && context$2.viewport && computedStyle
            && onSizesChange({
              content: context$2.viewport.scrollHeight,
              viewport: context$2.viewport.offsetHeight,
              scrollbar: {
                size: ref.current.clientHeight,
                paddingStart: toInt(computedStyle.paddingTop),
                paddingEnd: toInt(computedStyle.paddingBottom),
              },
            })
        },
      })
  }),
  [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME),
  ScrollAreaScrollbarImpl = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopeScrollArea,
        sizes,
        hasThumb,
        onThumbChange,
        onThumbPointerUp,
        onThumbPointerDown,
        onThumbPositionChange,
        onDragScroll,
        onWheelScroll,
        onResize,
        ...scrollbarProps
      } = props,
      context$2 = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea),
      [scrollbar, setScrollbar] = import_react.useState(null),
      composeRefs$1 = useComposedRefs(forwardedRef, node$1 => setScrollbar(node$1)),
      rectRef = import_react.useRef(null),
      prevWebkitUserSelectRef = import_react.useRef(``),
      viewport = context$2.viewport,
      maxScrollPos = sizes.content - sizes.viewport,
      handleWheelScroll = useCallbackRef(onWheelScroll),
      handleThumbPositionChange = useCallbackRef(onThumbPositionChange),
      handleResize = useDebounceCallback(onResize, 10)
    function handleDragScroll(event) {
      if (rectRef.current) {
        let x$2 = event.clientX - rectRef.current.left, y$3 = event.clientY - rectRef.current.top
        onDragScroll({ x: x$2, y: y$3 })
      }
    }
    return import_react.useEffect(() => {
      let handleWheel = event => {
        let element$2 = event.target, isScrollbarWheel = scrollbar?.contains(element$2)
        isScrollbarWheel && handleWheelScroll(event, maxScrollPos)
      }
      return document.addEventListener(`wheel`, handleWheel, { passive: !1 }),
        () => document.removeEventListener(`wheel`, handleWheel, { passive: !1 })
    }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]),
      import_react.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]),
      useResizeObserver(scrollbar, handleResize),
      useResizeObserver(context$2.content, handleResize),
      (0, import_jsx_runtime.jsx)(ScrollbarProvider, {
        scope: __scopeScrollArea,
        scrollbar,
        hasThumb,
        onThumbChange: useCallbackRef(onThumbChange),
        onThumbPointerUp: useCallbackRef(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: useCallbackRef(onThumbPointerDown),
        children: (0, import_jsx_runtime.jsx)(Primitive.div, {
          ...scrollbarProps,
          ref: composeRefs$1,
          style: { position: `absolute`, ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, event => {
            let mainPointer = 0
            if (event.button === mainPointer) {
              let element$2 = event.target
              element$2.setPointerCapture(event.pointerId),
                rectRef.current = scrollbar.getBoundingClientRect(),
                prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect,
                document.body.style.webkitUserSelect = `none`,
                context$2.viewport && (context$2.viewport.style.scrollBehavior = `auto`),
                handleDragScroll(event)
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, event => {
            let element$2 = event.target
            element$2.hasPointerCapture(event.pointerId) && element$2.releasePointerCapture(event.pointerId),
              document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current,
              context$2.viewport && (context$2.viewport.style.scrollBehavior = ``),
              rectRef.current = null
          }),
        }),
      })
  }),
  THUMB_NAME = `ScrollAreaThumb`,
  ScrollAreaThumb = import_react.forwardRef((props, forwardedRef) => {
    let { forceMount, ...thumbProps } = props,
      scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea)
    return (0, import_jsx_runtime.jsx)(Presence, {
      present: forceMount || scrollbarContext.hasThumb,
      children: (0, import_jsx_runtime.jsx)(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }),
    })
  }),
  ScrollAreaThumbImpl = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeScrollArea, style: style$1, ...thumbProps } = props,
      scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea),
      scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea),
      { onThumbPositionChange } = scrollbarContext,
      composedRef = useComposedRefs(forwardedRef, node$1 => scrollbarContext.onThumbChange(node$1)),
      removeUnlinkedScrollListenerRef = import_react.useRef(void 0),
      debounceScrollEnd = useDebounceCallback(() => {
        removeUnlinkedScrollListenerRef.current
          && (removeUnlinkedScrollListenerRef.current(), removeUnlinkedScrollListenerRef.current = void 0)
      }, 100)
    return import_react.useEffect(() => {
      let viewport = scrollAreaContext.viewport
      if (viewport) {
        let handleScroll$1 = () => {
          if (debounceScrollEnd(), !removeUnlinkedScrollListenerRef.current) {
            let listener = addUnlinkedScrollListener(viewport, onThumbPositionChange)
            removeUnlinkedScrollListenerRef.current = listener, onThumbPositionChange()
          }
        }
        return onThumbPositionChange(),
          viewport.addEventListener(`scroll`, handleScroll$1),
          () => viewport.removeEventListener(`scroll`, handleScroll$1)
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]),
      (0, import_jsx_runtime.jsx)(Primitive.div, {
        'data-state': scrollbarContext.hasThumb ? `visible` : `hidden`,
        ...thumbProps,
        ref: composedRef,
        style: {
          width: `var(--radix-scroll-area-thumb-width)`,
          height: `var(--radix-scroll-area-thumb-height)`,
          ...style$1,
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, event => {
          let thumb = event.target,
            thumbRect = thumb.getBoundingClientRect(),
            x$2 = event.clientX - thumbRect.left,
            y$3 = event.clientY - thumbRect.top
          scrollbarContext.onThumbPointerDown({ x: x$2, y: y$3 })
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp),
      })
  })
ScrollAreaThumb.displayName = THUMB_NAME
var CORNER_NAME = `ScrollAreaCorner`,
  ScrollAreaCorner = import_react.forwardRef((props, forwardedRef) => {
    let context$2 = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea),
      hasBothScrollbarsVisible = !!(context$2.scrollbarX && context$2.scrollbarY),
      hasCorner = context$2.type !== `scroll` && hasBothScrollbarsVisible
    return hasCorner ? (0, import_jsx_runtime.jsx)(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null
  })
ScrollAreaCorner.displayName = CORNER_NAME
var ScrollAreaCornerImpl = import_react.forwardRef((props, forwardedRef) => {
  let { __scopeScrollArea, ...cornerProps } = props,
    context$2 = useScrollAreaContext(CORNER_NAME, __scopeScrollArea),
    [width, setWidth] = import_react.useState(0),
    [height, setHeight] = import_react.useState(0),
    hasSize = !!(width && height)
  return useResizeObserver(context$2.scrollbarX, () => {
    let height2 = context$2.scrollbarX?.offsetHeight || 0
    context$2.onCornerHeightChange(height2), setHeight(height2)
  }),
    useResizeObserver(context$2.scrollbarY, () => {
      let width2 = context$2.scrollbarY?.offsetWidth || 0
      context$2.onCornerWidthChange(width2), setWidth(width2)
    }),
    hasSize
      ? (0, import_jsx_runtime.jsx)(Primitive.div, {
        ...cornerProps,
        ref: forwardedRef,
        style: {
          width,
          height,
          position: `absolute`,
          right: context$2.dir === `ltr` ? 0 : void 0,
          left: context$2.dir === `rtl` ? 0 : void 0,
          bottom: 0,
          ...props.style,
        },
      })
      : null
})
function toInt(value$2) {
  return value$2 ? parseInt(value$2, 10) : 0
}
function getThumbRatio(viewportSize, contentSize) {
  let ratio = viewportSize / contentSize
  return isNaN(ratio) ? 0 : ratio
}
function getThumbSize(sizes) {
  let ratio = getThumbRatio(sizes.viewport, sizes.content),
    scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd,
    thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio
  return Math.max(thumbSize, 18)
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = `ltr`) {
  let thumbSizePx = getThumbSize(sizes),
    thumbCenter = thumbSizePx / 2,
    offset$3 = pointerOffset || thumbCenter,
    thumbOffsetFromEnd = thumbSizePx - offset$3,
    minPointerPos = sizes.scrollbar.paddingStart + offset$3,
    maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd,
    maxScrollPos = sizes.content - sizes.viewport,
    scrollRange = dir === `ltr` ? [0, maxScrollPos] : [maxScrollPos * -1, 0],
    interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange)
  return interpolate(pointerPos)
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = `ltr`) {
  let thumbSizePx = getThumbSize(sizes),
    scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd,
    scrollbar = sizes.scrollbar.size - scrollbarPadding,
    maxScrollPos = sizes.content - sizes.viewport,
    maxThumbPos = scrollbar - thumbSizePx,
    scrollClampRange = dir === `ltr` ? [0, maxScrollPos] : [maxScrollPos * -1, 0],
    scrollWithoutMomentum = clamp(scrollPos, scrollClampRange),
    interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos])
  return interpolate(scrollWithoutMomentum)
}
function linearScale(input, output) {
  return value$2 => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0]
    let ratio = (output[1] - output[0]) / (input[1] - input[0])
    return output[0] + ratio * (value$2 - input[0])
  }
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos
}
var addUnlinkedScrollListener = (node$1, handler = () => {}) => {
  let prevPosition = { left: node$1.scrollLeft, top: node$1.scrollTop }, rAF = 0
  return function loop$2() {
    let position$2 = { left: node$1.scrollLeft, top: node$1.scrollTop },
      isHorizontalScroll = prevPosition.left !== position$2.left,
      isVerticalScroll = prevPosition.top !== position$2.top
    ;(isHorizontalScroll || isVerticalScroll) && handler(),
      prevPosition = position$2,
      rAF = window.requestAnimationFrame(loop$2)
  }(),
    () => window.cancelAnimationFrame(rAF)
}
function useDebounceCallback(callback, delay$2) {
  let handleCallback = useCallbackRef(callback), debounceTimerRef = import_react.useRef(0)
  return import_react.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []),
    import_react.useCallback(() => {
      window.clearTimeout(debounceTimerRef.current),
        debounceTimerRef.current = window.setTimeout(handleCallback, delay$2)
    }, [handleCallback, delay$2])
}
function useResizeObserver(element$2, onResize) {
  let handleResize = useCallbackRef(onResize)
  useLayoutEffect2(() => {
    let rAF = 0
    if (element$2) {
      let resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF), rAF = window.requestAnimationFrame(handleResize)
      })
      return resizeObserver.observe(element$2), () => {
        window.cancelAnimationFrame(rAF), resizeObserver.unobserve(element$2)
      }
    }
  }, [element$2, handleResize])
}
var Root = ScrollArea,
  Viewport$1 = ScrollAreaViewport,
  Scrollbar = ScrollAreaScrollbar,
  Thumb = ScrollAreaThumb,
  Corner = ScrollAreaCorner,
  import_react_dom = __toESM(require_react_dom(), 1),
  OPEN_KEYS = [` `, `Enter`, `ArrowUp`, `ArrowDown`],
  SELECTION_KEYS = [` `, `Enter`],
  SELECT_NAME = `Select`,
  [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME),
  [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
    createCollectionScope,
    createPopperScope,
  ]),
  usePopperScope$1 = createPopperScope(),
  [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME),
  [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME),
  Select = props => {
    let {
        __scopeSelect,
        children: children$3,
        open: openProp,
        defaultOpen,
        onOpenChange,
        value: valueProp,
        defaultValue,
        onValueChange,
        dir,
        name,
        autoComplete,
        disabled,
        required,
        form,
      } = props,
      popperScope = usePopperScope$1(__scopeSelect),
      [trigger, setTrigger] = import_react.useState(null),
      [valueNode, setValueNode] = import_react.useState(null),
      [valueNodeHasChildren, setValueNodeHasChildren] = import_react.useState(!1),
      direction = useDirection(dir),
      [open, setOpen] = useControllableState({
        prop: openProp,
        defaultProp: defaultOpen ?? !1,
        onChange: onOpenChange,
        caller: SELECT_NAME,
      }),
      [value$2, setValue] = useControllableState({
        prop: valueProp,
        defaultProp: defaultValue,
        onChange: onValueChange,
        caller: SELECT_NAME,
      }),
      triggerPointerDownPosRef = import_react.useRef(null),
      isFormControl = trigger ? form || !!trigger.closest(`form`) : !0,
      [nativeOptionsSet, setNativeOptionsSet] = import_react.useState(new Set()),
      nativeSelectKey = Array.from(nativeOptionsSet).map(option$5 => option$5.props.value).join(`;`)
    return (0, import_jsx_runtime.jsx)(Root2$3, {
      ...popperScope,
      children: (0, import_jsx_runtime.jsxs)(SelectProvider, {
        required,
        scope: __scopeSelect,
        trigger,
        onTriggerChange: setTrigger,
        valueNode,
        onValueNodeChange: setValueNode,
        valueNodeHasChildren,
        onValueNodeHasChildrenChange: setValueNodeHasChildren,
        contentId: useId(),
        value: value$2,
        onValueChange: setValue,
        open,
        onOpenChange: setOpen,
        dir: direction,
        triggerPointerDownPosRef,
        disabled,
        children: [
          (0, import_jsx_runtime.jsx)(Collection.Provider, {
            scope: __scopeSelect,
            children: (0, import_jsx_runtime.jsx)(SelectNativeOptionsProvider, {
              scope: props.__scopeSelect,
              onNativeOptionAdd: import_react.useCallback(option$5 => {
                setNativeOptionsSet(prev => new Set(prev).add(option$5))
              }, []),
              onNativeOptionRemove: import_react.useCallback(option$5 => {
                setNativeOptionsSet(prev => {
                  let optionsSet = new Set(prev)
                  return optionsSet.delete(option$5), optionsSet
                })
              }, []),
              children: children$3,
            }),
          }),
          isFormControl
            ? (0, import_jsx_runtime.jsxs)(SelectBubbleInput, {
              'aria-hidden': !0,
              required,
              tabIndex: -1,
              name,
              autoComplete,
              value: value$2,
              onChange: event => setValue(event.target.value),
              disabled,
              form,
              children: [
                value$2 === void 0 ? (0, import_jsx_runtime.jsx)(`option`, { value: `` }) : null,
                Array.from(nativeOptionsSet),
              ],
            }, nativeSelectKey)
            : null,
        ],
      }),
    })
  }
Select.displayName = SELECT_NAME
var TRIGGER_NAME$2 = `SelectTrigger`,
  SelectTrigger = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, disabled = !1, ...triggerProps } = props,
      popperScope = usePopperScope$1(__scopeSelect),
      context$2 = useSelectContext(TRIGGER_NAME$2, __scopeSelect),
      isDisabled$2 = context$2.disabled || disabled,
      composedRefs = useComposedRefs(forwardedRef, context$2.onTriggerChange),
      getItems = useCollection(__scopeSelect),
      pointerTypeRef = import_react.useRef(`touch`),
      [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch(search$1 => {
        let enabledItems = getItems().filter(item => !item.disabled),
          currentItem = enabledItems.find(item => item.value === context$2.value),
          nextItem = findNextItem(enabledItems, search$1, currentItem)
        nextItem !== void 0 && context$2.onValueChange(nextItem.value)
      }),
      handleOpen = pointerEvent => {
        isDisabled$2 || (context$2.onOpenChange(!0), resetTypeahead()),
          pointerEvent
          && (context$2.triggerPointerDownPosRef.current = {
            x: Math.round(pointerEvent.pageX),
            y: Math.round(pointerEvent.pageY),
          })
      }
    return (0, import_jsx_runtime.jsx)(Anchor, {
      asChild: !0,
      ...popperScope,
      children: (0, import_jsx_runtime.jsx)(Primitive.button, {
        type: `button`,
        role: `combobox`,
        'aria-controls': context$2.contentId,
        'aria-expanded': context$2.open,
        'aria-required': context$2.required,
        'aria-autocomplete': `none`,
        dir: context$2.dir,
        'data-state': context$2.open ? `open` : `closed`,
        disabled: isDisabled$2,
        'data-disabled': isDisabled$2 ? `` : void 0,
        'data-placeholder': shouldShowPlaceholder(context$2.value) ? `` : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, event => {
          event.currentTarget.focus(), pointerTypeRef.current !== `mouse` && handleOpen(event)
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, event => {
          pointerTypeRef.current = event.pointerType
          let target = event.target
          target.hasPointerCapture(event.pointerId) && target.releasePointerCapture(event.pointerId),
            event.button === 0 && event.ctrlKey === !1 && event.pointerType === `mouse`
            && (handleOpen(event), event.preventDefault())
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, event => {
          let isTypingAhead = searchRef.current !== ``, isModifierKey = event.ctrlKey || event.altKey || event.metaKey
          !isModifierKey && event.key.length === 1 && handleTypeaheadSearch(event.key),
            !(isTypingAhead && event.key === ` `) && OPEN_KEYS.includes(event.key)
            && (handleOpen(), event.preventDefault())
        }),
      }),
    })
  })
SelectTrigger.displayName = TRIGGER_NAME$2
var VALUE_NAME = `SelectValue`,
  SelectValue = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, className, style: style$1, children: children$3, placeholder = ``, ...valueProps } = props,
      context$2 = useSelectContext(VALUE_NAME, __scopeSelect),
      { onValueNodeHasChildrenChange } = context$2,
      hasChildren = children$3 !== void 0,
      composedRefs = useComposedRefs(forwardedRef, context$2.onValueNodeChange)
    return useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren)
    }, [onValueNodeHasChildrenChange, hasChildren]),
      (0, import_jsx_runtime.jsx)(Primitive.span, {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: `none` },
        children: shouldShowPlaceholder(context$2.value)
          ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: placeholder })
          : children$3,
      })
  })
SelectValue.displayName = VALUE_NAME
var ICON_NAME = `SelectIcon`,
  SelectIcon = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, children: children$3, ...iconProps } = props
    return (0, import_jsx_runtime.jsx)(Primitive.span, {
      'aria-hidden': !0,
      ...iconProps,
      ref: forwardedRef,
      children: children$3 || ``,
    })
  })
SelectIcon.displayName = ICON_NAME
var PORTAL_NAME$1 = `SelectPortal`,
  SelectPortal = props => (0, import_jsx_runtime.jsx)(Portal, { asChild: !0, ...props })
SelectPortal.displayName = PORTAL_NAME$1
var CONTENT_NAME$2 = `SelectContent`,
  SelectContent = import_react.forwardRef((props, forwardedRef) => {
    let context$2 = useSelectContext(CONTENT_NAME$2, props.__scopeSelect),
      [fragment, setFragment] = import_react.useState()
    if (
      useLayoutEffect2(() => {
        setFragment(new DocumentFragment())
      }, []), !context$2.open
    ) {
      let frag = fragment
      return frag
        ? import_react_dom.createPortal(
          (0, import_jsx_runtime.jsx)(SelectContentProvider, {
            scope: props.__scopeSelect,
            children: (0, import_jsx_runtime.jsx)(Collection.Slot, {
              scope: props.__scopeSelect,
              children: (0, import_jsx_runtime.jsx)(`div`, { children: props.children }),
            }),
          }),
          frag,
        )
        : null
    }
    return (0, import_jsx_runtime.jsx)(SelectContentImpl, { ...props, ref: forwardedRef })
  })
SelectContent.displayName = CONTENT_NAME$2
var CONTENT_MARGIN = 10,
  [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$2),
  CONTENT_IMPL_NAME = `SelectContentImpl`,
  Slot = createSlot(`SelectContent.RemoveScroll`),
  SelectContentImpl = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopeSelect,
        position: position$2 = `item-aligned`,
        onCloseAutoFocus,
        onEscapeKeyDown,
        onPointerDownOutside,
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions,
        ...contentProps
      } = props,
      context$2 = useSelectContext(CONTENT_NAME$2, __scopeSelect),
      [content$2, setContent] = import_react.useState(null),
      [viewport, setViewport] = import_react.useState(null),
      composedRefs = useComposedRefs(forwardedRef, node$1 => setContent(node$1)),
      [selectedItem, setSelectedItem] = import_react.useState(null),
      [selectedItemText, setSelectedItemText] = import_react.useState(null),
      getItems = useCollection(__scopeSelect),
      [isPositioned, setIsPositioned] = import_react.useState(!1),
      firstValidItemFoundRef = import_react.useRef(!1)
    import_react.useEffect(() => {
      if (content$2) return hideOthers(content$2)
    }, [content$2]), useFocusGuards()
    let focusFirst$2 = import_react.useCallback(candidates => {
        let [firstItem, ...restItems] = getItems().map(item => item.ref.current),
          [lastItem] = restItems.slice(-1),
          PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement
        for (let candidate of candidates) {
          if (
            candidate === PREVIOUSLY_FOCUSED_ELEMENT
            || (candidate?.scrollIntoView({ block: `nearest` }),
              candidate === firstItem && viewport && (viewport.scrollTop = 0),
              candidate === lastItem && viewport && (viewport.scrollTop = viewport.scrollHeight),
              candidate?.focus(),
              document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
          ) return
        }
      }, [getItems, viewport]),
      focusSelectedItem = import_react.useCallback(() => focusFirst$2([selectedItem, content$2]), [
        focusFirst$2,
        selectedItem,
        content$2,
      ])
    import_react.useEffect(() => {
      isPositioned && focusSelectedItem()
    }, [isPositioned, focusSelectedItem])
    let { onOpenChange, triggerPointerDownPosRef } = context$2
    import_react.useEffect(() => {
      if (content$2) {
        let pointerMoveDelta = { x: 0, y: 0 },
          handlePointerMove = event => {
            pointerMoveDelta = {
              x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
              y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0)),
            }
          },
          handlePointerUp = event => {
            pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10
              ? event.preventDefault()
              : content$2.contains(event.target) || onOpenChange(!1),
              document.removeEventListener(`pointermove`, handlePointerMove),
              triggerPointerDownPosRef.current = null
          }
        return triggerPointerDownPosRef.current !== null
          && (document.addEventListener(`pointermove`, handlePointerMove),
            document.addEventListener(`pointerup`, handlePointerUp, { capture: !0, once: !0 })),
          () => {
            document.removeEventListener(`pointermove`, handlePointerMove),
              document.removeEventListener(`pointerup`, handlePointerUp, { capture: !0 })
          }
      }
    }, [content$2, onOpenChange, triggerPointerDownPosRef]),
      import_react.useEffect(() => {
        let close$1 = () => onOpenChange(!1)
        return window.addEventListener(`blur`, close$1), window.addEventListener(`resize`, close$1), () => {
          window.removeEventListener(`blur`, close$1), window.removeEventListener(`resize`, close$1)
        }
      }, [onOpenChange])
    let [searchRef, handleTypeaheadSearch] = useTypeaheadSearch(search$1 => {
        let enabledItems = getItems().filter(item => !item.disabled),
          currentItem = enabledItems.find(item => item.ref.current === document.activeElement),
          nextItem = findNextItem(enabledItems, search$1, currentItem)
        nextItem && setTimeout(() => nextItem.ref.current.focus())
      }),
      itemRefCallback = import_react.useCallback((node$1, value$2, disabled) => {
        let isFirstValidItem = !firstValidItemFoundRef.current && !disabled,
          isSelectedItem = context$2.value !== void 0 && context$2.value === value$2
        ;(isSelectedItem || isFirstValidItem)
          && (setSelectedItem(node$1), isFirstValidItem && (firstValidItemFoundRef.current = !0))
      }, [context$2.value]),
      handleItemLeave = import_react.useCallback(() => content$2?.focus(), [content$2]),
      itemTextRefCallback = import_react.useCallback((node$1, value$2, disabled) => {
        let isFirstValidItem = !firstValidItemFoundRef.current && !disabled,
          isSelectedItem = context$2.value !== void 0 && context$2.value === value$2
        ;(isSelectedItem || isFirstValidItem) && setSelectedItemText(node$1)
      }, [context$2.value]),
      SelectPosition = position$2 === `popper` ? SelectPopperPosition : SelectItemAlignedPosition,
      popperContentProps = SelectPosition === SelectPopperPosition
        ? {
          side,
          sideOffset,
          align,
          alignOffset,
          arrowPadding,
          collisionBoundary,
          collisionPadding,
          sticky,
          hideWhenDetached,
          avoidCollisions,
        }
        : {}
    return (0, import_jsx_runtime.jsx)(SelectContentProvider, {
      scope: __scopeSelect,
      content: content$2,
      viewport,
      onViewportChange: setViewport,
      itemRefCallback,
      selectedItem,
      onItemLeave: handleItemLeave,
      itemTextRefCallback,
      focusSelectedItem,
      selectedItemText,
      position: position$2,
      isPositioned,
      searchRef,
      children: (0, import_jsx_runtime.jsx)(Combination_default, {
        as: Slot,
        allowPinchZoom: !0,
        children: (0, import_jsx_runtime.jsx)(FocusScope, {
          asChild: !0,
          trapped: context$2.open,
          onMountAutoFocus: event => {
            event.preventDefault()
          },
          onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, event => {
            context$2.trigger?.focus({ preventScroll: !0 }), event.preventDefault()
          }),
          children: (0, import_jsx_runtime.jsx)(DismissableLayer, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside: event => event.preventDefault(),
            onDismiss: () => context$2.onOpenChange(!1),
            children: (0, import_jsx_runtime.jsx)(SelectPosition, {
              role: `listbox`,
              id: context$2.contentId,
              'data-state': context$2.open ? `open` : `closed`,
              dir: context$2.dir,
              onContextMenu: event => event.preventDefault(),
              ...contentProps,
              ...popperContentProps,
              onPlaced: () => setIsPositioned(!0),
              ref: composedRefs,
              style: { display: `flex`, flexDirection: `column`, outline: `none`, ...contentProps.style },
              onKeyDown: composeEventHandlers(contentProps.onKeyDown, event => {
                let isModifierKey = event.ctrlKey || event.altKey || event.metaKey
                if (
                  event.key === `Tab` && event.preventDefault(),
                    !isModifierKey && event.key.length === 1 && handleTypeaheadSearch(event.key),
                    [`ArrowUp`, `ArrowDown`, `Home`, `End`].includes(event.key)
                ) {
                  let items = getItems().filter(item => !item.disabled),
                    candidateNodes = items.map(item => item.ref.current)
                  if (
                    [`ArrowUp`, `End`].includes(event.key) && (candidateNodes = candidateNodes.slice().reverse()),
                      [`ArrowUp`, `ArrowDown`].includes(event.key)
                  ) {
                    let currentElement = event.target, currentIndex = candidateNodes.indexOf(currentElement)
                    candidateNodes = candidateNodes.slice(currentIndex + 1)
                  }
                  setTimeout(() => focusFirst$2(candidateNodes)), event.preventDefault()
                }
              }),
            }),
          }),
        }),
      }),
    })
  })
SelectContentImpl.displayName = CONTENT_IMPL_NAME
var ITEM_ALIGNED_POSITION_NAME = `SelectItemAlignedPosition`,
  SelectItemAlignedPosition = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, onPlaced, ...popperProps } = props,
      context$2 = useSelectContext(CONTENT_NAME$2, __scopeSelect),
      contentContext = useSelectContentContext(CONTENT_NAME$2, __scopeSelect),
      [contentWrapper, setContentWrapper] = import_react.useState(null),
      [content$2, setContent] = import_react.useState(null),
      composedRefs = useComposedRefs(forwardedRef, node$1 => setContent(node$1)),
      getItems = useCollection(__scopeSelect),
      shouldExpandOnScrollRef = import_react.useRef(!1),
      shouldRepositionRef = import_react.useRef(!0),
      { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext,
      position$2 = import_react.useCallback(() => {
        if (
          context$2.trigger && context$2.valueNode && contentWrapper && content$2 && viewport && selectedItem
          && selectedItemText
        ) {
          let triggerRect = context$2.trigger.getBoundingClientRect(),
            contentRect = content$2.getBoundingClientRect(),
            valueNodeRect = context$2.valueNode.getBoundingClientRect(),
            itemTextRect = selectedItemText.getBoundingClientRect()
          if (context$2.dir !== `rtl`) {
            let itemTextOffset = itemTextRect.left - contentRect.left,
              left$2 = valueNodeRect.left - itemTextOffset,
              leftDelta = triggerRect.left - left$2,
              minContentWidth = triggerRect.width + leftDelta,
              contentWidth = Math.max(minContentWidth, contentRect.width),
              rightEdge = window.innerWidth - CONTENT_MARGIN,
              clampedLeft = clamp(left$2, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, rightEdge - contentWidth)])
            contentWrapper.style.minWidth = minContentWidth + `px`, contentWrapper.style.left = clampedLeft + `px`
          } else {
            let itemTextOffset = contentRect.right - itemTextRect.right,
              right$2 = window.innerWidth - valueNodeRect.right - itemTextOffset,
              rightDelta = window.innerWidth - triggerRect.right - right$2,
              minContentWidth = triggerRect.width + rightDelta,
              contentWidth = Math.max(minContentWidth, contentRect.width),
              leftEdge = window.innerWidth - CONTENT_MARGIN,
              clampedRight = clamp(right$2, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, leftEdge - contentWidth)])
            contentWrapper.style.minWidth = minContentWidth + `px`, contentWrapper.style.right = clampedRight + `px`
          }
          let items = getItems(),
            availableHeight = window.innerHeight - CONTENT_MARGIN * 2,
            itemsHeight = viewport.scrollHeight,
            contentStyles = window.getComputedStyle(content$2),
            contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10),
            contentPaddingTop = parseInt(contentStyles.paddingTop, 10),
            contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10),
            contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10),
            fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom
              + contentBorderBottomWidth,
            minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight),
            viewportStyles = window.getComputedStyle(viewport),
            viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10),
            viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10),
            topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN,
            triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle,
            selectedItemHalfHeight = selectedItem.offsetHeight / 2,
            itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight,
            contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle,
            itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle,
            willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle
          if (willAlignWithoutTopOverflow) {
            let isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current
            contentWrapper.style.bottom = `0px`
            let viewportOffsetBottom = content$2.clientHeight - viewport.offsetTop - viewport.offsetHeight,
              clampedTriggerMiddleToBottomEdge = Math.max(
                triggerMiddleToBottomEdge,
                selectedItemHalfHeight + (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom
                  + contentBorderBottomWidth,
              ),
              height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge
            contentWrapper.style.height = height + `px`
          } else {
            let isFirstItem = items.length > 0 && selectedItem === items[0].ref.current
            contentWrapper.style.top = `0px`
            let clampedTopEdgeToTriggerMiddle = Math.max(
                topEdgeToTriggerMiddle,
                contentBorderTopWidth + viewport.offsetTop + (isFirstItem ? viewportPaddingTop : 0)
                  + selectedItemHalfHeight,
              ),
              height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom
            contentWrapper.style.height = height + `px`,
              viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop
          }
          contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`,
            contentWrapper.style.minHeight = minContentHeight + `px`,
            contentWrapper.style.maxHeight = availableHeight + `px`,
            onPlaced?.(),
            requestAnimationFrame(() => shouldExpandOnScrollRef.current = !0)
        }
      }, [
        getItems,
        context$2.trigger,
        context$2.valueNode,
        contentWrapper,
        content$2,
        viewport,
        selectedItem,
        selectedItemText,
        context$2.dir,
        onPlaced,
      ])
    useLayoutEffect2(() => position$2(), [position$2])
    let [contentZIndex, setContentZIndex] = import_react.useState()
    useLayoutEffect2(() => {
      content$2 && setContentZIndex(window.getComputedStyle(content$2).zIndex)
    }, [content$2])
    let handleScrollButtonChange = import_react.useCallback(node$1 => {
      node$1 && shouldRepositionRef.current === !0
        && (position$2(), focusSelectedItem?.(), shouldRepositionRef.current = !1)
    }, [position$2, focusSelectedItem])
    return (0, import_jsx_runtime.jsx)(SelectViewportProvider, {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: (0, import_jsx_runtime.jsx)(`div`, {
        ref: setContentWrapper,
        style: { display: `flex`, flexDirection: `column`, position: `fixed`, zIndex: contentZIndex },
        children: (0, import_jsx_runtime.jsx)(Primitive.div, {
          ...popperProps,
          ref: composedRefs,
          style: { boxSizing: `border-box`, maxHeight: `100%`, ...popperProps.style },
        }),
      }),
    })
  })
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME
var POPPER_POSITION_NAME = `SelectPopperPosition`,
  SelectPopperPosition = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, align = `start`, collisionPadding = CONTENT_MARGIN, ...popperProps } = props,
      popperScope = usePopperScope$1(__scopeSelect)
    return (0, import_jsx_runtime.jsx)(Content$1, {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        boxSizing: `border-box`,
        ...popperProps.style,
        '--radix-select-content-transform-origin': `var(--radix-popper-transform-origin)`,
        '--radix-select-content-available-width': `var(--radix-popper-available-width)`,
        '--radix-select-content-available-height': `var(--radix-popper-available-height)`,
        '--radix-select-trigger-width': `var(--radix-popper-anchor-width)`,
        '--radix-select-trigger-height': `var(--radix-popper-anchor-height)`,
      },
    })
  })
SelectPopperPosition.displayName = POPPER_POSITION_NAME
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$2, {}),
  VIEWPORT_NAME = `SelectViewport`,
  SelectViewport = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, nonce, ...viewportProps } = props,
      contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect),
      viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect),
      composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange),
      prevScrollTopRef = import_react.useRef(0)
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsx)(`style`, {
          dangerouslySetInnerHTML: {
            __html:
              `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`,
          },
          nonce,
        }),
        (0, import_jsx_runtime.jsx)(Collection.Slot, {
          scope: __scopeSelect,
          children: (0, import_jsx_runtime.jsx)(Primitive.div, {
            'data-radix-select-viewport': ``,
            role: `presentation`,
            ...viewportProps,
            ref: composedRefs,
            style: { position: `relative`, flex: 1, overflow: `hidden auto`, ...viewportProps.style },
            onScroll: composeEventHandlers(viewportProps.onScroll, event => {
              let viewport = event.currentTarget, { contentWrapper, shouldExpandOnScrollRef } = viewportContext
              if (shouldExpandOnScrollRef?.current && contentWrapper) {
                let scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop)
                if (scrolledBy > 0) {
                  let availableHeight = window.innerHeight - CONTENT_MARGIN * 2,
                    cssMinHeight = parseFloat(contentWrapper.style.minHeight),
                    cssHeight = parseFloat(contentWrapper.style.height),
                    prevHeight = Math.max(cssMinHeight, cssHeight)
                  if (prevHeight < availableHeight) {
                    let nextHeight = prevHeight + scrolledBy,
                      clampedNextHeight = Math.min(availableHeight, nextHeight),
                      heightDiff = nextHeight - clampedNextHeight
                    contentWrapper.style.height = clampedNextHeight + `px`,
                      contentWrapper.style.bottom === `0px`
                      && (viewport.scrollTop = heightDiff > 0 ? heightDiff : 0,
                        contentWrapper.style.justifyContent = `flex-end`)
                  }
                }
              }
              prevScrollTopRef.current = viewport.scrollTop
            }),
          }),
        }),
      ],
    })
  })
SelectViewport.displayName = VIEWPORT_NAME
var GROUP_NAME = `SelectGroup`,
  [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME),
  SelectGroup = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, ...groupProps } = props, groupId = useId()
    return (0, import_jsx_runtime.jsx)(SelectGroupContextProvider, {
      scope: __scopeSelect,
      id: groupId,
      children: (0, import_jsx_runtime.jsx)(Primitive.div, {
        role: `group`,
        'aria-labelledby': groupId,
        ...groupProps,
        ref: forwardedRef,
      }),
    })
  })
SelectGroup.displayName = GROUP_NAME
var LABEL_NAME = `SelectLabel`,
  SelectLabel = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, ...labelProps } = props, groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect)
    return (0, import_jsx_runtime.jsx)(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef })
  })
SelectLabel.displayName = LABEL_NAME
var ITEM_NAME = `SelectItem`,
  [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME),
  SelectItem = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, value: value$2, disabled = !1, textValue: textValueProp, ...itemProps } = props,
      context$2 = useSelectContext(ITEM_NAME, __scopeSelect),
      contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect),
      isSelected = context$2.value === value$2,
      [textValue, setTextValue] = import_react.useState(textValueProp ?? ``),
      [isFocused, setIsFocused] = import_react.useState(!1),
      composedRefs = useComposedRefs(
        forwardedRef,
        node$1 => contentContext.itemRefCallback?.(node$1, value$2, disabled),
      ),
      textId = useId(),
      pointerTypeRef = import_react.useRef(`touch`),
      handleSelect = () => {
        disabled || (context$2.onValueChange(value$2), context$2.onOpenChange(!1))
      }
    if (value$2 === ``) {
      throw Error(
        `A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.`,
      )
    }
    return (0, import_jsx_runtime.jsx)(SelectItemContextProvider, {
      scope: __scopeSelect,
      value: value$2,
      disabled,
      textId,
      isSelected,
      onItemTextChange: import_react.useCallback(node$1 => {
        setTextValue(prevTextValue => prevTextValue || (node$1?.textContent ?? ``).trim())
      }, []),
      children: (0, import_jsx_runtime.jsx)(Collection.ItemSlot, {
        scope: __scopeSelect,
        value: value$2,
        disabled,
        textValue,
        children: (0, import_jsx_runtime.jsx)(Primitive.div, {
          role: `option`,
          'aria-labelledby': textId,
          'data-highlighted': isFocused ? `` : void 0,
          'aria-selected': isSelected && isFocused,
          'data-state': isSelected ? `checked` : `unchecked`,
          'aria-disabled': disabled || void 0,
          'data-disabled': disabled ? `` : void 0,
          tabIndex: disabled ? void 0 : -1,
          ...itemProps,
          ref: composedRefs,
          onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(!0)),
          onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(!1)),
          onClick: composeEventHandlers(itemProps.onClick, () => {
            pointerTypeRef.current !== `mouse` && handleSelect()
          }),
          onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
            pointerTypeRef.current === `mouse` && handleSelect()
          }),
          onPointerDown: composeEventHandlers(itemProps.onPointerDown, event => {
            pointerTypeRef.current = event.pointerType
          }),
          onPointerMove: composeEventHandlers(itemProps.onPointerMove, event => {
            pointerTypeRef.current = event.pointerType,
              disabled
                ? contentContext.onItemLeave?.()
                : pointerTypeRef.current === `mouse` && event.currentTarget.focus({ preventScroll: !0 })
          }),
          onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, event => {
            event.currentTarget === document.activeElement && contentContext.onItemLeave?.()
          }),
          onKeyDown: composeEventHandlers(itemProps.onKeyDown, event => {
            let isTypingAhead = contentContext.searchRef?.current !== ``
            isTypingAhead && event.key === ` `
              || (SELECTION_KEYS.includes(event.key) && handleSelect(), event.key === ` ` && event.preventDefault())
          }),
        }),
      }),
    })
  })
SelectItem.displayName = ITEM_NAME
var ITEM_TEXT_NAME = `SelectItemText`,
  SelectItemText = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, className, style: style$1, ...itemTextProps } = props,
      context$2 = useSelectContext(ITEM_TEXT_NAME, __scopeSelect),
      contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect),
      itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect),
      nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect),
      [itemTextNode, setItemTextNode] = import_react.useState(null),
      composedRefs = useComposedRefs(
        forwardedRef,
        node$1 => setItemTextNode(node$1),
        itemContext.onItemTextChange,
        node$1 => contentContext.itemTextRefCallback?.(node$1, itemContext.value, itemContext.disabled),
      ),
      textContent = itemTextNode?.textContent,
      nativeOption = import_react.useMemo(
        () =>
          (0, import_jsx_runtime.jsx)(`option`, {
            value: itemContext.value,
            disabled: itemContext.disabled,
            children: textContent,
          }, itemContext.value),
        [itemContext.disabled, itemContext.value, textContent],
      ),
      { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext
    return useLayoutEffect2(() => (onNativeOptionAdd(nativeOption), () => onNativeOptionRemove(nativeOption)), [
      onNativeOptionAdd,
      onNativeOptionRemove,
      nativeOption,
    ]),
      (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: [
          (0, import_jsx_runtime.jsx)(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
          itemContext.isSelected && context$2.valueNode && !context$2.valueNodeHasChildren
            ? import_react_dom.createPortal(itemTextProps.children, context$2.valueNode)
            : null,
        ],
      })
  })
SelectItemText.displayName = ITEM_TEXT_NAME
var ITEM_INDICATOR_NAME = `SelectItemIndicator`,
  SelectItemIndicator = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, ...itemIndicatorProps } = props,
      itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect)
    return itemContext.isSelected
      ? (0, import_jsx_runtime.jsx)(Primitive.span, { 'aria-hidden': !0, ...itemIndicatorProps, ref: forwardedRef })
      : null
  })
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME
var SCROLL_UP_BUTTON_NAME = `SelectScrollUpButton`,
  SelectScrollUpButton = import_react.forwardRef((props, forwardedRef) => {
    let contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect),
      viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect),
      [canScrollUp, setCanScrollUp] = import_react.useState(!1),
      composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange)
    return useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function() {
          let canScrollUp2 = viewport.scrollTop > 0
          setCanScrollUp(canScrollUp2)
        }
        var handleScroll$1 = handleScroll2
        let viewport = contentContext.viewport
        return handleScroll2(),
          viewport.addEventListener(`scroll`, handleScroll2),
          () => viewport.removeEventListener(`scroll`, handleScroll2)
      }
    }, [contentContext.viewport, contentContext.isPositioned]),
      canScrollUp
        ? (0, import_jsx_runtime.jsx)(SelectScrollButtonImpl, {
          ...props,
          ref: composedRefs,
          onAutoScroll: () => {
            let { viewport, selectedItem } = contentContext
            viewport && selectedItem && (viewport.scrollTop -= selectedItem.offsetHeight)
          },
        })
        : null
  })
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME
var SCROLL_DOWN_BUTTON_NAME = `SelectScrollDownButton`,
  SelectScrollDownButton = import_react.forwardRef((props, forwardedRef) => {
    let contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect),
      viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect),
      [canScrollDown, setCanScrollDown] = import_react.useState(!1),
      composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange)
    return useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function() {
          let maxScroll = viewport.scrollHeight - viewport.clientHeight,
            canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll
          setCanScrollDown(canScrollDown2)
        }
        var handleScroll$1 = handleScroll2
        let viewport = contentContext.viewport
        return handleScroll2(),
          viewport.addEventListener(`scroll`, handleScroll2),
          () => viewport.removeEventListener(`scroll`, handleScroll2)
      }
    }, [contentContext.viewport, contentContext.isPositioned]),
      canScrollDown
        ? (0, import_jsx_runtime.jsx)(SelectScrollButtonImpl, {
          ...props,
          ref: composedRefs,
          onAutoScroll: () => {
            let { viewport, selectedItem } = contentContext
            viewport && selectedItem && (viewport.scrollTop += selectedItem.offsetHeight)
          },
        })
        : null
  })
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME
var SelectScrollButtonImpl = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props,
      contentContext = useSelectContentContext(`SelectScrollButton`, __scopeSelect),
      autoScrollTimerRef = import_react.useRef(null),
      getItems = useCollection(__scopeSelect),
      clearAutoScrollTimer = import_react.useCallback(() => {
        autoScrollTimerRef.current !== null
          && (window.clearInterval(autoScrollTimerRef.current), autoScrollTimerRef.current = null)
      }, [])
    return import_react.useEffect(() => () => clearAutoScrollTimer(), [clearAutoScrollTimer]),
      useLayoutEffect2(() => {
        let activeItem = getItems().find(item => item.ref.current === document.activeElement)
        activeItem?.ref.current?.scrollIntoView({ block: `nearest` })
      }, [getItems]),
      (0, import_jsx_runtime.jsx)(Primitive.div, {
        'aria-hidden': !0,
        ...scrollIndicatorProps,
        ref: forwardedRef,
        style: { flexShrink: 0, ...scrollIndicatorProps.style },
        onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
          autoScrollTimerRef.current === null && (autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50))
        }),
        onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
          contentContext.onItemLeave?.(),
            autoScrollTimerRef.current === null && (autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50))
        }),
        onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
          clearAutoScrollTimer()
        }),
      })
  }),
  SEPARATOR_NAME = `SelectSeparator`,
  SelectSeparator = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, ...separatorProps } = props
    return (0, import_jsx_runtime.jsx)(Primitive.div, { 'aria-hidden': !0, ...separatorProps, ref: forwardedRef })
  })
SelectSeparator.displayName = SEPARATOR_NAME
var ARROW_NAME$1 = `SelectArrow`,
  SelectArrow = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeSelect, ...arrowProps } = props,
      popperScope = usePopperScope$1(__scopeSelect),
      context$2 = useSelectContext(ARROW_NAME$1, __scopeSelect),
      contentContext = useSelectContentContext(ARROW_NAME$1, __scopeSelect)
    return context$2.open && contentContext.position === `popper`
      ? (0, import_jsx_runtime.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef })
      : null
  })
SelectArrow.displayName = ARROW_NAME$1
var BUBBLE_INPUT_NAME = `SelectBubbleInput`,
  SelectBubbleInput = import_react.forwardRef(({ __scopeSelect, value: value$2, ...props }, forwardedRef) => {
    let ref = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref),
      prevValue = usePrevious(value$2)
    return import_react.useEffect(() => {
      let select = ref.current
      if (!select) return
      let selectProto = window.HTMLSelectElement.prototype,
        descriptor$2 = Object.getOwnPropertyDescriptor(selectProto, `value`),
        setValue = descriptor$2.set
      if (prevValue !== value$2 && setValue) {
        let event = new Event(`change`, { bubbles: !0 })
        setValue.call(select, value$2), select.dispatchEvent(event)
      }
    }, [prevValue, value$2]),
      (0, import_jsx_runtime.jsx)(Primitive.select, {
        ...props,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        ref: composedRefs,
        defaultValue: value$2,
      })
  })
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME
function shouldShowPlaceholder(value$2) {
  return value$2 === `` || value$2 === void 0
}
function useTypeaheadSearch(onSearchChange) {
  let handleSearchChange = useCallbackRef(onSearchChange),
    searchRef = import_react.useRef(``),
    timerRef = import_react.useRef(0),
    handleTypeaheadSearch = import_react.useCallback(key$1 => {
      let search$1 = searchRef.current + key$1
      handleSearchChange(search$1),
        function updateSearch(value$2) {
          searchRef.current = value$2,
            window.clearTimeout(timerRef.current),
            value$2 !== `` && (timerRef.current = window.setTimeout(() => updateSearch(``), 1e3))
        }(search$1)
    }, [handleSearchChange]),
    resetTypeahead = import_react.useCallback(() => {
      searchRef.current = ``, window.clearTimeout(timerRef.current)
    }, [])
  return import_react.useEffect(() => () => window.clearTimeout(timerRef.current), []),
    [searchRef, handleTypeaheadSearch, resetTypeahead]
}
function findNextItem(items, search$1, currentItem) {
  let isRepeated = search$1.length > 1 && Array.from(search$1).every(char => char === search$1[0]),
    normalizedSearch = isRepeated ? search$1[0] : search$1,
    currentItemIndex = currentItem ? items.indexOf(currentItem) : -1,
    wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0)),
    excludeCurrentItem = normalizedSearch.length === 1
  excludeCurrentItem && (wrappedItems = wrappedItems.filter(v$4 => v$4 !== currentItem))
  let nextItem = wrappedItems.find(item => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase()))
  return nextItem === currentItem ? void 0 : nextItem
}
function wrapArray(array$3, startIndex) {
  return array$3.map((_$1, index$4) => array$3[(startIndex + index$4) % array$3.length])
}
var Root2$1 = Select,
  Trigger$2 = SelectTrigger,
  Value = SelectValue,
  Icon = SelectIcon,
  Portal$2 = SelectPortal,
  Content2$1 = SelectContent,
  Viewport = SelectViewport,
  Group = SelectGroup,
  Label = SelectLabel,
  Item$2 = SelectItem,
  ItemText = SelectItemText,
  ItemIndicator = SelectItemIndicator,
  Separator = SelectSeparator,
  TABS_NAME = `Tabs`,
  [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [createRovingFocusGroupScope]),
  useRovingFocusGroupScope = createRovingFocusGroupScope(),
  [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME),
  Tabs = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopeTabs,
        value: valueProp,
        onValueChange,
        defaultValue,
        orientation = `horizontal`,
        dir,
        activationMode = `automatic`,
        ...tabsProps
      } = props,
      direction = useDirection(dir),
      [value$2, setValue] = useControllableState({
        prop: valueProp,
        onChange: onValueChange,
        defaultProp: defaultValue ?? ``,
        caller: TABS_NAME,
      })
    return (0, import_jsx_runtime.jsx)(TabsProvider, {
      scope: __scopeTabs,
      baseId: useId(),
      value: value$2,
      onValueChange: setValue,
      orientation,
      dir: direction,
      activationMode,
      children: (0, import_jsx_runtime.jsx)(Primitive.div, {
        dir: direction,
        'data-orientation': orientation,
        ...tabsProps,
        ref: forwardedRef,
      }),
    })
  })
Tabs.displayName = TABS_NAME
var TAB_LIST_NAME = `TabsList`,
  TabsList = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeTabs, loop: loop$2 = !0, ...listProps } = props,
      context$2 = useTabsContext(TAB_LIST_NAME, __scopeTabs),
      rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs)
    return (0, import_jsx_runtime.jsx)(Root$1, {
      asChild: !0,
      ...rovingFocusGroupScope,
      orientation: context$2.orientation,
      dir: context$2.dir,
      loop: loop$2,
      children: (0, import_jsx_runtime.jsx)(Primitive.div, {
        role: `tablist`,
        'aria-orientation': context$2.orientation,
        ...listProps,
        ref: forwardedRef,
      }),
    })
  })
TabsList.displayName = TAB_LIST_NAME
var TRIGGER_NAME$1 = `TabsTrigger`,
  TabsTrigger = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeTabs, value: value$2, disabled = !1, ...triggerProps } = props,
      context$2 = useTabsContext(TRIGGER_NAME$1, __scopeTabs),
      rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs),
      triggerId = makeTriggerId(context$2.baseId, value$2),
      contentId = makeContentId(context$2.baseId, value$2),
      isSelected = value$2 === context$2.value
    return (0, import_jsx_runtime.jsx)(Item$3, {
      asChild: !0,
      ...rovingFocusGroupScope,
      focusable: !disabled,
      active: isSelected,
      children: (0, import_jsx_runtime.jsx)(Primitive.button, {
        type: `button`,
        role: `tab`,
        'aria-selected': isSelected,
        'aria-controls': contentId,
        'data-state': isSelected ? `active` : `inactive`,
        'data-disabled': disabled ? `` : void 0,
        disabled,
        id: triggerId,
        ...triggerProps,
        ref: forwardedRef,
        onMouseDown: composeEventHandlers(props.onMouseDown, event => {
          !disabled && event.button === 0 && event.ctrlKey === !1
            ? context$2.onValueChange(value$2)
            : event.preventDefault()
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, event => {
          ;[` `, `Enter`].includes(event.key) && context$2.onValueChange(value$2)
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          let isAutomaticActivation = context$2.activationMode !== `manual`
          !isSelected && !disabled && isAutomaticActivation && context$2.onValueChange(value$2)
        }),
      }),
    })
  })
TabsTrigger.displayName = TRIGGER_NAME$1
var CONTENT_NAME$1 = `TabsContent`,
  TabsContent = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeTabs, value: value$2, forceMount, children: children$3, ...contentProps } = props,
      context$2 = useTabsContext(CONTENT_NAME$1, __scopeTabs),
      triggerId = makeTriggerId(context$2.baseId, value$2),
      contentId = makeContentId(context$2.baseId, value$2),
      isSelected = value$2 === context$2.value,
      isMountAnimationPreventedRef = import_react.useRef(isSelected)
    return import_react.useEffect(() => {
      let rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = !1)
      return () => cancelAnimationFrame(rAF)
    }, []),
      (0, import_jsx_runtime.jsx)(Presence, {
        present: forceMount || isSelected,
        children: ({ present }) =>
          (0, import_jsx_runtime.jsx)(Primitive.div, {
            'data-state': isSelected ? `active` : `inactive`,
            'data-orientation': context$2.orientation,
            role: `tabpanel`,
            'aria-labelledby': triggerId,
            hidden: !present,
            id: contentId,
            tabIndex: 0,
            ...contentProps,
            ref: forwardedRef,
            style: { ...props.style, animationDuration: isMountAnimationPreventedRef.current ? `0s` : void 0 },
            children: present && children$3,
          }),
      })
  })
TabsContent.displayName = CONTENT_NAME$1
function makeTriggerId(baseId, value$2) {
  return `${baseId}-trigger-${value$2}`
}
function makeContentId(baseId, value$2) {
  return `${baseId}-content-${value$2}`
}
var Root2 = Tabs,
  List = TabsList,
  Trigger$1 = TabsTrigger,
  Content = TabsContent,
  [createTooltipContext, createTooltipScope] = createContextScope(`Tooltip`, [createPopperScope]),
  usePopperScope = createPopperScope(),
  PROVIDER_NAME = `TooltipProvider`,
  DEFAULT_DELAY_DURATION = 700,
  TOOLTIP_OPEN = `tooltip.open`,
  [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME),
  TooltipProvider = props => {
    let {
        __scopeTooltip,
        delayDuration = DEFAULT_DELAY_DURATION,
        skipDelayDuration = 300,
        disableHoverableContent = !1,
        children: children$3,
      } = props,
      isOpenDelayedRef = import_react.useRef(!0),
      isPointerInTransitRef = import_react.useRef(!1),
      skipDelayTimerRef = import_react.useRef(0)
    return import_react.useEffect(() => {
      let skipDelayTimer = skipDelayTimerRef.current
      return () => window.clearTimeout(skipDelayTimer)
    }, []),
      (0, import_jsx_runtime.jsx)(TooltipProviderContextProvider, {
        scope: __scopeTooltip,
        isOpenDelayedRef,
        delayDuration,
        onOpen: import_react.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current), isOpenDelayedRef.current = !1
        }, []),
        onClose: import_react.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current),
            skipDelayTimerRef.current = window.setTimeout(() => isOpenDelayedRef.current = !0, skipDelayDuration)
        }, [skipDelayDuration]),
        isPointerInTransitRef,
        onPointerInTransitChange: import_react.useCallback(inTransit => {
          isPointerInTransitRef.current = inTransit
        }, []),
        disableHoverableContent,
        children: children$3,
      })
  }
TooltipProvider.displayName = PROVIDER_NAME
var TOOLTIP_NAME = `Tooltip`,
  [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME),
  Tooltip = props => {
    let {
        __scopeTooltip,
        children: children$3,
        open: openProp,
        defaultOpen,
        onOpenChange,
        disableHoverableContent: disableHoverableContentProp,
        delayDuration: delayDurationProp,
      } = props,
      providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip),
      popperScope = usePopperScope(__scopeTooltip),
      [trigger, setTrigger] = import_react.useState(null),
      contentId = useId(),
      openTimerRef = import_react.useRef(0),
      disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent,
      delayDuration = delayDurationProp ?? providerContext.delayDuration,
      wasOpenDelayedRef = import_react.useRef(!1),
      [open, setOpen] = useControllableState({
        prop: openProp,
        defaultProp: defaultOpen ?? !1,
        onChange: open2 => {
          open2
            ? (providerContext.onOpen(), document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN)))
            : providerContext.onClose(), onOpenChange?.(open2)
        },
        caller: TOOLTIP_NAME,
      }),
      stateAttribute = import_react.useMemo(
        () => open ? wasOpenDelayedRef.current ? `delayed-open` : `instant-open` : `closed`,
        [open],
      ),
      handleOpen = import_react.useCallback(() => {
        window.clearTimeout(openTimerRef.current), openTimerRef.current = 0, wasOpenDelayedRef.current = !1, setOpen(!0)
      }, [setOpen]),
      handleClose = import_react.useCallback(() => {
        window.clearTimeout(openTimerRef.current), openTimerRef.current = 0, setOpen(!1)
      }, [setOpen]),
      handleDelayedOpen = import_react.useCallback(() => {
        window.clearTimeout(openTimerRef.current),
          openTimerRef.current = window.setTimeout(() => {
            wasOpenDelayedRef.current = !0, setOpen(!0), openTimerRef.current = 0
          }, delayDuration)
      }, [delayDuration, setOpen])
    return import_react.useEffect(() => () => {
      openTimerRef.current && (window.clearTimeout(openTimerRef.current), openTimerRef.current = 0)
    }, []),
      (0, import_jsx_runtime.jsx)(Root2$3, {
        ...popperScope,
        children: (0, import_jsx_runtime.jsx)(TooltipContextProvider, {
          scope: __scopeTooltip,
          contentId,
          open,
          stateAttribute,
          trigger,
          onTriggerChange: setTrigger,
          onTriggerEnter: import_react.useCallback(() => {
            providerContext.isOpenDelayedRef.current ? handleDelayedOpen() : handleOpen()
          }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
          onTriggerLeave: import_react.useCallback(() => {
            disableHoverableContent
              ? handleClose()
              : (window.clearTimeout(openTimerRef.current), openTimerRef.current = 0)
          }, [handleClose, disableHoverableContent]),
          onOpen: handleOpen,
          onClose: handleClose,
          disableHoverableContent,
          children: children$3,
        }),
      })
  }
Tooltip.displayName = TOOLTIP_NAME
var TRIGGER_NAME = `TooltipTrigger`,
  TooltipTrigger = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeTooltip, ...triggerProps } = props,
      context$2 = useTooltipContext(TRIGGER_NAME, __scopeTooltip),
      providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip),
      popperScope = usePopperScope(__scopeTooltip),
      ref = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref, context$2.onTriggerChange),
      isPointerDownRef = import_react.useRef(!1),
      hasPointerMoveOpenedRef = import_react.useRef(!1),
      handlePointerUp = import_react.useCallback(() => isPointerDownRef.current = !1, [])
    return import_react.useEffect(() => () => document.removeEventListener(`pointerup`, handlePointerUp), [
      handlePointerUp,
    ]),
      (0, import_jsx_runtime.jsx)(Anchor, {
        asChild: !0,
        ...popperScope,
        children: (0, import_jsx_runtime.jsx)(Primitive.button, {
          'aria-describedby': context$2.open ? context$2.contentId : void 0,
          'data-state': context$2.stateAttribute,
          ...triggerProps,
          ref: composedRefs,
          onPointerMove: composeEventHandlers(props.onPointerMove, event => {
            event.pointerType !== `touch` && !hasPointerMoveOpenedRef.current
              && !providerContext.isPointerInTransitRef.current
              && (context$2.onTriggerEnter(), hasPointerMoveOpenedRef.current = !0)
          }),
          onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
            context$2.onTriggerLeave(), hasPointerMoveOpenedRef.current = !1
          }),
          onPointerDown: composeEventHandlers(props.onPointerDown, () => {
            context$2.open && context$2.onClose(),
              isPointerDownRef.current = !0,
              document.addEventListener(`pointerup`, handlePointerUp, { once: !0 })
          }),
          onFocus: composeEventHandlers(props.onFocus, () => {
            isPointerDownRef.current || context$2.onOpen()
          }),
          onBlur: composeEventHandlers(props.onBlur, context$2.onClose),
          onClick: composeEventHandlers(props.onClick, context$2.onClose),
        }),
      })
  })
TooltipTrigger.displayName = TRIGGER_NAME
var PORTAL_NAME = `TooltipPortal`,
  [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, { forceMount: void 0 }),
  TooltipPortal = props => {
    let { __scopeTooltip, forceMount, children: children$3, container } = props,
      context$2 = useTooltipContext(PORTAL_NAME, __scopeTooltip)
    return (0, import_jsx_runtime.jsx)(PortalProvider, {
      scope: __scopeTooltip,
      forceMount,
      children: (0, import_jsx_runtime.jsx)(Presence, {
        present: forceMount || context$2.open,
        children: (0, import_jsx_runtime.jsx)(Portal, { asChild: !0, container, children: children$3 }),
      }),
    })
  }
TooltipPortal.displayName = PORTAL_NAME
var CONTENT_NAME = `TooltipContent`,
  TooltipContent = import_react.forwardRef((props, forwardedRef) => {
    let portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip),
      { forceMount = portalContext.forceMount, side = `top`, ...contentProps } = props,
      context$2 = useTooltipContext(CONTENT_NAME, props.__scopeTooltip)
    return (0, import_jsx_runtime.jsx)(Presence, {
      present: forceMount || context$2.open,
      children: context$2.disableHoverableContent
        ? (0, import_jsx_runtime.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef })
        : (0, import_jsx_runtime.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }),
    })
  }),
  TooltipContentHoverable = import_react.forwardRef((props, forwardedRef) => {
    let context$2 = useTooltipContext(CONTENT_NAME, props.__scopeTooltip),
      providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip),
      ref = import_react.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, ref),
      [pointerGraceArea, setPointerGraceArea] = import_react.useState(null),
      { trigger, onClose } = context$2,
      content$2 = ref.current,
      { onPointerInTransitChange } = providerContext,
      handleRemoveGraceArea = import_react.useCallback(() => {
        setPointerGraceArea(null), onPointerInTransitChange(!1)
      }, [onPointerInTransitChange]),
      handleCreateGraceArea = import_react.useCallback((event, hoverTarget) => {
        let currentTarget = event.currentTarget,
          exitPoint = { x: event.clientX, y: event.clientY },
          exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect()),
          paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide),
          hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect()),
          graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints])
        setPointerGraceArea(graceArea), onPointerInTransitChange(!0)
      }, [onPointerInTransitChange])
    return import_react.useEffect(() => () => handleRemoveGraceArea(), [handleRemoveGraceArea]),
      import_react.useEffect(() => {
        if (trigger && content$2) {
          let handleTriggerLeave = event => handleCreateGraceArea(event, content$2),
            handleContentLeave = event => handleCreateGraceArea(event, trigger)
          return trigger.addEventListener(`pointerleave`, handleTriggerLeave),
            content$2.addEventListener(`pointerleave`, handleContentLeave),
            () => {
              trigger.removeEventListener(`pointerleave`, handleTriggerLeave),
                content$2.removeEventListener(`pointerleave`, handleContentLeave)
            }
        }
      }, [trigger, content$2, handleCreateGraceArea, handleRemoveGraceArea]),
      import_react.useEffect(() => {
        if (pointerGraceArea) {
          let handleTrackPointerGrace = event => {
            let target = event.target,
              pointerPosition = { x: event.clientX, y: event.clientY },
              hasEnteredTarget = trigger?.contains(target) || content$2?.contains(target),
              isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea)
            hasEnteredTarget
              ? handleRemoveGraceArea()
              : isPointerOutsideGraceArea && (handleRemoveGraceArea(), onClose())
          }
          return document.addEventListener(`pointermove`, handleTrackPointerGrace),
            () => document.removeEventListener(`pointermove`, handleTrackPointerGrace)
        }
      }, [trigger, content$2, pointerGraceArea, onClose, handleRemoveGraceArea]),
      (0, import_jsx_runtime.jsx)(TooltipContentImpl, { ...props, ref: composedRefs })
  }),
  [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, {
    isInside: !1,
  }),
  Slottable = createSlottable(`TooltipContent`),
  TooltipContentImpl = import_react.forwardRef((props, forwardedRef) => {
    let {
        __scopeTooltip,
        children: children$3,
        'aria-label': ariaLabel,
        onEscapeKeyDown,
        onPointerDownOutside,
        ...contentProps
      } = props,
      context$2 = useTooltipContext(CONTENT_NAME, __scopeTooltip),
      popperScope = usePopperScope(__scopeTooltip),
      { onClose } = context$2
    return import_react.useEffect(
      () => (document.addEventListener(TOOLTIP_OPEN, onClose),
        () => document.removeEventListener(TOOLTIP_OPEN, onClose)),
      [onClose],
    ),
      import_react.useEffect(() => {
        if (context$2.trigger) {
          let handleScroll$1 = event => {
            let target = event.target
            target?.contains(context$2.trigger) && onClose()
          }
          return window.addEventListener(`scroll`, handleScroll$1, { capture: !0 }),
            () => window.removeEventListener(`scroll`, handleScroll$1, { capture: !0 })
        }
      }, [context$2.trigger, onClose]),
      (0, import_jsx_runtime.jsx)(DismissableLayer, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: event => event.preventDefault(),
        onDismiss: onClose,
        children: (0, import_jsx_runtime.jsxs)(Content$1, {
          'data-state': context$2.stateAttribute,
          ...popperScope,
          ...contentProps,
          ref: forwardedRef,
          style: {
            ...contentProps.style,
            '--radix-tooltip-content-transform-origin': `var(--radix-popper-transform-origin)`,
            '--radix-tooltip-content-available-width': `var(--radix-popper-available-width)`,
            '--radix-tooltip-content-available-height': `var(--radix-popper-available-height)`,
            '--radix-tooltip-trigger-width': `var(--radix-popper-anchor-width)`,
            '--radix-tooltip-trigger-height': `var(--radix-popper-anchor-height)`,
          },
          children: [
            (0, import_jsx_runtime.jsx)(Slottable, { children: children$3 }),
            (0, import_jsx_runtime.jsx)(VisuallyHiddenContentContextProvider, {
              scope: __scopeTooltip,
              isInside: !0,
              children: (0, import_jsx_runtime.jsx)(Root$3, {
                id: context$2.contentId,
                role: `tooltip`,
                children: ariaLabel || children$3,
              }),
            }),
          ],
        }),
      })
  })
TooltipContent.displayName = CONTENT_NAME
var ARROW_NAME = `TooltipArrow`,
  TooltipArrow = import_react.forwardRef((props, forwardedRef) => {
    let { __scopeTooltip, ...arrowProps } = props,
      popperScope = usePopperScope(__scopeTooltip),
      visuallyHiddenContentContext = useVisuallyHiddenContentContext(ARROW_NAME, __scopeTooltip)
    return visuallyHiddenContentContext.isInside
      ? null
      : (0, import_jsx_runtime.jsx)(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef })
  })
TooltipArrow.displayName = ARROW_NAME
function getExitSideFromRect(point$3, rect) {
  let top = Math.abs(rect.top - point$3.y),
    bottom = Math.abs(rect.bottom - point$3.y),
    right$2 = Math.abs(rect.right - point$3.x),
    left$2 = Math.abs(rect.left - point$3.x)
  switch (Math.min(top, bottom, right$2, left$2)) {
    case left$2:
      return `left`
    case right$2:
      return `right`
    case top:
      return `top`
    case bottom:
      return `bottom`
    default:
      throw Error(`unreachable`)
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  let paddedExitPoints = []
  switch (exitSide) {
    case `top`:
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y + padding }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding,
      })
      break
    case `bottom`:
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, {
        x: exitPoint.x + padding,
        y: exitPoint.y - padding,
      })
      break
    case `left`:
      paddedExitPoints.push({ x: exitPoint.x + padding, y: exitPoint.y - padding }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding,
      })
      break
    case `right`:
      paddedExitPoints.push({ x: exitPoint.x - padding, y: exitPoint.y - padding }, {
        x: exitPoint.x - padding,
        y: exitPoint.y + padding,
      })
      break
  }
  return paddedExitPoints
}
function getPointsFromRect(rect) {
  let { top, right: right$2, bottom, left: left$2 } = rect
  return [{ x: left$2, y: top }, { x: right$2, y: top }, { x: right$2, y: bottom }, { x: left$2, y: bottom }]
}
function isPointInPolygon(point$3, polygon) {
  let { x: x$2, y: y$3 } = point$3, inside = !1
  for (let i$14 = 0, j$1 = polygon.length - 1; i$14 < polygon.length; j$1 = i$14++) {
    let ii = polygon[i$14],
      jj = polygon[j$1],
      xi = ii.x,
      yi = ii.y,
      xj = jj.x,
      yj = jj.y,
      intersect$5 = yi > y$3 != yj > y$3 && x$2 < (xj - xi) * (y$3 - yi) / (yj - yi) + xi
    intersect$5 && (inside = !inside)
  }
  return inside
}
function getHull(points) {
  let newPoints = points.slice()
  return newPoints.sort((a$22, b$3) =>
    a$22.x < b$3.x ? -1 : a$22.x > b$3.x ? 1 : a$22.y < b$3.y ? -1 : a$22.y > b$3.y ? 1 : 0
  ),
    getHullPresorted(newPoints)
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice()
  let upperHull = []
  for (let i$14 = 0; i$14 < points.length; i$14++) {
    let p$25 = points[i$14]
    for (; upperHull.length >= 2;) {
      let q$1 = upperHull[upperHull.length - 1], r$26 = upperHull[upperHull.length - 2]
      if ((q$1.x - r$26.x) * (p$25.y - r$26.y) >= (q$1.y - r$26.y) * (p$25.x - r$26.x)) upperHull.pop()
      else break
    }
    upperHull.push(p$25)
  }
  upperHull.pop()
  let lowerHull = []
  for (let i$14 = points.length - 1; i$14 >= 0; i$14--) {
    let p$25 = points[i$14]
    for (; lowerHull.length >= 2;) {
      let q$1 = lowerHull[lowerHull.length - 1], r$26 = lowerHull[lowerHull.length - 2]
      if ((q$1.x - r$26.x) * (p$25.y - r$26.y) >= (q$1.y - r$26.y) * (p$25.x - r$26.x)) lowerHull.pop()
      else break
    }
    lowerHull.push(p$25)
  }
  return lowerHull.pop(),
    upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x
      && upperHull[0].y === lowerHull[0].y
      ? upperHull
      : upperHull.concat(lowerHull)
}
var Provider = TooltipProvider,
  Root3 = Tooltip,
  Trigger = TooltipTrigger,
  Portal$1 = TooltipPortal,
  Content2 = TooltipContent,
  Arrow2 = TooltipArrow,
  import_classnames$27 = __toESM(require_classnames())
const r = import_react.forwardRef((p$25, t$18) => {
  let { children: e$26, className: s$14, asChild: a$22, as: n$19 = `h1`, color: i$14, ...m$12 } = v$1(p$25, n$12, r$4)
  return import_react.createElement(Slot$2, {
    'data-accent-color': i$14,
    ...m$12,
    ref: t$18,
    className: (0, import_classnames$27.default)(`rt-Heading`, s$14),
  }, a$22 ? e$26 : import_react.createElement(n$19, null, e$26))
})
r.displayName = `Heading`
var import_classnames$26 = __toESM(require_classnames())
const p$2 = import_react.forwardRef((t$18, r$26) => {
  let { children: e$26, className: s$14, asChild: m$12, as: a$22 = `span`, color: n$19, ...P$5 } = v$1(t$18, n$11, r$4)
  return import_react.createElement(Slot$2, {
    'data-accent-color': n$19,
    ...P$5,
    ref: r$26,
    className: (0, import_classnames$26.default)(`rt-Text`, s$14),
  }, m$12 ? e$26 : import_react.createElement(a$22, null, e$26))
})
p$2.displayName = `Text`
var import_classnames$25 = __toESM(require_classnames())
const d$5 = () => {}, P$4 = import_react.createContext(void 0)
function H$1() {
  let a$22 = import_react.useContext(P$4)
  if (a$22 === void 0) throw Error('`useThemeContext` must be used within a `Theme`')
  return a$22
}
const R = import_react.forwardRef((a$22, s$14) =>
  import_react.useContext(P$4) === void 0
    ? import_react.createElement(
      Provider,
      { delayDuration: 200 },
      import_react.createElement(Provider$1, { dir: `ltr` }, import_react.createElement(I$2, { ...a$22, ref: s$14 })),
    )
    : import_react.createElement(A$1, { ...a$22, ref: s$14 })
)
R.displayName = `Theme`
const I$2 = import_react.forwardRef((a$22, s$14) => {
  let {
      appearance: r$26 = s$10.appearance.default,
      accentColor: c$3 = s$10.accentColor.default,
      grayColor: l$9 = s$10.grayColor.default,
      panelBackground: p$25 = s$10.panelBackground.default,
      radius: n$19 = s$10.radius.default,
      scaling: t$18 = s$10.scaling.default,
      hasBackground: i$14 = s$10.hasBackground.default,
      ...u$7
    } = a$22,
    [h$2, m$12] = import_react.useState(r$26)
  import_react.useEffect(() => m$12(r$26), [r$26])
  let [y$3, g$3] = import_react.useState(c$3)
  import_react.useEffect(() => g$3(c$3), [c$3])
  let [v$4, C$4] = import_react.useState(l$9)
  import_react.useEffect(() => C$4(l$9), [l$9])
  let [k$1, f$14] = import_react.useState(p$25)
  import_react.useEffect(() => f$14(p$25), [p$25])
  let [B$2, x$2] = import_react.useState(n$19)
  import_react.useEffect(() => x$2(n$19), [n$19])
  let [T$2, b$3] = import_react.useState(t$18)
  return import_react.useEffect(() => b$3(t$18), [t$18]),
    import_react.createElement(A$1, {
      ...u$7,
      ref: s$14,
      isRoot: !0,
      hasBackground: i$14,
      appearance: h$2,
      accentColor: y$3,
      grayColor: v$4,
      panelBackground: k$1,
      radius: B$2,
      scaling: T$2,
      onAppearanceChange: m$12,
      onAccentColorChange: g$3,
      onGrayColorChange: C$4,
      onPanelBackgroundChange: f$14,
      onRadiusChange: x$2,
      onScalingChange: b$3,
    })
})
I$2.displayName = `ThemeRoot`
const A$1 = import_react.forwardRef((a$22, s$14) => {
  let r$26 = import_react.useContext(P$4),
    {
      asChild: c$3,
      isRoot: l$9,
      hasBackground: p$25,
      appearance: n$19 = r$26?.appearance ?? s$10.appearance.default,
      accentColor: t$18 = r$26?.accentColor ?? s$10.accentColor.default,
      grayColor: i$14 = r$26?.resolvedGrayColor ?? s$10.grayColor.default,
      panelBackground: u$7 = r$26?.panelBackground ?? s$10.panelBackground.default,
      radius: h$2 = r$26?.radius ?? s$10.radius.default,
      scaling: m$12 = r$26?.scaling ?? s$10.scaling.default,
      onAppearanceChange: y$3 = d$5,
      onAccentColorChange: g$3 = d$5,
      onGrayColorChange: v$4 = d$5,
      onPanelBackgroundChange: C$4 = d$5,
      onRadiusChange: k$1 = d$5,
      onScalingChange: f$14 = d$5,
      ...B$2
    } = a$22,
    x$2 = c$3 ? Slot$2 : `div`,
    T$2 = i$14 === `auto` ? a$10(t$18) : i$14,
    b$3 = a$22.appearance === `light` || a$22.appearance === `dark`,
    S$2 = p$25 === void 0 ? l$9 || b$3 : p$25
  return import_react.createElement(
    P$4.Provider,
    {
      value: import_react.useMemo(() => ({
        appearance: n$19,
        accentColor: t$18,
        grayColor: i$14,
        resolvedGrayColor: T$2,
        panelBackground: u$7,
        radius: h$2,
        scaling: m$12,
        onAppearanceChange: y$3,
        onAccentColorChange: g$3,
        onGrayColorChange: v$4,
        onPanelBackgroundChange: C$4,
        onRadiusChange: k$1,
        onScalingChange: f$14,
      }), [n$19, t$18, i$14, T$2, u$7, h$2, m$12, y$3, g$3, v$4, C$4, k$1, f$14]),
    },
    import_react.createElement(x$2, {
      'data-is-root-theme': l$9 ? `true` : `false`,
      'data-accent-color': t$18,
      'data-gray-color': T$2,
      'data-has-background': S$2 ? `true` : `false`,
      'data-panel-background': u$7,
      'data-radius': h$2,
      'data-scaling': m$12,
      ref: s$14,
      ...B$2,
      className: (0, import_classnames$25.default)(
        `radix-themes`,
        { light: n$19 === `light`, dark: n$19 === `dark` },
        B$2.className,
      ),
    }),
  )
})
A$1.displayName = `ThemeImpl`
var import_classnames$24 = __toESM(require_classnames())
const e = import_react.forwardRef((r$26, p$25) => {
  let { asChild: t$18, className: s$14, color: a$22, radius: m$12, ...n$19 } = v$1(r$26, p$14, r$4),
    d$7 = t$18 ? Slot$2 : `span`
  return import_react.createElement(d$7, {
    'data-accent-color': a$22,
    'data-radius': m$12,
    ...n$19,
    ref: p$25,
    className: (0, import_classnames$24.default)(`rt-reset`, `rt-Badge`, s$14),
  })
})
e.displayName = `Badge`
const l$4 = Slot$2, e$8 = Slot$2, r$9 = Slottable$1
var import_classnames$23 = __toESM(require_classnames())
const p = import_react.forwardRef((r$26, s$14) => {
  let { className: t$18, asChild: e$26, as: m$12 = `div`, ...a$22 } = v$1(r$26, p$13, u$3, r$4)
  return import_react.createElement(e$26 ? e$8 : m$12, {
    ...a$22,
    ref: s$14,
    className: (0, import_classnames$23.default)(`rt-Box`, t$18),
  })
})
p.displayName = `Box`
var import_classnames$22 = __toESM(require_classnames())
const p$1 = import_react.forwardRef((r$26, e$26) => {
  let { className: s$14, asChild: t$18, as: m$12 = `div`, ...l$9 } = v$1(r$26, u$5, u$3, r$4)
  return import_react.createElement(t$18 ? e$8 : m$12, {
    ...l$9,
    ref: e$26,
    className: (0, import_classnames$22.default)(`rt-Flex`, s$14),
  })
})
p$1.displayName = `Flex`
var import_classnames$21 = __toESM(require_classnames())
const s$8 = import_react.forwardRef((i$14, o$18) => {
  let { className: a$22, children: e$26, loading: t$18, ...m$12 } = v$1(i$14, s$9, r$4)
  if (!t$18) return e$26
  let r$26 = import_react.createElement(
    `span`,
    { ...m$12, ref: o$18, className: (0, import_classnames$21.default)(`rt-Spinner`, a$22) },
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
    import_react.createElement(`span`, { className: `rt-SpinnerLeaf` }),
  )
  return e$26 === void 0
    ? r$26
    : import_react.createElement(
      p$1,
      { asChild: !0, position: `relative`, align: `center`, justify: `center` },
      import_react.createElement(
        `span`,
        null,
        import_react.createElement(`span`, {
          'aria-hidden': !0,
          style: { display: `contents`, visibility: `hidden` },
          inert: void 0,
        }, e$26),
        import_react.createElement(p$1, {
          asChild: !0,
          align: `center`,
          justify: `center`,
          position: `absolute`,
          inset: `0`,
        }, import_react.createElement(`span`, null, r$26)),
      ),
    )
})
s$8.displayName = `Spinner`
const d$4 = Root$3, e$9 = Root$3
var import_classnames$20 = __toESM(require_classnames())
const n$5 = import_react.forwardRef((t$18, p$25) => {
  let { size: i$14 = i$6.size.default } = t$18,
    { className: a$22, children: e$26, asChild: m$12, color: d$7, radius: l$9, disabled: s$14 = t$18.loading, ...u$7 } =
      v$1(t$18, i$6, r$4),
    f$14 = m$12 ? Slot$2 : `button`
  return import_react.createElement(
    f$14,
    {
      'data-disabled': s$14 || void 0,
      'data-accent-color': d$7,
      'data-radius': l$9,
      ...u$7,
      ref: p$25,
      className: (0, import_classnames$20.default)(`rt-reset`, `rt-BaseButton`, a$22),
      disabled: s$14,
    },
    t$18.loading
      ? import_react.createElement(
        import_react.Fragment,
        null,
        import_react.createElement(
          `span`,
          { style: { display: `contents`, visibility: `hidden` }, 'aria-hidden': !0 },
          e$26,
        ),
        import_react.createElement(d$4, null, e$26),
        import_react.createElement(p$1, {
          asChild: !0,
          align: `center`,
          justify: `center`,
          position: `absolute`,
          inset: `0`,
        }, import_react.createElement(`span`, null, import_react.createElement(s$8, { size: s$6(i$14, r$8) }))),
      )
      : e$26,
  )
})
n$5.displayName = `BaseButton`
var import_classnames$19 = __toESM(require_classnames())
const o$3 = import_react.forwardRef(({ className: e$26, ...n$19 }, r$26) =>
  import_react.createElement(n$5, {
    ...n$19,
    ref: r$26,
    className: (0, import_classnames$19.default)(`rt-Button`, e$26),
  })
)
o$3.displayName = `Button`
var callout_exports = {}
__export(callout_exports, { Icon: () => m$7, Root: () => n$9, Text: () => u$4 })
var import_classnames$18 = __toESM(require_classnames())
const a$8 = import_react.createContext({}),
  n$9 = import_react.forwardRef((t$18, l$9) => {
    let { size: e$26 = a$7.size.default } = t$18,
      { asChild: r$26, children: C$4, className: i$14, color: c$3, ...f$14 } = v$1(t$18, a$7, r$4),
      P$5 = r$26 ? Slot$2 : `div`
    return import_react.createElement(P$5, {
      'data-accent-color': c$3,
      ...f$14,
      className: (0, import_classnames$18.default)(`rt-CalloutRoot`, i$14),
      ref: l$9,
    }, import_react.createElement(a$8.Provider, { value: import_react.useMemo(() => ({ size: e$26 }), [e$26]) }, C$4))
  })
n$9.displayName = `Callout.Root`
const m$7 = import_react.forwardRef(({ className: t$18, ...l$9 }, e$26) =>
  import_react.createElement(`div`, {
    ...l$9,
    className: (0, import_classnames$18.default)(`rt-CalloutIcon`, t$18),
    ref: e$26,
  })
)
m$7.displayName = `Callout.Icon`
const u$4 = import_react.forwardRef(({ className: t$18, ...l$9 }, e$26) => {
  let { size: r$26 } = import_react.useContext(a$8)
  return import_react.createElement(p$2, {
    as: `p`,
    size: s$6(r$26, p$12),
    ...l$9,
    asChild: !1,
    ref: e$26,
    className: (0, import_classnames$18.default)(`rt-CalloutText`, t$18),
  })
})
u$4.displayName = `Callout.Text`
var import_classnames$17 = __toESM(require_classnames())
const o = import_react.forwardRef((p$25, e$26) => {
  let { asChild: t$18, className: s$14, ...a$22 } = v$1(p$25, a$6, r$4), m$12 = t$18 ? Slot$2 : `div`
  return import_react.createElement(m$12, {
    ref: e$26,
    ...a$22,
    className: (0, import_classnames$17.default)(`rt-reset`, `rt-BaseCard`, `rt-Card`, s$14),
  })
})
o.displayName = `Card`
var import_classnames$16 = __toESM(require_classnames())
const o$4 = import_react.forwardRef((p$25, s$14) => {
  let { className: t$18, asChild: e$26, as: i$14 = `div`, ...m$12 } = v$1(p$25, s$4, u$3, r$4)
  return import_react.createElement(e$26 ? e$8 : i$14, {
    ...m$12,
    ref: s$14,
    className: (0, import_classnames$16.default)(`rt-Grid`, t$18),
  })
})
o$4.displayName = `Grid`
const r$7 = import_react.forwardRef((e$26, n$19) =>
  import_react.createElement(
    `svg`,
    {
      width: `9`,
      height: `9`,
      viewBox: `0 0 9 9`,
      fill: `currentcolor`,
      xmlns: `http://www.w3.org/2000/svg`,
      ...e$26,
      ref: n$19,
    },
    import_react.createElement(`path`, {
      fillRule: `evenodd`,
      clipRule: `evenodd`,
      d: `M0.75 4.5C0.75 4.08579 1.08579 3.75 1.5 3.75H7.5C7.91421 3.75 8.25 4.08579 8.25 4.5C8.25 4.91421 7.91421 5.25 7.5 5.25H1.5C1.08579 5.25 0.75 4.91421 0.75 4.5Z`,
    }),
  )
)
r$7.displayName = `ThickDividerHorizontalIcon`
const t$3 = import_react.forwardRef((e$26, n$19) =>
  import_react.createElement(
    `svg`,
    {
      width: `9`,
      height: `9`,
      viewBox: `0 0 9 9`,
      fill: `currentcolor`,
      xmlns: `http://www.w3.org/2000/svg`,
      ...e$26,
      ref: n$19,
    },
    import_react.createElement(`path`, {
      fillRule: `evenodd`,
      clipRule: `evenodd`,
      d: `M8.53547 0.62293C8.88226 0.849446 8.97976 1.3142 8.75325 1.66099L4.5083 8.1599C4.38833 8.34356 4.19397 8.4655 3.9764 8.49358C3.75883 8.52167 3.53987 8.45309 3.3772 8.30591L0.616113 5.80777C0.308959 5.52987 0.285246 5.05559 0.563148 4.74844C0.84105 4.44128 1.31533 4.41757 1.62249 4.69547L3.73256 6.60459L7.49741 0.840706C7.72393 0.493916 8.18868 0.396414 8.53547 0.62293Z`,
    }),
  )
)
t$3.displayName = `ThickCheckIcon`
const i$2 = import_react.forwardRef((e$26, n$19) =>
  import_react.createElement(
    `svg`,
    {
      width: `9`,
      height: `9`,
      viewBox: `0 0 9 9`,
      fill: `currentcolor`,
      xmlns: `http://www.w3.org/2000/svg`,
      ...e$26,
      ref: n$19,
    },
    import_react.createElement(`path`, {
      d: `M0.135232 3.15803C0.324102 2.95657 0.640521 2.94637 0.841971 3.13523L4.5 6.56464L8.158 3.13523C8.3595 2.94637 8.6759 2.95657 8.8648 3.15803C9.0536 3.35949 9.0434 3.67591 8.842 3.86477L4.84197 7.6148C4.64964 7.7951 4.35036 7.7951 4.15803 7.6148L0.158031 3.86477C-0.0434285 3.67591 -0.0536285 3.35949 0.135232 3.15803Z`,
    }),
  )
)
i$2.displayName = `ChevronDownIcon`
const l$3 = import_react.forwardRef((e$26, n$19) =>
  import_react.createElement(
    `svg`,
    {
      width: `9`,
      height: `9`,
      viewBox: `0 0 9 9`,
      fill: `currentcolor`,
      xmlns: `http://www.w3.org/2000/svg`,
      ...e$26,
      ref: n$19,
    },
    import_react.createElement(`path`, {
      fillRule: `evenodd`,
      clipRule: `evenodd`,
      d: `M3.23826 0.201711C3.54108 -0.0809141 4.01567 -0.0645489 4.29829 0.238264L7.79829 3.98826C8.06724 4.27642 8.06724 4.72359 7.79829 5.01174L4.29829 8.76174C4.01567 9.06455 3.54108 9.08092 3.23826 8.79829C2.93545 8.51567 2.91909 8.04108 3.20171 7.73826L6.22409 4.5L3.20171 1.26174C2.91909 0.958928 2.93545 0.484337 3.23826 0.201711Z`,
    }),
  )
)
l$3.displayName = `ThickChevronRightIcon`
var import_classnames$15 = __toESM(require_classnames())
const p$3 = import_react.forwardRef((o$18, t$18) => {
  let { asChild: s$14, className: m$12, color: e$26, ...d$7 } = v$1(o$18, f$7, r$4),
    n$19 = o$18.variant === `ghost` ? e$26 || void 0 : e$26,
    a$22 = s$14 ? Slot$2 : `code`
  return import_react.createElement(a$22, {
    'data-accent-color': n$19,
    ...d$7,
    ref: t$18,
    className: (0, import_classnames$15.default)(`rt-reset`, `rt-Code`, m$12),
  })
})
p$3.displayName = `Code`
var import_classnames$14 = __toESM(require_classnames())
const p$5 = import_react.forwardRef(
  ({ width: n$19, minWidth: s$14, maxWidth: i$14, height: m$12, minHeight: a$22, maxHeight: f$14, ...P$5 }, l$9) => {
    let { asChild: r$26, children: C$4, className: c$3, ...y$3 } = v$1(P$5, n$8, u$3, r$4),
      { className: d$7, style: h$2 } = v$1(
        { width: n$19, minWidth: s$14, maxWidth: i$14, height: m$12, minHeight: a$22, maxHeight: f$14 },
        t$8,
        e$7,
      ),
      u$7 = r$26 ? Slot$2 : `div`
    return import_react.createElement(
      u$7,
      { ...y$3, ref: l$9, className: (0, import_classnames$14.default)(`rt-Container`, c$3) },
      d$2({ asChild: r$26, children: C$4 }, v$4 =>
        import_react.createElement(`div`, {
          className: (0, import_classnames$14.default)(`rt-ContainerInner`, d$7),
          style: h$2,
        }, v$4)),
    )
  },
)
p$5.displayName = `Container`
var import_classnames$13 = __toESM(require_classnames())
const c$1 = import_react.forwardRef((n$19, S$2) => {
  let { rest: f$14, ...P$5 } = a$4(n$19),
    [u$7, A$2] = S$1(P$5),
    {
      asChild: a$22,
      children: d$7,
      className: y$3,
      style: v$4,
      type: t$18,
      scrollHideDelay: N$2 = t$18 === `scroll` ? void 0 : 0,
      dir: V$1,
      size: i$14 = t$6.size.default,
      radius: p$25 = t$6.radius.default,
      scrollbars: l$9 = t$6.scrollbars.default,
      ...b$3
    } = f$14
  return import_react.createElement(
    Root,
    {
      type: t$18,
      scrollHideDelay: N$2,
      className: (0, import_classnames$13.default)(`rt-ScrollAreaRoot`, u$7, y$3),
      style: l$2(A$2, v$4),
      asChild: a$22,
    },
    d$2({ asChild: a$22, children: d$7 }, g$3 =>
      import_react.createElement(
        import_react.Fragment,
        null,
        import_react.createElement(Viewport$1, { ...b$3, ref: S$2, className: `rt-ScrollAreaViewport` }, g$3),
        import_react.createElement(`div`, { className: `rt-ScrollAreaViewportFocusRing` }),
        l$9 === `vertical`
          ? null
          : import_react.createElement(Scrollbar, {
            'data-radius': p$25,
            orientation: `horizontal`,
            className: (0, import_classnames$13.default)(
              `rt-ScrollAreaScrollbar`,
              g$1({ className: `rt-r-size`, value: i$14, propValues: t$6.size.values }),
            ),
          }, import_react.createElement(Thumb, { className: `rt-ScrollAreaThumb` })),
        l$9 === `horizontal`
          ? null
          : import_react.createElement(Scrollbar, {
            'data-radius': p$25,
            orientation: `vertical`,
            className: (0, import_classnames$13.default)(
              `rt-ScrollAreaScrollbar`,
              g$1({ className: `rt-r-size`, value: i$14, propValues: t$6.size.values }),
            ),
          }, import_react.createElement(Thumb, { className: `rt-ScrollAreaThumb` })),
        l$9 === `both` ? import_react.createElement(Corner, { className: `rt-ScrollAreaCorner` }) : null,
      )),
  )
})
c$1.displayName = `ScrollArea`
var data_list_exports = {}
__export(data_list_exports, { Item: () => m$6, Label: () => L$1, Root: () => i$5, Value: () => l$1 })
var import_classnames$12 = __toESM(require_classnames())
const i$5 = import_react.forwardRef((a$22, e$26) => {
  let { className: s$14, ...o$18 } = v$1(a$22, n$7, r$4)
  return import_react.createElement(
    p$2,
    { asChild: !0 },
    import_react.createElement(`dl`, {
      ...o$18,
      ref: e$26,
      className: (0, import_classnames$12.default)(`rt-DataListRoot`, s$14),
    }),
  )
})
i$5.displayName = `DataList.Root`
const m$6 = import_react.forwardRef((a$22, e$26) => {
  let { className: s$14, ...o$18 } = v$1(a$22, p$11)
  return import_react.createElement(`div`, {
    ...o$18,
    ref: e$26,
    className: (0, import_classnames$12.default)(`rt-DataListItem`, s$14),
  })
})
m$6.displayName = `DataList.Item`
const L$1 = import_react.forwardRef((a$22, e$26) => {
  let { className: s$14, color: o$18, ...n$19 } = v$1(a$22, m$5)
  return import_react.createElement(`dt`, {
    ...n$19,
    'data-accent-color': o$18,
    ref: e$26,
    className: (0, import_classnames$12.default)(`rt-DataListLabel`, s$14),
  })
})
L$1.displayName = `DataList.Label`
const l$1 = import_react.forwardRef(({ children: a$22, className: e$26, ...s$14 }, o$18) =>
  import_react.createElement(`dd`, {
    ...s$14,
    ref: o$18,
    className: (0, import_classnames$12.default)(e$26, `rt-DataListValue`),
  }, a$22)
)
l$1.displayName = `DataList.Value`
var import_classnames$11 = __toESM(require_classnames())
const e$2 = import_react.forwardRef((p$25, m$12) => {
  let { asChild: r$26, className: t$18, ...s$14 } = v$1(p$25, t$5), f$14 = r$26 ? Slot$2 : `em`
  return import_react.createElement(f$14, {
    ...s$14,
    ref: m$12,
    className: (0, import_classnames$11.default)(`rt-Em`, t$18),
  })
})
e$2.displayName = `Em`
var import_classnames$10 = __toESM(require_classnames())
const o$2 = import_react.forwardRef(({ className: e$26, ...n$19 }, r$26) =>
  import_react.createElement(n$5, {
    ...n$19,
    ref: r$26,
    className: (0, import_classnames$10.default)(`rt-IconButton`, e$26),
  })
)
o$2.displayName = `IconButton`
var import_classnames$9 = __toESM(require_classnames())
const e$1 = import_react.forwardRef((p$25, t$18) => {
  let { children: r$26, className: s$14, color: n$19, asChild: i$14, ...m$12 } = v$1(p$25, m$4)
  return import_react.createElement(p$2, {
    ...m$12,
    'data-accent-color': n$19,
    ref: t$18,
    asChild: !0,
    className: (0, import_classnames$9.default)(`rt-reset`, `rt-Link`, s$14),
  }, i$14 ? r$26 : import_react.createElement(`a`, null, r$26))
})
e$1.displayName = `Link`
var import_classnames$8 = __toESM(require_classnames())
const P$3 = e$26 => import_react.createElement(Root2$2, { ...e$26 })
P$3.displayName = `Popover.Root`
const s$1 = import_react.forwardRef(({ children: e$26, ...r$26 }, t$18) =>
  import_react.createElement(Trigger$3, { ...r$26, ref: t$18, asChild: !0 }, a$2(e$26))
)
s$1.displayName = `Popover.Trigger`
const i$4 = import_react.forwardRef((e$26, r$26) => {
  let { className: t$18, forceMount: a$22, container: f$14, ...l$9 } = v$1(e$26, r$5)
  return import_react.createElement(
    Portal$3,
    { container: f$14, forceMount: a$22 },
    import_react.createElement(
      R,
      { asChild: !0 },
      import_react.createElement(Content2$2, {
        align: `start`,
        sideOffset: 8,
        collisionPadding: 10,
        ...l$9,
        ref: r$26,
        className: (0, import_classnames$8.default)(`rt-PopperContent`, `rt-PopoverContent`, t$18),
      }),
    ),
  )
})
i$4.displayName = `Popover.Content`
const v$3 = import_react.forwardRef(({ children: e$26, ...r$26 }, t$18) =>
  import_react.createElement(Close, { ...r$26, ref: t$18, asChild: !0 }, a$2(e$26))
)
v$3.displayName = `Popover.Close`
const m$3 = import_react.forwardRef(({ children: e$26, ...r$26 }, t$18) =>
  import_react.createElement(Anchor2, { ...r$26, ref: t$18 })
)
m$3.displayName = `Popover.Anchor`
var import_classnames$7 = __toESM(require_classnames())
const e$3 = import_react.forwardRef((t$18, p$25) => {
  let { asChild: r$26, className: s$14, ...m$12 } = v$1(t$18, p$10), f$14 = r$26 ? Slot$2 : `q`
  return import_react.createElement(f$14, {
    ...m$12,
    ref: p$25,
    className: (0, import_classnames$7.default)(`rt-Quote`, s$14),
  })
})
e$3.displayName = `Quote`
var import_classnames$6 = __toESM(require_classnames())
const r$1 = import_react.forwardRef((t$18, p$25) => {
  let { asChild: e$26, className: s$14, ...m$12 } = v$1(t$18, t$4, u$3, r$4), i$14 = e$26 ? Slot$2 : `section`
  return import_react.createElement(i$14, {
    ...m$12,
    ref: p$25,
    className: (0, import_classnames$6.default)(`rt-Section`, s$14),
  })
})
r$1.displayName = `Section`
var import_classnames$5 = __toESM(require_classnames())
const f$5 = import_react.createContext({}),
  C$2 = r$26 => {
    let { children: o$18, size: t$18 = o$6.size.default, ...s$14 } = r$26
    return import_react.createElement(
      Root2$1,
      { ...s$14 },
      import_react.createElement(f$5.Provider, { value: import_react.useMemo(() => ({ size: t$18 }), [t$18]) }, o$18),
    )
  }
C$2.displayName = `Select.Root`
const u$2 = import_react.forwardRef((r$26, o$18) => {
  let t$18 = import_react.useContext(f$5),
    { children: s$14, className: p$25, color: n$19, radius: m$12, placeholder: c$3, ...S$2 } = v$1(
      { size: t$18?.size, ...r$26 },
      { size: o$6.size },
      i$3,
      r$4,
    )
  return import_react.createElement(
    Trigger$2,
    { asChild: !0 },
    import_react.createElement(
      `button`,
      {
        'data-accent-color': n$19,
        'data-radius': m$12,
        ...S$2,
        ref: o$18,
        className: (0, import_classnames$5.default)(`rt-reset`, `rt-SelectTrigger`, p$25),
      },
      import_react.createElement(
        `span`,
        { className: `rt-SelectTriggerInner` },
        import_react.createElement(Value, { placeholder: c$3 }, s$14),
      ),
      import_react.createElement(
        Icon,
        { asChild: !0 },
        import_react.createElement(i$2, { className: `rt-SelectIcon` }),
      ),
    ),
  )
})
u$2.displayName = `Select.Trigger`
const g$2 = import_react.forwardRef((r$26, o$18) => {
  let t$18 = import_react.useContext(f$5),
    { className: s$14, children: p$25, color: n$19, container: m$12, ...c$3 } = v$1({ size: t$18?.size, ...r$26 }, {
      size: o$6.size,
    }, p$9),
    S$2 = H$1(),
    T$2 = n$19 || S$2.accentColor
  return import_react.createElement(
    Portal$2,
    { container: m$12 },
    import_react.createElement(
      R,
      { asChild: !0 },
      import_react.createElement(
        Content2$1,
        {
          'data-accent-color': T$2,
          sideOffset: 4,
          ...c$3,
          asChild: !1,
          ref: o$18,
          className: (0, import_classnames$5.default)(
            { 'rt-PopperContent': c$3.position === `popper` },
            `rt-SelectContent`,
            s$14,
          ),
        },
        import_react.createElement(
          Root,
          { type: `auto`, className: `rt-ScrollAreaRoot` },
          import_react.createElement(
            Viewport,
            { asChild: !0, className: `rt-SelectViewport` },
            import_react.createElement(
              Viewport$1,
              { className: `rt-ScrollAreaViewport`, style: { overflowY: void 0 } },
              p$25,
            ),
          ),
          import_react.createElement(Scrollbar, {
            className: `rt-ScrollAreaScrollbar rt-r-size-1`,
            orientation: `vertical`,
          }, import_react.createElement(Thumb, { className: `rt-ScrollAreaThumb` })),
        ),
      ),
    ),
  )
})
g$2.displayName = `Select.Content`
const v$2 = import_react.forwardRef((r$26, o$18) => {
  let { className: t$18, children: s$14, ...p$25 } = r$26
  return import_react.createElement(
    Item$2,
    { ...p$25, asChild: !1, ref: o$18, className: (0, import_classnames$5.default)(`rt-SelectItem`, t$18) },
    import_react.createElement(
      ItemIndicator,
      { className: `rt-SelectItemIndicator` },
      import_react.createElement(t$3, { className: `rt-SelectItemIndicatorIcon` }),
    ),
    import_react.createElement(ItemText, null, s$14),
  )
})
v$2.displayName = `Select.Item`
const y$2 = import_react.forwardRef(({ className: r$26, ...o$18 }, t$18) =>
  import_react.createElement(Group, {
    ...o$18,
    asChild: !1,
    ref: t$18,
    className: (0, import_classnames$5.default)(`rt-SelectGroup`, r$26),
  })
)
y$2.displayName = `Select.Group`
const h$1 = import_react.forwardRef(({ className: r$26, ...o$18 }, t$18) =>
  import_react.createElement(Label, {
    ...o$18,
    asChild: !1,
    ref: t$18,
    className: (0, import_classnames$5.default)(`rt-SelectLabel`, r$26),
  })
)
h$1.displayName = `Select.Label`
const I$1 = import_react.forwardRef(({ className: r$26, ...o$18 }, t$18) =>
  import_react.createElement(Separator, {
    ...o$18,
    asChild: !1,
    ref: t$18,
    className: (0, import_classnames$5.default)(`rt-SelectSeparator`, r$26),
  })
)
I$1.displayName = `Select.Separator`
var import_classnames$4 = __toESM(require_classnames())
const o$1 = import_react.forwardRef((p$25, e$26) => {
  let { className: t$18, color: a$22, decorative: s$14, ...m$12 } = v$1(p$25, t$2, r$4)
  return import_react.createElement(`span`, {
    'data-accent-color': a$22,
    role: s$14 ? void 0 : `separator`,
    ...m$12,
    ref: e$26,
    className: (0, import_classnames$4.default)(`rt-Separator`, t$18),
  })
})
o$1.displayName = `Separator`
var import_classnames$3 = __toESM(require_classnames())
const r$2 = import_react.forwardRef((t$18, e$26) => {
  let { asChild: p$25, className: s$14, ...n$19 } = v$1(t$18, p$8), m$12 = p$25 ? Slot$2 : `strong`
  return import_react.createElement(m$12, {
    ...n$19,
    ref: e$26,
    className: (0, import_classnames$3.default)(`rt-Strong`, s$14),
  })
})
r$2.displayName = `Strong`
var import_classnames$2 = __toESM(require_classnames())
const m$2 = import_react.forwardRef((o$18, l$9) => {
  let { layout: a$22, ...r$26 } = n$1,
    { className: C$4, children: c$3, layout: y$3, ...i$14 } = v$1(o$18, r$26, r$4),
    w$1 = g$1({ value: y$3, className: n$1.layout.className, propValues: n$1.layout.values })
  return import_react.createElement(
    `div`,
    { ref: l$9, className: (0, import_classnames$2.default)(`rt-TableRoot`, C$4), ...i$14 },
    import_react.createElement(
      c$1,
      null,
      import_react.createElement(
        `table`,
        { className: (0, import_classnames$2.default)(`rt-TableRootTable`, w$1) },
        c$3,
      ),
    ),
  )
})
m$2.displayName = `Table.Root`
const d$1 = import_react.forwardRef(({ className: o$18, ...l$9 }, a$22) =>
  import_react.createElement(`thead`, {
    ...l$9,
    ref: a$22,
    className: (0, import_classnames$2.default)(`rt-TableHeader`, o$18),
  })
)
d$1.displayName = `Table.Header`
const b$2 = import_react.forwardRef(({ className: o$18, ...l$9 }, a$22) =>
  import_react.createElement(`tbody`, {
    ...l$9,
    ref: a$22,
    className: (0, import_classnames$2.default)(`rt-TableBody`, o$18),
  })
)
b$2.displayName = `Table.Body`
const P$2 = import_react.forwardRef((o$18, l$9) => {
  let { className: a$22, ...r$26 } = v$1(o$18, u$1)
  return import_react.createElement(`tr`, {
    ...r$26,
    ref: l$9,
    className: (0, import_classnames$2.default)(`rt-TableRow`, a$22),
  })
})
P$2.displayName = `Table.Row`
const T$1 = import_react.forwardRef((o$18, l$9) => {
  let { className: a$22, ...r$26 } = v$1(o$18, f$2)
  return import_react.createElement(`td`, {
    className: (0, import_classnames$2.default)(`rt-TableCell`, a$22),
    ref: l$9,
    ...r$26,
  })
})
T$1.displayName = `Table.Cell`
const f$3 = import_react.forwardRef((o$18, l$9) => {
  let { className: a$22, ...r$26 } = v$1(o$18, f$2)
  return import_react.createElement(`th`, {
    className: (0, import_classnames$2.default)(`rt-TableCell`, `rt-TableColumnHeaderCell`, a$22),
    scope: `col`,
    ref: l$9,
    ...r$26,
  })
})
f$3.displayName = `Table.ColumnHeaderCell`
const R$2 = import_react.forwardRef((o$18, l$9) => {
  let { className: a$22, ...r$26 } = v$1(o$18, f$2)
  return import_react.createElement(`th`, {
    className: (0, import_classnames$2.default)(`rt-TableCell`, `rt-TableRowHeaderCell`, a$22),
    scope: `row`,
    ref: l$9,
    ...r$26,
  })
})
R$2.displayName = `Table.RowHeaderCell`
var tabs_exports = {}
__export(tabs_exports, { Content: () => f$1, List: () => b$1, Root: () => m$1, Trigger: () => P$1 })
var import_classnames$1 = __toESM(require_classnames())
const m$1 = import_react.forwardRef((t$18, o$18) => {
  let { className: r$26, ...e$26 } = v$1(t$18, r$4)
  return import_react.createElement(Root2, {
    ...e$26,
    ref: o$18,
    className: (0, import_classnames$1.default)(`rt-TabsRoot`, r$26),
  })
})
m$1.displayName = `Tabs.Root`
const b$1 = import_react.forwardRef((t$18, o$18) => {
  let { className: r$26, color: e$26, ...n$19 } = v$1(t$18, p$7, r$4)
  return import_react.createElement(List, {
    'data-accent-color': e$26,
    ...n$19,
    asChild: !1,
    ref: o$18,
    className: (0, import_classnames$1.default)(`rt-BaseTabList`, `rt-TabsList`, r$26),
  })
})
b$1.displayName = `Tabs.List`
const P$1 = import_react.forwardRef((t$18, o$18) => {
  let { className: r$26, children: e$26, ...n$19 } = t$18
  return import_react.createElement(
    Trigger$1,
    {
      ...n$19,
      asChild: !1,
      ref: o$18,
      className: (0, import_classnames$1.default)(`rt-reset`, `rt-BaseTabListTrigger`, `rt-TabsTrigger`, r$26),
    },
    import_react.createElement(`span`, { className: `rt-BaseTabListTriggerInner rt-TabsTriggerInner` }, e$26),
    import_react.createElement(
      `span`,
      { className: `rt-BaseTabListTriggerInnerHidden rt-TabsTriggerInnerHidden` },
      e$26,
    ),
  )
})
P$1.displayName = `Tabs.Trigger`
const f$1 = import_react.forwardRef((t$18, o$18) => {
  let { className: r$26, ...e$26 } = v$1(t$18, r$4)
  return import_react.createElement(Content, {
    ...e$26,
    ref: o$18,
    className: (0, import_classnames$1.default)(`rt-TabsContent`, r$26),
  })
})
f$1.displayName = `Tabs.Content`
var import_classnames = __toESM(require_classnames())
const e$4 = import_react.forwardRef((i$14, p$25) => {
  let {
      children: r$26,
      className: n$19,
      open: s$14,
      defaultOpen: l$9,
      onOpenChange: m$12,
      delayDuration: a$22,
      disableHoverableContent: f$14,
      content: P$5,
      container: T$2,
      forceMount: c$3,
      ...d$7
    } = v$1(i$14, e$6),
    C$4 = { open: s$14, defaultOpen: l$9, onOpenChange: m$12, delayDuration: a$22, disableHoverableContent: f$14 }
  return import_react.createElement(
    Root3,
    { ...C$4 },
    import_react.createElement(Trigger, { asChild: !0 }, r$26),
    import_react.createElement(
      Portal$1,
      { container: T$2, forceMount: c$3 },
      import_react.createElement(
        R,
        { asChild: !0 },
        import_react.createElement(
          Content2,
          {
            sideOffset: 4,
            collisionPadding: 10,
            ...d$7,
            asChild: !1,
            ref: p$25,
            className: (0, import_classnames.default)(`rt-TooltipContent`, n$19),
          },
          import_react.createElement(p$2, { as: `p`, className: `rt-TooltipText`, size: `1` }, P$5),
          import_react.createElement(Arrow2, { className: `rt-TooltipArrow` }),
        ),
      ),
    ),
  )
})
e$4.displayName = `Tooltip`
var logo_default = {
  light:
    `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMjggMTI4IiB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCI+CiAgPGNpcmNsZSBjeD0iNjQiIGN5PSI2NCIgcj0iNDgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iOCIvPgo8L3N2Zz4=`,
  dark:
    `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMjggMTI4IiB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCI+CiAgPGNpcmNsZSBjeD0iNjQiIGN5PSI2NCIgcj0iNDgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iOCIvPgo8L3N2Zz4=`,
  mode: `single`,
  designedFor: `light`,
}
const navbar = [],
  createThemeManager = (options$2 = {}) => {
    let { cookieName = `theme`, classPrefix = ``, maxAge = 31536e3, path: path$1 = `/` } = options$2,
      getThemeClass = theme => classPrefix ? `${classPrefix}${theme}` : theme,
      readCookie = cookieString => {
        let cookies = cookieString || (typeof document < `u` ? document.cookie : ``)
        if (!cookies) return null
        let match$13 = RegExp(`(^| )${cookieName}=([^;]+)`).exec(cookies), value$2 = match$13?.[2]
        return value$2 === `light` || value$2 === `dark` || value$2 === `system` ? value$2 : null
      },
      writeCookie = theme => {
        let cookieValue = theme === `system`
          ? `${cookieName}=; Max-Age=0; Path=${path$1}; SameSite=Strict`
          : `${cookieName}=${theme}; Max-Age=${maxAge}; Path=${path$1}; SameSite=Strict`
        return typeof document < `u` && (document.cookie = cookieValue), cookieValue
      },
      applyToDOM = theme => {
        if (typeof document > `u`) return
        let actualTheme = theme === `system`
            ? globalThis.matchMedia(`(prefers-color-scheme: dark)`).matches ? `dark` : `light`
            : theme,
          themeClass = getThemeClass(actualTheme),
          otherTheme = actualTheme === `light` ? `dark` : `light`,
          otherClass = getThemeClass(otherTheme)
        document.documentElement.classList.remove(otherClass),
          document.documentElement.classList.add(themeClass),
          document.documentElement.setAttribute(`data-theme`, actualTheme)
      },
      getCurrentFromDOM = () => {
        if (typeof document > `u`) return null
        let classList = document.documentElement.classList
        return classList.contains(getThemeClass(`dark`))
          ? `dark`
          : classList.contains(getThemeClass(`light`))
          ? `light`
          : null
      },
      set$6 = theme => {
        writeCookie(theme), applyToDOM(theme)
      },
      toggle$2 = () => {
        let cookieTheme = readCookie(), newTheme
        return newTheme = !cookieTheme || cookieTheme === `system`
          ? `light`
          : cookieTheme === `light`
          ? `dark`
          : `system`,
          set$6(newTheme),
          newTheme
      },
      getCSS = () => {
        let lightClass = getThemeClass(`light`), darkClass = getThemeClass(`dark`)
        return `
/* Theme CSS - handles both system preference and user override */
:root {
  /* Default light theme variables */
  color-scheme: light;
}

@media (prefers-color-scheme: dark) {
  :root {
    /* Dark theme variables for system preference */
    color-scheme: dark;
  }
}

/* User preference overrides (set via cookie/JS) */
html.${lightClass} {
  /* Force light theme */
  color-scheme: light;
}

html.${darkClass} {
  /* Force dark theme */  
  color-scheme: dark;
}
`.trim()
      }
    return { readCookie, writeCookie, applyToDOM, getCurrentFromDOM, toggle: toggle$2, set: set$6, getCSS }
  },
  ThemeContext = (0, import_react.createContext)(void 0),
  themeManager = createThemeManager({ cookieName: `polen-theme-preference` }),
  ThemeCSS = () => {
    let css = themeManager.getCSS()
    return (0, import_jsx_runtime.jsx)(`style`, { dangerouslySetInnerHTML: { __html: css } })
  },
  ThemeProvider = ({ children: children$3 }) => {
    let [appearance, setAppearance] = (0, import_react.useState)(() => {
        let serverTheme = globalThis.__POLEN__.serverContext.theme
        return serverTheme === `system`
          ? globalThis.window === void 0
            ? `light`
            : globalThis.matchMedia(`(prefers-color-scheme: dark)`).matches
            ? `dark`
            : `light`
          : serverTheme
      }),
      [preference, setPreference] = (0, import_react.useState)(() => {
        let serverTheme = globalThis.__POLEN__.serverContext.theme
        return serverTheme
      })
    ;(0, import_react.useEffect)(() => {
      if (themeManager.applyToDOM(preference), preference === `system`) {
        let systemTheme = globalThis.matchMedia(`(prefers-color-scheme: dark)`).matches ? `dark` : `light`
        setAppearance(systemTheme)
        let mediaQuery = globalThis.matchMedia(`(prefers-color-scheme: dark)`),
          handleChange = e$26 => {
            preference === `system` && setAppearance(e$26.matches ? `dark` : `light`)
          }
        return mediaQuery.addEventListener(`change`, handleChange),
          () => mediaQuery.removeEventListener(`change`, handleChange)
      } else setAppearance(preference)
    }, [preference])
    let toggleTheme = () => {
      let newPref = themeManager.toggle()
      setPreference(newPref)
    }
    return (0, import_jsx_runtime.jsxs)(ThemeContext.Provider, {
      value: { appearance, preference, toggleTheme },
      children: [(0, import_jsx_runtime.jsx)(ThemeCSS, {}), children$3],
    })
  },
  useTheme = () => {
    let context$2 = (0, import_react.useContext)(ThemeContext)
    if (!context$2) throw Error(`useTheme must be used within a ThemeProvider`)
    return context$2
  },
  Logo = ({ src, title: title$1, height = 30, showTitle = !0 }) => {
    let { appearance } = useTheme(), logoSrc, needsInvert = !1
    return typeof src == `string`
      ? logoSrc = src
      : src.mode === `dual`
      ? logoSrc = appearance === `dark` ? src.dark : src.light
      : (logoSrc = src.light,
        needsInvert = src.designedFor === `light` && appearance === `dark`
          || src.designedFor === `dark` && appearance === `light`),
      (0, import_jsx_runtime.jsxs)(p$1, {
        align: `center`,
        gap: `2`,
        children: [
          (0, import_jsx_runtime.jsx)(p, {
            style: { height, display: `flex`, alignItems: `center` },
            children: (0, import_jsx_runtime.jsx)(`img`, {
              src: logoSrc,
              alt: title$1,
              height,
              className: `polen-logo`,
              style: {
                height: `100%`,
                width: `auto`,
                transition: `filter 0.2s ease-in-out`,
                filter: needsInvert ? `invert(1)` : void 0,
              },
            }),
          }),
          showTitle && (0, import_jsx_runtime.jsx)(p$2, { size: `3`, weight: `medium`, children: title$1 }),
        ],
      })
  },
  DefaultNavbar = ({ items, Item: Item$5, Logo: Logo$1, ThemeToggle: ThemeToggle$1 }) => {
    let [leftItems, rightItems] = partition$4(items, item => item.position === `right`)
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsx)(Item$4, { cols: 3, children: (0, import_jsx_runtime.jsx)(Logo$1, {}) }),
        (0, import_jsx_runtime.jsx)(Item$4, {
          cols: 4,
          children: (0, import_jsx_runtime.jsx)(p$1, {
            direction: `row`,
            gap: `4`,
            justify: `center`,
            align: `center`,
            children: leftItems.map((item, index$4) =>
              (0, import_jsx_runtime.jsx)(Item$5, { item, index: index$4 }, index$4)
            ),
          }),
        }),
        (0, import_jsx_runtime.jsx)(Item$4, {
          cols: 6,
          children: (0, import_jsx_runtime.jsxs)(p$1, {
            direction: `row`,
            gap: `4`,
            justify: `end`,
            align: `center`,
            children: [
              rightItems.map((item, index$4) => (0, import_jsx_runtime.jsx)(Item$5, { item, index: index$4 }, index$4)),
              (0, import_jsx_runtime.jsx)(ThemeToggle$1, {}),
            ],
          }),
        }),
      ],
    })
  }
function useClientOnly(clientValue, serverValue) {
  let [value$2, setValue] = (0, import_react.useState)(serverValue)
  return (0, import_react.useEffect)(() => {
    setValue(clientValue())
  }, []),
    value$2
}
const reactRouterPropKeys = [
    `discover`,
    `prefetch`,
    `reloadDocument`,
    `replace`,
    `state`,
    `preventScrollReset`,
    `relative`,
    `to`,
    `viewTransition`,
    `children`,
  ],
  Link$1 = props => {
    let location = useLocation(),
      toPathExp = typeof props.to == `string` ? props.to : props.to.pathname || ``,
      active$1 = useClientOnly(() => getPathActiveReport(toPathExp, location.pathname), {
        is: !1,
        isDirect: !1,
        isDescendant: !1,
      }),
      { picked: reactRouterProps, omitted: radixProps } = ObjPartition(props, reactRouterPropKeys),
      linkRadixProps = {
        ...radixProps,
        asChild: !0,
        ...active$1.is && { 'data-active': !0 },
        ...active$1.isDirect && { 'data-active-direct': !0 },
        ...active$1.isDescendant && { 'data-active-descendant': !0 },
      }
    return (0, import_jsx_runtime.jsx)(e$1, {
      ...linkRadixProps,
      children: (0, import_jsx_runtime.jsx)(Link, { ...reactRouterProps }),
    })
  },
  getPathActiveReport = (pathExp, currentPathExp) => {
    let normalizedPath = pathExp.startsWith(`/`) ? pathExp.slice(1) : pathExp,
      normalizedCurrentPath = currentPathExp.startsWith(`/`) ? currentPathExp.slice(1) : currentPathExp,
      isDirect = normalizedCurrentPath === normalizedPath,
      isDescendant = normalizedCurrentPath.startsWith(normalizedPath + `/`) && normalizedCurrentPath !== normalizedPath,
      is$29 = isDirect || isDescendant
    return { is: is$29, isDirect, isDescendant }
  },
  Item = ({ item }) => (0, import_jsx_runtime.jsx)(Link$1, { color: `gray`, to: item.pathExp, children: item.title }),
  NotFound = () =>
    (0, import_jsx_runtime.jsxs)(p$1, {
      direction: `column`,
      align: `center`,
      gap: `6`,
      style: { textAlign: `center`, paddingTop: `4rem` },
      children: [
        (0, import_jsx_runtime.jsx)(r, { size: `9`, style: { color: `var(--gray-12)` }, children: `404` }),
        (0, import_jsx_runtime.jsxs)(p, {
          children: [
            (0, import_jsx_runtime.jsx)(r, { size: `5`, mb: `2`, children: `Page Not Found` }),
            (0, import_jsx_runtime.jsx)(p$2, {
              size: `3`,
              color: `gray`,
              children: `The page you're looking for doesn't exist or has been moved.`,
            }),
          ],
        }),
        (0, import_jsx_runtime.jsxs)(p$1, {
          gap: `3`,
          children: [
            (0, import_jsx_runtime.jsx)(Link, {
              to: `/`,
              children: (0, import_jsx_runtime.jsx)(o$3, { variant: `soft`, size: `3`, children: `Go Home` }),
            }),
            (0, import_jsx_runtime.jsx)(Link, {
              to: `/reference`,
              children: (0, import_jsx_runtime.jsx)(o$3, {
                variant: `outline`,
                size: `3`,
                children: `View API Reference`,
              }),
            }),
          ],
        }),
      ],
    })
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {}
  var target = {}, sourceKeys = Object.keys(source), key$1, i$14
  for (i$14 = 0; i$14 < sourceKeys.length; i$14++) {
    key$1 = sourceKeys[i$14], !(excluded.indexOf(key$1) >= 0) && (target[key$1] = source[key$1])
  }
  return target
}
var _excluded$U = [`color`],
  CheckCircledIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$U)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M7.49991 0.877045C3.84222 0.877045 0.877075 3.84219 0.877075 7.49988C0.877075 11.1575 3.84222 14.1227 7.49991 14.1227C11.1576 14.1227 14.1227 11.1575 14.1227 7.49988C14.1227 3.84219 11.1576 0.877045 7.49991 0.877045ZM1.82708 7.49988C1.82708 4.36686 4.36689 1.82704 7.49991 1.82704C10.6329 1.82704 13.1727 4.36686 13.1727 7.49988C13.1727 10.6329 10.6329 13.1727 7.49991 13.1727C4.36689 13.1727 1.82708 10.6329 1.82708 7.49988ZM10.1589 5.53774C10.3178 5.31191 10.2636 5.00001 10.0378 4.84109C9.81194 4.68217 9.50004 4.73642 9.34112 4.96225L6.51977 8.97154L5.35681 7.78706C5.16334 7.59002 4.84677 7.58711 4.64973 7.78058C4.45268 7.97404 4.44978 8.29061 4.64325 8.48765L6.22658 10.1003C6.33054 10.2062 6.47617 10.2604 6.62407 10.2483C6.77197 10.2363 6.90686 10.1591 6.99226 10.0377L10.1589 5.53774Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$1q = [`color`],
  Cross1Icon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$1q)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M12.8536 2.85355C13.0488 2.65829 13.0488 2.34171 12.8536 2.14645C12.6583 1.95118 12.3417 1.95118 12.1464 2.14645L7.5 6.79289L2.85355 2.14645C2.65829 1.95118 2.34171 1.95118 2.14645 2.14645C1.95118 2.34171 1.95118 2.65829 2.14645 2.85355L6.79289 7.5L2.14645 12.1464C1.95118 12.3417 1.95118 12.6583 2.14645 12.8536C2.34171 13.0488 2.65829 13.0488 2.85355 12.8536L7.5 8.20711L12.1464 12.8536C12.3417 13.0488 12.6583 13.0488 12.8536 12.8536C13.0488 12.6583 13.0488 12.3417 12.8536 12.1464L8.20711 7.5L12.8536 2.85355Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$1r = [`color`],
  Cross2Icon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$1r)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$1s = [`color`],
  CrossCircledIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$1s)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M0.877075 7.49988C0.877075 3.84219 3.84222 0.877045 7.49991 0.877045C11.1576 0.877045 14.1227 3.84219 14.1227 7.49988C14.1227 11.1575 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1575 0.877075 7.49988ZM7.49991 1.82704C4.36689 1.82704 1.82708 4.36686 1.82708 7.49988C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49988C13.1727 4.36686 10.6329 1.82704 7.49991 1.82704ZM9.85358 5.14644C10.0488 5.3417 10.0488 5.65829 9.85358 5.85355L8.20713 7.49999L9.85358 9.14644C10.0488 9.3417 10.0488 9.65829 9.85358 9.85355C9.65832 10.0488 9.34173 10.0488 9.14647 9.85355L7.50002 8.2071L5.85358 9.85355C5.65832 10.0488 5.34173 10.0488 5.14647 9.85355C4.95121 9.65829 4.95121 9.3417 5.14647 9.14644L6.79292 7.49999L5.14647 5.85355C4.95121 5.65829 4.95121 5.3417 5.14647 5.14644C5.34173 4.95118 5.65832 4.95118 5.85358 5.14644L7.50002 6.79289L9.14647 5.14644C9.34173 4.95118 9.65832 4.95118 9.85358 5.14644Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$1B = [`color`],
  DesktopIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$1B)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M1 3.25C1 3.11193 1.11193 3 1.25 3H13.75C13.8881 3 14 3.11193 14 3.25V10.75C14 10.8881 13.8881 11 13.75 11H1.25C1.11193 11 1 10.8881 1 10.75V3.25ZM1.25 2C0.559643 2 0 2.55964 0 3.25V10.75C0 11.4404 0.559644 12 1.25 12H5.07341L4.82991 13.2986C4.76645 13.6371 5.02612 13.95 5.37049 13.95H9.62951C9.97389 13.95 10.2336 13.6371 10.1701 13.2986L9.92659 12H13.75C14.4404 12 15 11.4404 15 10.75V3.25C15 2.55964 14.4404 2 13.75 2H1.25ZM9.01091 12H5.98909L5.79222 13.05H9.20778L9.01091 12Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$20 = [`color`],
  ExclamationTriangleIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$20)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M8.4449 0.608765C8.0183 -0.107015 6.9817 -0.107015 6.55509 0.608766L0.161178 11.3368C-0.275824 12.07 0.252503 13 1.10608 13H13.8939C14.7475 13 15.2758 12.07 14.8388 11.3368L8.4449 0.608765ZM7.4141 1.12073C7.45288 1.05566 7.54712 1.05566 7.5859 1.12073L13.9798 11.8488C14.0196 11.9154 13.9715 12 13.8939 12H1.10608C1.02849 12 0.980454 11.9154 1.02018 11.8488L7.4141 1.12073ZM6.8269 4.48611C6.81221 4.10423 7.11783 3.78663 7.5 3.78663C7.88217 3.78663 8.18778 4.10423 8.1731 4.48612L8.01921 8.48701C8.00848 8.766 7.7792 8.98664 7.5 8.98664C7.2208 8.98664 6.99151 8.766 6.98078 8.48701L6.8269 4.48611ZM8.24989 10.476C8.24989 10.8902 7.9141 11.226 7.49989 11.226C7.08567 11.226 6.74989 10.8902 6.74989 10.476C6.74989 10.0618 7.08567 9.72599 7.49989 9.72599C7.9141 9.72599 8.24989 10.0618 8.24989 10.476Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$2s = [`color`],
  HamburgerMenuIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$2s)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$2D = [`color`],
  InfoCircledIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$2D)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M7.49991 0.876892C3.84222 0.876892 0.877075 3.84204 0.877075 7.49972C0.877075 11.1574 3.84222 14.1226 7.49991 14.1226C11.1576 14.1226 14.1227 11.1574 14.1227 7.49972C14.1227 3.84204 11.1576 0.876892 7.49991 0.876892ZM1.82707 7.49972C1.82707 4.36671 4.36689 1.82689 7.49991 1.82689C10.6329 1.82689 13.1727 4.36671 13.1727 7.49972C13.1727 10.6327 10.6329 13.1726 7.49991 13.1726C4.36689 13.1726 1.82707 10.6327 1.82707 7.49972ZM8.24992 4.49999C8.24992 4.9142 7.91413 5.24999 7.49992 5.24999C7.08571 5.24999 6.74992 4.9142 6.74992 4.49999C6.74992 4.08577 7.08571 3.74999 7.49992 3.74999C7.91413 3.74999 8.24992 4.08577 8.24992 4.49999ZM6.00003 5.99999H6.50003H7.50003C7.77618 5.99999 8.00003 6.22384 8.00003 6.49999V9.99999H8.50003H9.00003V11H8.50003H7.50003H6.50003H6.00003V9.99999H6.50003H7.00003V6.99999H6.50003H6.00003V5.99999Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$3e = [`color`],
  MoonIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$3e)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M2.89998 0.499976C2.89998 0.279062 2.72089 0.0999756 2.49998 0.0999756C2.27906 0.0999756 2.09998 0.279062 2.09998 0.499976V1.09998H1.49998C1.27906 1.09998 1.09998 1.27906 1.09998 1.49998C1.09998 1.72089 1.27906 1.89998 1.49998 1.89998H2.09998V2.49998C2.09998 2.72089 2.27906 2.89998 2.49998 2.89998C2.72089 2.89998 2.89998 2.72089 2.89998 2.49998V1.89998H3.49998C3.72089 1.89998 3.89998 1.72089 3.89998 1.49998C3.89998 1.27906 3.72089 1.09998 3.49998 1.09998H2.89998V0.499976ZM5.89998 3.49998C5.89998 3.27906 5.72089 3.09998 5.49998 3.09998C5.27906 3.09998 5.09998 3.27906 5.09998 3.49998V4.09998H4.49998C4.27906 4.09998 4.09998 4.27906 4.09998 4.49998C4.09998 4.72089 4.27906 4.89998 4.49998 4.89998H5.09998V5.49998C5.09998 5.72089 5.27906 5.89998 5.49998 5.89998C5.72089 5.89998 5.89998 5.72089 5.89998 5.49998V4.89998H6.49998C6.72089 4.89998 6.89998 4.72089 6.89998 4.49998C6.89998 4.27906 6.72089 4.09998 6.49998 4.09998H5.89998V3.49998ZM1.89998 6.49998C1.89998 6.27906 1.72089 6.09998 1.49998 6.09998C1.27906 6.09998 1.09998 6.27906 1.09998 6.49998V7.09998H0.499976C0.279062 7.09998 0.0999756 7.27906 0.0999756 7.49998C0.0999756 7.72089 0.279062 7.89998 0.499976 7.89998H1.09998V8.49998C1.09998 8.72089 1.27906 8.89997 1.49998 8.89997C1.72089 8.89997 1.89998 8.72089 1.89998 8.49998V7.89998H2.49998C2.72089 7.89998 2.89998 7.72089 2.89998 7.49998C2.89998 7.27906 2.72089 7.09998 2.49998 7.09998H1.89998V6.49998ZM8.54406 0.98184L8.24618 0.941586C8.03275 0.917676 7.90692 1.1655 8.02936 1.34194C8.17013 1.54479 8.29981 1.75592 8.41754 1.97445C8.91878 2.90485 9.20322 3.96932 9.20322 5.10022C9.20322 8.37201 6.82247 11.0878 3.69887 11.6097C3.45736 11.65 3.20988 11.6772 2.96008 11.6906C2.74563 11.702 2.62729 11.9535 2.77721 12.1072C2.84551 12.1773 2.91535 12.2458 2.98667 12.3128L3.05883 12.3795L3.31883 12.6045L3.50684 12.7532L3.62796 12.8433L3.81491 12.9742L3.99079 13.089C4.11175 13.1651 4.23536 13.2375 4.36157 13.3059L4.62496 13.4412L4.88553 13.5607L5.18837 13.6828L5.43169 13.7686C5.56564 13.8128 5.70149 13.8529 5.83857 13.8885C5.94262 13.9155 6.04767 13.9401 6.15405 13.9622C6.27993 13.9883 6.40713 14.0109 6.53544 14.0298L6.85241 14.0685L7.11934 14.0892C7.24637 14.0965 7.37436 14.1002 7.50322 14.1002C11.1483 14.1002 14.1032 11.1453 14.1032 7.50023C14.1032 7.25044 14.0893 7.00389 14.0623 6.76131L14.0255 6.48407C13.991 6.26083 13.9453 6.04129 13.8891 5.82642C13.8213 5.56709 13.7382 5.31398 13.6409 5.06881L13.5279 4.80132L13.4507 4.63542L13.3766 4.48666C13.2178 4.17773 13.0353 3.88295 12.8312 3.60423L12.6782 3.40352L12.4793 3.16432L12.3157 2.98361L12.1961 2.85951L12.0355 2.70246L11.8134 2.50184L11.4925 2.24191L11.2483 2.06498L10.9562 1.87446L10.6346 1.68894L10.3073 1.52378L10.1938 1.47176L9.95488 1.3706L9.67791 1.2669L9.42566 1.1846L9.10075 1.09489L8.83599 1.03486L8.54406 0.98184ZM10.4032 5.30023C10.4032 4.27588 10.2002 3.29829 9.83244 2.40604C11.7623 3.28995 13.1032 5.23862 13.1032 7.50023C13.1032 10.593 10.596 13.1002 7.50322 13.1002C6.63646 13.1002 5.81597 12.9036 5.08355 12.5522C6.5419 12.0941 7.81081 11.2082 8.74322 10.0416C8.87963 10.2284 9.10028 10.3497 9.34928 10.3497C9.76349 10.3497 10.0993 10.0139 10.0993 9.59971C10.0993 9.24256 9.84965 8.94373 9.51535 8.86816C9.57741 8.75165 9.63653 8.63334 9.6926 8.51332C9.88358 8.63163 10.1088 8.69993 10.35 8.69993C11.0403 8.69993 11.6 8.14028 11.6 7.44993C11.6 6.75976 11.0406 6.20024 10.3505 6.19993C10.3853 5.90487 10.4032 5.60464 10.4032 5.30023Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  }),
  _excluded$4i = [`color`],
  SunIcon = (0, import_react.forwardRef)(function(_ref, forwardedRef) {
    var _ref$color = _ref.color,
      color$1 = _ref$color === void 0 ? `currentColor` : _ref$color,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$4i)
    return (0, import_react.createElement)(
      `svg`,
      Object.assign(
        { width: `15`, height: `15`, viewBox: `0 0 15 15`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` },
        props,
        { ref: forwardedRef },
      ),
      (0, import_react.createElement)(`path`, {
        d: `M7.5 0C7.77614 0 8 0.223858 8 0.5V2.5C8 2.77614 7.77614 3 7.5 3C7.22386 3 7 2.77614 7 2.5V0.5C7 0.223858 7.22386 0 7.5 0ZM2.1967 2.1967C2.39196 2.00144 2.70854 2.00144 2.90381 2.1967L4.31802 3.61091C4.51328 3.80617 4.51328 4.12276 4.31802 4.31802C4.12276 4.51328 3.80617 4.51328 3.61091 4.31802L2.1967 2.90381C2.00144 2.70854 2.00144 2.39196 2.1967 2.1967ZM0.5 7C0.223858 7 0 7.22386 0 7.5C0 7.77614 0.223858 8 0.5 8H2.5C2.77614 8 3 7.77614 3 7.5C3 7.22386 2.77614 7 2.5 7H0.5ZM2.1967 12.8033C2.00144 12.608 2.00144 12.2915 2.1967 12.0962L3.61091 10.682C3.80617 10.4867 4.12276 10.4867 4.31802 10.682C4.51328 10.8772 4.51328 11.1938 4.31802 11.3891L2.90381 12.8033C2.70854 12.9986 2.39196 12.9986 2.1967 12.8033ZM12.5 7C12.2239 7 12 7.22386 12 7.5C12 7.77614 12.2239 8 12.5 8H14.5C14.7761 8 15 7.77614 15 7.5C15 7.22386 14.7761 7 14.5 7H12.5ZM10.682 4.31802C10.4867 4.12276 10.4867 3.80617 10.682 3.61091L12.0962 2.1967C12.2915 2.00144 12.608 2.00144 12.8033 2.1967C12.9986 2.39196 12.9986 2.70854 12.8033 2.90381L11.3891 4.31802C11.1938 4.51328 10.8772 4.51328 10.682 4.31802ZM8 12.5C8 12.2239 7.77614 12 7.5 12C7.22386 12 7 12.2239 7 12.5V14.5C7 14.7761 7.22386 15 7.5 15C7.77614 15 8 14.7761 8 14.5V12.5ZM10.682 10.682C10.8772 10.4867 11.1938 10.4867 11.3891 10.682L12.8033 12.0962C12.9986 12.2915 12.9986 12.608 12.8033 12.8033C12.608 12.9986 12.2915 12.9986 12.0962 12.8033L10.682 11.3891C10.4867 11.1938 10.4867 10.8772 10.682 10.682ZM5.5 7.5C5.5 6.39543 6.39543 5.5 7.5 5.5C8.60457 5.5 9.5 6.39543 9.5 7.5C9.5 8.60457 8.60457 9.5 7.5 9.5C6.39543 9.5 5.5 8.60457 5.5 7.5ZM7.5 4.5C5.84315 4.5 4.5 5.84315 4.5 7.5C4.5 9.15685 5.84315 10.5 7.5 10.5C9.15685 10.5 10.5 9.15685 10.5 7.5C10.5 5.84315 9.15685 4.5 7.5 4.5Z`,
        fill: color$1,
        fillRule: `evenodd`,
        clipRule: `evenodd`,
      }),
    )
  })
const ThemeToggle = () => {
    let { appearance, toggleTheme, preference } = useTheme(),
      handleClick = () => {
        toggleTheme()
      },
      getNextTheme = () =>
        !preference || preference === `system` ? `light` : preference === `light` ? `dark` : `system`,
      getIcon = () =>
        !preference || preference === `system`
          ? (0, import_jsx_runtime.jsx)(DesktopIcon, { width: `18`, height: `18` })
          : preference === `light`
          ? (0, import_jsx_runtime.jsx)(SunIcon, { width: `18`, height: `18` })
          : (0, import_jsx_runtime.jsx)(MoonIcon, { width: `18`, height: `18` })
    return (0, import_jsx_runtime.jsx)(o$2, {
      size: `2`,
      variant: `ghost`,
      color: `gray`,
      onClick: handleClick,
      'aria-label': `Switch to ${getNextTheme()} theme`,
      style: { cursor: `pointer` },
      children: getIcon(),
    })
  },
  toastVariants = {
    info: { icon: (0, import_jsx_runtime.jsx)(InfoCircledIcon, {}), color: `blue` },
    success: { icon: (0, import_jsx_runtime.jsx)(CheckCircledIcon, {}), color: `green` },
    warning: { icon: (0, import_jsx_runtime.jsx)(ExclamationTriangleIcon, {}), color: `amber` },
    error: { icon: (0, import_jsx_runtime.jsx)(CrossCircledIcon, {}), color: `red` },
  },
  ToastItem = ({ toast }) => {
    let handleClose = () => store.remove(toast.id),
      duration = toast.duration ?? 5e3,
      showTimer = duration > 0,
      type$2 = toast.type || `info`
    return (0, import_jsx_runtime.jsxs)(o, {
      size: `2`,
      style: { animation: `slideIn 0.2s ease-out`, position: `relative` },
      children: [
        (0, import_jsx_runtime.jsxs)(p$1, {
          gap: `3`,
          align: `start`,
          maxWidth: `400px`,
          children: [
            (0, import_jsx_runtime.jsx)(p$2, {
              as: `div`,
              size: `4`,
              color: toastVariants[type$2].color,
              children: toastVariants[type$2].icon,
            }),
            (0, import_jsx_runtime.jsxs)(p, {
              style: { flex: 1 },
              children: [
                (0, import_jsx_runtime.jsxs)(p$1, {
                  align: `baseline`,
                  gap: `2`,
                  wrap: `wrap`,
                  children: [
                    (0, import_jsx_runtime.jsx)(p$2, { weight: `medium`, size: `2`, children: toast.message }),
                    toast.actions.map(action =>
                      (0, import_jsx_runtime.jsx)(o$3, {
                        id: action.label,
                        size: `1`,
                        variant: `soft`,
                        onClick: () => {
                          action.onClick(), handleClose()
                        },
                        children: action.label,
                      })
                    ),
                  ],
                }),
                toast.description
                && (0, import_jsx_runtime.jsx)(p$2, {
                  size: `1`,
                  color: `gray`,
                  mt: `1`,
                  style: { display: `block` },
                  children: toast.description,
                }),
              ],
            }),
            (0, import_jsx_runtime.jsx)(o$2, {
              size: `1`,
              variant: `ghost`,
              color: `gray`,
              onClick: handleClose,
              style: { flexShrink: 0 },
              children: (0, import_jsx_runtime.jsx)(Cross2Icon, {}),
            }),
          ],
        }),
        showTimer && (0, import_jsx_runtime.jsx)(p, {
          style: {
            position: `absolute`,
            bottom: 0,
            left: 0,
            right: 0,
            height: `2px`,
            backgroundColor: `var(--${toastVariants[toast.type || `info`].color}-a3)`,
            overflow: `hidden`,
          },
          children: (0, import_jsx_runtime.jsx)(p, {
            style: {
              height: `100%`,
              backgroundColor: `var(--${toastVariants[toast.type || `info`].color}-a6)`,
              animation: `timerCountdown ${duration}ms linear forwards`,
            },
          }),
        }),
      ],
    })
  },
  ToastContainer = () => {
    let snap = useSnapshot(store)
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsx)(`style`, {
          children: `
          @keyframes slideIn {
            from {
              transform: translateX(100%);
              opacity: 0;
            }
            to {
              transform: translateX(0);
              opacity: 1;
            }
          }

          @keyframes slideOut {
            from {
              transform: translateX(0);
              opacity: 1;
            }
            to {
              transform: translateX(100%);
              opacity: 0;
            }
          }

          @keyframes timerCountdown {
            from {
              width: 100%;
            }
            to {
              width: 0%;
            }
          }
        `,
        }),
        (0, import_jsx_runtime.jsx)(p, {
          position: `fixed`,
          bottom: `0`,
          right: `0`,
          p: `4`,
          style: { zIndex: 9999, pointerEvents: `none` },
          children: (0, import_jsx_runtime.jsx)(p$1, {
            direction: `column`,
            gap: `2`,
            align: `end`,
            style: { pointerEvents: `auto` },
            children: snap.toasts.map(toast => (0, import_jsx_runtime.jsx)(ToastItem, { toast }, toast.id)),
          }),
        }),
      ],
    })
  },
  swissSharpTheme = { accentColor: `blue`, grayColor: `gray`, radius: `none`, panelBackground: `solid` }
var VersionCoverageUnversioned = class extends TaggedClass()(`VersionCoverageUnversioned`, {}) {}
const VersionCoverageOne = Version,
  VersionCoverageSet = HashSet(Version),
  VersionCoverage = Union(VersionCoverageUnversioned, VersionCoverageOne, VersionCoverageSet).annotations({
    identifier: `VersionCoverage`,
    description: `Unversioned (all versions), a single version, or a set of versions`,
  }),
  is$8 = is$25(VersionCoverage),
  isUnversioned = coverage => coverage instanceof VersionCoverageUnversioned,
  isSingle = coverage => is$11(coverage),
  isSet = coverage => !isUnversioned(coverage) && !is$11(coverage),
  decode$9 = decode$26(VersionCoverage),
  decodeSync$6 = decodeSync$18(VersionCoverage),
  encode$8 = encode$25(VersionCoverage),
  encodeSync$2 = encodeSync$4(VersionCoverage),
  equivalence$3 = equivalence$20(VersionCoverage),
  contains = (versionCoverage, version) =>
    isUnversioned(versionCoverage)
      ? !0
      : is$11(versionCoverage)
      ? equivalence$6(versionCoverage, version)
      : has$4(versionCoverage, version),
  toLabel = versionCoverage =>
    isUnversioned(versionCoverage)
      ? `All Versions`
      : pipe(versionCoverage, encodeSync$2, ensure, map$17(_$1 => _$1.toString()), join$6(`, `)),
  toVersions = versionCoverage =>
    isUnversioned(versionCoverage) ? [] : is$11(versionCoverage) ? [versionCoverage] : toValues(versionCoverage),
  getLatest$2 = versionCoverage => {
    if (isUnversioned(versionCoverage)) throw Error(`Cannot get latest version from unversioned coverage`)
    if (is$11(versionCoverage)) return versionCoverage
    let versions = toValues(versionCoverage)
    if (versions.length === 0) throw Error(`Cannot get latest version from empty version set`)
    return versions.reduce((latest, current) => max$2(latest, current))
  },
  Unversioned = TaggedStruct(`CatalogUnversioned`, { schema: Unversioned$1 }).annotations({
    identifier: `CatalogUnversioned`,
    title: `Unversioned Catalog`,
    description: `A catalog of an unversioned GraphQL schema with its revision history`,
    adt: { name: `Catalog` },
  }),
  make$5 = Unversioned.make,
  is$7 = is$25(Unversioned),
  decode$8 = decode$26(Unversioned),
  encode$7 = encode$25(Unversioned),
  equivalence$2 = equivalence$20(Unversioned),
  Versioned = TaggedStruct(`CatalogVersioned`, { entries: HashMap({ key: Version, value: Versioned$1 }) }).annotations({
    identifier: `CatalogVersioned`,
    title: `Versioned Catalog`,
    description: `A catalog of versioned GraphQL schemas with their revision history`,
    adt: { name: `Catalog` },
  }),
  make$4 = Versioned.make,
  is$6 = is$25(Versioned),
  decode$7 = decode$26(Versioned),
  encode$6 = encode$25(Versioned),
  equivalence$1 = equivalence$20(Versioned),
  getLatest$1 = catalog => {
    let schema = getAll(catalog)[0]
    return schema
      ? right(schema)
      : left(new EmptyCatalogError({ reason: `Versioned catalog has no entries - cannot get latest schema` }))
  },
  getLatestOrThrow = catalog => {
    let result = getLatest$1(catalog)
    if (isLeft(result)) throw Error(result.left.reason)
    return result.right
  },
  getAll = catalog => pipe(catalog.entries, values$2, fromIterable$10, sort(reverse$3(order$2))),
  getVersions = catalog => pipe(catalog, getAll, map$17(_$1 => _$1.version))
var VersionNotFoundInCatalogError = class extends TaggedError(`VersionNotFoundInCatalogError`) {},
  EmptyCatalogError = class extends TaggedError(`EmptyCatalogError`) {}
const Catalog$1 = Union(Versioned, Unversioned).annotations({
    identifier: `Catalog`,
    title: `Schema Catalog`,
    description: `A catalog of GraphQL schemas and their revision history`,
  }),
  is$5 = is$25(Catalog$1),
  decode$6 = decode$26(Catalog$1),
  decodeSync$5 = decodeSync$18(Catalog$1),
  encode$5 = encode$25(Catalog$1),
  encodeSync$1 = encodeSync$4(Catalog$1),
  equivalence = equivalence$20(Catalog$1),
  getLatest = catalog =>
    value(catalog).pipe(
      tagsExhaustive({ CatalogVersioned: getLatestOrThrow, CatalogUnversioned: unversioned => unversioned.schema }),
    ),
  getLatestVersion = catalog =>
    catalog
      ? value(catalog).pipe(tagsExhaustive({
        CatalogUnversioned: () => none$7(),
        CatalogVersioned: cat => {
          let versions = getVersions(cat)
          return versions[0] ? some$4(versions[0]) : none$7()
        },
      }))
      : none$7(),
  resolveCatalogSchemaEither = (catalog, versionCoverage) => {
    if (is$7(catalog)) return right(catalog.schema)
    if (!versionCoverage) return getLatest$1(catalog)
    let version = getLatest$2(versionCoverage), schemaOption = get$5(catalog.entries, version)
    return isNone$2(schemaOption)
      ? left(
        new VersionNotFoundInCatalogError({
          version: encodeSync$3(version),
          reason: `Version ${encodeSync$3(version)} not found in catalog`,
        }),
      )
      : right(getOrThrow(schemaOption))
  }
function useLoaderData(schema) {
  let matches = useMatches(), match$13 = matches.find(m$12 => m$12.handle?.schema === schema)
  if (!match$13) {
    throw Error(
      `No route found with the specified schema. Make sure the route uses schemaRoute() or has the schema in its handle.`,
    )
  }
  if (match$13.data === void 0) {
    throw Error(`No loader data found for route ${match$13.id}. Make sure the route has a loader.`)
  }
  return decodeUnknownSync(schema)(match$13.data)
}
const schemasCatalog = null,
  CRITICALITY_CONFIG = {
    BREAKING: { label: `Breaking Changes`, color: `red` },
    DANGEROUS: { label: `Dangerous Changes`, color: `orange` },
    NON_BREAKING: { label: `Safe Changes`, color: `green` },
  },
  CriticalitySection = ({ level, changes, children: children$3 }) => {
    if (changes.length === 0) return null
    let config = CRITICALITY_CONFIG[level]
    return (0, import_jsx_runtime.jsxs)(`section`, {
      children: [
        (0, import_jsx_runtime.jsx)(r, { as: `h3`, size: `4`, mb: `3`, children: config.label }),
        (0, import_jsx_runtime.jsx)(`ul`, {
          style: { listStyle: `none`, paddingLeft: 0, margin: 0 },
          children: children$3,
        }),
      ],
    })
  },
  ChangeBase = ({ change, children: children$3 }) =>
    (0, import_jsx_runtime.jsx)(`li`, { style: { marginBottom: `0.5rem` }, children: children$3 }),
  DirectiveArgument = ({ change }) => {
    switch (change._tag) {
      case `DIRECTIVE_ARGUMENT_DEFAULT_VALUE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed default value for directive `,
            (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.directiveName] }),
            ` argument`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
          ],
        })
      case `DIRECTIVE_ARGUMENT_TYPE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed directive `,
            (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.directiveName] }),
            ` argument `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
            ` type from`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldType }),
            ` to `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newType }),
          ],
        })
    }
  },
  DirectiveArgumentDescription = ({ change }) =>
    (0, import_jsx_runtime.jsxs)(ChangeBase, {
      change,
      children: [
        `Changed description for directive `,
        (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.directiveName] }),
        ` argument `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
      ],
    }),
  DirectiveArgumentOperation = ({ change }) => {
    switch (change._tag) {
      case `DIRECTIVE_ARGUMENT_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added argument `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
            ` to directive `,
            (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.directiveName] }),
          ],
        })
      case `DIRECTIVE_ARGUMENT_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed argument `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
            ` from directive `,
            (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.directiveName] }),
          ],
        })
    }
  },
  DirectiveDescription = ({ change }) =>
    (0, import_jsx_runtime.jsxs)(ChangeBase, {
      change,
      children: [
        `Changed description for directive `,
        (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.name] }),
      ],
    }),
  DirectiveLocationOperation = ({ change }) => {
    switch (change._tag) {
      case `DIRECTIVE_LOCATION_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Directive `,
            (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.name] }),
            ` can now be used on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.location }),
          ],
        })
      case `DIRECTIVE_LOCATION_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Directive `,
            (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.name] }),
            ` can no longer be used on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.location }),
          ],
        })
    }
  },
  DirectiveOperation = ({ change }) => {
    switch (change._tag) {
      case `DIRECTIVE_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [`Added directive `, (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.name] })],
        })
      case `DIRECTIVE_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [`Removed directive `, (0, import_jsx_runtime.jsxs)(p$3, { children: [`@`, change.name] })],
        })
    }
  },
  EnumValueDeprecationReason = ({ change }) => {
    switch (change._tag) {
      case `ENUM_VALUE_DEPRECATION_REASON_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Deprecated enum value `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.value }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.enumName }),
            change.reason
            && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [`: "`, change.reason, `"`] }),
          ],
        })
      case `ENUM_VALUE_DEPRECATION_REASON_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed deprecation from enum value `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.value }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.enumName }),
          ],
        })
      case `ENUM_VALUE_DEPRECATION_REASON_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed deprecation reason for enum value `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.value }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.enumName }),
          ],
        })
    }
  },
  EnumValueDescription = ({ change }) =>
    (0, import_jsx_runtime.jsxs)(ChangeBase, {
      change,
      children: [
        `Changed description for enum value `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.value }),
        ` on `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.enumName }),
      ],
    }),
  EnumValueOperation = ({ change }) => {
    switch (change._tag) {
      case `ENUM_VALUE_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added value `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.value }),
            ` to enum `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.enumName }),
          ],
        })
      case `ENUM_VALUE_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed value `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.value }),
            ` from enum `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.enumName }),
          ],
        })
    }
  },
  FieldArgument = ({ change }) => {
    switch (change._tag) {
      case `FIELD_ARGUMENT_DEFAULT_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed default value for argument `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
            ` on field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` `,
            `on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
            ` from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldDefault }),
            ` to `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newDefault }),
          ],
        })
      case `FIELD_ARGUMENT_TYPE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed argument `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
            ` type from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldType }),
            ` to`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newType }),
            ` on field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
    }
  },
  FieldArgumentDescription = ({ change }) =>
    (0, import_jsx_runtime.jsxs)(ChangeBase, {
      change,
      children: [
        `Changed description for argument `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
        ` on field `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
        ` on`,
        ` `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
      ],
    }),
  FieldArgumentOperation = ({ change }) => {
    switch (change._tag) {
      case `FIELD_ARGUMENT_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added argument `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
            ` to field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
      case `FIELD_ARGUMENT_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed argument `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.argumentName }),
            ` from field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
    }
  },
  FieldDeprecation = ({ change }) => {
    switch (change._tag) {
      case `FIELD_DEPRECATION_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Deprecated field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
      case `FIELD_DEPRECATION_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed deprecation from field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
    }
  },
  FieldDeprecationReason = ({ change }) => {
    switch (change._tag) {
      case `FIELD_DEPRECATION_REASON_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added deprecation reason to field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
            change.reason
            && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [`: "`, change.reason, `"`] }),
          ],
        })
      case `FIELD_DEPRECATION_REASON_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed deprecation reason from field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
      case `FIELD_DEPRECATION_REASON_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed deprecation reason for field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
            ` from`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldReason }),
            ` to `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newReason }),
          ],
        })
    }
  },
  FieldDescription = ({ change }) => {
    switch (change._tag) {
      case `FIELD_DESCRIPTION_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added description to field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
      case `FIELD_DESCRIPTION_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed description from field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
      case `FIELD_DESCRIPTION_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed description for field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
    }
  },
  FieldOperation = ({ change }) => {
    switch (change._tag) {
      case `FIELD_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` to `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
      case `FIELD_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
      case `FIELD_TYPE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` type from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldType }),
            ` to`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newType }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.typeName }),
          ],
        })
    }
  },
  InputFieldDefaultValue = ({ change }) =>
    (0, import_jsx_runtime.jsxs)(ChangeBase, {
      change,
      children: [
        `Changed default value for input field `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
        ` on `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.inputName }),
        ` from`,
        ` `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.oldDefault }),
        ` to `,
        (0, import_jsx_runtime.jsx)(p$3, { children: change.newDefault }),
      ],
    }),
  InputFieldDescription = ({ change }) => {
    switch (change._tag) {
      case `INPUT_FIELD_DESCRIPTION_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added description to input field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.inputName }),
          ],
        })
      case `INPUT_FIELD_DESCRIPTION_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed description from input field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.inputName }),
          ],
        })
      case `INPUT_FIELD_DESCRIPTION_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed description for input field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` on `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.inputName }),
          ],
        })
    }
  },
  InputFieldOperation = ({ change }) => {
    switch (change._tag) {
      case `INPUT_FIELD_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added input field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` to `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.inputName }),
          ],
        })
      case `INPUT_FIELD_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed input field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.inputName }),
          ],
        })
      case `INPUT_FIELD_TYPE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed field `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.fieldName }),
            ` type from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldType }),
            ` to`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newType }),
            ` on input `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.inputName }),
          ],
        })
    }
  },
  ObjectTypeInterfaceOperation = ({ change }) => {
    switch (change._tag) {
      case `OBJECT_TYPE_INTERFACE_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            (0, import_jsx_runtime.jsx)(p$3, { children: change.objectName }),
            ` object implements `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.interfaceName }),
            ` interface`,
          ],
        })
      case `OBJECT_TYPE_INTERFACE_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            (0, import_jsx_runtime.jsx)(p$3, { children: change.objectName }),
            ` object no longer implements `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.interfaceName }),
            ` interface`,
          ],
        })
    }
  },
  SchemaRootType = ({ change }) => {
    switch (change._tag) {
      case `SCHEMA_QUERY_TYPE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Schema query root type changed from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldType }),
            ` to `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newType }),
          ],
        })
      case `SCHEMA_MUTATION_TYPE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Schema mutation root type changed from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldType || `null` }),
            ` to`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newType || `null` }),
          ],
        })
      case `SCHEMA_SUBSCRIPTION_TYPE_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Schema subscription root type changed from `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.oldType || `null` }),
            ` to`,
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.newType || `null` }),
          ],
        })
    }
  },
  TypeDescription = ({ change }) => {
    switch (change._tag) {
      case `TYPE_DESCRIPTION_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [`Added description to type `, (0, import_jsx_runtime.jsx)(p$3, { children: change.name })],
        })
      case `TYPE_DESCRIPTION_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [`Removed description from type `, (0, import_jsx_runtime.jsx)(p$3, { children: change.name })],
        })
      case `TYPE_DESCRIPTION_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [`Changed description for type `, (0, import_jsx_runtime.jsx)(p$3, { children: change.name })],
        })
    }
  },
  TypeClassNameEnum = {
    Scalar: `GraphQLScalarType`,
    Object: `GraphQLObjectType`,
    Interface: `GraphQLInterfaceType`,
    Union: `GraphQLUnionType`,
    Enum: `GraphQLEnumType`,
    InputObject: `GraphQLInputObjectType`,
    List: `GraphQLList`,
    NonNull: `GraphQLNonNull`,
  },
  typeClassToName = node$1 => {
    switch (!0) {
      case isObjectType(node$1):
        return TypeClassNameEnum.Object
      case isInputObjectType(node$1):
        return TypeClassNameEnum.InputObject
      case isUnionType(node$1):
        return TypeClassNameEnum.Union
      case isInterfaceType(node$1):
        return TypeClassNameEnum.Interface
      case isEnumType(node$1):
        return TypeClassNameEnum.Enum
      case isScalarType(node$1):
        return TypeClassNameEnum.Scalar
      default:
        throw Error(`Unknown node kind: ${String(node$1)}`)
    }
  },
  namedTypeClassNameToClassMap = {
    [TypeClassNameEnum.Scalar]: GraphQLScalarType,
    [TypeClassNameEnum.Object]: GraphQLObjectType,
    [TypeClassNameEnum.Interface]: GraphQLInterfaceType,
    [TypeClassNameEnum.Union]: GraphQLUnionType,
    [TypeClassNameEnum.Enum]: GraphQLEnumType,
    [TypeClassNameEnum.InputObject]: GraphQLInputObjectType,
  },
  typeClassNameToClassMap = {
    [TypeClassNameEnum.NonNull]: GraphQLNonNull,
    [TypeClassNameEnum.List]: GraphQLList,
    ...namedTypeClassNameToClassMap,
  },
  TypeKindNameEnum = {
    Scalar: `Scalar`,
    Object: `Object`,
    Interface: `Interface`,
    Union: `Union`,
    Enum: `Enum`,
    InputObject: `InputObject`,
    List: `List`,
    NonNull: `NonNull`,
  },
  typeKindFromClass = typeClass => {
    let typeClassName = typeClassToName(typeClass), kindName = typeClassNameToKindMap[typeClassName]
    return kindName
  },
  typeClassNameToKindMap = {
    [TypeClassNameEnum.Scalar]: TypeKindNameEnum.Scalar,
    [TypeClassNameEnum.Object]: TypeKindNameEnum.Object,
    [TypeClassNameEnum.Interface]: TypeKindNameEnum.Interface,
    [TypeClassNameEnum.Union]: TypeKindNameEnum.Union,
    [TypeClassNameEnum.Enum]: TypeKindNameEnum.Enum,
    [TypeClassNameEnum.InputObject]: TypeKindNameEnum.InputObject,
    [TypeClassNameEnum.List]: TypeKindNameEnum.List,
    [TypeClassNameEnum.NonNull]: TypeKindNameEnum.NonNull,
  },
  isFielded = type$2 => isFieldedOutput(type$2) || isFieldedInput(type$2),
  isFieldedOutput = type$2 => isInterfaceType(type$2) || isObjectType(type$2),
  isFieldedInput = type$2 => isInputObjectType(type$2),
  getFields = type$2 => Object.values(type$2.getFields()),
  typeKindTokensIndex = {
    Object: { symbol: `O`, color: `iris` },
    Interface: { symbol: `T`, color: `pink` },
    Union: { symbol: `U`, color: `pink` },
    Enum: { symbol: `E`, color: `orange` },
    Scalar: { symbol: `S`, color: `orange` },
    InputObject: { symbol: `I`, color: `green` },
    List: { symbol: `L`, color: `gray` },
    NonNull: { symbol: `N`, color: `gray` },
  },
  unknownTypeKindToken = { symbol: `UNKNOWN`, color: `jade` },
  TypeKindIcon = ({ kind }) => {
    let { symbol: symbol$3, color: color$1 } = typeKindTokensIndex[kind] ?? unknownTypeKindToken
    return (0, import_jsx_runtime.jsx)(p$3, { color: color$1, weight: `bold`, variant: `outline`, children: symbol$3 })
  },
  dateToVersionString = date$1 => date$1.toLocaleDateString(`en-CA`),
  createReferencePath = parts$1 => {
    let basePath = createReferenceBasePath(parts$1.version)
    return joinSegmentsAndPaths(basePath, parts$1.type, parts$1.field)
  },
  createReferenceBasePath = version =>
    joinSegmentsAndPaths(segmentLiterals.reference, createReferenceVersionPath(version)),
  segmentLiterals = { reference: `reference`, version: `version`, changelog: `changelog` },
  createReferenceVersionPath = version =>
    version === void 0 ? `` : `/${segmentLiterals.version}/${encodeSync$3(version)}`,
  joinSegmentsAndPaths = (...segmentsOrPaths) => {
    let segments = filterMap$4(segmentsOrPaths.flat(), segment => {
        if (!isNotNullable(segment)) return none$7()
        let cleaned = segment.replace(/^\//, ``).replace(/\/$/, ``)
        return cleaned ? some$4(cleaned) : none$7()
      }),
      path$1 = `/` + segments.join(`/`)
    return path$1
  },
  isReferenceRoute = route$1 =>
    route$1.params.type !== void 0 || route$1.params.field !== void 0 || route$1.params.argument !== void 0
    || route$1.pathname.includes(`/${segmentLiterals.reference}`),
  assertReferenceRoute = route$1 => {
    if (!isReferenceRoute(route$1)) {
      throw Error(`Not on a reference route. This function can only be used on reference routes.`)
    }
  },
  getReferenceViewType = params => {
    let { schema, type: typeName, field: fieldName } = params
    if (!typeName) return `index`
    let type$2 = schema.definition.getType(typeName)
    if (!type$2) return `type-missing`
    if (!fieldName) return `type`
    if (!isFielded(type$2)) return `field-missing`
    let fields = type$2.getFields()
    return fields[fieldName] ? `field` : `field-missing`
  },
  createChangelogUrl = (revisionDate, schema) => {
    let version = getVersion(schema),
      changelogBase = version
        ? joinSegmentsAndPaths(segmentLiterals.changelog, segmentLiterals.version, encodeSync$3(version))
        : `/${segmentLiterals.changelog}`
    return `${changelogBase}#${revisionDate}`
  },
  doesPathExist = (schema, path$1) => {
    if (!path$1.type) return !0
    let type$2 = schema.getType(path$1.type)
    if (!type$2) return !1
    if (!path$1.field) return !0
    if (!isFielded(type$2)) return !1
    let fields = type$2.getFields(), field = fields[path$1.field]
    if (!field) return !1
    if (!path$1.argument) return !0
    let arg = findFirst$7(field.args, a$22 => a$22.name === path$1.argument)
    return isSome(arg)
  },
  findFallbackPath = (schema, currentPath) => {
    if (!currentPath.type) return { type: `Query` }
    if (doesPathExist(schema, currentPath)) return currentPath
    if (currentPath.argument && currentPath.field) {
      let fieldPath = { type: currentPath.type, field: currentPath.field }
      if (doesPathExist(schema, fieldPath)) return fieldPath
    }
    if (currentPath.field) {
      let typePath = { type: currentPath.type }
      if (doesPathExist(schema, typePath)) return typePath
    }
    return { type: `Query` }
  },
  getRedirectDescription = (targetSchema, currentPath, fallbackPath, targetVersion) => {
    if (!currentPath.type) return null
    let currentExists = doesPathExist(targetSchema, currentPath)
    if (currentExists) return null
    let versionInfo = targetVersion ? ` in version ${targetVersion}` : ` in this version`
    return currentPath.argument && fallbackPath.field
      ? `Argument "${currentPath.argument}" doesn't exist${versionInfo}. Redirecting to field "${fallbackPath.field}".`
      : currentPath.field && fallbackPath.type && !fallbackPath.field
      ? `Field "${currentPath.field}" doesn't exist${versionInfo}. Redirecting to type "${fallbackPath.type}".`
      : currentPath.type === fallbackPath.type
      ? `This path doesn't exist${versionInfo}. Redirecting to a valid location.`
      : `Type "${currentPath.type}" doesn't exist${versionInfo}. Redirecting to type "${fallbackPath.type}".`
  },
  useVersionPath = () => {
    let params = useParams(), versionParam = params.version
    if (!versionParam) return ``
    let version = fromString(versionParam)
    return createReferenceVersionPath(version)
  },
  ReferenceLink = ({ type: type$2, field, children: children$3 }) => {
    let versionPath = useVersionPath(),
      path$1 = joinSegmentsAndPaths(segmentLiterals.reference, versionPath, type$2, field)
    return (0, import_jsx_runtime.jsx)(Link$1, { to: path$1, children: children$3 })
  },
  TypeLink = ({ type: type$2 }) => {
    let kind = typeKindFromClass(type$2)
    return (0, import_jsx_runtime.jsx)(ReferenceLink, {
      type: type$2.name,
      children: (0, import_jsx_runtime.jsxs)(p$1, {
        align: `center`,
        gap: `1`,
        display: `inline-flex`,
        children: [
          (0, import_jsx_runtime.jsx)(TypeKindIcon, { kind }),
          ` `,
          (0, import_jsx_runtime.jsx)(p$3, {
            color: typeKindTokensIndex[kind].color,
            variant: `ghost`,
            children: type$2.name,
          }),
        ],
      }),
    })
  },
  TypeOperation = ({ change, schema }) => {
    let renderTypeName = (name, kind) => {
      if (!schema) return (0, import_jsx_runtime.jsx)(p$3, { children: name })
      let type$2 = schema.definition.getType(name)
      if (type$2 && isNamedType(type$2)) {
        let actualKind = kind || typeKindFromClass(type$2)
        if (actualKind in typeKindTokensIndex) {
          return (0, import_jsx_runtime.jsx)(ReferenceLink, {
            type: name,
            children: (0, import_jsx_runtime.jsxs)(p$1, {
              align: `center`,
              gap: `1`,
              display: `inline-flex`,
              children: [
                (0, import_jsx_runtime.jsx)(TypeKindIcon, { kind: actualKind }),
                ` `,
                (0, import_jsx_runtime.jsx)(p$3, {
                  color: typeKindTokensIndex[actualKind].color,
                  variant: `ghost`,
                  children: name,
                }),
              ],
            }),
          })
        }
      }
      return kind && kind in typeKindTokensIndex
        ? (0, import_jsx_runtime.jsxs)(p$1, {
          align: `center`,
          gap: `1`,
          display: `inline-flex`,
          children: [
            (0, import_jsx_runtime.jsx)(TypeKindIcon, { kind }),
            ` `,
            (0, import_jsx_runtime.jsx)(p$3, {
              color: typeKindTokensIndex[kind].color,
              variant: `ghost`,
              children: name,
            }),
          ],
        })
        : (0, import_jsx_runtime.jsx)(p$3, { children: name })
    }
    switch (change._tag) {
      case `TYPE_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [`Added type `, renderTypeName(change.name)],
        })
      case `TYPE_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [`Removed type `, renderTypeName(change.name)],
        })
      case `TYPE_KIND_CHANGED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Changed type `,
            renderTypeName(change.name, change.newKind),
            ` from `,
            change.oldKind,
            ` to `,
            change.newKind,
          ],
        })
    }
  },
  UnionMemberOperation = ({ change }) => {
    switch (change._tag) {
      case `UNION_MEMBER_ADDED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Added `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.memberName }),
            ` to union `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.unionName }),
          ],
        })
      case `UNION_MEMBER_REMOVED`:
        return (0, import_jsx_runtime.jsxs)(ChangeBase, {
          change,
          children: [
            `Removed `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.memberName }),
            ` from union `,
            (0, import_jsx_runtime.jsx)(p$3, { children: change.unionName }),
          ],
        })
    }
  }
var groups_exports = {}
__export(groups_exports, {
  DirectiveArgument: () => DirectiveArgument,
  DirectiveArgumentDescription: () => DirectiveArgumentDescription,
  DirectiveArgumentOperation: () => DirectiveArgumentOperation,
  DirectiveDescription: () => DirectiveDescription,
  DirectiveLocationOperation: () => DirectiveLocationOperation,
  DirectiveOperation: () => DirectiveOperation,
  EnumValueDeprecationReason: () => EnumValueDeprecationReason,
  EnumValueDescription: () => EnumValueDescription,
  EnumValueOperation: () => EnumValueOperation,
  FieldArgument: () => FieldArgument,
  FieldArgumentDescription: () => FieldArgumentDescription,
  FieldArgumentOperation: () => FieldArgumentOperation,
  FieldDeprecation: () => FieldDeprecation,
  FieldDeprecationReason: () => FieldDeprecationReason,
  FieldDescription: () => FieldDescription,
  FieldOperation: () => FieldOperation,
  InputFieldDefaultValue: () => InputFieldDefaultValue,
  InputFieldDescription: () => InputFieldDescription,
  InputFieldOperation: () => InputFieldOperation,
  ObjectTypeInterfaceOperation: () => ObjectTypeInterfaceOperation,
  SchemaRootType: () => SchemaRootType,
  TypeDescription: () => TypeDescription,
  TypeOperation: () => TypeOperation,
  UnionMemberOperation: () => UnionMemberOperation,
})
const ComponentDispatch = ({ components, name, props }) => {
    let Component$7 = components[name]
    return import_react.createElement(Component$7, props)
  },
  renderDate = dateOnly => {
    let date$1 = toDate(dateOnly), year = date$1.getUTCFullYear()
    return `${year} ${date$1.toLocaleString(`default`, { month: `long`, day: `numeric`, timeZone: `UTC` })}`
  },
  CRITICALITY_LEVELS = [`BREAKING`, `DANGEROUS`, `NON_BREAKING`],
  ChangelogBody = ({ schema }) =>
    (0, import_jsx_runtime.jsxs)(p, {
      children: [
        (0, import_jsx_runtime.jsx)(r, {
          size: `5`,
          style: { padding: `1rem 0`, borderBottom: `1px solid var(--gray-4)`, marginBottom: `1.5rem` },
          children: `Changelog`,
        }),
        schema.revisions.map(revision => (0, import_jsx_runtime.jsx)(Changeset, { revision, schema }, revision.date)),
      ],
    }),
  Changeset = ({ revision, schema }) => {
    let groupedChanges = (0, import_react.useMemo)(() => {
      let groups = {}
      return CRITICALITY_LEVELS.forEach(level => {
        groups[level] = []
      }),
        revision.changes.forEach(change => {
          let level = change.criticality.level
          groups[level] && groups[level].push(change)
        }),
        CRITICALITY_LEVELS.filter(level => groups[level].length > 0).map(level => ({ level, changes: groups[level] }))
    }, [revision])
    return (0, import_jsx_runtime.jsxs)(p, {
      mb: `6`,
      id: revision.date,
      style: { scrollMarginTop: `2rem` },
      children: [
        (0, import_jsx_runtime.jsx)(`h1`, {
          children: (0, import_jsx_runtime.jsx)(`a`, {
            href: `#${revision.date}`,
            style: { color: `inherit`, textDecoration: `none`, position: `relative` },
            onClick: e$26 => {
              e$26.preventDefault(),
                window.history.pushState(null, ``, `#${revision.date}`),
                window.dispatchEvent(new Event(`pushstate`)),
                document.getElementById(revision.date)?.scrollIntoView({ behavior: `smooth` })
            },
            onMouseEnter: e$26 => {
              e$26.currentTarget.style.textDecoration = `underline`
            },
            onMouseLeave: e$26 => {
              e$26.currentTarget.style.textDecoration = `none`
            },
            children: renderDate(revision.date),
          }),
        }),
        groupedChanges.map(group =>
          (0, import_jsx_runtime.jsx)(CriticalitySection, {
            level: group.level,
            changes: group.changes,
            children: group.changes.map((change, index$4) => {
              let type$2 = getType(change)
              return (0, import_jsx_runtime.jsx)(ComponentDispatch, {
                components: groups_exports,
                name: type$2,
                props: { change, schema },
              }, `${change._tag}-${change.path || change.message}-${index$4}`)
            }),
          }, group.level)
        ),
      ],
    })
  },
  VersionPicker = ({ versions, currentVersion, onVersionChange }) =>
    versions.length <= 1 ? null : (0, import_jsx_runtime.jsxs)(C$2, {
      value: encodeSync$3(currentVersion),
      onValueChange: versionEncoded => onVersionChange(fromString(versionEncoded)),
      children: [
        (0, import_jsx_runtime.jsxs)(u$2, {
          style: { minWidth: `120px` },
          children: [`Version `, encodeSync$3(currentVersion)],
        }),
        (0, import_jsx_runtime.jsx)(g$2, {
          position: `popper`,
          sideOffset: 5,
          children: versions.map(version =>
            (0, import_jsx_runtime.jsxs)(v$2, {
              value: encodeSync$3(version),
              children: [`Version `, encodeSync$3(version)],
            }, encodeSync$3(version))
          ),
        }),
      ],
    }),
  ChangelogSidebarItem = ({ revision, isActive: isActive$2 }) => {
    let counts = calculateCounts(revision)
    return (0, import_jsx_runtime.jsx)(p, {
      mb: `2`,
      children: (0, import_jsx_runtime.jsxs)(`a`, {
        href: `#${revision.date}`,
        style: {
          textDecoration: `none`,
          display: `flex`,
          alignItems: `center`,
          justifyContent: `space-between`,
          padding: `0.5rem 0.75rem`,
          borderRadius: `4px`,
          backgroundColor: isActive$2 ? `var(--gray-a3)` : `transparent`,
          color: `inherit`,
          transition: `background-color 0.2s`,
        },
        onClick: e$26 => {
          e$26.preventDefault(),
            window.history.pushState(null, ``, `#${revision.date}`),
            window.dispatchEvent(new Event(`pushstate`)),
            document.getElementById(revision.date)?.scrollIntoView({ behavior: `smooth` })
        },
        children: [
          (0, import_jsx_runtime.jsx)(p$2, {
            size: `2`,
            weight: isActive$2 ? `medium` : `regular`,
            children: renderDate(revision.date),
          }),
          (0, import_jsx_runtime.jsxs)(p$1, {
            gap: `2`,
            align: `center`,
            children: [
              counts.breaking > 0
              && (0, import_jsx_runtime.jsx)(p$2, {
                size: `1`,
                weight: `medium`,
                style: { color: `#ef4444` },
                children: counts.breaking,
              }),
              counts.dangerous > 0
              && (0, import_jsx_runtime.jsx)(p$2, {
                size: `1`,
                weight: `medium`,
                style: { color: `#f59e0b` },
                children: counts.dangerous,
              }),
              counts.safe > 0
              && (0, import_jsx_runtime.jsx)(p$2, {
                size: `1`,
                weight: `medium`,
                style: { color: `#10b981` },
                children: counts.safe,
              }),
            ],
          }),
        ],
      }),
    })
  },
  calculateCounts = revision => ({
    breaking: revision.changes.filter(isBreaking).length,
    dangerous: revision.changes.filter(isDangerous).length,
    safe: revision.changes.filter(isSafe).length,
  }),
  ChangelogSidebar = ({ catalog, schema }) => {
    {
      let navigate = useNavigate(),
        revisions = schema.revisions,
        [activeRevision, setActiveRevision] = (0, import_react.useState)(null)
      return (0, import_react.useEffect)(() => {
        let handleHashChange = () => {
          let hash$1 = window.location.hash.slice(1)
          setActiveRevision(hash$1 || null)
        }
        return handleHashChange(),
          window.addEventListener(`hashchange`, handleHashChange),
          window.addEventListener(`pushstate`, handleHashChange),
          () => {
            window.removeEventListener(`hashchange`, handleHashChange),
              window.removeEventListener(`pushstate`, handleHashChange)
          }
      }, []),
        (0, import_jsx_runtime.jsxs)(Item$4, {
          cols: 3,
          style: {
            position: `sticky`,
            top: `2rem`,
            height: `fit-content`,
            minWidth: `250px`,
            maxHeight: `calc(100vh - 4rem)`,
            overflowY: `auto`,
          },
          children: [
            is$6(catalog) && is$10(schema)
            && (0, import_jsx_runtime.jsx)(p, {
              mb: `3`,
              children: (0, import_jsx_runtime.jsx)(VersionPicker, {
                versions: getVersions(catalog),
                currentVersion: schema.version,
                onVersionChange: newVersion => {
                  navigate(`/changelog/version/${encodeSync$3(newVersion)}`)
                },
              }),
            }),
            (0, import_jsx_runtime.jsx)(p$2, {
              size: `2`,
              weight: `medium`,
              mb: `3`,
              style: { display: `block` },
              children: `Revisions`,
            }),
            revisions.map(revision =>
              (0, import_jsx_runtime.jsx)(ChangelogSidebarItem, {
                revision,
                isActive: activeRevision === revision.date,
              }, revision.date)
            ),
          ],
        })
    }
  },
  LoaderSchema = Struct({ catalog: Catalog$1, schema: Schema$1 }),
  loader$2 = ({ params }) => {
    let catalog = schemasCatalog
    if (is$6(catalog) && !params.version) {
      let latestVersion = getLatestVersion(catalog), urlVersion = encodeSync$3(getOrThrow(latestVersion))
      throw redirect(`/changelog/version/${urlVersion}`)
    }
    let schemaMaybe = (() => {
      if (is$6(catalog)) {
        let version = decodeSync$7(params.version), schema = get$5(catalog.entries, version)
        return schema
      }
      return some$4(catalog.schema)
    })()
    if (isNone$2(schemaMaybe)) throw notFound
    return succeed$1({ catalog, schema: schemaMaybe.value })
  },
  Component$5 = () => {
    let { catalog, schema } = useLoaderData(LoaderSchema)
    return (0, import_jsx_runtime.jsxs)(Body, {
      subgrid: !0,
      children: [
        (0, import_jsx_runtime.jsx)(ChangelogSidebar, { schema, catalog }),
        (0, import_jsx_runtime.jsx)(Item$4, {
          start: 5,
          cols: 8,
          children: (0, import_jsx_runtime.jsx)(ChangelogBody, { schema }),
        }),
      ],
    })
  },
  changelog = null,
  DocumentUnversioned = TaggedStruct(`DocumentUnversioned`, { document: String$ }),
  make$3 = DocumentUnversioned.make,
  is$4 = is$25(DocumentUnversioned),
  decode$5 = decode$26(DocumentUnversioned),
  decodeSync$4 = decodeSync$18(DocumentUnversioned),
  encode$4 = encode$25(DocumentUnversioned),
  DocumentVersioned = TaggedStruct(`DocumentVersioned`, {
    versionDocuments: HashMap({ key: VersionCoverage, value: String$ }),
  }),
  make$2 = DocumentVersioned.make,
  is$3 = is$25(DocumentVersioned),
  decode$4 = decode$26(DocumentVersioned),
  decodeSync$3 = decodeSync$18(DocumentVersioned),
  encode$3 = encode$25(DocumentVersioned),
  getContentForVersion = (doc, version) => {
    let exactMatch = get$5(doc.versionDocuments, version)
    if (isSome(exactMatch)) return some$4(exactMatch.value)
    for (let [selection, content$2] of entries(doc.versionDocuments)) {
      if (isSet(selection) && contains(selection, version)) return some$4(content$2)
    }
    return none$7()
  },
  getAllVersions = doc => {
    let versions = new Set()
    for (let selection of keys$3(doc.versionDocuments)) for (let v$4 of toVersions(selection)) versions.add(v$4)
    return Array.from(versions)
  },
  getContentForLatestVersionOrThrow = doc => {
    let versions = getAllVersions(doc)
    if (versions.length === 0) throw Error(`No versions found in document`)
    let latestVersion = versions.reduce(max$2), contentOption = getContentForVersion(doc, latestVersion)
    if (isNone$2(contentOption)) throw Error(`Latest version not found in document`)
    return contentOption.value
  }
var VersionCoverageMismatchError = class extends TaggedError(`VersionCoverageMismatchError`) {},
  VersionNotFoundInDocumentError = class extends TaggedError(`VersionNotFoundInDocumentError`) {}
const Document = Union(DocumentUnversioned, DocumentVersioned),
  is$2 = is$25(Document),
  decode$3 = decode$26(Document),
  decodeSync$2 = decodeSync$18(Document),
  encode$2 = encode$25(Document),
  resolveDocumentContent = (document$3, versionCoverage) => {
    if (document$3._tag === `DocumentUnversioned`) return document$3.document
    if (!versionCoverage) return getContentForLatestVersionOrThrow(document$3)
    let version = getLatest$2(versionCoverage), contentOption = getContentForVersion(document$3, version)
    if (isNone$2(contentOption)) {
      throw new VersionNotFoundInDocumentError({
        version: encodeSync$3(version),
        reason: `Version ${encodeSync$3(version)} not covered by document`,
      })
    }
    return contentOption.value
  },
  resolveDocumentAndSchema = (document$3, catalog, versionCoverage) => {
    if (document$3._tag === `DocumentUnversioned`) {
      let content$3 = document$3.document
      return catalog
        ? resolveCatalogSchemaEither(catalog, null).pipe(map$19(schema => ({ content: content$3, schema })))
        : right({ content: content$3 })
    }
    let content$2
    try {
      content$2 = resolveDocumentContent(document$3, versionCoverage)
    } catch (error) {
      return error instanceof VersionNotFoundInDocumentError
        ? left(error)
        : left(
          new VersionNotFoundInDocumentError({
            version: String(versionCoverage),
            reason: error instanceof Error ? error.message : String(error),
          }),
        )
    }
    return catalog
      ? versionCoverage && is$7(catalog)
        ? left(
          new VersionCoverageMismatchError({ reason: `Cannot use a version coverage with an unversioned catalog` }),
        )
        : resolveCatalogSchemaEither(catalog, versionCoverage).pipe(map$19(schema => ({ content: content$2, schema })))
      : right({ content: content$2 })
  },
  Example = Struct({ name: String$, path: String$, document: Document }).annotations({
    identifier: `Example`,
    description: `A GraphQL example that contains a document with optional versioning support`,
  }),
  make$1 = Example.make,
  order$1 = mapInput(string$3, example => example.name),
  equivalent = equivalence$20(Example),
  is$1 = is$25(Example),
  decode$2 = decode$26(Example),
  decodeSync$1 = decodeSync$18(Example),
  encode$1 = encode$25(Example),
  UnversionedKey = TaggedStruct(`UnversionedKey`, {}),
  UNVERSIONED_KEY = UnversionedKey.make({}),
  VersionKey = Union(Version, UnversionedKey)
var ExampleReference = class extends Class(`ExampleReference`)({ name: String$, version: NullOr(Version) }) {}
const TypeUsageIndex = HashMap({ key: VersionKey, value: HashMap({ key: String$, value: HashSet(ExampleReference) }) })
    .annotations({
      identifier: `TypeUsageIndex`,
      description: `Index mapping versions to types to example references that use those types`,
    }),
  Catalog = Struct({
    examples: Array$(Example),
    index: optional(Struct({ path: String$ })),
    typeUsageIndex: optional(TypeUsageIndex),
  }).annotations({
    identifier: `ExamplesCatalog`,
    description: `A catalog of GraphQL examples with optional index file and type usage index`,
  }),
  make = Catalog.make,
  is = is$25(Catalog),
  decode$1 = decode$26(Catalog),
  decodeSync = decodeSync$18(Catalog),
  encode = encode$25(Catalog),
  encodeSync = encodeSync$4(Catalog),
  IndexComponent = null,
  catalogData = { examples: [] },
  examplesCatalog = runSync(decode$1(catalogData)),
  SidebarContext = (0, import_react.createContext)({}),
  MinorHeading = props =>
    (0, import_jsx_runtime.jsx)(p$2, {
      ...props,
      weight: `bold`,
      style: {
        ...props.style,
        color: `var(--accent-10)`,
        fontSize: `0.6rem`,
        letterSpacing: `0.025rem`,
        textTransform: `uppercase`,
      },
    }),
  Items = ({ items }) =>
    (0, import_jsx_runtime.jsx)(p$1, {
      direction: `column`,
      gap: `2px`,
      children: items.map((item, index$4) =>
        (0, import_jsx_runtime.jsx)(Item$1, { item }, `${item.pathExp}-${index$4}`)
      ),
    }),
  Item$1 = ({ item }) =>
    item.type === `ItemLink`
      ? (0, import_jsx_runtime.jsx)(SBLink, { link: item })
      : item.type === `ItemSection` && item.isLinkToo
      ? (0, import_jsx_runtime.jsx)(LinkedSection, { section: item })
      : (0, import_jsx_runtime.jsx)(Section, { section: item }),
  SBLink = ({ link: link$2 }) => {
    let location = useLocation(),
      { basePath } = (0, import_react.useContext)(SidebarContext),
      currentPathExp = location.pathname,
      href = joinSegmentsAndPaths(basePath, link$2.pathExp),
      active$1 = getPathActiveReport(href, currentPathExp),
      displayTitle = typeof link$2.title == `string` ? title(link$2.title) : link$2.title
    return (0, import_jsx_runtime.jsx)(Link$1, {
      role: `Sidebar Link`,
      color: active$1.is ? `iris` : `gray`,
      'data-testid': `sidebar-link-${link$2.pathExp}`,
      to: href,
      style: {
        display: `block`,
        textDecoration: `none`,
        color: active$1.is ? `var(--accent-12)` : void 0,
        backgroundColor: active$1.isDirect
          ? `var(--accent-3)`
          : active$1.isDescendant
          ? `var(--gray-2)`
          : `transparent`,
        borderRadius: `var(--radius-2)`,
      },
      children: (0, import_jsx_runtime.jsx)(p, { py: `2`, px: `4`, children: displayTitle }),
    })
  },
  Section = ({ section }) => {
    let displayTitle = typeof section.title == `string` ? title(section.title) : section.title
    return (0, import_jsx_runtime.jsxs)(p, {
      mt: `8`,
      children: [
        (0, import_jsx_runtime.jsx)(p, {
          ml: `4`,
          mb: `2`,
          children: (0, import_jsx_runtime.jsx)(MinorHeading, { color: `gray`, children: displayTitle }),
        }),
        (0, import_jsx_runtime.jsx)(Items, { items: section.links }),
      ],
    })
  },
  LinkedSection = ({ section }) =>
    (0, import_jsx_runtime.jsxs)(p, {
      children: [
        (0, import_jsx_runtime.jsx)(SBLink, { link: section }),
        (0, import_jsx_runtime.jsx)(p$1, {
          direction: `column`,
          gap: `2`,
          id: `section-${section.pathExp.replace(/\//g, `-`)}`,
          role: `group`,
          ml: `5`,
          py: `2px`,
          style: { borderLeft: `1px solid var(--gray-5)` },
          children: section.links.map((link$2, index$4) =>
            (0, import_jsx_runtime.jsx)(SectionLink, { link: link$2 }, `${link$2.pathExp}-${index$4}`)
          ),
        }),
      ],
    }),
  SectionLink = ({ link: link$2 }) => {
    let location = useLocation(),
      { basePath } = (0, import_react.useContext)(SidebarContext),
      href = joinSegmentsAndPaths(basePath, link$2.pathExp),
      active$1 = getPathActiveReport(href, location.pathname),
      displayTitle = typeof link$2.title == `string` ? title(link$2.title) : link$2.title
    return (0, import_jsx_runtime.jsx)(Link$1, {
      role: `Sidebar Link`,
      to: href,
      color: active$1.is ? `iris` : `gray`,
      style: {
        textDecoration: `none`,
        color: active$1.is ? `var(--accent-12)` : void 0,
        backgroundColor: active$1.isDirect
          ? `var(--accent-3)`
          : active$1.isDescendant
          ? `var(--gray-2)`
          : `transparent`,
        borderBottomRightRadius: `var(--radius-2)`,
        borderTopRightRadius: `var(--radius-2)`,
      },
      children: (0, import_jsx_runtime.jsx)(p, { py: `2`, px: `4`, children: displayTitle }),
    })
  },
  Sidebar = ({ data, basePath, topContent, ...props }) =>
    (0, import_jsx_runtime.jsx)(SidebarContext.Provider, {
      value: basePath === void 0 ? {} : { basePath },
      children: (0, import_jsx_runtime.jsxs)(p, {
        'data-testid': `sidebar`,
        role: `Sidebar`,
        ...props,
        children: [
          (0, import_jsx_runtime.jsx)(`style`, {
            children: `
            div[role="Sidebar"] a:not([data-active]):hover {
              background-color: var(--iris-2) !important;
            }
          `,
          }),
          topContent && (0, import_jsx_runtime.jsx)(p, { mb: `4`, children: topContent }),
          (0, import_jsx_runtime.jsx)(Items, { items: data }),
        ],
      }),
    })
function routeIndex(input) {
  let routeConfig = isComponentType(input) ? { Component: input } : input,
    { schema, loader: loader$3, handle: handle$2, ...restConfig } = routeConfig,
    routeId
  if (
    typeof restConfig.id == `string` ? routeId = restConfig.id : restConfig.id === !0 && (routeId = `@index`), !schema
  ) {
    return {
      ...restConfig,
      ...routeId && { id: routeId },
      handle: handle$2,
      loader: loader$3,
      index: !0,
      children: void 0,
    }
  }
  let route$1 = {
    ...restConfig,
    ...routeId && { id: routeId },
    index: !0,
    children: void 0,
    handle: { ...handle$2, schema, schemaId: routeId },
  }
  return loader$3 && (route$1.loader = async args$1 => {
    let result = loader$3(args$1), decodedData
    decodedData = isEffect(result) ? await runPromise(result) : await result
    let encodedData = encodeSync$4(schema)(decodedData)
    return encodedData
  }),
    route$1
}
const isComponentType = value$2 => typeof value$2 == `function`,
  DevelopmentTip = ({ title: title$1 = `Development Tip`, variant = `info`, children: children$3 }) => null,
  emptyComponents = {},
  MDXContext = import_react.createContext(emptyComponents)
function useMDXComponents(components) {
  let contextComponents = import_react.useContext(MDXContext)
  return import_react.useMemo(function() {
    return typeof components == `function` ? components(contextComponents) : { ...contextComponents, ...components }
  }, [contextComponents, components])
}
function MDXProvider(properties) {
  let allComponents
  return allComponents = properties.disableParentContext
    ? typeof properties.components == `function`
      ? properties.components(emptyComponents)
      : properties.components || emptyComponents
    : useMDXComponents(properties.components),
    import_react.createElement(MDXContext.Provider, { value: allComponents }, properties.children)
}
async function A(A$2) {
  throw Error(`no fs`)
}
async function B(A$2) {
  console.warn(`Code Hike warning: Fetching resource from network "${A$2}"`)
  let B$2 = await fetch(`https://lighter.codehike.org/${A$2}.json`)
  if (B$2.ok) return await B$2.json()
}
const Q = A$2 => /^#([A-Fa-f0-9]{3,4}){1,2}$/.test(A$2),
  g = (A$2, B$2) => A$2.match(RegExp(`.{${B$2}}`, `g`)),
  E = A$2 => parseInt(A$2.repeat(2 / A$2.length), 16)
function C$1(A$2, B$2) {
  return A$2 === void 0 ? typeof B$2 != `number` || B$2 < 0 || B$2 > 1 ? 1 : B$2 : A$2 / 255
}
function I(A$2, B$2) {
  if (!A$2) return A$2
  let { r: I$3, g: D$1, b: w$1, a: o$18 } = function(A$3) {
    if (!A$3) return
    if (!Q(A$3)) throw Error(`Invalid color string, must be a valid hex color`)
    let B$3 = Math.floor((A$3.length - 1) / 3), I$4 = g(A$3.slice(1), B$3), [D$2, w$2, o$19, s$14] = I$4.map(E)
    return { r: D$2, g: w$2, b: o$19, a: C$1(s$14, 1) }
  }(A$2)
  return function(A$3) {
    if (!A$3) return
    let { r: B$3, g: Q$1, b: g$3, a: E$2 } = A$3, C$4 = Math.round(255 * E$2)
    return `#${B$3.toString(16).padStart(2, `0`)}${Q$1.toString(16).padStart(2, `0`)}${
      g$3.toString(16).padStart(2, `0`)
    }${C$4.toString(16).padStart(2, `0`)}`
  }({ r: I$3, g: D$1, b: w$1, a: o$18 * B$2 })
}
function D(A$2) {
  return A$2.type === `from-css` ? `var(--ch-0)` : A$2.type
}
function w(A$2, B$2) {
  let Q$1 = A$2.colors || {}
  if (Q$1[B$2]) return Q$1[B$2]
  let g$3 = s[B$2]
  if (!g$3) throw Error(`Unknown theme color key: ${B$2}`)
  return typeof g$3 == `string` ? w(A$2, g$3) : function(A$3, B$3) {
    let Q$2 = B$3[A$3.type]
    if (Array.isArray(Q$2)) {
      let [B$4, g$4, ...E$2] = Q$2
      return B$4(w(A$3, g$4), ...E$2)
    }
    return Q$2
  }(A$2, g$3)
}
const o$5 = `#6FC3DF`,
  s = {
    'editor.foreground': { dark: `#bbbbbb`, light: `#333333`, hc: `#ffffff` },
    'editorLineNumber.foreground': { dark: `#858585`, light: `#237893`, hc: `#fffffe` },
    'editor.selectionBackground': { light: `#ADD6FF`, dark: `#264F78`, hc: `#f3f518` },
    'editor.background': { light: `#fffffe`, dark: `#1E1E1E`, hc: `#000000` },
    'editorGroupHeader.tabsBackground': { dark: `#252526`, light: `#F3F3F3` },
    'tab.activeBackground': `editor.background`,
    'tab.activeForeground': { dark: `#ffffff`, light: `#333333`, hc: `#ffffff` },
    'tab.border': { dark: `#252526`, light: `#F3F3F3`, hc: o$5 },
    'tab.activeBorder': `tab.activeBackground`,
    'tab.inactiveBackground': { dark: `#2D2D2D`, light: `#ECECEC` },
    'tab.inactiveForeground': {
      dark: [I, `tab.activeForeground`, .5],
      light: [I, `tab.activeForeground`, .5],
      hc: `#ffffff`,
    },
    'diffEditor.insertedTextBackground': { dark: `#9ccc2c33`, light: `#9ccc2c40` },
    'diffEditor.removedTextBackground': { dark: `#ff000033`, light: `#ff000033` },
    'diffEditor.insertedLineBackground': { dark: `#9bb95533`, light: `#9bb95533` },
    'diffEditor.removedLineBackground': { dark: `#ff000033`, light: `#ff000033` },
    'icon.foreground': { dark: `#C5C5C5`, light: `#424242`, hc: `#FFFFFF` },
    'sideBar.background': { dark: `#252526`, light: `#F3F3F3`, hc: `#000000` },
    'sideBar.foreground': `editor.foreground`,
    'sideBar.border': `sideBar.background`,
    'list.inactiveSelectionBackground': { dark: `#37373D`, light: `#E4E6F1` },
    'list.inactiveSelectionForeground': {},
    'list.hoverBackground': { dark: `#2A2D2E`, light: `#F0F0F0` },
    'list.hoverForeground': {},
    'editorGroupHeader.tabsBorder': { hc: o$5 },
    'tab.activeBorderTop': { hc: o$5 },
    'tab.hoverBackground': `tab.inactiveBackground`,
    'tab.hoverForeground': `tab.inactiveForeground`,
    'editor.rangeHighlightBackground': { dark: `#ffffff0b`, light: `#fdff0033` },
    'editor.infoForeground': { dark: `#3794FF`, light: `#1a85ff`, hc: `#3794FF` },
    'input.border': { hc: o$5 },
    'input.background': { dark: `#3C3C3C`, light: `#fffffe`, hc: `#000000` },
    'input.foreground': `editor.foreground`,
    'editor.lineHighlightBackground': {},
    focusBorder: { light: `#0090F1`, dark: `#007FD4`, hc: o$5 },
    'editorGroup.border': { dark: `#444444`, light: `#E7E7E7`, hc: o$5 },
    'list.activeSelectionBackground': { dark: `#094771`, light: `#0060C0`, hc: `#000000` },
    'list.activeSelectionForeground': { dark: `#fffffe`, light: `#fffffe`, hc: `#fffffe` },
    'lighter.inlineBackground': { dark: [I, `editor.background`, .9], light: [I, `editor.background`, .9] },
    'terminal.background': `editor.background`,
    'terminal.foreground': `editor.foreground`,
    'terminal.ansiBlack': { dark: `#000000`, light: `#000000`, hc: `#000000` },
    'terminal.ansiRed': { dark: `#cd3131`, light: `#cd3131`, hc: `#cd0000` },
    'terminal.ansiGreen': { dark: `#0DBC79`, light: `#00BC00`, hc: `#00cd00` },
    'terminal.ansiYellow': { dark: `#e5e510`, light: `#949800`, hc: `#cdcd00` },
    'terminal.ansiBlue': { dark: `#2472c8`, light: `#0451a5`, hc: `#0000ee` },
    'terminal.ansiMagenta': { dark: `#bc3fbc`, light: `#bc05bc`, hc: `#cd00cd` },
    'terminal.ansiCyan': { dark: `#11a8cd`, light: `#0598bc`, hc: `#00cdcd` },
    'terminal.ansiWhite': { dark: `#e5e5e5`, light: `#555555`, hc: `#e5e5e5` },
    'terminal.ansiBrightBlack': { dark: `#666666`, light: `#666666`, hc: `#7f7f7f` },
    'terminal.ansiBrightRed': { dark: `#f14c4c`, light: `#cd3131`, hc: `#ff0000` },
    'terminal.ansiBrightGreen': { dark: `#23d18b`, light: `#14CE14`, hc: `#00ff00` },
    'terminal.ansiBrightYellow': { dark: `#f5f543`, light: `#b5ba00`, hc: `#ffff00` },
    'terminal.ansiBrightBlue': { dark: `#3b8eea`, light: `#0451a5`, hc: `#5c5cff` },
    'terminal.ansiBrightMagenta': { dark: `#d670d6`, light: `#bc05bc`, hc: `#ff00ff` },
    'terminal.ansiBrightCyan': { dark: `#29b8db`, light: `#0598bc`, hc: `#00ffff` },
    'terminal.ansiBrightWhite': { dark: `#e5e5e5`, light: `#a5a5a5`, hc: `#ffffff` },
  },
  e$5 = new Map(),
  c = new Map()
async function i(A$2) {
  if (typeof A$2 == `string`) {
    let Q$1 = A$2
    if (!h.includes(Q$1)) throw new F(Q$1)
    if (!e$5.has(Q$1)) {
      let A$3 = async function(A$4) {
        try {
          return await async function(A$5) {
            throw Error(`no fs`)
          }()
        } catch {
          return await B(`themes/${A$4}`)
        }
      }(Q$1).then(A$4 => (c.set(Q$1, A$4), A$4))
      e$5.set(Q$1, A$3)
    }
    return e$5.get(Q$1)
  }
  return A$2
}
function t(A$2) {
  let B$2 = null
  if (typeof A$2 == `string`) {
    if (B$2 = c.get(A$2), !B$2) throw Error(`Syntax highlighting error: theme not loaded`)
    else B$2 = A$2
  }
  return function(A$3) {
    if (!A$3) return
    let B$3 = A$3.settings || A$3.tokenColors || [],
      Q$1 = {
        name: A$3.name || `unknown-theme`,
        type: M(A$3),
        foreground: ``,
        background: ``,
        settings: B$3,
        colors: A$3.colors || {},
        colorNames: A$3.colorNames,
      },
      g$3 = B$3.find(A$4 => !A$4.scope)
    if (g$3) {
      let { foreground: A$4, background: B$4 } = g$3?.settings || {}, E$2 = {}
      A$4 && !Q$1.colors[`editor.foreground`] && (E$2[`editor.foreground`] = A$4),
        B$4 && !Q$1.colors[`editor.background`] && (E$2[`editor.background`] = B$4),
        Object.keys(E$2).length > 0 && (Q$1.colors = Object.assign(Object.assign({}, Q$1.colors), E$2)),
        Q$1.foreground = A$4,
        Q$1.background = B$4
    }
    if (
      g$3
      || (Q$1.settings = [{
        settings: { foreground: w(Q$1, `editor.foreground`), background: w(Q$1, `editor.background`) },
      }, ...Q$1.settings]),
        Q$1.background = Q$1.background || w(Q$1, `editor.background`),
        Q$1.foreground = Q$1.foreground || w(Q$1, `editor.foreground`),
        A$3.type === `from-css` && !Q$1.colorNames
    ) {
      let A$4 = {}, B$4 = 0
      Q$1.settings = Q$1.settings.map(Q$2 => {
        let g$4 = Object.assign(Object.assign({}, Q$2), { settings: Object.assign({}, Q$2.settings) }),
          { foreground: E$2, background: C$4 } = g$4.settings || {}
        return E$2 && !A$4[E$2] && (A$4[E$2] = `#${B$4.toString(16).padStart(6, `0`)}`, B$4++),
          C$4 && !A$4[C$4] && (A$4[C$4] = `#${B$4.toString(16).padStart(6, `0`)}`, B$4++),
          E$2 && (g$4.settings.foreground = A$4[E$2]),
          C$4 && (g$4.settings.background = A$4[C$4]),
          g$4
      }), Q$1.colorNames = A$4
    }
    return Q$1
  }(B$2)
}
function M(A$2) {
  var B$2
  return A$2.type === `from-css`
    ? `from-css`
    : (A$2.type ? A$2.type : (B$2 = A$2.name)?.toLowerCase().includes(`light`) ? `light` : `dark`) === `light`
    ? `light`
    : `dark`
}
const h = [
  `dark-plus`,
  `dracula-soft`,
  `dracula`,
  `github-dark`,
  `github-dark-dimmed`,
  `github-from-css`,
  `github-light`,
  `light-plus`,
  `material-darker`,
  `material-default`,
  `material-from-css`,
  `material-lighter`,
  `material-ocean`,
  `material-palenight`,
  `min-dark`,
  `min-light`,
  `monokai`,
  `nord`,
  `one-dark-pro`,
  `poimandres`,
  `slack-dark`,
  `slack-ochin`,
  `solarized-dark`,
  `solarized-light`,
]
var F = class extends Error {
  constructor(A$2) {
    super(`Unknown theme: ${A$2}`), this.theme = A$2
  }
}
const a =
    `abap.actionscript-3.ada.adoc.angular-html.angular-ts.apache.apex.apl.applescript.ara.asciidoc.asm.astro.awk.ballerina.bash.bat.batch.be.beancount.berry.bibtex.bicep.blade.c.c#.c++.cadence.cdc.clarity.clj.clojure.closure-templates.cmake.cmd.cobol.codeowners.codeql.coffee.coffeescript.common-lisp.console.cpp.cql.crystal.cs.csharp.css.csv.cue.cypher.d.dart.dax.desktop.diff.docker.dockerfile.dotenv.dream-maker.edge.elisp.elixir.elm.emacs-lisp.erb.erl.erlang.f.f#.f03.f08.f18.f77.f90.f95.fennel.fish.fluent.for.fortran-fixed-form.fortran-free-form.fs.fsharp.fsl.ftl.gdresource.gdscript.gdshader.genie.gherkin.git-commit.git-rebase.gjs.gleam.glimmer-js.glimmer-ts.glsl.gnuplot.go.gql.graphql.groovy.gts.hack.haml.handlebars.haskell.haxe.hbs.hcl.hjson.hlsl.hs.html.html-derivative.http.hxml.hy.imba.ini.jade.java.javascript.jinja.jison.jl.js.json.json5.jsonc.jsonl.jsonnet.jssm.jsx.julia.kotlin.kql.kt.kts.kusto.latex.lean.lean4.less.liquid.lisp.lit.log.logo.lua.luau.make.makefile.markdown.marko.matlab.md.mdc.mdx.mediawiki.mermaid.mojo.move.nar.narrat.nextflow.nf.nginx.nim.nix.nu.nushell.objc.objective-c.objective-cpp.ocaml.pascal.perl.perl6.php.plsql.po.postcss.pot.potx.powerquery.powershell.prisma.prolog.properties.proto.ps.ps1.pug.puppet.purescript.py.python.ql.qml.qmldir.qss.r.racket.raku.razor.rb.reg.regex.regexp.rel.riscv.rs.rst.ruby.rust.sas.sass.scala.scheme.scss.sh.shader.shaderlab.shell.shellscript.shellsession.smalltalk.solidity.soy.sparql.spl.splunk.sql.ssh-config.stata.styl.stylus.svelte.swift.system-verilog.systemd.tasl.tcl.templ.terminal.terraform.tex.text.tf.tfvars.toml.ts.ts-tags.tsp.tsv.tsx.turtle.twig.txt.typ.typescript.typespec.typst.v.vala.vb.verilog.vhdl.vim.viml.vimscript.vue.vue-html.vy.vyper.wasm.wenyan.wgsl.wiki.wikitext.wl.wolfram.xml.xsl.yaml.yml.zenscript.zig.zsh.`
      .split(`.`),
  n = {
    abap: `source.abap`,
    'actionscript-3': `source.actionscript.3`,
    ada: `source.ada`,
    'angular-html': `text.html.derivative.ng`,
    'angular-ts': `source.ts.ng`,
    apache: `source.apacheconf`,
    apex: `source.apex`,
    apl: `source.apl`,
    applescript: `source.applescript`,
    ara: `source.ara`,
    asciidoc: `text.asciidoc`,
    adoc: `text.asciidoc`,
    asm: `source.asm.x86_64`,
    astro: `source.astro`,
    awk: `source.awk`,
    ballerina: `source.ballerina`,
    bat: `source.batchfile`,
    batch: `source.batchfile`,
    beancount: `text.beancount`,
    berry: `source.berry`,
    be: `source.berry`,
    bibtex: `text.bibtex`,
    bicep: `source.bicep`,
    blade: `text.html.php.blade`,
    c: `source.c`,
    cadence: `source.cadence`,
    cdc: `source.cadence`,
    clarity: `source.clar`,
    clojure: `source.clojure`,
    clj: `source.clojure`,
    cmake: `source.cmake`,
    cobol: `source.cobol`,
    codeowners: `text.codeowners`,
    codeql: `source.ql`,
    ql: `source.ql`,
    coffee: `source.coffee`,
    coffeescript: `source.coffee`,
    'common-lisp': `source.commonlisp`,
    lisp: `source.commonlisp`,
    cpp: `source.cpp`,
    'c++': `source.cpp`,
    crystal: `source.crystal`,
    csharp: `source.cs`,
    'c#': `source.cs`,
    cs: `source.cs`,
    css: `source.css`,
    csv: `text.csv`,
    cue: `source.cue`,
    cypher: `source.cypher`,
    cql: `source.cypher`,
    d: `source.d`,
    dart: `source.dart`,
    dax: `source.dax`,
    desktop: `source.desktop`,
    diff: `source.diff`,
    docker: `source.dockerfile`,
    dockerfile: `source.dockerfile`,
    dotenv: `source.dotenv`,
    'dream-maker': `source.dm`,
    edge: `text.html.edge`,
    elixir: `source.elixir`,
    elm: `source.elm`,
    'emacs-lisp': `source.emacs.lisp`,
    elisp: `source.emacs.lisp`,
    erb: `text.html.erb`,
    erlang: `source.erlang`,
    erl: `source.erlang`,
    fennel: `source.fnl`,
    fish: `source.fish`,
    fluent: `source.ftl`,
    ftl: `source.ftl`,
    'fortran-fixed-form': `source.fortran.fixed`,
    f: `source.fortran.fixed`,
    for: `source.fortran.fixed`,
    f77: `source.fortran.fixed`,
    'fortran-free-form': `source.fortran.free`,
    f90: `source.fortran.free`,
    f95: `source.fortran.free`,
    f03: `source.fortran.free`,
    f08: `source.fortran.free`,
    f18: `source.fortran.free`,
    fsharp: `source.fsharp`,
    'f#': `source.fsharp`,
    fs: `source.fsharp`,
    gdresource: `source.gdresource`,
    gdscript: `source.gdscript`,
    gdshader: `source.gdshader`,
    genie: `source.genie`,
    gherkin: `text.gherkin.feature`,
    'git-commit': `text.git-commit`,
    'git-rebase': `text.git-rebase`,
    gleam: `source.gleam`,
    'glimmer-js': `source.gjs`,
    gjs: `source.gjs`,
    'glimmer-ts': `source.gts`,
    gts: `source.gts`,
    glsl: `source.glsl`,
    gnuplot: `source.gnuplot`,
    go: `source.go`,
    graphql: `source.graphql`,
    gql: `source.graphql`,
    groovy: `source.groovy`,
    hack: `source.hack`,
    haml: `text.haml`,
    handlebars: `text.html.handlebars`,
    hbs: `text.html.handlebars`,
    haskell: `source.haskell`,
    hs: `source.haskell`,
    haxe: `source.hx`,
    hcl: `source.hcl`,
    hjson: `source.hjson`,
    hlsl: `source.hlsl`,
    html: `text.html.basic`,
    'html-derivative': `text.html.derivative`,
    http: `source.http`,
    hxml: `source.hxml`,
    hy: `source.hy`,
    imba: `source.imba`,
    ini: `source.ini`,
    properties: `source.ini`,
    java: `source.java`,
    javascript: `source.js`,
    js: `source.js`,
    jinja: `source.jinja`,
    jison: `source.jison`,
    json: `source.json`,
    json5: `source.json5`,
    jsonc: `source.json.comments`,
    jsonl: `source.json.lines`,
    jsonnet: `source.jsonnet`,
    jssm: `source.jssm`,
    fsl: `source.jssm`,
    jsx: `source.js.jsx`,
    julia: `source.julia`,
    jl: `source.julia`,
    kotlin: `source.kotlin`,
    kt: `source.kotlin`,
    kts: `source.kotlin`,
    kusto: `source.kusto`,
    kql: `source.kusto`,
    latex: `text.tex.latex`,
    lean: `source.lean4`,
    lean4: `source.lean4`,
    less: `source.css.less`,
    liquid: `text.html.liquid`,
    log: `text.log`,
    logo: `source.logo`,
    lua: `source.lua`,
    luau: `source.luau`,
    make: `source.makefile`,
    makefile: `source.makefile`,
    markdown: `text.html.markdown`,
    md: `text.html.markdown`,
    marko: `text.marko`,
    matlab: `source.matlab`,
    mdc: `text.markdown.mdc`,
    mdx: `source.mdx`,
    mermaid: `markdown.mermaid.codeblock`,
    mojo: `source.mojo`,
    move: `source.move`,
    narrat: `source.narrat`,
    nar: `source.narrat`,
    nextflow: `source.nextflow`,
    nf: `source.nextflow`,
    nginx: `source.nginx`,
    nim: `source.nim`,
    nix: `source.nix`,
    nushell: `source.nushell`,
    nu: `source.nushell`,
    'objective-c': `source.objc`,
    objc: `source.objc`,
    'objective-cpp': `source.objcpp`,
    ocaml: `source.ocaml`,
    pascal: `source.pascal`,
    perl: `source.perl`,
    php: `source.php`,
    plsql: `source.plsql.oracle`,
    po: `source.po`,
    pot: `source.po`,
    potx: `source.po`,
    postcss: `source.css.postcss`,
    powerquery: `source.powerquery`,
    powershell: `source.powershell`,
    ps: `source.powershell`,
    ps1: `source.powershell`,
    prisma: `source.prisma`,
    prolog: `source.prolog`,
    proto: `source.proto`,
    pug: `text.pug`,
    jade: `text.pug`,
    puppet: `source.puppet`,
    purescript: `source.purescript`,
    python: `source.python`,
    py: `source.python`,
    qml: `source.qml`,
    qmldir: `source.qmldir`,
    qss: `source.qss`,
    r: `source.r`,
    racket: `source.racket`,
    raku: `source.perl.6`,
    perl6: `source.perl.6`,
    razor: `text.aspnetcorerazor`,
    reg: `source.reg`,
    regexp: `source.regexp.python`,
    regex: `source.regexp.python`,
    rel: `source.rel`,
    riscv: `source.riscv`,
    rst: `source.rst`,
    ruby: `source.ruby`,
    rb: `source.ruby`,
    rust: `source.rust`,
    rs: `source.rust`,
    sas: `source.sas`,
    sass: `source.sass`,
    scala: `source.scala`,
    scheme: `source.scheme`,
    scss: `source.css.scss`,
    shaderlab: `source.shaderlab`,
    shader: `source.shaderlab`,
    shellscript: `source.shell`,
    bash: `source.shell`,
    sh: `source.shell`,
    shell: `source.shell`,
    zsh: `source.shell`,
    shellsession: `text.shell-session`,
    console: `text.shell-session`,
    smalltalk: `source.smalltalk`,
    solidity: `source.solidity`,
    soy: `text.html.soy`,
    'closure-templates': `text.html.soy`,
    sparql: `source.sparql`,
    splunk: `source.splunk_search`,
    spl: `source.splunk_search`,
    sql: `source.sql`,
    'ssh-config': `source.ssh-config`,
    stata: `source.stata`,
    stylus: `source.stylus`,
    styl: `source.stylus`,
    svelte: `source.svelte`,
    swift: `source.swift`,
    'system-verilog': `source.systemverilog`,
    systemd: `source.systemd`,
    tasl: `source.tasl`,
    tcl: `source.tcl`,
    templ: `source.templ`,
    terraform: `source.hcl.terraform`,
    tf: `source.hcl.terraform`,
    tfvars: `source.hcl.terraform`,
    tex: `text.tex`,
    toml: `source.toml`,
    'ts-tags': `source.ts.tags`,
    lit: `source.ts.tags`,
    tsv: `text.tsv`,
    tsx: `source.tsx`,
    turtle: `source.turtle`,
    twig: `text.html.twig`,
    txt: `source.txt`,
    typescript: `source.ts`,
    ts: `source.ts`,
    typespec: `source.tsp`,
    tsp: `source.tsp`,
    typst: `source.typst`,
    typ: `source.typst`,
    v: `source.v`,
    vala: `source.vala`,
    vb: `source.asp.vb.net`,
    cmd: `source.asp.vb.net`,
    verilog: `source.verilog`,
    vhdl: `source.vhdl`,
    viml: `source.viml`,
    vim: `source.viml`,
    vimscript: `source.viml`,
    vue: `source.vue`,
    'vue-html': `text.html.vue-html`,
    vyper: `source.vyper`,
    vy: `source.vyper`,
    wasm: `source.wat`,
    wenyan: `source.wenyan`,
    : `source.wenyan`,
    wgsl: `source.wgsl`,
    wikitext: `source.wikitext`,
    mediawiki: `source.wikitext`,
    wiki: `source.wikitext`,
    wolfram: `source.wolfram`,
    wl: `source.wolfram`,
    xml: `text.xml`,
    xsl: `text.xml.xsl`,
    yaml: `source.yaml`,
    yml: `source.yaml`,
    zenscript: `source.zenscript`,
    zig: `source.zig`,
  },
  N = {
    'source.abap': { id: `abap`, embeddedScopes: [] },
    'source.actionscript.3': { id: `actionscript-3`, embeddedScopes: [] },
    'source.ada': { id: `ada`, embeddedScopes: [] },
    'text.html.derivative.ng': { id: `angular-html`, embeddedScopes: [`text.html.basic`] },
    'source.ts.ng': { id: `angular-ts`, embeddedScopes: [] },
    'source.apacheconf': { id: `apache`, embeddedScopes: [] },
    'source.apex': { id: `apex`, embeddedScopes: [] },
    'source.apl': {
      id: `apl`,
      embeddedScopes: [`text.html.basic`, `text.xml`, `source.css`, `source.js`, `source.json`],
    },
    'source.applescript': { id: `applescript`, embeddedScopes: [] },
    'source.ara': { id: `ara`, embeddedScopes: [] },
    'text.asciidoc': {
      id: `asciidoc`,
      embeddedScopes:
        `text.html.basic,source.yaml,text.csv,source.c,source.clojure,source.coffee,source.cpp,source.css,source.cs,source.diff,source.dockerfile,source.elixir,source.elm,source.erlang,source.go,source.groovy,source.haskell,source.java,source.js,source.json,source.js.jsx,source.julia,source.kotlin,source.css.less,source.makefile,source.objc,source.ocaml,source.perl,source.python,source.r,source.ruby,source.rust,source.sass,source.scala,source.css.scss,source.shell,source.sql,source.swift,source.toml,source.ts,text.xml`
          .split(`,`),
    },
    'source.asm.x86_64': { id: `asm`, embeddedScopes: [] },
    'source.astro': {
      id: `astro`,
      embeddedScopes: [
        `source.json`,
        `source.js`,
        `source.ts`,
        `source.stylus`,
        `source.sass`,
        `source.css`,
        `source.css.scss`,
        `source.css.less`,
        `source.css.postcss`,
        `source.tsx`,
      ],
    },
    'source.awk': { id: `awk`, embeddedScopes: [] },
    'source.ballerina': { id: `ballerina`, embeddedScopes: [] },
    'source.batchfile': { id: `bat`, embeddedScopes: [] },
    'text.beancount': { id: `beancount`, embeddedScopes: [] },
    'source.berry': { id: `berry`, embeddedScopes: [] },
    'text.bibtex': { id: `bibtex`, embeddedScopes: [] },
    'source.bicep': { id: `bicep`, embeddedScopes: [] },
    'text.html.php.blade': {
      id: `blade`,
      embeddedScopes: [`text.html.basic`, `text.xml`, `source.sql`, `source.js`, `source.json`, `source.css`],
    },
    'source.c': { id: `c`, embeddedScopes: [] },
    'source.cadence': { id: `cadence`, embeddedScopes: [] },
    'source.clar': { id: `clarity`, embeddedScopes: [] },
    'source.clojure': { id: `clojure`, embeddedScopes: [] },
    'source.cmake': { id: `cmake`, embeddedScopes: [] },
    'source.cobol': { id: `cobol`, embeddedScopes: [`source.sql`, `text.html.basic`, `source.java`] },
    'text.codeowners': { id: `codeowners`, embeddedScopes: [] },
    'source.ql': { id: `codeql`, embeddedScopes: [] },
    'source.coffee': { id: `coffee`, embeddedScopes: [`source.js`] },
    'source.commonlisp': { id: `common-lisp`, embeddedScopes: [] },
    'source.cpp': { id: `cpp`, embeddedScopes: [`source.regexp.python`, `source.glsl`, `source.sql`] },
    'source.crystal': {
      id: `crystal`,
      embeddedScopes: [`text.html.basic`, `source.sql`, `source.css`, `source.c`, `source.js`, `source.shell`],
    },
    'source.cs': { id: `csharp`, embeddedScopes: [] },
    'source.css': { id: `css`, embeddedScopes: [] },
    'text.csv': { id: `csv`, embeddedScopes: [] },
    'source.cue': { id: `cue`, embeddedScopes: [] },
    'source.cypher': { id: `cypher`, embeddedScopes: [] },
    'source.d': { id: `d`, embeddedScopes: [] },
    'source.dart': { id: `dart`, embeddedScopes: [] },
    'source.dax': { id: `dax`, embeddedScopes: [] },
    'source.desktop': { id: `desktop`, embeddedScopes: [] },
    'source.diff': { id: `diff`, embeddedScopes: [] },
    'source.dockerfile': { id: `docker`, embeddedScopes: [] },
    'source.dotenv': { id: `dotenv`, embeddedScopes: [] },
    'source.dm': { id: `dream-maker`, embeddedScopes: [] },
    'text.html.edge': { id: `edge`, embeddedScopes: [`source.ts`, `text.html.basic`, `text.html.derivative`] },
    'source.elixir': { id: `elixir`, embeddedScopes: [`text.html.basic`] },
    'source.elm': { id: `elm`, embeddedScopes: [`source.glsl`] },
    'source.emacs.lisp': { id: `emacs-lisp`, embeddedScopes: [] },
    'text.html.erb': { id: `erb`, embeddedScopes: [`text.html.basic`, `source.ruby`] },
    'source.erlang': { id: `erlang`, embeddedScopes: [] },
    'source.fnl': { id: `fennel`, embeddedScopes: [] },
    'source.fish': { id: `fish`, embeddedScopes: [] },
    'source.ftl': { id: `fluent`, embeddedScopes: [] },
    'source.fortran.fixed': { id: `fortran-fixed-form`, embeddedScopes: [`source.fortran.free`] },
    'source.fortran.free': { id: `fortran-free-form`, embeddedScopes: [] },
    'source.fsharp': { id: `fsharp`, embeddedScopes: [`text.html.markdown`] },
    'source.gdresource': { id: `gdresource`, embeddedScopes: [`source.gdshader`, `source.gdscript`] },
    'source.gdscript': { id: `gdscript`, embeddedScopes: [] },
    'source.gdshader': { id: `gdshader`, embeddedScopes: [] },
    'source.genie': { id: `genie`, embeddedScopes: [] },
    'text.gherkin.feature': { id: `gherkin`, embeddedScopes: [] },
    'text.git-commit': { id: `git-commit`, embeddedScopes: [`source.diff`] },
    'text.git-rebase': { id: `git-rebase`, embeddedScopes: [`source.shell`] },
    'source.gleam': { id: `gleam`, embeddedScopes: [] },
    'source.gjs': { id: `glimmer-js`, embeddedScopes: [`source.js`, `source.ts`, `source.css`, `text.html.basic`] },
    'source.gts': { id: `glimmer-ts`, embeddedScopes: [`source.ts`, `source.css`, `source.js`, `text.html.basic`] },
    'source.glsl': { id: `glsl`, embeddedScopes: [`source.c`] },
    'source.gnuplot': { id: `gnuplot`, embeddedScopes: [] },
    'source.go': { id: `go`, embeddedScopes: [] },
    'source.graphql': { id: `graphql`, embeddedScopes: [`source.js`, `source.ts`, `source.js.jsx`, `source.tsx`] },
    'source.groovy': { id: `groovy`, embeddedScopes: [] },
    'source.hack': { id: `hack`, embeddedScopes: [`text.html.basic`, `source.sql`] },
    'text.haml': {
      id: `haml`,
      embeddedScopes: [`source.ruby`, `source.js`, `source.sass`, `source.coffee`, `text.html.markdown`, `source.css`],
    },
    'text.html.handlebars': {
      id: `handlebars`,
      embeddedScopes: [`text.html.basic`, `source.css`, `source.js`, `source.yaml`],
    },
    'source.haskell': { id: `haskell`, embeddedScopes: [] },
    'source.hx': { id: `haxe`, embeddedScopes: [] },
    'source.hcl': { id: `hcl`, embeddedScopes: [] },
    'source.hjson': { id: `hjson`, embeddedScopes: [] },
    'source.hlsl': { id: `hlsl`, embeddedScopes: [] },
    'text.html.basic': { id: `html`, embeddedScopes: [`source.js`, `source.css`] },
    'text.html.derivative': { id: `html-derivative`, embeddedScopes: [`text.html.basic`] },
    'source.http': { id: `http`, embeddedScopes: [`source.shell`, `source.json`, `text.xml`, `source.graphql`] },
    'source.hxml': { id: `hxml`, embeddedScopes: [`source.hx`] },
    'source.hy': { id: `hy`, embeddedScopes: [] },
    'source.imba': { id: `imba`, embeddedScopes: [`source.ts`] },
    'source.ini': { id: `ini`, embeddedScopes: [] },
    'source.java': { id: `java`, embeddedScopes: [] },
    'source.js': { id: `javascript`, embeddedScopes: [] },
    'source.jinja': { id: `jinja`, embeddedScopes: [] },
    'source.jison': { id: `jison`, embeddedScopes: [`source.js`] },
    'source.json': { id: `json`, embeddedScopes: [] },
    'source.json5': { id: `json5`, embeddedScopes: [] },
    'source.json.comments': { id: `jsonc`, embeddedScopes: [] },
    'source.json.lines': { id: `jsonl`, embeddedScopes: [] },
    'source.jsonnet': { id: `jsonnet`, embeddedScopes: [] },
    'source.jssm': { id: `jssm`, embeddedScopes: [] },
    'source.js.jsx': { id: `jsx`, embeddedScopes: [] },
    'source.julia': {
      id: `julia`,
      embeddedScopes: [`source.cpp`, `source.python`, `source.js`, `source.r`, `source.sql`],
    },
    'source.kotlin': { id: `kotlin`, embeddedScopes: [] },
    'source.kusto': { id: `kusto`, embeddedScopes: [] },
    'text.tex.latex': {
      id: `latex`,
      embeddedScopes: [
        `text.tex`,
        `source.shell`,
        `source.css`,
        `source.gnuplot`,
        `source.haskell`,
        `text.html.basic`,
        `source.java`,
        `source.julia`,
        `source.js`,
        `source.lua`,
        `source.python`,
        `source.ruby`,
        `source.rust`,
        `source.ts`,
        `text.xml`,
        `source.yaml`,
        `source.scala`,
      ],
    },
    'source.lean4': { id: `lean`, embeddedScopes: [] },
    'source.css.less': { id: `less`, embeddedScopes: [] },
    'text.html.liquid': { id: `liquid`, embeddedScopes: [`text.html.basic`, `source.css`, `source.json`, `source.js`] },
    'text.log': { id: `log`, embeddedScopes: [] },
    'source.logo': { id: `logo`, embeddedScopes: [] },
    'source.lua': { id: `lua`, embeddedScopes: [`source.c`] },
    'source.luau': { id: `luau`, embeddedScopes: [] },
    'source.makefile': { id: `make`, embeddedScopes: [] },
    'text.html.markdown': {
      id: `markdown`,
      embeddedScopes:
        `source.css,text.html.basic,source.ini,source.java,source.lua,source.makefile,source.perl,source.r,source.ruby,source.php,source.sql,source.asp.vb.net,text.xml,text.xml.xsl,source.yaml,source.batchfile,source.clojure,source.coffee,source.c,source.cpp,source.diff,source.dockerfile,text.git-commit,text.git-rebase,source.go,source.groovy,text.pug,source.js,source.json,source.json.comments,source.css.less,source.objc,source.swift,source.css.scss,source.perl.6,source.powershell,source.python,source.julia,source.regexp.python,source.rust,source.scala,source.shell,source.ts,source.tsx,source.cs,source.fsharp,source.dart,text.html.handlebars,text.log,source.erlang,source.elixir,text.tex.latex,text.bibtex,text.html.derivative`
          .split(`,`),
    },
    'text.marko': { id: `marko`, embeddedScopes: [`source.css`, `source.css.less`, `source.css.scss`, `source.js`] },
    'source.matlab': { id: `matlab`, embeddedScopes: [] },
    'text.markdown.mdc': { id: `mdc`, embeddedScopes: [`text.html.markdown`, `source.yaml`, `text.html.derivative`] },
    'source.mdx': {
      id: `mdx`,
      embeddedScopes:
        `source.tsx,source.toml,source.yaml,source.c,source.clojure,source.coffee,source.cpp,source.cs,source.css,source.diff,source.dockerfile,source.elixir,source.elm,source.erlang,source.go,source.graphql,source.haskell,text.html.basic,source.ini,source.java,source.js,source.json,source.julia,source.kotlin,source.css.less,source.lua,source.makefile,text.html.markdown,source.objc,source.perl,source.python,source.r,source.ruby,source.rust,source.scala,source.css.scss,source.shell,text.shell-session,source.sql,text.xml,source.swift,source.ts`
          .split(`,`),
    },
    'markdown.mermaid.codeblock': { id: `mermaid`, embeddedScopes: [] },
    'source.mojo': { id: `mojo`, embeddedScopes: [] },
    'source.move': { id: `move`, embeddedScopes: [] },
    'source.narrat': { id: `narrat`, embeddedScopes: [] },
    'source.nextflow': { id: `nextflow`, embeddedScopes: [] },
    'source.nginx': { id: `nginx`, embeddedScopes: [`source.lua`] },
    'source.nim': {
      id: `nim`,
      embeddedScopes: [
        `source.c`,
        `text.html.basic`,
        `text.xml`,
        `source.js`,
        `source.css`,
        `source.glsl`,
        `text.html.markdown`,
      ],
    },
    'source.nix': { id: `nix`, embeddedScopes: [] },
    'source.nushell': { id: `nushell`, embeddedScopes: [] },
    'source.objc': { id: `objective-c`, embeddedScopes: [] },
    'source.objcpp': { id: `objective-cpp`, embeddedScopes: [] },
    'source.ocaml': { id: `ocaml`, embeddedScopes: [] },
    'source.pascal': { id: `pascal`, embeddedScopes: [] },
    'source.perl': {
      id: `perl`,
      embeddedScopes: [`text.html.basic`, `text.xml`, `source.css`, `source.js`, `source.sql`],
    },
    'source.php': {
      id: `php`,
      embeddedScopes: [`text.html.basic`, `text.xml`, `source.sql`, `source.js`, `source.json`, `source.css`],
    },
    'source.plsql.oracle': { id: `plsql`, embeddedScopes: [] },
    'source.po': { id: `po`, embeddedScopes: [] },
    'source.css.postcss': { id: `postcss`, embeddedScopes: [] },
    'source.powerquery': { id: `powerquery`, embeddedScopes: [] },
    'source.powershell': { id: `powershell`, embeddedScopes: [] },
    'source.prisma': { id: `prisma`, embeddedScopes: [] },
    'source.prolog': { id: `prolog`, embeddedScopes: [] },
    'source.proto': { id: `proto`, embeddedScopes: [] },
    'text.pug': {
      id: `pug`,
      embeddedScopes: [
        `source.js`,
        `source.css`,
        `source.sass`,
        `source.css.scss`,
        `source.stylus`,
        `source.coffee`,
        `text.html.basic`,
      ],
    },
    'source.puppet': { id: `puppet`, embeddedScopes: [] },
    'source.purescript': { id: `purescript`, embeddedScopes: [] },
    'source.python': { id: `python`, embeddedScopes: [] },
    'source.qml': { id: `qml`, embeddedScopes: [`source.js`] },
    'source.qmldir': { id: `qmldir`, embeddedScopes: [] },
    'source.qss': { id: `qss`, embeddedScopes: [] },
    'source.r': { id: `r`, embeddedScopes: [] },
    'source.racket': { id: `racket`, embeddedScopes: [] },
    'source.perl.6': { id: `raku`, embeddedScopes: [] },
    'text.aspnetcorerazor': { id: `razor`, embeddedScopes: [`text.html.basic`, `source.cs`] },
    'source.reg': { id: `reg`, embeddedScopes: [] },
    'source.regexp.python': { id: `regexp`, embeddedScopes: [] },
    'source.rel': { id: `rel`, embeddedScopes: [] },
    'source.riscv': { id: `riscv`, embeddedScopes: [] },
    'source.rst': {
      id: `rst`,
      embeddedScopes: [
        `text.html.derivative`,
        `source.cpp`,
        `source.python`,
        `source.js`,
        `source.shell`,
        `source.yaml`,
        `source.cmake`,
        `source.ruby`,
      ],
    },
    'source.ruby': {
      id: `ruby`,
      embeddedScopes: [
        `text.html.basic`,
        `text.xml`,
        `source.sql`,
        `source.css`,
        `source.c`,
        `source.js`,
        `source.shell`,
        `source.lua`,
      ],
    },
    'source.rust': { id: `rust`, embeddedScopes: [] },
    'source.sas': { id: `sas`, embeddedScopes: [`source.sql`] },
    'source.sass': { id: `sass`, embeddedScopes: [] },
    'source.scala': { id: `scala`, embeddedScopes: [] },
    'source.scheme': { id: `scheme`, embeddedScopes: [] },
    'source.css.scss': { id: `scss`, embeddedScopes: [`source.css`] },
    'source.shaderlab': { id: `shaderlab`, embeddedScopes: [`source.hlsl`] },
    'source.shell': { id: `shellscript`, embeddedScopes: [] },
    'text.shell-session': { id: `shellsession`, embeddedScopes: [`source.shell`] },
    'source.smalltalk': { id: `smalltalk`, embeddedScopes: [] },
    'source.solidity': { id: `solidity`, embeddedScopes: [] },
    'text.html.soy': { id: `soy`, embeddedScopes: [`text.html.basic`] },
    'source.sparql': { id: `sparql`, embeddedScopes: [`source.turtle`] },
    'source.splunk_search': { id: `splunk`, embeddedScopes: [] },
    'source.sql': { id: `sql`, embeddedScopes: [] },
    'source.ssh-config': { id: `ssh-config`, embeddedScopes: [] },
    'source.stata': { id: `stata`, embeddedScopes: [`source.sql`] },
    'source.stylus': { id: `stylus`, embeddedScopes: [] },
    'source.svelte': {
      id: `svelte`,
      embeddedScopes: [
        `source.js`,
        `source.ts`,
        `source.coffee`,
        `source.stylus`,
        `source.sass`,
        `source.css`,
        `source.css.scss`,
        `source.css.less`,
        `source.css.postcss`,
        `text.pug`,
        `text.html.markdown`,
      ],
    },
    'source.swift': { id: `swift`, embeddedScopes: [] },
    'source.systemverilog': { id: `system-verilog`, embeddedScopes: [] },
    'source.systemd': { id: `systemd`, embeddedScopes: [] },
    'source.tasl': { id: `tasl`, embeddedScopes: [] },
    'source.tcl': { id: `tcl`, embeddedScopes: [] },
    'source.templ': { id: `templ`, embeddedScopes: [`source.go`, `source.js`, `source.css`] },
    'source.hcl.terraform': { id: `terraform`, embeddedScopes: [] },
    'text.tex': { id: `tex`, embeddedScopes: [`source.r`] },
    'source.toml': { id: `toml`, embeddedScopes: [] },
    'source.ts.tags': { id: `ts-tags`, embeddedScopes: [`source.ts`] },
    'text.tsv': { id: `tsv`, embeddedScopes: [] },
    'source.tsx': { id: `tsx`, embeddedScopes: [] },
    'source.turtle': { id: `turtle`, embeddedScopes: [] },
    'text.html.twig': {
      id: `twig`,
      embeddedScopes: [`source.css`, `source.js`, `source.css.scss`, `source.php`, `source.python`, `source.ruby`],
    },
    'source.txt': { id: `txt`, embeddedScopes: [] },
    'source.ts': { id: `typescript`, embeddedScopes: [] },
    'source.tsp': { id: `typespec`, embeddedScopes: [] },
    'source.typst': { id: `typst`, embeddedScopes: [] },
    'source.v': { id: `v`, embeddedScopes: [] },
    'source.vala': { id: `vala`, embeddedScopes: [] },
    'source.asp.vb.net': { id: `vb`, embeddedScopes: [] },
    'source.verilog': { id: `verilog`, embeddedScopes: [] },
    'source.vhdl': { id: `vhdl`, embeddedScopes: [] },
    'source.viml': { id: `viml`, embeddedScopes: [] },
    'source.vue': {
      id: `vue`,
      embeddedScopes: [
        `text.html.basic`,
        `text.html.markdown`,
        `text.pug`,
        `source.stylus`,
        `source.sass`,
        `source.css`,
        `source.css.scss`,
        `source.css.less`,
        `source.js`,
        `source.ts`,
        `source.js.jsx`,
        `source.tsx`,
        `source.coffee`,
        `source.json`,
        `source.json.comments`,
        `source.json5`,
        `source.yaml`,
        `source.toml`,
        `source.graphql`,
        `text.html.derivative`,
      ],
    },
    'text.html.vue-html': { id: `vue-html`, embeddedScopes: [`source.vue`, `source.js`] },
    'source.vyper': { id: `vyper`, embeddedScopes: [] },
    'source.wat': { id: `wasm`, embeddedScopes: [] },
    'source.wenyan': { id: `wenyan`, embeddedScopes: [] },
    'source.wgsl': { id: `wgsl`, embeddedScopes: [] },
    'source.wikitext': {
      id: `wikitext`,
      embeddedScopes:
        `text.html.basic,source.css,source.ini,source.java,source.lua,source.makefile,source.perl,source.r,source.ruby,source.php,source.sql,source.asp.vb.net,text.xml,text.xml.xsl,source.yaml,source.batchfile,source.clojure,source.coffee,source.c,source.cpp,source.diff,source.dockerfile,source.go,source.groovy,text.pug,source.js,source.json.comments,source.css.less,source.objc,source.swift,source.css.scss,source.perl.6,source.powershell,source.python,source.julia,source.rust,source.scala,source.shell,source.ts,source.cs,source.fsharp,source.dart,text.html.handlebars,text.html.markdown,source.erlang,source.elixir,text.tex.latex,text.bibtex,source.json`
          .split(`,`),
    },
    'source.wolfram': { id: `wolfram`, embeddedScopes: [] },
    'text.xml': { id: `xml`, embeddedScopes: [`source.java`] },
    'text.xml.xsl': { id: `xsl`, embeddedScopes: [`text.xml`] },
    'source.yaml': { id: `yaml`, embeddedScopes: [] },
    'source.zenscript': { id: `zenscript`, embeddedScopes: [] },
    'source.zig': { id: `zig`, embeddedScopes: [] },
  }
var r$3 = {
    d: (A$2, B$2) => {
      for (var Q$1 in B$2) {
        r$3.o(B$2, Q$1) && !r$3.o(A$2, Q$1) && Object.defineProperty(A$2, Q$1, { enumerable: !0, get: B$2[Q$1] })
      }
    },
    o: (A$2, B$2) => Object.prototype.hasOwnProperty.call(A$2, B$2),
  },
  H = {}
r$3.d(H, { _X: () => vA, Bz: () => XA, ot: () => TA, u: () => WA, jG: () => Y, Pn: () => ZA })
const L = typeof process < `u` && !!{}.VSCODE_TEXTMATE_DEBUG
var k
function R$1(A$2, B$2) {
  let Q$1 = [],
    g$3 = function(A$3) {
      let B$3 = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, Q$2 = B$3.exec(A$3)
      return {
        next: () => {
          if (!Q$2) return null
          let g$4 = Q$2[0]
          return Q$2 = B$3.exec(A$3), g$4
        },
      }
    }(A$2),
    E$2 = g$3.next()
  for (; E$2 !== null;) {
    let A$3 = 0
    if (E$2.length === 2 && E$2.charAt(1) === `:`) {
      switch (E$2.charAt(0)) {
        case `R`:
          A$3 = 1
          break
        case `L`:
          A$3 = -1
          break
        default:
          console.log(`Unknown priority ${E$2} in scope selector`)
      }
      E$2 = g$3.next()
    }
    let B$3 = I$3()
    if (Q$1.push({ matcher: B$3, priority: A$3 }), E$2 !== `,`) break
    E$2 = g$3.next()
  }
  return Q$1
  function C$4() {
    if (E$2 === `-`) {
      E$2 = g$3.next()
      let A$3 = C$4()
      return B$3 => !!A$3 && !A$3(B$3)
    }
    if (E$2 === `(`) {
      E$2 = g$3.next()
      let A$3 = function() {
        let A$4 = [], B$3 = I$3()
        for (; B$3 && (A$4.push(B$3), E$2 === `|` || E$2 === `,`);) {
          do E$2 = g$3.next()
          while (E$2 === `|` || E$2 === `,`)
          B$3 = I$3()
        }
        return B$4 => A$4.some(A$5 => A$5(B$4))
      }()
      return E$2 === `)` && (E$2 = g$3.next()), A$3
    }
    if (K(E$2)) {
      let A$3 = []
      do A$3.push(E$2), E$2 = g$3.next()
      while (K(E$2))
      return Q$2 => B$2(A$3, Q$2)
    }
    return null
  }
  function I$3() {
    let A$3 = [], B$3 = C$4()
    for (; B$3;) A$3.push(B$3), B$3 = C$4()
    return B$4 => A$3.every(A$4 => A$4(B$4))
  }
}
function K(A$2) {
  return !!A$2 && !!A$2.match(/[\w\.:]+/)
}
function Y(A$2) {
  typeof A$2.dispose == `function` && A$2.dispose()
}
function U(A$2) {
  return Array.isArray(A$2)
    ? function(A$3) {
      let B$2 = []
      for (let Q$1 = 0, g$3 = A$3.length; Q$1 < g$3; Q$1++) B$2[Q$1] = U(A$3[Q$1])
      return B$2
    }(A$2)
    : typeof A$2 == `object`
    ? function(A$3) {
      let B$2 = {}
      for (let Q$1 in A$3) B$2[Q$1] = U(A$3[Q$1])
      return B$2
    }(A$2)
    : A$2
}
function P(A$2, ...B$2) {
  return B$2.forEach(B$3 => {
    for (let Q$1 in B$3) A$2[Q$1] = B$3[Q$1]
  }),
    A$2
}
function u(A$2) {
  let B$2 = ~A$2.lastIndexOf(`/`) || ~A$2.lastIndexOf(`\\`)
  return B$2 === 0 ? A$2 : ~B$2 == A$2.length - 1 ? u(A$2.substring(0, A$2.length - 1)) : A$2.substr(1 + ~B$2)
}
;(function(A$2) {
  A$2.toBinaryStr = function(A$3) {
    let B$2 = A$3.toString(2)
    for (; B$2.length < 32;) B$2 = `0` + B$2
    return B$2
  },
    A$2.print = function(B$2) {
      let Q$1 = A$2.getLanguageId(B$2),
        g$3 = A$2.getTokenType(B$2),
        E$2 = A$2.getFontStyle(B$2),
        C$4 = A$2.getForeground(B$2),
        I$3 = A$2.getBackground(B$2)
      console.log({ languageId: Q$1, tokenType: g$3, fontStyle: E$2, foreground: C$4, background: I$3 })
    },
    A$2.getLanguageId = function(A$3) {
      return (255 & A$3) >>> 0
    },
    A$2.getTokenType = function(A$3) {
      return (768 & A$3) >>> 8
    },
    A$2.containsBalancedBrackets = function(A$3) {
      return (1024 & A$3) != 0
    },
    A$2.getFontStyle = function(A$3) {
      return (30720 & A$3) >>> 11
    },
    A$2.getForeground = function(A$3) {
      return (16744448 & A$3) >>> 15
    },
    A$2.getBackground = function(A$3) {
      return (4278190080 & A$3) >>> 24
    },
    A$2.set = function(B$2, Q$1, g$3, E$2, C$4, I$3, D$1) {
      let w$1 = A$2.getLanguageId(B$2),
        o$18 = A$2.getTokenType(B$2),
        s$14 = A$2.containsBalancedBrackets(B$2) ? 1 : 0,
        e$26 = A$2.getFontStyle(B$2),
        c$3 = A$2.getForeground(B$2),
        i$14 = A$2.getBackground(B$2)
      return Q$1 !== 0 && (w$1 = Q$1),
        g$3 !== 8 && (o$18 = g$3),
        E$2 !== null && (s$14 = E$2 ? 1 : 0),
        C$4 !== -1 && (e$26 = C$4),
        I$3 !== 0 && (c$3 = I$3),
        D$1 !== 0 && (i$14 = D$1),
        (w$1 << 0 | o$18 << 8 | s$14 << 10 | e$26 << 11 | c$3 << 15 | i$14 << 24) >>> 0
    }
})(k ||= {})
let y = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g
var J = class {
  static hasCaptures(A$2) {
    return A$2 !== null && (y.lastIndex = 0, y.test(A$2))
  }
  static replaceCaptures(A$2, B$2, Q$1) {
    return A$2.replace(y, (A$3, g$3, E$2, C$4) => {
      let I$3 = Q$1[parseInt(g$3 || E$2, 10)]
      if (!I$3) return A$3
      {
        let A$4 = B$2.substring(I$3.start, I$3.end)
        for (; A$4[0] === `.`;) A$4 = A$4.substring(1)
        switch (C$4) {
          case `downcase`:
            return A$4.toLowerCase()
          case `upcase`:
            return A$4.toUpperCase()
          default:
            return A$4
        }
      }
    })
  }
}
function S(A$2, B$2) {
  return A$2 < B$2 ? -1 : A$2 > B$2 ? 1 : 0
}
function d(A$2, B$2) {
  if (A$2 === null && B$2 === null) return 0
  if (!A$2) return -1
  if (!B$2) return 1
  let Q$1 = A$2.length, g$3 = B$2.length
  if (Q$1 === g$3) {
    for (let g$4 = 0; g$4 < Q$1; g$4++) {
      let Q$2 = S(A$2[g$4], B$2[g$4])
      if (Q$2 !== 0) return Q$2
    }
    return 0
  }
  return Q$1 - g$3
}
function l(A$2) {
  return !!(/^#[0-9a-f]{6}$/i.test(A$2) || /^#[0-9a-f]{8}$/i.test(A$2) || /^#[0-9a-f]{3}$/i.test(A$2)
    || /^#[0-9a-f]{4}$/i.test(A$2))
}
function p$6(A$2) {
  return A$2.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, `\\$&`)
}
var f = class {
  constructor(A$2) {
    this.fn = A$2, this.cache = new Map()
  }
  get(A$2) {
    if (this.cache.has(A$2)) return this.cache.get(A$2)
    let B$2 = this.fn(A$2)
    return this.cache.set(A$2, B$2), B$2
  }
}
const x = typeof performance > `u`
  ? function() {
    return Date.now()
  }
  : function() {
    return performance.now()
  }
var O = class {
    constructor(A$2) {
      this.scopeName = A$2
    }
    toKey() {
      return this.scopeName
    }
  },
  m = class {
    constructor(A$2, B$2) {
      this.scopeName = A$2, this.ruleName = B$2
    }
    toKey() {
      return `${this.scopeName}#${this.ruleName}`
    }
  },
  q = class {
    constructor() {
      this._references = [], this._seenReferenceKeys = new Set(), this.visitedRule = new Set()
    }
    get references() {
      return this._references
    }
    add(A$2) {
      let B$2 = A$2.toKey()
      this._seenReferenceKeys.has(B$2) || (this._seenReferenceKeys.add(B$2), this._references.push(A$2))
    }
  },
  b = class {
    constructor(A$2, B$2) {
      this.repo = A$2,
        this.initialScopeName = B$2,
        this.seenFullScopeRequests = new Set(),
        this.seenPartialScopeRequests = new Set(),
        this.seenFullScopeRequests.add(this.initialScopeName),
        this.Q = [new O(this.initialScopeName)]
    }
    processQueue() {
      let A$2 = this.Q
      this.Q = []
      let B$2 = new q()
      for (let Q$1 of A$2) W(Q$1, this.initialScopeName, this.repo, B$2)
      for (let A$3 of B$2.references) {
        if (A$3 instanceof O) {
          if (this.seenFullScopeRequests.has(A$3.scopeName)) continue
          this.seenFullScopeRequests.add(A$3.scopeName), this.Q.push(A$3)
        } else {
          if (this.seenFullScopeRequests.has(A$3.scopeName) || this.seenPartialScopeRequests.has(A$3.toKey())) continue
          this.seenPartialScopeRequests.add(A$3.toKey()), this.Q.push(A$3)
        }
      }
    }
  }
function W(A$2, B$2, Q$1, g$3) {
  let E$2 = Q$1.lookup(A$2.scopeName)
  if (!E$2) {
    if (A$2.scopeName === B$2) throw Error(`No grammar provided for <${B$2}>`)
    return
  }
  let C$4 = Q$1.lookup(B$2)
  A$2 instanceof O
    ? X({ baseGrammar: C$4, selfGrammar: E$2 }, g$3)
    : T(A$2.ruleName, { baseGrammar: C$4, selfGrammar: E$2, repository: E$2.repository }, g$3)
  let I$3 = Q$1.injections(A$2.scopeName)
  if (I$3) for (let A$3 of I$3) g$3.add(new O(A$3))
}
function T(A$2, B$2, Q$1) {
  B$2.repository && B$2.repository[A$2] && v([B$2.repository[A$2]], B$2, Q$1)
}
function X(A$2, B$2) {
  A$2.selfGrammar.patterns && Array.isArray(A$2.selfGrammar.patterns)
  && v(A$2.selfGrammar.patterns, { ...A$2, repository: A$2.selfGrammar.repository }, B$2),
    A$2.selfGrammar.injections
    && v(Object.values(A$2.selfGrammar.injections), { ...A$2, repository: A$2.selfGrammar.repository }, B$2)
}
function v(A$2, B$2, Q$1) {
  for (let g$3 of A$2) {
    if (Q$1.visitedRule.has(g$3)) continue
    Q$1.visitedRule.add(g$3)
    let A$3 = g$3.repository ? P({}, B$2.repository, g$3.repository) : B$2.repository
    Array.isArray(g$3.patterns) && v(g$3.patterns, { ...B$2, repository: A$3 }, Q$1)
    let E$2 = g$3.include
    if (!E$2) continue
    let C$4 = $(E$2)
    switch (C$4.kind) {
      case 0:
        X({ ...B$2, selfGrammar: B$2.baseGrammar }, Q$1)
        break
      case 1:
        X(B$2, Q$1)
        break
      case 2:
        T(C$4.ruleName, { ...B$2, repository: A$3 }, Q$1)
        break
      case 3:
      case 4:
        let g$4 = C$4.scopeName === B$2.selfGrammar.scopeName
          ? B$2.selfGrammar
          : C$4.scopeName === B$2.baseGrammar.scopeName
          ? B$2.baseGrammar
          : void 0
        if (g$4) {
          let E$3 = { baseGrammar: B$2.baseGrammar, selfGrammar: g$4, repository: A$3 }
          C$4.kind === 4 ? T(C$4.ruleName, E$3, Q$1) : X(E$3, Q$1)
        } else C$4.kind === 4 ? Q$1.add(new m(C$4.scopeName, C$4.ruleName)) : Q$1.add(new O(C$4.scopeName))
    }
  }
}
var Z = class {
    constructor() {
      this.kind = 0
    }
  },
  j = class {
    constructor() {
      this.kind = 1
    }
  },
  V = class {
    constructor(A$2) {
      this.ruleName = A$2, this.kind = 2
    }
  },
  z = class {
    constructor(A$2) {
      this.scopeName = A$2, this.kind = 3
    }
  },
  _ = class {
    constructor(A$2, B$2) {
      this.scopeName = A$2, this.ruleName = B$2, this.kind = 4
    }
  }
function $(A$2) {
  if (A$2 === `$base`) return new Z()
  if (A$2 === `$self`) return new j()
  let B$2 = A$2.indexOf(`#`)
  if (B$2 === -1) return new z(A$2)
  if (B$2 === 0) return new V(A$2.substring(1))
  {
    let Q$1 = A$2.substring(0, B$2), g$3 = A$2.substring(B$2 + 1)
    return new _(Q$1, g$3)
  }
}
const AA = /\\(\d+)/, BA = /\\(\d+)/g
var QA = class {
    constructor(A$2, B$2, Q$1, g$3) {
      this.$location = A$2,
        this.id = B$2,
        this._name = Q$1 || null,
        this._nameIsCapturing = J.hasCaptures(this._name),
        this._contentName = g$3 || null,
        this._contentNameIsCapturing = J.hasCaptures(this._contentName)
    }
    get debugName() {
      let A$2 = this.$location ? `${u(this.$location.filename)}:${this.$location.line}` : `unknown`
      return `${this.constructor.name}#${this.id} @ ${A$2}`
    }
    getName(A$2, B$2) {
      return this._nameIsCapturing && this._name !== null && A$2 !== null && B$2 !== null
        ? J.replaceCaptures(this._name, A$2, B$2)
        : this._name
    }
    getContentName(A$2, B$2) {
      return this._contentNameIsCapturing && this._contentName !== null
        ? J.replaceCaptures(this._contentName, A$2, B$2)
        : this._contentName
    }
  },
  gA = class extends QA {
    constructor(A$2, B$2, Q$1, g$3, E$2) {
      super(A$2, B$2, Q$1, g$3), this.retokenizeCapturedWithRuleId = E$2
    }
    dispose() {}
    collectPatterns(A$2, B$2) {
      throw Error(`Not supported!`)
    }
    compile(A$2, B$2) {
      throw Error(`Not supported!`)
    }
    compileAG(A$2, B$2, Q$1, g$3) {
      throw Error(`Not supported!`)
    }
  },
  EA = class extends QA {
    constructor(A$2, B$2, Q$1, g$3, E$2) {
      super(A$2, B$2, Q$1, null),
        this._match = new oA(g$3, this.id),
        this.captures = E$2,
        this._cachedCompiledPatterns = null
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null)
    }
    get debugMatchRegExp() {
      return `${this._match.source}`
    }
    collectPatterns(A$2, B$2) {
      B$2.push(this._match)
    }
    compile(A$2, B$2) {
      return this._getCachedCompiledPatterns(A$2).compile(A$2)
    }
    compileAG(A$2, B$2, Q$1, g$3) {
      return this._getCachedCompiledPatterns(A$2).compileAG(A$2, Q$1, g$3)
    }
    _getCachedCompiledPatterns(A$2) {
      return this._cachedCompiledPatterns
        || (this._cachedCompiledPatterns = new sA(), this.collectPatterns(A$2, this._cachedCompiledPatterns)),
        this._cachedCompiledPatterns
    }
  },
  CA = class extends QA {
    constructor(A$2, B$2, Q$1, g$3, E$2) {
      super(A$2, B$2, Q$1, g$3),
        this.patterns = E$2.patterns,
        this.hasMissingPatterns = E$2.hasMissingPatterns,
        this._cachedCompiledPatterns = null
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null)
    }
    collectPatterns(A$2, B$2) {
      for (let Q$1 of this.patterns) A$2.getRule(Q$1).collectPatterns(A$2, B$2)
    }
    compile(A$2, B$2) {
      return this._getCachedCompiledPatterns(A$2).compile(A$2)
    }
    compileAG(A$2, B$2, Q$1, g$3) {
      return this._getCachedCompiledPatterns(A$2).compileAG(A$2, Q$1, g$3)
    }
    _getCachedCompiledPatterns(A$2) {
      return this._cachedCompiledPatterns
        || (this._cachedCompiledPatterns = new sA(), this.collectPatterns(A$2, this._cachedCompiledPatterns)),
        this._cachedCompiledPatterns
    }
  },
  IA = class extends QA {
    constructor(A$2, B$2, Q$1, g$3, E$2, C$4, I$3, D$1, w$1, o$18) {
      super(A$2, B$2, Q$1, g$3),
        this._begin = new oA(E$2, this.id),
        this.beginCaptures = C$4,
        this._end = new oA(I$3 || ``, -1),
        this.endHasBackReferences = this._end.hasBackReferences,
        this.endCaptures = D$1,
        this.applyEndPatternLast = w$1 || !1,
        this.patterns = o$18.patterns,
        this.hasMissingPatterns = o$18.hasMissingPatterns,
        this._cachedCompiledPatterns = null
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null)
    }
    get debugBeginRegExp() {
      return `${this._begin.source}`
    }
    get debugEndRegExp() {
      return `${this._end.source}`
    }
    getEndWithResolvedBackReferences(A$2, B$2) {
      return this._end.resolveBackReferences(A$2, B$2)
    }
    collectPatterns(A$2, B$2) {
      B$2.push(this._begin)
    }
    compile(A$2, B$2) {
      return this._getCachedCompiledPatterns(A$2, B$2).compile(A$2)
    }
    compileAG(A$2, B$2, Q$1, g$3) {
      return this._getCachedCompiledPatterns(A$2, B$2).compileAG(A$2, Q$1, g$3)
    }
    _getCachedCompiledPatterns(A$2, B$2) {
      if (!this._cachedCompiledPatterns) {
        this._cachedCompiledPatterns = new sA()
        for (let B$3 of this.patterns) A$2.getRule(B$3).collectPatterns(A$2, this._cachedCompiledPatterns)
        this.applyEndPatternLast
          ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end)
          : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end)
      }
      return this._end.hasBackReferences
        && (this.applyEndPatternLast
          ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, B$2)
          : this._cachedCompiledPatterns.setSource(0, B$2)),
        this._cachedCompiledPatterns
    }
  },
  DA = class extends QA {
    constructor(A$2, B$2, Q$1, g$3, E$2, C$4, I$3, D$1, w$1) {
      super(A$2, B$2, Q$1, g$3),
        this._begin = new oA(E$2, this.id),
        this.beginCaptures = C$4,
        this.whileCaptures = D$1,
        this._while = new oA(I$3, -2),
        this.whileHasBackReferences = this._while.hasBackReferences,
        this.patterns = w$1.patterns,
        this.hasMissingPatterns = w$1.hasMissingPatterns,
        this._cachedCompiledPatterns = null,
        this._cachedCompiledWhilePatterns = null
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null),
        this._cachedCompiledWhilePatterns
        && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null)
    }
    get debugBeginRegExp() {
      return `${this._begin.source}`
    }
    get debugWhileRegExp() {
      return `${this._while.source}`
    }
    getWhileWithResolvedBackReferences(A$2, B$2) {
      return this._while.resolveBackReferences(A$2, B$2)
    }
    collectPatterns(A$2, B$2) {
      B$2.push(this._begin)
    }
    compile(A$2, B$2) {
      return this._getCachedCompiledPatterns(A$2).compile(A$2)
    }
    compileAG(A$2, B$2, Q$1, g$3) {
      return this._getCachedCompiledPatterns(A$2).compileAG(A$2, Q$1, g$3)
    }
    _getCachedCompiledPatterns(A$2) {
      if (!this._cachedCompiledPatterns) {
        this._cachedCompiledPatterns = new sA()
        for (let B$2 of this.patterns) A$2.getRule(B$2).collectPatterns(A$2, this._cachedCompiledPatterns)
      }
      return this._cachedCompiledPatterns
    }
    compileWhile(A$2, B$2) {
      return this._getCachedCompiledWhilePatterns(A$2, B$2).compile(A$2)
    }
    compileWhileAG(A$2, B$2, Q$1, g$3) {
      return this._getCachedCompiledWhilePatterns(A$2, B$2).compileAG(A$2, Q$1, g$3)
    }
    _getCachedCompiledWhilePatterns(A$2, B$2) {
      return this._cachedCompiledWhilePatterns
        || (this._cachedCompiledWhilePatterns = new sA(),
          this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)),
        this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, B$2 || ``),
        this._cachedCompiledWhilePatterns
    }
  },
  wA = class wA {
    static createCaptureRule(A$2, B$2, Q$1, g$3, E$2) {
      return A$2.registerRule(A$3 => new gA(B$2, A$3, Q$1, g$3, E$2))
    }
    static getCompiledRuleId(A$2, B$2, Q$1) {
      return A$2.id || B$2.registerRule(g$3 => {
        if (A$2.id = g$3, A$2.match) {
          return new EA(
            A$2.$vscodeTextmateLocation,
            A$2.id,
            A$2.name,
            A$2.match,
            wA._compileCaptures(A$2.captures, B$2, Q$1),
          )
        }
        if (A$2.begin === void 0) {
          A$2.repository && (Q$1 = P({}, Q$1, A$2.repository))
          let g$4 = A$2.patterns
          return g$4 === void 0 && A$2.include && (g$4 = [{ include: A$2.include }]),
            new CA(A$2.$vscodeTextmateLocation, A$2.id, A$2.name, A$2.contentName, wA._compilePatterns(g$4, B$2, Q$1))
        }
        return A$2.while
          ? new DA(
            A$2.$vscodeTextmateLocation,
            A$2.id,
            A$2.name,
            A$2.contentName,
            A$2.begin,
            wA._compileCaptures(A$2.beginCaptures || A$2.captures, B$2, Q$1),
            A$2.while,
            wA._compileCaptures(A$2.whileCaptures || A$2.captures, B$2, Q$1),
            wA._compilePatterns(A$2.patterns, B$2, Q$1),
          )
          : new IA(
            A$2.$vscodeTextmateLocation,
            A$2.id,
            A$2.name,
            A$2.contentName,
            A$2.begin,
            wA._compileCaptures(A$2.beginCaptures || A$2.captures, B$2, Q$1),
            A$2.end,
            wA._compileCaptures(A$2.endCaptures || A$2.captures, B$2, Q$1),
            A$2.applyEndPatternLast,
            wA._compilePatterns(A$2.patterns, B$2, Q$1),
          )
      }),
        A$2.id
    }
    static _compileCaptures(A$2, B$2, Q$1) {
      let g$3 = []
      if (A$2) {
        let E$2 = 0
        for (let B$3 in A$2) {
          if (B$3 === `$vscodeTextmateLocation`) continue
          let A$3 = parseInt(B$3, 10)
          A$3 > E$2 && (E$2 = A$3)
        }
        for (let A$3 = 0; A$3 <= E$2; A$3++) g$3[A$3] = null
        for (let E$3 in A$2) {
          if (E$3 === `$vscodeTextmateLocation`) continue
          let C$4 = parseInt(E$3, 10), I$3 = 0
          A$2[E$3].patterns && (I$3 = wA.getCompiledRuleId(A$2[E$3], B$2, Q$1)),
            g$3[C$4] = wA.createCaptureRule(
              B$2,
              A$2[E$3].$vscodeTextmateLocation,
              A$2[E$3].name,
              A$2[E$3].contentName,
              I$3,
            )
        }
      }
      return g$3
    }
    static _compilePatterns(A$2, B$2, Q$1) {
      let g$3 = []
      if (A$2) {
        for (let E$2 = 0, C$4 = A$2.length; E$2 < C$4; E$2++) {
          let C$5 = A$2[E$2], I$3 = -1
          if (C$5.include) {
            let A$3 = $(C$5.include)
            switch (A$3.kind) {
              case 0:
              case 1:
                I$3 = wA.getCompiledRuleId(Q$1[C$5.include], B$2, Q$1)
                break
              case 2:
                let g$4 = Q$1[A$3.ruleName]
                g$4 && (I$3 = wA.getCompiledRuleId(g$4, B$2, Q$1))
                break
              case 3:
              case 4:
                let E$3 = A$3.scopeName,
                  D$1 = A$3.kind === 4 ? A$3.ruleName : null,
                  w$1 = B$2.getExternalGrammar(E$3, Q$1)
                if (w$1) {
                  if (D$1) {
                    let A$4 = w$1.repository[D$1]
                    A$4 && (I$3 = wA.getCompiledRuleId(A$4, B$2, w$1.repository))
                  } else I$3 = wA.getCompiledRuleId(w$1.repository.$self, B$2, w$1.repository)
                }
            }
          } else I$3 = wA.getCompiledRuleId(C$5, B$2, Q$1)
          if (I$3 !== -1) {
            let A$3 = B$2.getRule(I$3), Q$2 = !1
            if (
              (A$3 instanceof CA || A$3 instanceof IA || A$3 instanceof DA) && A$3.hasMissingPatterns
              && A$3.patterns.length === 0 && (Q$2 = !0), Q$2
            ) continue
            g$3.push(I$3)
          }
        }
      }
      return { patterns: g$3, hasMissingPatterns: (A$2 ? A$2.length : 0) !== g$3.length }
    }
  },
  oA = class oA {
    constructor(A$2, B$2) {
      if (A$2) {
        let B$3 = A$2.length, Q$1 = 0, g$3 = [], E$2 = !1
        for (let C$4 = 0; C$4 < B$3; C$4++) {
          if (A$2.charAt(C$4) === `\\` && C$4 + 1 < B$3) {
            let B$4 = A$2.charAt(C$4 + 1)
            B$4 === `z`
              ? (g$3.push(A$2.substring(Q$1, C$4)), g$3.push(`$(?!\\n)(?<!\\n)`), Q$1 = C$4 + 2)
              : B$4 !== `A` && B$4 !== `G` || (E$2 = !0), C$4++
          }
        }
        this.hasAnchor = E$2,
          Q$1 === 0 ? this.source = A$2 : (g$3.push(A$2.substring(Q$1, B$3)), this.source = g$3.join(``))
      } else this.hasAnchor = !1, this.source = A$2
      this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null,
        this.ruleId = B$2,
        this.hasBackReferences = AA.test(this.source)
    }
    clone() {
      return new oA(this.source, this.ruleId)
    }
    setSource(A$2) {
      this.source !== A$2 && (this.source = A$2, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()))
    }
    resolveBackReferences(A$2, B$2) {
      let Q$1 = B$2.map(B$3 => A$2.substring(B$3.start, B$3.end))
      return BA.lastIndex = 0, this.source.replace(BA, (A$3, B$3) => p$6(Q$1[parseInt(B$3, 10)] || ``))
    }
    _buildAnchorCache() {
      let A$2, B$2, Q$1, g$3, E$2 = [], C$4 = [], I$3 = [], D$1 = []
      for (A$2 = 0, B$2 = this.source.length; A$2 < B$2; A$2++) {
        Q$1 = this.source.charAt(A$2),
          E$2[A$2] = Q$1,
          C$4[A$2] = Q$1,
          I$3[A$2] = Q$1,
          D$1[A$2] = Q$1,
          Q$1 === `\\` && A$2 + 1 < B$2 && (g$3 = this.source.charAt(A$2 + 1),
            g$3 === `A`
              ? (E$2[A$2 + 1] = ``, C$4[A$2 + 1] = ``, I$3[A$2 + 1] = `A`, D$1[A$2 + 1] = `A`)
              : g$3 === `G`
              ? (E$2[A$2 + 1] = ``, C$4[A$2 + 1] = `G`, I$3[A$2 + 1] = ``, D$1[A$2 + 1] = `G`)
              : (E$2[A$2 + 1] = g$3, C$4[A$2 + 1] = g$3, I$3[A$2 + 1] = g$3, D$1[A$2 + 1] = g$3),
            A$2++)
      }
      return { A0_G0: E$2.join(``), A0_G1: C$4.join(``), A1_G0: I$3.join(``), A1_G1: D$1.join(``) }
    }
    resolveAnchors(A$2, B$2) {
      return this.hasAnchor && this._anchorCache
        ? A$2
          ? B$2 ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0
          : B$2
          ? this._anchorCache.A0_G1
          : this._anchorCache.A0_G0
        : this.source
    }
  },
  sA = class {
    constructor() {
      this._items = [],
        this._hasAnchors = !1,
        this._cached = null,
        this._anchorCache = { A0_G0: null, A0_G1: null, A1_G0: null, A1_G1: null }
    }
    dispose() {
      this._disposeCaches()
    }
    _disposeCaches() {
      this._cached && (this._cached.dispose(), this._cached = null),
        this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null),
        this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null),
        this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null),
        this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null)
    }
    push(A$2) {
      this._items.push(A$2), this._hasAnchors = this._hasAnchors || A$2.hasAnchor
    }
    unshift(A$2) {
      this._items.unshift(A$2), this._hasAnchors = this._hasAnchors || A$2.hasAnchor
    }
    length() {
      return this._items.length
    }
    setSource(A$2, B$2) {
      this._items[A$2].source !== B$2 && (this._disposeCaches(), this._items[A$2].setSource(B$2))
    }
    compile(A$2) {
      if (!this._cached) {
        let B$2 = this._items.map(A$3 => A$3.source)
        this._cached = new eA(A$2, B$2, this._items.map(A$3 => A$3.ruleId))
      }
      return this._cached
    }
    compileAG(A$2, B$2, Q$1) {
      return this._hasAnchors
        ? B$2
          ? Q$1
            ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(A$2, B$2, Q$1)),
              this._anchorCache.A1_G1)
            : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(A$2, B$2, Q$1)),
              this._anchorCache.A1_G0)
          : Q$1
          ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(A$2, B$2, Q$1)),
            this._anchorCache.A0_G1)
          : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(A$2, B$2, Q$1)),
            this._anchorCache.A0_G0)
        : this.compile(A$2)
    }
    _resolveAnchors(A$2, B$2, Q$1) {
      let g$3 = this._items.map(A$3 => A$3.resolveAnchors(B$2, Q$1))
      return new eA(A$2, g$3, this._items.map(A$3 => A$3.ruleId))
    }
  },
  eA = class {
    constructor(A$2, B$2, Q$1) {
      this.regExps = B$2, this.rules = Q$1, this.scanner = A$2.createOnigScanner(B$2)
    }
    dispose() {
      typeof this.scanner.dispose == `function` && this.scanner.dispose()
    }
    toString() {
      let A$2 = []
      for (let B$2 = 0, Q$1 = this.rules.length; B$2 < Q$1; B$2++) {
        A$2.push(`   - ` + this.rules[B$2] + `: ` + this.regExps[B$2])
      }
      return A$2.join(`
`)
    }
    findNextMatchSync(A$2, B$2, Q$1) {
      let g$3 = this.scanner.findNextMatchSync(A$2, B$2, Q$1)
      return g$3 ? { ruleId: this.rules[g$3.index], captureIndices: g$3.captureIndices } : null
    }
  },
  cA = class cA {
    constructor(A$2, B$2, Q$1) {
      this._colorMap = A$2,
        this._defaults = B$2,
        this._root = Q$1,
        this._cachedMatchRoot = new f(A$3 => this._root.match(A$3))
    }
    static createFromRawTheme(A$2, B$2) {
      return this.createFromParsedTheme(
        function(A$3) {
          if (!A$3 || !A$3.settings || !Array.isArray(A$3.settings)) return []
          let B$3 = A$3.settings, Q$1 = [], g$3 = 0
          for (let A$4 = 0, E$2 = B$3.length; A$4 < E$2; A$4++) {
            let E$3, C$4 = B$3[A$4]
            if (!C$4.settings) continue
            if (typeof C$4.scope == `string`) {
              let A$5 = C$4.scope
              A$5 = A$5.replace(/^[,]+/, ``), A$5 = A$5.replace(/[,]+$/, ``), E$3 = A$5.split(`,`)
            } else E$3 = Array.isArray(C$4.scope) ? C$4.scope : [``]
            let I$3 = -1
            if (typeof C$4.settings.fontStyle == `string`) {
              I$3 = 0
              let A$5 = C$4.settings.fontStyle.split(` `)
              for (let B$4 = 0, Q$2 = A$5.length; B$4 < Q$2; B$4++) {
                switch (A$5[B$4]) {
                  case `italic`:
                    I$3 |= 1
                    break
                  case `bold`:
                    I$3 |= 2
                    break
                  case `underline`:
                    I$3 |= 4
                    break
                  case `strikethrough`:
                    I$3 |= 8
                }
              }
            }
            let D$1 = null
            typeof C$4.settings.foreground == `string` && l(C$4.settings.foreground) && (D$1 = C$4.settings.foreground)
            let w$1 = null
            typeof C$4.settings.background == `string` && l(C$4.settings.background) && (w$1 = C$4.settings.background)
            for (let B$4 = 0, C$5 = E$3.length; B$4 < C$5; B$4++) {
              let C$6 = E$3[B$4].trim().split(` `), o$18 = C$6[C$6.length - 1], s$14 = null
              C$6.length > 1 && (s$14 = C$6.slice(0, C$6.length - 1), s$14.reverse()),
                Q$1[g$3++] = new hA(o$18, s$14, A$4, I$3, D$1, w$1)
            }
          }
          return Q$1
        }(A$2),
        B$2,
      )
    }
    static createFromParsedTheme(A$2, B$2) {
      return function(A$3, B$3) {
        A$3.sort((A$4, B$4) => {
          let Q$2 = S(A$4.scope, B$4.scope)
          return Q$2 === 0
            ? (Q$2 = d(A$4.parentScopes, B$4.parentScopes), Q$2 === 0 ? A$4.index - B$4.index : Q$2)
            : Q$2
        })
        let Q$1 = 0, g$3 = `#000000`, E$2 = `#ffffff`
        for (; A$3.length >= 1 && A$3[0].scope === ``;) {
          let B$4 = A$3.shift()
          B$4.fontStyle !== -1 && (Q$1 = B$4.fontStyle),
            B$4.foreground !== null && (g$3 = B$4.foreground),
            B$4.background !== null && (E$2 = B$4.background)
        }
        let C$4 = new FA(B$3),
          I$3 = new MA(Q$1, C$4.getId(g$3), C$4.getId(E$2)),
          D$1 = new aA(new GA(0, null, -1, 0, 0), [])
        for (let B$4 = 0, Q$2 = A$3.length; B$4 < Q$2; B$4++) {
          let Q$3 = A$3[B$4]
          D$1.insert(
            0,
            Q$3.scope,
            Q$3.parentScopes,
            Q$3.fontStyle,
            C$4.getId(Q$3.foreground),
            C$4.getId(Q$3.background),
          )
        }
        return new cA(C$4, I$3, D$1)
      }(A$2, B$2)
    }
    getColorMap() {
      return this._colorMap.getColorMap()
    }
    getDefaults() {
      return this._defaults
    }
    match(A$2) {
      if (A$2 === null) return this._defaults
      let B$2 = A$2.scopeName,
        Q$1 = this._cachedMatchRoot.get(B$2).find(B$3 =>
          function(A$3, B$4) {
            if (B$4 === null) return !0
            let Q$2 = 0, g$3 = B$4[Q$2]
            for (; A$3;) {
              if (tA(A$3.scopeName, g$3)) {
                if (Q$2++, Q$2 === B$4.length) return !0
                g$3 = B$4[Q$2]
              }
              A$3 = A$3.parent
            }
            return !1
          }(A$2.parent, B$3.parentScopes)
        )
      return Q$1 ? new MA(Q$1.fontStyle, Q$1.foreground, Q$1.background) : null
    }
  },
  iA = class iA {
    constructor(A$2, B$2) {
      this.parent = A$2, this.scopeName = B$2
    }
    static push(A$2, B$2) {
      for (let Q$1 of B$2) A$2 = new iA(A$2, Q$1)
      return A$2
    }
    static from(...A$2) {
      let B$2 = null
      for (let Q$1 = 0; Q$1 < A$2.length; Q$1++) B$2 = new iA(B$2, A$2[Q$1])
      return B$2
    }
    push(A$2) {
      return new iA(this, A$2)
    }
    getSegments() {
      let A$2 = this, B$2 = []
      for (; A$2;) B$2.push(A$2.scopeName), A$2 = A$2.parent
      return B$2.reverse(), B$2
    }
    toString() {
      return this.getSegments().join(` `)
    }
    extends(A$2) {
      return this === A$2 || this.parent !== null && this.parent.extends(A$2)
    }
    getExtensionIfDefined(A$2) {
      let B$2 = [], Q$1 = this
      for (; Q$1 && Q$1 !== A$2;) B$2.push(Q$1.scopeName), Q$1 = Q$1.parent
      return Q$1 === A$2 ? B$2.reverse() : void 0
    }
  }
function tA(A$2, B$2) {
  return B$2 === A$2 || A$2.startsWith(B$2) && A$2[B$2.length] === `.`
}
var MA = class {
    constructor(A$2, B$2, Q$1) {
      this.fontStyle = A$2, this.foregroundId = B$2, this.backgroundId = Q$1
    }
  },
  hA = class {
    constructor(A$2, B$2, Q$1, g$3, E$2, C$4) {
      this.scope = A$2,
        this.parentScopes = B$2,
        this.index = Q$1,
        this.fontStyle = g$3,
        this.foreground = E$2,
        this.background = C$4
    }
  },
  FA = class {
    constructor(A$2) {
      if (this._lastColorId = 0, this._id2color = [], this._color2id = Object.create(null), Array.isArray(A$2)) {
        this._isFrozen = !0
        for (let B$2 = 0, Q$1 = A$2.length; B$2 < Q$1; B$2++) {
          this._color2id[A$2[B$2]] = B$2, this._id2color[B$2] = A$2[B$2]
        }
      } else this._isFrozen = !1
    }
    getId(A$2) {
      if (A$2 === null) return 0
      A$2 = A$2.toUpperCase()
      let B$2 = this._color2id[A$2]
      if (B$2) return B$2
      if (this._isFrozen) throw Error(`Missing color in color map - ${A$2}`)
      return B$2 = ++this._lastColorId, this._color2id[A$2] = B$2, this._id2color[B$2] = A$2, B$2
    }
    getColorMap() {
      return this._id2color.slice(0)
    }
  },
  GA = class GA {
    constructor(A$2, B$2, Q$1, g$3, E$2) {
      this.scopeDepth = A$2, this.parentScopes = B$2, this.fontStyle = Q$1, this.foreground = g$3, this.background = E$2
    }
    clone() {
      return new GA(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background)
    }
    static cloneArr(A$2) {
      let B$2 = []
      for (let Q$1 = 0, g$3 = A$2.length; Q$1 < g$3; Q$1++) B$2[Q$1] = A$2[Q$1].clone()
      return B$2
    }
    acceptOverwrite(A$2, B$2, Q$1, g$3) {
      this.scopeDepth > A$2 ? console.log(`how did this happen?`) : this.scopeDepth = A$2,
        B$2 !== -1 && (this.fontStyle = B$2),
        Q$1 !== 0 && (this.foreground = Q$1),
        g$3 !== 0 && (this.background = g$3)
    }
  },
  aA = class aA {
    constructor(A$2, B$2 = [], Q$1 = {}) {
      this._mainRule = A$2, this._children = Q$1, this._rulesWithParentScopes = B$2
    }
    static _sortBySpecificity(A$2) {
      return A$2.length === 1 || A$2.sort(this._cmpBySpecificity), A$2
    }
    static _cmpBySpecificity(A$2, B$2) {
      if (A$2.scopeDepth === B$2.scopeDepth) {
        let Q$1 = A$2.parentScopes,
          g$3 = B$2.parentScopes,
          E$2 = Q$1 === null ? 0 : Q$1.length,
          C$4 = g$3 === null ? 0 : g$3.length
        if (E$2 === C$4) {
          for (let A$3 = 0; A$3 < E$2; A$3++) {
            let B$3 = Q$1[A$3].length, E$3 = g$3[A$3].length
            if (B$3 !== E$3) return E$3 - B$3
          }
        }
        return C$4 - E$2
      }
      return B$2.scopeDepth - A$2.scopeDepth
    }
    match(A$2) {
      if (A$2 === ``) return aA._sortBySpecificity([].concat(this._mainRule, this._rulesWithParentScopes))
      let B$2, Q$1, g$3 = A$2.indexOf(`.`)
      return g$3 === -1 ? (B$2 = A$2, Q$1 = ``) : (B$2 = A$2.substring(0, g$3), Q$1 = A$2.substring(g$3 + 1)),
        this._children.hasOwnProperty(B$2)
          ? this._children[B$2].match(Q$1)
          : aA._sortBySpecificity([].concat(this._mainRule, this._rulesWithParentScopes))
    }
    insert(A$2, B$2, Q$1, g$3, E$2, C$4) {
      if (B$2 === ``) return void this._doInsertHere(A$2, Q$1, g$3, E$2, C$4)
      let I$3, D$1, w$1, o$18 = B$2.indexOf(`.`)
      o$18 === -1 ? (I$3 = B$2, D$1 = ``) : (I$3 = B$2.substring(0, o$18), D$1 = B$2.substring(o$18 + 1)),
        this._children.hasOwnProperty(I$3)
          ? w$1 = this._children[I$3]
          : (w$1 = new aA(this._mainRule.clone(), GA.cloneArr(this._rulesWithParentScopes)), this._children[I$3] = w$1),
        w$1.insert(A$2 + 1, D$1, Q$1, g$3, E$2, C$4)
    }
    _doInsertHere(A$2, B$2, Q$1, g$3, E$2) {
      if (B$2 !== null) {
        for (let C$4 = 0, I$3 = this._rulesWithParentScopes.length; C$4 < I$3; C$4++) {
          let I$4 = this._rulesWithParentScopes[C$4]
          if (d(I$4.parentScopes, B$2) === 0) return void I$4.acceptOverwrite(A$2, Q$1, g$3, E$2)
        }
        Q$1 === -1 && (Q$1 = this._mainRule.fontStyle),
          g$3 === 0 && (g$3 = this._mainRule.foreground),
          E$2 === 0 && (E$2 = this._mainRule.background),
          this._rulesWithParentScopes.push(new GA(A$2, B$2, Q$1, g$3, E$2))
      } else this._mainRule.acceptOverwrite(A$2, Q$1, g$3, E$2)
    }
  },
  nA = class {
    constructor(A$2, B$2) {
      this.languageId = A$2, this.tokenType = B$2
    }
  },
  NA = class NA {
    constructor(A$2, B$2) {
      this._getBasicScopeAttributes = new f(A$3 => {
        let B$3 = this._scopeToLanguage(A$3), Q$1 = this._toStandardTokenType(A$3)
        return new nA(B$3, Q$1)
      }),
        this._defaultAttributes = new nA(A$2, 8),
        this._embeddedLanguagesMatcher = new rA(Object.entries(B$2 || {}))
    }
    getDefaultAttributes() {
      return this._defaultAttributes
    }
    getBasicScopeAttributes(A$2) {
      return A$2 === null ? NA._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(A$2)
    }
    _scopeToLanguage(A$2) {
      return this._embeddedLanguagesMatcher.match(A$2) || 0
    }
    _toStandardTokenType(A$2) {
      let B$2 = A$2.match(NA.STANDARD_TOKEN_TYPE_REGEXP)
      if (!B$2) return 8
      switch (B$2[1]) {
        case `comment`:
          return 1
        case `string`:
          return 2
        case `regex`:
          return 3
        case `meta.embedded`:
          return 0
      }
      throw Error(`Unexpected match for standard token type!`)
    }
  }
NA._NULL_SCOPE_METADATA = new nA(0, 0), NA.STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/
var rA = class {
    constructor(A$2) {
      if (A$2.length === 0) this.values = null, this.scopesRegExp = null
      else {
        this.values = new Map(A$2)
        let B$2 = A$2.map(([A$3, B$3]) => p$6(A$3))
        B$2.sort(), B$2.reverse(), this.scopesRegExp = RegExp(`^((${B$2.join(`)|(`)}))($|\\.)`, ``)
      }
    }
    match(A$2) {
      if (!this.scopesRegExp) return
      let B$2 = A$2.match(this.scopesRegExp)
      return B$2 ? this.values.get(B$2[1]) : void 0
    }
  },
  HA = class {
    constructor(A$2, B$2) {
      this.stack = A$2, this.stoppedEarly = B$2
    }
  }
function LA(A$2, B$2, Q$1, g$3, E$2, C$4, I$3, D$1) {
  let w$1 = B$2.content.length, o$18 = !1, s$14 = -1
  if (I$3) {
    let I$4 = function(A$3, B$3, Q$2, g$4, E$3, C$5) {
      let I$5 = E$3.beginRuleCapturedEOL ? 0 : -1, D$2 = []
      for (let B$4 = E$3; B$4; B$4 = B$4.pop()) {
        let Q$3 = B$4.getRule(A$3)
        Q$3 instanceof DA && D$2.push({ rule: Q$3, stack: B$4 })
      }
      for (let w$2 = D$2.pop(); w$2; w$2 = D$2.pop()) {
        let { ruleScanner: D$3, findOptions: o$19 } = RA(w$2.rule, A$3, w$2.stack.endRule, Q$2, g$4 === I$5),
          s$15 = D$3.findNextMatchSync(B$3, g$4, o$19)
        if (L && (console.log(`  scanning for while rule`), console.log(D$3.toString())), !s$15) {
          L && console.log(`  popping ` + w$2.rule.debugName + ` - ` + w$2.rule.debugWhileRegExp), E$3 = w$2.stack.pop()
          break
        }
        if (s$15.ruleId !== -2) {
          E$3 = w$2.stack.pop()
          break
        }
        s$15.captureIndices && s$15.captureIndices.length
          && (C$5.produce(w$2.stack, s$15.captureIndices[0].start),
            KA(A$3, B$3, Q$2, w$2.stack, C$5, w$2.rule.whileCaptures, s$15.captureIndices),
            C$5.produce(w$2.stack, s$15.captureIndices[0].end),
            I$5 = s$15.captureIndices[0].end,
            s$15.captureIndices[0].end > g$4 && (g$4 = s$15.captureIndices[0].end, Q$2 = !1))
      }
      return { stack: E$3, linePos: g$4, anchorPosition: I$5, isFirstLine: Q$2 }
    }(A$2, B$2, Q$1, g$3, E$2, C$4)
    E$2 = I$4.stack, g$3 = I$4.linePos, Q$1 = I$4.isFirstLine, s$14 = I$4.anchorPosition
  }
  let e$26 = Date.now()
  for (; !o$18;) {
    if (D$1 !== 0 && Date.now() - e$26 > D$1) return new HA(E$2, !0)
    c$3()
  }
  return new HA(E$2, !1)
  function c$3() {
    L && (console.log(``), console.log(`@@scanNext ${g$3}: |${B$2.content.substr(g$3).replace(/\n$/, `\\n`)}|`))
    let I$4 = function(A$3, B$3, Q$2, g$4, E$3, C$5) {
      let I$5 = function(A$4, B$4, Q$3, g$5, E$4, C$6) {
          let I$6 = E$4.getRule(A$4),
            { ruleScanner: D$4, findOptions: w$3 } = kA(I$6, A$4, E$4.endRule, Q$3, g$5 === C$6),
            o$20 = 0
          L && (o$20 = x())
          let s$16 = D$4.findNextMatchSync(B$4, g$5, w$3)
          if (L) {
            let A$5 = x() - o$20
            A$5 > 5 && console.warn(`Rule ${I$6.debugName} (${I$6.id}) matching took ${A$5} against '${B$4}'`),
              console.log(`  scanning for (linePos: ${g$5}, anchorPosition: ${C$6})`),
              console.log(D$4.toString()),
              s$16
              && console.log(
                `matched rule id: ${s$16.ruleId} from ${s$16.captureIndices[0].start} to ${s$16.captureIndices[0].end}`,
              )
          }
          return s$16 ? { captureIndices: s$16.captureIndices, matchedRuleId: s$16.ruleId } : null
        }(A$3, B$3, Q$2, g$4, E$3, C$5),
        D$3 = A$3.getInjections()
      if (D$3.length === 0) return I$5
      let w$2 = function(A$4, B$4, Q$3, g$5, E$4, C$6, I$6) {
        let D$4, w$3 = Number.MAX_VALUE, o$20 = null, s$16 = 0, e$28 = C$6.contentNameScopesList.getScopeNames()
        for (let C$7 = 0, c$5 = A$4.length; C$7 < c$5; C$7++) {
          let c$6 = A$4[C$7]
          if (!c$6.matcher(e$28)) continue
          let i$14 = B$4.getRule(c$6.ruleId),
            { ruleScanner: t$18, findOptions: M$1 } = kA(i$14, B$4, null, g$5, E$4 === I$6),
            h$2 = t$18.findNextMatchSync(Q$3, E$4, M$1)
          if (!h$2) continue
          L && (console.log(`  matched injection: ${c$6.debugSelector}`), console.log(t$18.toString()))
          let F$1 = h$2.captureIndices[0].start
          if (
            !(F$1 >= w$3) && (w$3 = F$1, o$20 = h$2.captureIndices, D$4 = h$2.ruleId, s$16 = c$6.priority, w$3 === E$4)
          ) break
        }
        return o$20 ? { priorityMatch: s$16 === -1, captureIndices: o$20, matchedRuleId: D$4 } : null
      }(D$3, A$3, B$3, Q$2, g$4, E$3, C$5)
      if (!w$2) return I$5
      if (!I$5) return w$2
      let o$19 = I$5.captureIndices[0].start, s$15 = w$2.captureIndices[0].start
      return s$15 < o$19 || w$2.priorityMatch && s$15 === o$19 ? w$2 : I$5
    }(A$2, B$2, Q$1, g$3, E$2, s$14)
    if (!I$4) return L && console.log(`  no more matches.`), C$4.produce(E$2, w$1), void (o$18 = !0)
    let D$2 = I$4.captureIndices, e$27 = I$4.matchedRuleId, c$4 = !!(D$2 && D$2.length > 0) && D$2[0].end > g$3
    if (e$27 === -1) {
      let I$5 = E$2.getRule(A$2)
      L && console.log(`  popping ` + I$5.debugName + ` - ` + I$5.debugEndRegExp),
        C$4.produce(E$2, D$2[0].start),
        E$2 = E$2.withContentNameScopesList(E$2.nameScopesList),
        KA(A$2, B$2, Q$1, E$2, C$4, I$5.endCaptures, D$2),
        C$4.produce(E$2, D$2[0].end)
      let e$28 = E$2
      if (E$2 = E$2.parent, s$14 = e$28.getAnchorPos(), !c$4 && e$28.getEnterPos() === g$3) {
        return L
          && console.error(`[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing`),
          E$2 = e$28,
          C$4.produce(E$2, w$1),
          void (o$18 = !0)
      }
    } else {
      let I$5 = A$2.getRule(e$27)
      C$4.produce(E$2, D$2[0].start)
      let i$14 = E$2, t$18 = I$5.getName(B$2.content, D$2), M$1 = E$2.contentNameScopesList.pushAttributed(t$18, A$2)
      if (E$2 = E$2.push(e$27, g$3, s$14, D$2[0].end === w$1, null, M$1, M$1), I$5 instanceof IA) {
        let g$4 = I$5
        L && console.log(`  pushing ` + g$4.debugName + ` - ` + g$4.debugBeginRegExp),
          KA(A$2, B$2, Q$1, E$2, C$4, g$4.beginCaptures, D$2),
          C$4.produce(E$2, D$2[0].end),
          s$14 = D$2[0].end
        let e$28 = g$4.getContentName(B$2.content, D$2), t$19 = M$1.pushAttributed(e$28, A$2)
        if (
          E$2 = E$2.withContentNameScopesList(t$19),
            g$4.endHasBackReferences && (E$2 = E$2.withEndRule(g$4.getEndWithResolvedBackReferences(B$2.content, D$2))),
            !c$4 && i$14.hasSameRuleAs(E$2)
        ) {
          return L
            && console.error(`[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing`),
            E$2 = E$2.pop(),
            C$4.produce(E$2, w$1),
            void (o$18 = !0)
        }
      } else if (I$5 instanceof DA) {
        let g$4 = I$5
        L && console.log(`  pushing ` + g$4.debugName),
          KA(A$2, B$2, Q$1, E$2, C$4, g$4.beginCaptures, D$2),
          C$4.produce(E$2, D$2[0].end),
          s$14 = D$2[0].end
        let e$28 = g$4.getContentName(B$2.content, D$2), t$19 = M$1.pushAttributed(e$28, A$2)
        if (
          E$2 = E$2.withContentNameScopesList(t$19),
            g$4.whileHasBackReferences
            && (E$2 = E$2.withEndRule(g$4.getWhileWithResolvedBackReferences(B$2.content, D$2))),
            !c$4 && i$14.hasSameRuleAs(E$2)
        ) {
          return L
            && console.error(`[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing`),
            E$2 = E$2.pop(),
            C$4.produce(E$2, w$1),
            void (o$18 = !0)
        }
      } else {
        let g$4 = I$5
        if (
          L && console.log(`  matched ` + g$4.debugName + ` - ` + g$4.debugMatchRegExp),
            KA(A$2, B$2, Q$1, E$2, C$4, g$4.captures, D$2),
            C$4.produce(E$2, D$2[0].end),
            E$2 = E$2.pop(),
            !c$4
        ) {
          return L
            && console.error(
              `[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping`,
            ),
            E$2 = E$2.safePop(),
            C$4.produce(E$2, w$1),
            void (o$18 = !0)
        }
      }
    }
    D$2[0].end > g$3 && (g$3 = D$2[0].end, Q$1 = !1)
  }
}
function kA(A$2, B$2, Q$1, g$3, E$2) {
  return { ruleScanner: A$2.compileAG(B$2, Q$1, g$3, E$2), findOptions: 0 }
}
function RA(A$2, B$2, Q$1, g$3, E$2) {
  return { ruleScanner: A$2.compileWhileAG(B$2, Q$1, g$3, E$2), findOptions: 0 }
}
function KA(A$2, B$2, Q$1, g$3, E$2, C$4, I$3) {
  if (C$4.length === 0) return
  let D$1 = B$2.content, w$1 = Math.min(C$4.length, I$3.length), o$18 = [], s$14 = I$3[0].end
  for (let B$3 = 0; B$3 < w$1; B$3++) {
    let w$2 = C$4[B$3]
    if (w$2 === null) continue
    let e$26 = I$3[B$3]
    if (e$26.length === 0) continue
    if (e$26.start > s$14) break
    for (; o$18.length > 0 && o$18[o$18.length - 1].endPos <= e$26.start;) {
      E$2.produceFromScopes(o$18[o$18.length - 1].scopes, o$18[o$18.length - 1].endPos), o$18.pop()
    }
    if (
      o$18.length > 0 ? E$2.produceFromScopes(o$18[o$18.length - 1].scopes, e$26.start) : E$2.produce(g$3, e$26.start),
        w$2.retokenizeCapturedWithRuleId
    ) {
      let B$4 = w$2.getName(D$1, I$3),
        C$5 = g$3.contentNameScopesList.pushAttributed(B$4, A$2),
        o$19 = w$2.getContentName(D$1, I$3),
        s$15 = C$5.pushAttributed(o$19, A$2),
        c$4 = g$3.push(w$2.retokenizeCapturedWithRuleId, e$26.start, -1, !1, null, C$5, s$15),
        i$14 = A$2.createOnigString(D$1.substring(0, e$26.end))
      LA(A$2, i$14, Q$1 && e$26.start === 0, e$26.start, c$4, E$2, !1, 0), Y(i$14)
      continue
    }
    let c$3 = w$2.getName(D$1, I$3)
    if (c$3 !== null) {
      let B$4 = (o$18.length > 0 ? o$18[o$18.length - 1].scopes : g$3.contentNameScopesList).pushAttributed(c$3, A$2)
      o$18.push(new YA(B$4, e$26.end))
    }
  }
  for (; o$18.length > 0;) E$2.produceFromScopes(o$18[o$18.length - 1].scopes, o$18[o$18.length - 1].endPos), o$18.pop()
}
var YA = class {
  constructor(A$2, B$2) {
    this.scopes = A$2, this.endPos = B$2
  }
}
function UA(A$2, B$2, Q$1, g$3, E$2) {
  let C$4 = R$1(B$2, PA), I$3 = wA.getCompiledRuleId(Q$1, g$3, E$2.repository)
  for (let Q$2 of C$4) {
    A$2.push({ debugSelector: B$2, matcher: Q$2.matcher, ruleId: I$3, grammar: E$2, priority: Q$2.priority })
  }
}
function PA(A$2, B$2) {
  if (B$2.length < A$2.length) return !1
  let Q$1 = 0
  return A$2.every(A$3 => {
    for (let g$3 = Q$1; g$3 < B$2.length; g$3++) if (uA(B$2[g$3], A$3)) return Q$1 = g$3 + 1, !0
    return !1
  })
}
function uA(A$2, B$2) {
  if (!A$2) return !1
  if (A$2 === B$2) return !0
  let Q$1 = B$2.length
  return A$2.length > Q$1 && A$2.substr(0, Q$1) === B$2 && A$2[Q$1] === `.`
}
var yA = class {
  constructor(A$2, B$2, Q$1, g$3, E$2, C$4, I$3, D$1) {
    if (
      this._rootScopeName = A$2,
        this.balancedBracketSelectors = C$4,
        this._onigLib = D$1,
        this._basicScopeAttributesProvider = new NA(Q$1, g$3),
        this._rootId = -1,
        this._lastRuleId = 0,
        this._ruleId2desc = [null],
        this._includedGrammars = {},
        this._grammarRepository = I$3,
        this._grammar = JA(B$2, null),
        this._injections = null,
        this._tokenTypeMatchers = [],
        E$2
    ) {
      for (let A$3 of Object.keys(E$2)) {
        let B$3 = R$1(A$3, PA)
        for (let Q$2 of B$3) this._tokenTypeMatchers.push({ matcher: Q$2.matcher, type: E$2[A$3] })
      }
    }
  }
  get themeProvider() {
    return this._grammarRepository
  }
  dispose() {
    for (let A$2 of this._ruleId2desc) A$2 && A$2.dispose()
  }
  createOnigScanner(A$2) {
    return this._onigLib.createOnigScanner(A$2)
  }
  createOnigString(A$2) {
    return this._onigLib.createOnigString(A$2)
  }
  getMetadataForScope(A$2) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(A$2)
  }
  _collectInjections() {
    let A$2 = [],
      B$2 = this._rootScopeName,
      Q$1 = (A$3 => A$3 === this._rootScopeName ? this._grammar : this.getExternalGrammar(A$3))(B$2)
    if (Q$1) {
      let g$3 = Q$1.injections
      if (g$3) for (let B$3 in g$3) UA(A$2, B$3, g$3[B$3], this, Q$1)
      let E$2 = this._grammarRepository.injections(B$2)
      E$2 && E$2.forEach(B$3 => {
        let Q$2 = this.getExternalGrammar(B$3)
        if (Q$2) {
          let B$4 = Q$2.injectionSelector
          B$4 && UA(A$2, B$4, Q$2, this, Q$2)
        }
      })
    }
    return A$2.sort((A$3, B$3) => A$3.priority - B$3.priority), A$2
  }
  getInjections() {
    if (this._injections === null && (this._injections = this._collectInjections(), L && this._injections.length > 0)) {
      console.log(`Grammar ${this._rootScopeName} contains the following injections:`)
      for (let A$2 of this._injections) console.log(`  - ${A$2.debugSelector}`)
    }
    return this._injections
  }
  registerRule(A$2) {
    let B$2 = ++this._lastRuleId, Q$1 = A$2(B$2)
    return this._ruleId2desc[B$2] = Q$1, Q$1
  }
  getRule(A$2) {
    return this._ruleId2desc[A$2]
  }
  getExternalGrammar(A$2, B$2) {
    if (this._includedGrammars[A$2]) return this._includedGrammars[A$2]
    if (this._grammarRepository) {
      let Q$1 = this._grammarRepository.lookup(A$2)
      if (Q$1) return this._includedGrammars[A$2] = JA(Q$1, B$2 && B$2.$base), this._includedGrammars[A$2]
    }
  }
  tokenizeLine(A$2, B$2, Q$1 = 0) {
    let g$3 = this._tokenize(A$2, B$2, !1, Q$1)
    return {
      tokens: g$3.lineTokens.getResult(g$3.ruleStack, g$3.lineLength),
      ruleStack: g$3.ruleStack,
      stoppedEarly: g$3.stoppedEarly,
    }
  }
  tokenizeLine2(A$2, B$2, Q$1 = 0) {
    let g$3 = this._tokenize(A$2, B$2, !0, Q$1)
    return {
      tokens: g$3.lineTokens.getBinaryResult(g$3.ruleStack, g$3.lineLength),
      ruleStack: g$3.ruleStack,
      stoppedEarly: g$3.stoppedEarly,
    }
  }
  _tokenize(A$2, B$2, Q$1, g$3) {
    let E$2
    if (
      this._rootId === -1
      && (this._rootId = wA.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository),
        this.getInjections()), B$2 && B$2 !== dA.NULL
    ) E$2 = !1, B$2.reset()
    else {
      E$2 = !0
      let A$3 = this._basicScopeAttributesProvider.getDefaultAttributes(),
        Q$2 = this.themeProvider.getDefaults(),
        g$4 = k.set(0, A$3.languageId, A$3.tokenType, null, Q$2.fontStyle, Q$2.foregroundId, Q$2.backgroundId),
        C$5 = this.getRule(this._rootId).getName(null, null),
        I$4
      I$4 = C$5 ? SA.createRootAndLookUpScopeName(C$5, g$4, this) : SA.createRoot(`unknown`, g$4),
        B$2 = new dA(null, this._rootId, -1, -1, !1, null, I$4, I$4)
    }
    A$2 += `
`
    let C$4 = this.createOnigString(A$2),
      I$3 = C$4.content.length,
      D$1 = new pA(Q$1, A$2, this._tokenTypeMatchers, this.balancedBracketSelectors),
      w$1 = LA(this, C$4, E$2, 0, B$2, D$1, !0, g$3)
    return Y(C$4), { lineLength: I$3, lineTokens: D$1, ruleStack: w$1.stack, stoppedEarly: w$1.stoppedEarly }
  }
}
function JA(A$2, B$2) {
  return (A$2 = U(A$2)).repository = A$2.repository || {},
    A$2.repository.$self = {
      $vscodeTextmateLocation: A$2.$vscodeTextmateLocation,
      patterns: A$2.patterns,
      name: A$2.scopeName,
    },
    A$2.repository.$base = B$2 || A$2.repository.$self,
    A$2
}
var SA = class SA {
    constructor(A$2, B$2, Q$1) {
      this.parent = A$2, this.scopePath = B$2, this.tokenAttributes = Q$1
    }
    static fromExtension(A$2, B$2) {
      let Q$1 = A$2, g$3 = A$2?.scopePath ?? null
      for (let A$3 of B$2) g$3 = iA.push(g$3, A$3.scopeNames), Q$1 = new SA(Q$1, g$3, A$3.encodedTokenAttributes)
      return Q$1
    }
    static createRoot(A$2, B$2) {
      return new SA(null, new iA(null, A$2), B$2)
    }
    static createRootAndLookUpScopeName(A$2, B$2, Q$1) {
      let g$3 = Q$1.getMetadataForScope(A$2),
        E$2 = new iA(null, A$2),
        C$4 = Q$1.themeProvider.themeMatch(E$2),
        I$3 = SA.mergeAttributes(B$2, g$3, C$4)
      return new SA(null, E$2, I$3)
    }
    get scopeName() {
      return this.scopePath.scopeName
    }
    toString() {
      return this.getScopeNames().join(` `)
    }
    equals(A$2) {
      return SA.equals(this, A$2)
    }
    static equals(A$2, B$2) {
      for (;;) {
        if (A$2 === B$2 || !A$2 && !B$2) return !0
        if (!A$2 || !B$2 || A$2.scopeName !== B$2.scopeName || A$2.tokenAttributes !== B$2.tokenAttributes) return !1
        A$2 = A$2.parent, B$2 = B$2.parent
      }
    }
    static mergeAttributes(A$2, B$2, Q$1) {
      let g$3 = -1, E$2 = 0, C$4 = 0
      return Q$1 !== null && (g$3 = Q$1.fontStyle, E$2 = Q$1.foregroundId, C$4 = Q$1.backgroundId),
        k.set(A$2, B$2.languageId, B$2.tokenType, null, g$3, E$2, C$4)
    }
    pushAttributed(A$2, B$2) {
      if (A$2 === null) return this
      if (A$2.indexOf(` `) === -1) return SA._pushAttributed(this, A$2, B$2)
      let Q$1 = A$2.split(/ /g), g$3 = this
      for (let A$3 of Q$1) g$3 = SA._pushAttributed(g$3, A$3, B$2)
      return g$3
    }
    static _pushAttributed(A$2, B$2, Q$1) {
      let g$3 = Q$1.getMetadataForScope(B$2),
        E$2 = A$2.scopePath.push(B$2),
        C$4 = Q$1.themeProvider.themeMatch(E$2),
        I$3 = SA.mergeAttributes(A$2.tokenAttributes, g$3, C$4)
      return new SA(A$2, E$2, I$3)
    }
    getScopeNames() {
      return this.scopePath.getSegments()
    }
    getExtensionIfDefined(A$2) {
      let B$2 = [], Q$1 = this
      for (; Q$1 && Q$1 !== A$2;) {
        B$2.push({
          encodedTokenAttributes: Q$1.tokenAttributes,
          scopeNames: Q$1.scopePath.getExtensionIfDefined(Q$1.parent?.scopePath ?? null),
        }), Q$1 = Q$1.parent
      }
      return Q$1 === A$2 ? B$2.reverse() : void 0
    }
  },
  dA = class dA {
    constructor(A$2, B$2, Q$1, g$3, E$2, C$4, I$3, D$1) {
      this.parent = A$2,
        this.ruleId = B$2,
        this.beginRuleCapturedEOL = E$2,
        this.endRule = C$4,
        this.nameScopesList = I$3,
        this.contentNameScopesList = D$1,
        this._stackElementBrand = void 0,
        this.depth = this.parent ? this.parent.depth + 1 : 1,
        this._enterPos = Q$1,
        this._anchorPos = g$3
    }
    equals(A$2) {
      return A$2 !== null && dA._equals(this, A$2)
    }
    static _equals(A$2, B$2) {
      return A$2 === B$2
        || !!this._structuralEquals(A$2, B$2) && SA.equals(A$2.contentNameScopesList, B$2.contentNameScopesList)
    }
    static _structuralEquals(A$2, B$2) {
      for (;;) {
        if (A$2 === B$2 || !A$2 && !B$2) return !0
        if (!A$2 || !B$2 || A$2.depth !== B$2.depth || A$2.ruleId !== B$2.ruleId || A$2.endRule !== B$2.endRule) {
          return !1
        }
        A$2 = A$2.parent, B$2 = B$2.parent
      }
    }
    clone() {
      return this
    }
    static _reset(A$2) {
      for (; A$2;) A$2._enterPos = -1, A$2._anchorPos = -1, A$2 = A$2.parent
    }
    reset() {
      dA._reset(this)
    }
    pop() {
      return this.parent
    }
    safePop() {
      return this.parent ? this.parent : this
    }
    push(A$2, B$2, Q$1, g$3, E$2, C$4, I$3) {
      return new dA(this, A$2, B$2, Q$1, g$3, E$2, C$4, I$3)
    }
    getEnterPos() {
      return this._enterPos
    }
    getAnchorPos() {
      return this._anchorPos
    }
    getRule(A$2) {
      return A$2.getRule(this.ruleId)
    }
    toString() {
      let A$2 = []
      return this._writeString(A$2, 0), `[` + A$2.join(`,`) + `]`
    }
    _writeString(A$2, B$2) {
      return this.parent && (B$2 = this.parent._writeString(A$2, B$2)),
        A$2[B$2++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`,
        B$2
    }
    withContentNameScopesList(A$2) {
      return this.contentNameScopesList === A$2
        ? this
        : this.parent.push(
          this.ruleId,
          this._enterPos,
          this._anchorPos,
          this.beginRuleCapturedEOL,
          this.endRule,
          this.nameScopesList,
          A$2,
        )
    }
    withEndRule(A$2) {
      return this.endRule === A$2
        ? this
        : new dA(
          this.parent,
          this.ruleId,
          this._enterPos,
          this._anchorPos,
          this.beginRuleCapturedEOL,
          A$2,
          this.nameScopesList,
          this.contentNameScopesList,
        )
    }
    hasSameRuleAs(A$2) {
      let B$2 = this
      for (; B$2 && B$2._enterPos === A$2._enterPos;) {
        if (B$2.ruleId === A$2.ruleId) return !0
        B$2 = B$2.parent
      }
      return !1
    }
    toStateStackFrame() {
      return {
        ruleId: this.ruleId,
        beginRuleCapturedEOL: this.beginRuleCapturedEOL,
        endRule: this.endRule,
        nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
        contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? [],
      }
    }
    static pushFrame(A$2, B$2) {
      let Q$1 = SA.fromExtension(A$2?.nameScopesList ?? null, B$2.nameScopesList)
      return new dA(
        A$2,
        B$2.ruleId,
        B$2.enterPos ?? -1,
        B$2.anchorPos ?? -1,
        B$2.beginRuleCapturedEOL,
        B$2.endRule,
        Q$1,
        SA.fromExtension(Q$1, B$2.contentNameScopesList),
      )
    }
  }
dA.NULL = new dA(null, 0, 0, 0, !1, null, null, null)
var lA = class {
    constructor(A$2, B$2) {
      this.allowAny = !1,
        this.balancedBracketScopes = A$2.flatMap(
          A$3 => A$3 === `*` ? (this.allowAny = !0, []) : R$1(A$3, PA).map(A$4 => A$4.matcher),
        ),
        this.unbalancedBracketScopes = B$2.flatMap(A$3 => R$1(A$3, PA).map(A$4 => A$4.matcher))
    }
    get matchesAlways() {
      return this.allowAny && this.unbalancedBracketScopes.length === 0
    }
    get matchesNever() {
      return this.balancedBracketScopes.length === 0 && !this.allowAny
    }
    match(A$2) {
      for (let B$2 of this.unbalancedBracketScopes) if (B$2(A$2)) return !1
      for (let B$2 of this.balancedBracketScopes) if (B$2(A$2)) return !0
      return this.allowAny
    }
  },
  pA = class {
    constructor(A$2, B$2, Q$1, g$3) {
      this.balancedBracketSelectors = g$3,
        this._emitBinaryTokens = A$2,
        this._tokenTypeOverrides = Q$1,
        this._lineText = L ? B$2 : null,
        this._tokens = [],
        this._binaryTokens = [],
        this._lastTokenEndIndex = 0
    }
    produce(A$2, B$2) {
      this.produceFromScopes(A$2.contentNameScopesList, B$2)
    }
    produceFromScopes(A$2, B$2) {
      if (this._lastTokenEndIndex >= B$2) return
      if (this._emitBinaryTokens) {
        let Q$2 = A$2?.tokenAttributes ?? 0, g$3 = !1
        if (
          this.balancedBracketSelectors?.matchesAlways && (g$3 = !0),
            this._tokenTypeOverrides.length > 0
            || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways
              && !this.balancedBracketSelectors.matchesNever
        ) {
          let B$3 = A$2?.getScopeNames() ?? []
          for (let A$3 of this._tokenTypeOverrides) A$3.matcher(B$3) && (Q$2 = k.set(Q$2, 0, A$3.type, null, -1, 0, 0))
          this.balancedBracketSelectors && (g$3 = this.balancedBracketSelectors.match(B$3))
        }
        if (
          g$3 && (Q$2 = k.set(Q$2, 0, 8, g$3, -1, 0, 0)),
            this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === Q$2
        ) return void (this._lastTokenEndIndex = B$2)
        if (L) {
          let Q$3 = A$2?.getScopeNames() ?? []
          console.log(`  token: |` + this._lineText.substring(this._lastTokenEndIndex, B$2).replace(/\n$/, `\\n`) + `|`)
          for (let A$3 = 0; A$3 < Q$3.length; A$3++) console.log(`      * ` + Q$3[A$3])
        }
        return this._binaryTokens.push(this._lastTokenEndIndex),
          this._binaryTokens.push(Q$2),
          void (this._lastTokenEndIndex = B$2)
      }
      let Q$1 = A$2?.getScopeNames() ?? []
      if (L) {
        console.log(`  token: |` + this._lineText.substring(this._lastTokenEndIndex, B$2).replace(/\n$/, `\\n`) + `|`)
        for (let A$3 = 0; A$3 < Q$1.length; A$3++) console.log(`      * ` + Q$1[A$3])
      }
      this._tokens.push({ startIndex: this._lastTokenEndIndex, endIndex: B$2, scopes: Q$1 }),
        this._lastTokenEndIndex = B$2
    }
    getResult(A$2, B$2) {
      return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === B$2 - 1
        && this._tokens.pop(),
        this._tokens.length === 0
        && (this._lastTokenEndIndex = -1, this.produce(A$2, B$2), this._tokens[this._tokens.length - 1].startIndex = 0),
        this._tokens
    }
    getBinaryResult(A$2, B$2) {
      this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === B$2 - 1
      && (this._binaryTokens.pop(), this._binaryTokens.pop()),
        this._binaryTokens.length === 0
        && (this._lastTokenEndIndex = -1, this.produce(A$2, B$2), this._binaryTokens[this._binaryTokens.length - 2] = 0)
      let Q$1 = new Uint32Array(this._binaryTokens.length)
      for (let A$3 = 0, B$3 = this._binaryTokens.length; A$3 < B$3; A$3++) Q$1[A$3] = this._binaryTokens[A$3]
      return Q$1
    }
  }
function fA(A$2, B$2, Q$1) {
  let g$3 = A$2.length, E$2 = 0, C$4 = 1, I$3 = 0
  function D$1(B$3) {
    if (Q$1 === null) E$2 += B$3
    else for (; B$3 > 0;) A$2.charCodeAt(E$2) === 10 ? (E$2++, C$4++, I$3 = 0) : (E$2++, I$3++), B$3--
  }
  function w$1(A$3) {
    Q$1 === null ? E$2 = A$3 : D$1(A$3 - E$2)
  }
  function o$18() {
    for (; E$2 < g$3;) {
      let B$3 = A$2.charCodeAt(E$2)
      if (B$3 !== 32 && B$3 !== 9 && B$3 !== 13 && B$3 !== 10) break
      D$1(1)
    }
  }
  function s$14(B$3) {
    return A$2.substr(E$2, B$3.length) === B$3 && (D$1(B$3.length), !0)
  }
  function e$26(B$3) {
    let Q$2 = A$2.indexOf(B$3, E$2)
    w$1(Q$2 === -1 ? g$3 : Q$2 + B$3.length)
  }
  function c$3(B$3) {
    let Q$2 = A$2.indexOf(B$3, E$2)
    if (Q$2 !== -1) {
      let g$4 = A$2.substring(E$2, Q$2)
      return w$1(Q$2 + B$3.length), g$4
    }
    {
      let B$4 = A$2.substr(E$2)
      return w$1(g$3), B$4
    }
  }
  g$3 > 0 && A$2.charCodeAt(0) === 65279 && (E$2 = 1)
  let i$14 = 0, t$18 = null, M$1 = [], h$2 = [], F$1 = null
  function G(A$3, B$3) {
    M$1.push(i$14), h$2.push(t$18), i$14 = A$3, t$18 = B$3
  }
  function a$22() {
    if (M$1.length === 0) return n$19(`illegal state stack`)
    i$14 = M$1.pop(), t$18 = h$2.pop()
  }
  function n$19(B$3) {
    throw Error(`Near offset ` + E$2 + `: ` + B$3 + ` ~~~` + A$2.substr(E$2, 50) + `~~~`)
  }
  let N$2 = function() {
      if (F$1 === null) return n$19(`missing <key>`)
      let A$3 = {}
      Q$1 !== null && (A$3[Q$1] = { filename: B$2, line: C$4, char: I$3 }), t$18[F$1] = A$3, F$1 = null, G(1, A$3)
    },
    r$26 = function() {
      if (F$1 === null) return n$19(`missing <key>`)
      let A$3 = []
      t$18[F$1] = A$3, F$1 = null, G(2, A$3)
    },
    H$2 = function() {
      let A$3 = {}
      Q$1 !== null && (A$3[Q$1] = { filename: B$2, line: C$4, char: I$3 }), t$18.push(A$3), G(1, A$3)
    },
    L$2 = function() {
      let A$3 = []
      t$18.push(A$3), G(2, A$3)
    }
  function k$1() {
    if (i$14 !== 1) return n$19(`unexpected </dict>`)
    a$22()
  }
  function R$4() {
    return i$14 === 1 || i$14 !== 2 ? n$19(`unexpected </array>`) : void a$22()
  }
  function K$1(A$3) {
    if (i$14 === 1) {
      if (F$1 === null) return n$19(`missing <key>`)
      t$18[F$1] = A$3, F$1 = null
    } else i$14 === 2 ? t$18.push(A$3) : t$18 = A$3
  }
  function Y$1(A$3) {
    if (isNaN(A$3)) return n$19(`cannot parse float`)
    if (i$14 === 1) {
      if (F$1 === null) return n$19(`missing <key>`)
      t$18[F$1] = A$3, F$1 = null
    } else i$14 === 2 ? t$18.push(A$3) : t$18 = A$3
  }
  function U$1(A$3) {
    if (isNaN(A$3)) return n$19(`cannot parse integer`)
    if (i$14 === 1) {
      if (F$1 === null) return n$19(`missing <key>`)
      t$18[F$1] = A$3, F$1 = null
    } else i$14 === 2 ? t$18.push(A$3) : t$18 = A$3
  }
  function P$5(A$3) {
    if (i$14 === 1) {
      if (F$1 === null) return n$19(`missing <key>`)
      t$18[F$1] = A$3, F$1 = null
    } else i$14 === 2 ? t$18.push(A$3) : t$18 = A$3
  }
  function u$7(A$3) {
    if (i$14 === 1) {
      if (F$1 === null) return n$19(`missing <key>`)
      t$18[F$1] = A$3, F$1 = null
    } else i$14 === 2 ? t$18.push(A$3) : t$18 = A$3
  }
  function y$3(A$3) {
    if (i$14 === 1) {
      if (F$1 === null) return n$19(`missing <key>`)
      t$18[F$1] = A$3, F$1 = null
    } else i$14 === 2 ? t$18.push(A$3) : t$18 = A$3
  }
  function J$1() {
    let A$3 = c$3(`>`), B$3 = !1
    return A$3.charCodeAt(A$3.length - 1) === 47 && (B$3 = !0, A$3 = A$3.substring(0, A$3.length - 1)),
      { name: A$3.trim(), isClosed: B$3 }
  }
  function S$2(A$3) {
    if (A$3.isClosed) return ``
    let B$3 = c$3(`</`)
    return e$26(`>`),
      B$3.replace(/&#([0-9]+);/g, function(A$4, B$4) {
        return String.fromCodePoint(parseInt(B$4, 10))
      }).replace(/&#x([0-9a-f]+);/g, function(A$4, B$4) {
        return String.fromCodePoint(parseInt(B$4, 16))
      }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function(A$4) {
        switch (A$4) {
          case `&amp;`:
            return `&`
          case `&lt;`:
            return `<`
          case `&gt;`:
            return `>`
          case `&quot;`:
            return `"`
          case `&apos;`:
            return `'`
        }
        return A$4
      })
  }
  for (; E$2 < g$3 && (o$18(), !(E$2 >= g$3));) {
    let w$2 = A$2.charCodeAt(E$2)
    if (D$1(1), w$2 !== 60) return n$19(`expected <`)
    if (E$2 >= g$3) return n$19(`unexpected end of input`)
    let c$4 = A$2.charCodeAt(E$2)
    if (c$4 === 63) {
      D$1(1), e$26(`?>`)
      continue
    }
    if (c$4 === 33) {
      if (D$1(1), s$14(`--`)) {
        e$26(`-->`)
        continue
      }
      e$26(`>`)
      continue
    }
    if (c$4 === 47) {
      if (D$1(1), o$18(), s$14(`plist`)) {
        e$26(`>`)
        continue
      }
      if (s$14(`dict`)) {
        e$26(`>`), k$1()
        continue
      }
      if (s$14(`array`)) {
        e$26(`>`), R$4()
        continue
      }
      return n$19(`unexpected closed tag`)
    }
    let M$2 = J$1()
    switch (M$2.name) {
      case `dict`:
        i$14 === 1
          ? N$2()
          : i$14 === 2
          ? H$2()
          : (t$18 = {}, Q$1 !== null && (t$18[Q$1] = { filename: B$2, line: C$4, char: I$3 }), G(1, t$18)),
          M$2.isClosed && k$1()
        continue
      case `array`:
        i$14 === 1 ? r$26() : i$14 === 2 ? L$2() : (t$18 = [], G(2, t$18)), M$2.isClosed && R$4()
        continue
      case `key`:
        d$7 = S$2(M$2), i$14 === 1 ? F$1 === null ? F$1 = d$7 : n$19(`too many <key>`) : n$19(`unexpected <key>`)
        continue
      case `string`:
        K$1(S$2(M$2))
        continue
      case `real`:
        Y$1(parseFloat(S$2(M$2)))
        continue
      case `integer`:
        U$1(parseInt(S$2(M$2), 10))
        continue
      case `date`:
        P$5(new Date(S$2(M$2)))
        continue
      case `data`:
        u$7(S$2(M$2))
        continue
      case `true`:
        S$2(M$2), y$3(!0)
        continue
      case `false`:
        S$2(M$2), y$3(!1)
        continue
    }
    if (!/^plist/.test(M$2.name)) return n$19(`unexpected opened tag ` + M$2.name)
  }
  var d$7
  return t$18
}
function xA(A$2, B$2) {
  throw Error(`Near offset ` + A$2.pos + `: ` + B$2 + ` ~~~` + A$2.source.substr(A$2.pos, 50) + `~~~`)
}
var OA = class {
    constructor(A$2) {
      this.source = A$2, this.pos = 0, this.len = A$2.length, this.line = 1, this.char = 0
    }
  },
  mA = class {
    constructor() {
      this.value = null, this.type = 0, this.offset = -1, this.len = -1, this.line = -1, this.char = -1
    }
    toLocation(A$2) {
      return { filename: A$2, line: this.line, char: this.char }
    }
  }
function qA(A$2, B$2) {
  B$2.value = null, B$2.type = 0, B$2.offset = -1, B$2.len = -1, B$2.line = -1, B$2.char = -1
  let Q$1, g$3 = A$2.source, E$2 = A$2.pos, C$4 = A$2.len, I$3 = A$2.line, D$1 = A$2.char
  for (;;) {
    if (E$2 >= C$4) return !1
    if (Q$1 = g$3.charCodeAt(E$2), Q$1 !== 32 && Q$1 !== 9 && Q$1 !== 13) {
      if (Q$1 !== 10) break
      E$2++, I$3++, D$1 = 0
    } else E$2++, D$1++
  }
  if (B$2.offset = E$2, B$2.line = I$3, B$2.char = D$1, Q$1 === 34) {
    for (B$2.type = 1, E$2++, D$1++;;) {
      if (E$2 >= C$4) return !1
      if (Q$1 = g$3.charCodeAt(E$2), E$2++, D$1++, Q$1 !== 92) {
        if (Q$1 === 34) break
        else E$2++, D$1++
      }
    }
    B$2.value = g$3.substring(B$2.offset + 1, E$2 - 1).replace(
      /\\u([0-9A-Fa-f]{4})/g,
      (A$3, B$3) => String.fromCodePoint(parseInt(B$3, 16)),
    ).replace(/\\(.)/g, (B$3, Q$2) => {
      switch (Q$2) {
        case `"`:
          return `"`
        case `\\`:
          return `\\`
        case `/`:
          return `/`
        case `b`:
          return `\b`
        case `f`:
          return `\f`
        case `n`:
          return `
`
        case `r`:
          return `\r`
        case `t`:
          return `	`
        default:
          xA(A$2, `invalid escape sequence`)
      }
      throw Error(`unreachable`)
    })
  } else if (Q$1 === 91) B$2.type = 2, E$2++, D$1++
  else if (Q$1 === 123) B$2.type = 3, E$2++, D$1++
  else if (Q$1 === 93) B$2.type = 4, E$2++, D$1++
  else if (Q$1 === 125) B$2.type = 5, E$2++, D$1++
  else if (Q$1 === 58) B$2.type = 6, E$2++, D$1++
  else if (Q$1 === 44) B$2.type = 7, E$2++, D$1++
  else if (Q$1 === 110) {
    if (
      B$2.type = 8,
        E$2++,
        D$1++,
        Q$1 = g$3.charCodeAt(E$2),
        Q$1 !== 117 || (E$2++, D$1++, Q$1 = g$3.charCodeAt(E$2), Q$1 !== 108)
        || (E$2++, D$1++, Q$1 = g$3.charCodeAt(E$2), Q$1 !== 108)
    ) return !1
    E$2++, D$1++
  } else if (Q$1 === 116) {
    if (
      B$2.type = 9,
        E$2++,
        D$1++,
        Q$1 = g$3.charCodeAt(E$2),
        Q$1 !== 114 || (E$2++, D$1++, Q$1 = g$3.charCodeAt(E$2), Q$1 !== 117)
        || (E$2++, D$1++, Q$1 = g$3.charCodeAt(E$2), Q$1 !== 101)
    ) return !1
    E$2++, D$1++
  } else if (Q$1 === 102) {
    if (
      B$2.type = 10,
        E$2++,
        D$1++,
        Q$1 = g$3.charCodeAt(E$2),
        Q$1 !== 97 || (E$2++, D$1++, Q$1 = g$3.charCodeAt(E$2), Q$1 !== 108)
        || (E$2++, D$1++, Q$1 = g$3.charCodeAt(E$2), Q$1 !== 115)
        || (E$2++, D$1++, Q$1 = g$3.charCodeAt(E$2), Q$1 !== 101)
    ) return !1
    E$2++, D$1++
  } else {for (B$2.type = 11;;) {
      if (E$2 >= C$4) return !1
      if (
        Q$1 = g$3.charCodeAt(E$2),
          !(Q$1 === 46 || Q$1 >= 48 && Q$1 <= 57 || Q$1 === 101 || Q$1 === 69 || Q$1 === 45 || Q$1 === 43)
      ) break
      E$2++, D$1++
    }}
  return B$2.len = E$2 - B$2.offset,
    B$2.value === null && (B$2.value = g$3.substr(B$2.offset, B$2.len)),
    A$2.pos = E$2,
    A$2.line = I$3,
    A$2.char = D$1,
    !0
}
var bA = class {
  constructor(A$2, B$2) {
    this._onigLibPromise = B$2,
      this._grammars = new Map(),
      this._rawGrammars = new Map(),
      this._injectionGrammars = new Map(),
      this._theme = A$2
  }
  dispose() {
    for (let A$2 of this._grammars.values()) A$2.dispose()
  }
  setTheme(A$2) {
    this._theme = A$2
  }
  getColorMap() {
    return this._theme.getColorMap()
  }
  addGrammar(A$2, B$2) {
    this._rawGrammars.set(A$2.scopeName, A$2), B$2 && this._injectionGrammars.set(A$2.scopeName, B$2)
  }
  lookup(A$2) {
    return this._rawGrammars.get(A$2)
  }
  injections(A$2) {
    return this._injectionGrammars.get(A$2)
  }
  getDefaults() {
    return this._theme.getDefaults()
  }
  themeMatch(A$2) {
    return this._theme.match(A$2)
  }
  async grammarForScopeName(A$2, B$2, Q$1, g$3, E$2) {
    if (!this._grammars.has(A$2)) {
      let C$4 = this._rawGrammars.get(A$2)
      if (!C$4) return null
      this._grammars.set(
        A$2,
        function(A$3, B$3, Q$2, g$4, E$3, C$5, I$3, D$1) {
          return new yA(A$3, B$3, Q$2, g$4, E$3, C$5, I$3, D$1)
        }(A$2, C$4, B$2, Q$1, g$3, E$2, this, await this._onigLibPromise),
      )
    }
    return this._grammars.get(A$2)
  }
}
function WA(A$2, B$2) {
  let Q$1 = 0, g$3 = [], E$2 = A$2, C$4 = B$2
  for (; E$2 !== C$4;) {
    E$2 && (!C$4 || E$2.depth >= C$4.depth)
      ? (Q$1++, E$2 = E$2.parent)
      : (g$3.push(C$4.toStateStackFrame()), C$4 = C$4.parent)
  }
  return { pops: Q$1, newFrames: g$3.reverse() }
}
function TA(A$2, B$2) {
  let Q$1 = A$2
  for (let A$3 = 0; A$3 < B$2.pops; A$3++) Q$1 = Q$1.parent
  for (let A$3 of B$2.newFrames) Q$1 = dA.pushFrame(Q$1, A$3)
  return Q$1
}
var XA = class {
  constructor(A$2) {
    this._options = A$2,
      this._syncRegistry = new bA(cA.createFromRawTheme(A$2.theme, A$2.colorMap), A$2.onigLib),
      this._ensureGrammarCache = new Map()
  }
  dispose() {
    this._syncRegistry.dispose()
  }
  setTheme(A$2, B$2) {
    this._syncRegistry.setTheme(cA.createFromRawTheme(A$2, B$2))
  }
  getColorMap() {
    return this._syncRegistry.getColorMap()
  }
  loadGrammarWithEmbeddedLanguages(A$2, B$2, Q$1) {
    return this.loadGrammarWithConfiguration(A$2, B$2, { embeddedLanguages: Q$1 })
  }
  loadGrammarWithConfiguration(A$2, B$2, Q$1) {
    return this._loadGrammar(
      A$2,
      B$2,
      Q$1.embeddedLanguages,
      Q$1.tokenTypes,
      new lA(Q$1.balancedBracketSelectors || [], Q$1.unbalancedBracketSelectors || []),
    )
  }
  loadGrammar(A$2) {
    return this._loadGrammar(A$2, 0, null, null, null)
  }
  async _loadGrammar(A$2, B$2, Q$1, g$3, E$2) {
    let C$4 = new b(this._syncRegistry, A$2)
    for (; C$4.Q.length > 0;) {
      await Promise.all(C$4.Q.map(A$3 => this._loadSingleGrammar(A$3.scopeName))), C$4.processQueue()
    }
    return this._grammarForScopeName(A$2, B$2, Q$1, g$3, E$2)
  }
  async _loadSingleGrammar(A$2) {
    return this._ensureGrammarCache.has(A$2) || this._ensureGrammarCache.set(A$2, this._doLoadSingleGrammar(A$2)),
      this._ensureGrammarCache.get(A$2)
  }
  async _doLoadSingleGrammar(A$2) {
    let B$2 = await this._options.loadGrammar(A$2)
    if (B$2) {
      let Q$1 = typeof this._options.getInjections == `function` ? this._options.getInjections(A$2) : void 0
      this._syncRegistry.addGrammar(B$2, Q$1)
    }
  }
  async addGrammar(A$2, B$2 = [], Q$1 = 0, g$3 = null) {
    return this._syncRegistry.addGrammar(A$2, B$2), await this._grammarForScopeName(A$2.scopeName, Q$1, g$3)
  }
  _grammarForScopeName(A$2, B$2 = 0, Q$1 = null, g$3 = null, E$2 = null) {
    return this._syncRegistry.grammarForScopeName(A$2, B$2, Q$1, g$3, E$2)
  }
}
const vA = dA.NULL,
  ZA = function(A$2, B$2 = null) {
    return B$2 !== null && /\.json$/.test(B$2)
      ? (Q$1 = A$2,
        L
          ? function(A$3, B$3, Q$2) {
            let g$3 = new OA(A$3), E$2 = new mA(), C$4 = 0, I$3 = null, D$1 = [], w$1 = []
            function o$18() {
              D$1.push(C$4), w$1.push(I$3)
            }
            function s$14() {
              C$4 = D$1.pop(), I$3 = w$1.pop()
            }
            function e$26(A$4) {
              xA(g$3, A$4)
            }
            for (; qA(g$3, E$2);) {
              if (C$4 === 0) {
                if (I$3 !== null && e$26(`too many constructs in root`), E$2.type === 3) {
                  I$3 = {}, I$3.$vscodeTextmateLocation = E$2.toLocation(B$3), o$18(), C$4 = 1
                  continue
                }
                if (E$2.type === 2) {
                  I$3 = [], o$18(), C$4 = 4
                  continue
                }
                e$26(`unexpected token in root`)
              }
              if (C$4 === 2) {
                if (E$2.type === 5) {
                  s$14()
                  continue
                }
                if (E$2.type === 7) {
                  C$4 = 3
                  continue
                }
                e$26(`expected , or }`)
              }
              if (C$4 === 1 || C$4 === 3) {
                if (C$4 === 1 && E$2.type === 5) {
                  s$14()
                  continue
                }
                if (E$2.type === 1) {
                  let A$4 = E$2.value
                  if (
                    qA(g$3, E$2) && E$2.type === 6 || e$26(`expected colon`),
                      qA(g$3, E$2) || e$26(`expected value`),
                      C$4 = 2,
                      E$2.type === 1
                  ) {
                    I$3[A$4] = E$2.value
                    continue
                  }
                  if (E$2.type === 8) {
                    I$3[A$4] = null
                    continue
                  }
                  if (E$2.type === 9) {
                    I$3[A$4] = !0
                    continue
                  }
                  if (E$2.type === 10) {
                    I$3[A$4] = !1
                    continue
                  }
                  if (E$2.type === 11) {
                    I$3[A$4] = parseFloat(E$2.value)
                    continue
                  }
                  if (E$2.type === 2) {
                    let B$4 = []
                    I$3[A$4] = B$4, o$18(), C$4 = 4, I$3 = B$4
                    continue
                  }
                  if (E$2.type === 3) {
                    let Q$3 = {}
                    Q$3.$vscodeTextmateLocation = E$2.toLocation(B$3), I$3[A$4] = Q$3, o$18(), C$4 = 1, I$3 = Q$3
                    continue
                  }
                }
                e$26(`unexpected token in dict`)
              }
              if (C$4 === 5) {
                if (E$2.type === 4) {
                  s$14()
                  continue
                }
                if (E$2.type === 7) {
                  C$4 = 6
                  continue
                }
                e$26(`expected , or ]`)
              }
              if (C$4 === 4 || C$4 === 6) {
                if (C$4 === 4 && E$2.type === 4) {
                  s$14()
                  continue
                }
                if (C$4 = 5, E$2.type === 1) {
                  I$3.push(E$2.value)
                  continue
                }
                if (E$2.type === 8) {
                  I$3.push(null)
                  continue
                }
                if (E$2.type === 9) {
                  I$3.push(!0)
                  continue
                }
                if (E$2.type === 10) {
                  I$3.push(!1)
                  continue
                }
                if (E$2.type === 11) {
                  I$3.push(parseFloat(E$2.value))
                  continue
                }
                if (E$2.type === 2) {
                  let A$4 = []
                  I$3.push(A$4), o$18(), C$4 = 4, I$3 = A$4
                  continue
                }
                if (E$2.type === 3) {
                  let A$4 = {}
                  A$4.$vscodeTextmateLocation = E$2.toLocation(B$3), I$3.push(A$4), o$18(), C$4 = 1, I$3 = A$4
                  continue
                }
                e$26(`unexpected token in array`)
              }
              e$26(`unknown state`)
            }
            return w$1.length !== 0 && e$26(`unclosed constructs`), I$3
          }(Q$1, B$2)
          : JSON.parse(Q$1))
      : function(A$3, B$3) {
        return L
          ? function(A$4, B$4, Q$2) {
            return fA(A$4, B$4, `$vscodeTextmateLocation`)
          }(A$3, B$3)
          : function(A$4) {
            return fA(A$4, null, null)
          }(A$3)
      }(A$2, B$2)
    var Q$1
  }
var jA = H.Bz,
  VA = (typeof document < `u` && document.currentScript && document.currentScript.src, function(A$2) {
    var B$2, Q$1, g$3 = (A$2 ||= {}) === void 0 ? {} : A$2
    g$3.ready = new Promise(function(A$3, g$4) {
      B$2 = A$3, Q$1 = g$4
    })
    var E$2, C$4 = Object.assign({}, g$3), I$3 = !1
    E$2 = function(A$3) {
      let B$3
      return typeof readbuffer == `function`
        ? new Uint8Array(readbuffer(A$3))
        : (B$3 = read(A$3, `binary`), typeof B$3 == `object` || H$2(Q$2), B$3)
      var Q$2
    },
      typeof onig_print < `u`
      && (typeof console > `u` && (console = {}),
        console.log = onig_print,
        console.warn = console.error = typeof printErr < `u` ? printErr : onig_print)
    var D$1, w$1, o$18 = g$3.print || console.log.bind(console), s$14 = g$3.printErr || console.warn.bind(console)
    Object.assign(g$3, C$4),
      C$4 = null,
      g$3.arguments && g$3.arguments,
      g$3.thisProgram && g$3.thisProgram,
      g$3.quit && g$3.quit,
      g$3.wasmBinary && (D$1 = g$3.wasmBinary),
      g$3.noExitRuntime,
      typeof WebAssembly != `object` && H$2(`no native wasm support detected`)
    var e$26, c$3, i$14, t$18 = !1, M$1 = typeof TextDecoder < `u` ? new TextDecoder(`utf8`) : void 0
    function h$2(A$3, B$3, Q$2) {
      for (var g$4 = B$3 + Q$2, E$3 = B$3; A$3[E$3] && !(E$3 >= g$4);) ++E$3
      if (E$3 - B$3 > 16 && A$3.buffer && M$1) return M$1.decode(A$3.subarray(B$3, E$3))
      for (var C$5 = ``; B$3 < E$3;) {
        var I$4 = A$3[B$3++]
        if (128 & I$4) {
          var D$2 = 63 & A$3[B$3++]
          if ((224 & I$4) != 192) {
            var w$2 = 63 & A$3[B$3++]
            if (
              (I$4 = (240 & I$4) == 224
                ? (15 & I$4) << 12 | D$2 << 6 | w$2
                : (7 & I$4) << 18 | D$2 << 12 | w$2 << 6 | 63 & A$3[B$3++]) < 65536
            ) C$5 += String.fromCharCode(I$4)
            else {
              var o$19 = I$4 - 65536
              C$5 += String.fromCharCode(55296 | o$19 >> 10, 56320 | 1023 & o$19)
            }
          } else C$5 += String.fromCharCode((31 & I$4) << 6 | D$2)
        } else C$5 += String.fromCharCode(I$4)
      }
      return C$5
    }
    function F$1(A$3) {
      e$26 = A$3,
        g$3.HEAP8 = new Int8Array(A$3),
        g$3.HEAP16 = new Int16Array(A$3),
        g$3.HEAP32 = new Int32Array(A$3),
        g$3.HEAPU8 = c$3 = new Uint8Array(A$3),
        g$3.HEAPU16 = new Uint16Array(A$3),
        g$3.HEAPU32 = i$14 = new Uint32Array(A$3),
        g$3.HEAPF32 = new Float32Array(A$3),
        g$3.HEAPF64 = new Float64Array(A$3)
    }
    g$3.INITIAL_MEMORY
    var G = [], a$22 = [], n$19 = [], N$2 = 0, r$26 = null
    function H$2(A$3) {
      g$3.onAbort && g$3.onAbort(A$3),
        s$14(A$3 = `Aborted(` + A$3 + `)`),
        t$18 = !0,
        A$3 += `. Build with -sASSERTIONS for more info.`
      var B$3 = new WebAssembly.RuntimeError(A$3)
      throw Q$1(B$3), B$3
    }
    var L$2, k$1, R$4, K$1 = `data:application/octet-stream;base64,`
    function Y$1(A$3) {
      return A$3.startsWith(K$1)
    }
    function U$1(A$3) {
      try {
        if (A$3 == L$2 && D$1) return new Uint8Array(D$1)
        if (E$2) return E$2(A$3)
        throw `both async and sync fetching of the wasm failed`
      } catch (A$4) {
        H$2(A$4)
      }
    }
    function P$5(A$3) {
      for (; A$3.length > 0;) A$3.shift()(g$3)
    }
    function u$7(A$3) {
      try {
        return w$1.grow(A$3 - e$26.byteLength + 65535 >>> 16), F$1(w$1.buffer), 1
      } catch {}
    }
    Y$1(L$2 = `onig.wasm`) || (k$1 = L$2, L$2 = g$3.locateFile ? g$3.locateFile(k$1, ``) : `` + k$1),
      R$4 = typeof dateNow < `u` ? dateNow : () => performance.now()
    var y$3 = [null, [], []]
    function J$1(A$3, B$3) {
      var Q$2 = y$3[A$3]
      B$3 === 0 || B$3 === 10 ? ((A$3 === 1 ? o$18 : s$14)(h$2(Q$2, 0)), Q$2.length = 0) : Q$2.push(B$3)
    }
    var S$2,
      d$7 = {
        emscripten_get_now: R$4,
        emscripten_memcpy_big: function(A$3, B$3, Q$2) {
          c$3.copyWithin(A$3, B$3, B$3 + Q$2)
        },
        emscripten_resize_heap: function(A$3) {
          var B$3 = c$3.length, Q$2 = 2147483648
          if ((A$3 >>>= 0) > Q$2) return !1
          let g$4 = (A$4, B$4) => A$4 + (B$4 - A$4 % B$4) % B$4
          for (var E$3 = 1; E$3 <= 4; E$3 *= 2) {
            var C$5 = B$3 * (1 + .2 / E$3)
            if (C$5 = Math.min(C$5, A$3 + 100663296), u$7(Math.min(Q$2, g$4(Math.max(A$3, C$5), 65536)))) return !0
          }
          return !1
        },
        fd_write: function(A$3, B$3, Q$2, g$4) {
          for (var E$3 = 0, C$5 = 0; C$5 < Q$2; C$5++) {
            var I$4 = i$14[B$3 >> 2], D$2 = i$14[B$3 + 4 >> 2]
            B$3 += 8
            for (var w$2 = 0; w$2 < D$2; w$2++) J$1(A$3, c$3[I$4 + w$2])
            E$3 += D$2
          }
          return i$14[g$4 >> 2] = E$3, 0
        },
      }
    function l$9(A$3) {
      function Q$2() {
        S$2
          || (S$2 = !0,
            g$3.calledRun = !0,
            t$18 || (P$5(a$22),
              B$2(g$3),
              g$3.onRuntimeInitialized && g$3.onRuntimeInitialized(),
              function() {
                if (g$3.postRun) {
                  for (typeof g$3.postRun == `function` && (g$3.postRun = [g$3.postRun]); g$3.postRun.length;) {
                    A$4 = g$3.postRun.shift(), n$19.unshift(A$4)
                  }
                }
                var A$4
                P$5(n$19)
              }()))
      }
      N$2 > 0 || (function() {
        if (g$3.preRun) {
          for (
            typeof g$3.preRun == `function` && (g$3.preRun = [g$3.preRun]);
            g$3.preRun.length;
          ) A$4 = g$3.preRun.shift(), G.unshift(A$4)
        }
        var A$4
        P$5(G)
      }(),
        N$2 > 0 || (g$3.setStatus
          ? (g$3.setStatus(`Running...`),
            setTimeout(function() {
              setTimeout(function() {
                g$3.setStatus(``)
              }, 1), Q$2()
            }, 1))
          : Q$2()))
    }
    if (
      function() {
        var A$3 = { env: d$7, wasi_snapshot_preview1: d$7 }
        function B$3(A$4, B$4) {
          var Q$2, E$4 = A$4.exports
          g$3.asm = E$4,
            F$1((w$1 = g$3.asm.memory).buffer),
            g$3.asm.__indirect_function_table,
            Q$2 = g$3.asm.__wasm_call_ctors,
            a$22.unshift(Q$2),
            function(A$5) {
              if (N$2--, g$3.monitorRunDependencies && g$3.monitorRunDependencies(N$2), N$2 == 0 && r$26) {
                var B$5 = r$26
                r$26 = null, B$5()
              }
            }()
        }
        function E$3(A$4) {
          B$3(A$4.instance)
        }
        function C$5(B$4) {
          return (!D$1 && I$3 && typeof fetch == `function`
            ? fetch(L$2, { credentials: `same-origin` }).then(function(A$4) {
              if (!A$4.ok) throw `failed to load wasm binary file at '` + L$2 + `'`
              return A$4.arrayBuffer()
            }).catch(function() {
              return U$1(L$2)
            })
            : Promise.resolve().then(function() {
              return U$1(L$2)
            })).then(function(B$5) {
              return WebAssembly.instantiate(B$5, A$3)
            }).then(function(A$4) {
              return A$4
            }).then(B$4, function(A$4) {
              s$14(`failed to asynchronously prepare wasm: ` + A$4), H$2(A$4)
            })
        }
        if (N$2++, g$3.monitorRunDependencies && g$3.monitorRunDependencies(N$2), g$3.instantiateWasm) {
          try {
            return g$3.instantiateWasm(A$3, B$3)
          } catch (A$4) {
            s$14(`Module.instantiateWasm callback failed with error: ` + A$4), Q$1(A$4)
          }
        }
        ;(D$1 || typeof WebAssembly.instantiateStreaming != `function` || Y$1(L$2) || typeof fetch != `function`
          ? C$5(E$3)
          : fetch(L$2, { credentials: `same-origin` }).then(function(B$4) {
            return WebAssembly.instantiateStreaming(B$4, A$3).then(E$3, function(A$4) {
              return s$14(`wasm streaming compile failed: ` + A$4),
                s$14(`falling back to ArrayBuffer instantiation`),
                C$5(E$3)
            })
          })).catch(Q$1)
      }(),
        g$3.___wasm_call_ctors = function() {
          return (g$3.___wasm_call_ctors = g$3.asm.__wasm_call_ctors).apply(null, arguments)
        },
        g$3.___errno_location = function() {
          return (g$3.___errno_location = g$3.asm.__errno_location).apply(null, arguments)
        },
        g$3._omalloc = function() {
          return (g$3._omalloc = g$3.asm.omalloc).apply(null, arguments)
        },
        g$3._ofree = function() {
          return (g$3._ofree = g$3.asm.ofree).apply(null, arguments)
        },
        g$3._getLastOnigError = function() {
          return (g$3._getLastOnigError = g$3.asm.getLastOnigError).apply(null, arguments)
        },
        g$3._createOnigScanner = function() {
          return (g$3._createOnigScanner = g$3.asm.createOnigScanner).apply(null, arguments)
        },
        g$3._freeOnigScanner = function() {
          return (g$3._freeOnigScanner = g$3.asm.freeOnigScanner).apply(null, arguments)
        },
        g$3._findNextOnigScannerMatch = function() {
          return (g$3._findNextOnigScannerMatch = g$3.asm.findNextOnigScannerMatch).apply(null, arguments)
        },
        g$3._findNextOnigScannerMatchDbg = function() {
          return (g$3._findNextOnigScannerMatchDbg = g$3.asm.findNextOnigScannerMatchDbg).apply(null, arguments)
        },
        g$3.stackSave = function() {
          return (g$3.stackSave = g$3.asm.stackSave).apply(null, arguments)
        },
        g$3.stackRestore = function() {
          return (g$3.stackRestore = g$3.asm.stackRestore).apply(null, arguments)
        },
        g$3.stackAlloc = function() {
          return (g$3.stackAlloc = g$3.asm.stackAlloc).apply(null, arguments)
        },
        g$3.dynCall_jiji = function() {
          return (g$3.dynCall_jiji = g$3.asm.dynCall_jiji).apply(null, arguments)
        },
        g$3.UTF8ToString = function(A$3, B$3) {
          return A$3 ? h$2(c$3, A$3, B$3) : ``
        },
        r$26 = function A$3() {
          S$2 || l$9(), S$2 || (r$26 = A$3)
        },
        g$3.preInit
    ) {
      for (typeof g$3.preInit == `function` && (g$3.preInit = [g$3.preInit]); g$3.preInit.length > 0;) {
        g$3.preInit.pop()()
      }
    }
    return l$9(), A$2.ready
  })
let zA = null
var _A = class _A {
    static _utf8ByteLength(A$2) {
      let B$2 = 0
      for (let Q$1 = 0, g$3 = A$2.length; Q$1 < g$3; Q$1++) {
        let E$2 = A$2.charCodeAt(Q$1), C$4 = E$2, I$3 = !1
        if (E$2 >= 55296 && E$2 <= 56319 && Q$1 + 1 < g$3) {
          let B$3 = A$2.charCodeAt(Q$1 + 1)
          B$3 >= 56320 && B$3 <= 57343 && (C$4 = 65536 + (E$2 - 55296 << 10) | B$3 - 56320, I$3 = !0)
        }
        B$2 += C$4 <= 127 ? 1 : C$4 <= 2047 ? 2 : C$4 <= 65535 ? 3 : 4, I$3 && Q$1++
      }
      return B$2
    }
    constructor(A$2) {
      let B$2 = A$2.length,
        Q$1 = _A._utf8ByteLength(A$2),
        g$3 = Q$1 !== B$2,
        E$2 = g$3 ? new Uint32Array(B$2 + 1) : null
      g$3 && (E$2[B$2] = Q$1)
      let C$4 = g$3 ? new Uint32Array(Q$1 + 1) : null
      g$3 && (C$4[Q$1] = B$2)
      let I$3 = new Uint8Array(Q$1), D$1 = 0
      for (let Q$2 = 0; Q$2 < B$2; Q$2++) {
        let w$1 = A$2.charCodeAt(Q$2), o$18 = w$1, s$14 = !1
        if (w$1 >= 55296 && w$1 <= 56319 && Q$2 + 1 < B$2) {
          let B$3 = A$2.charCodeAt(Q$2 + 1)
          B$3 >= 56320 && B$3 <= 57343 && (o$18 = 65536 + (w$1 - 55296 << 10) | B$3 - 56320, s$14 = !0)
        }
        g$3
        && (E$2[Q$2] = D$1,
          s$14 && (E$2[Q$2 + 1] = D$1),
          o$18 <= 127
            ? C$4[D$1 + 0] = Q$2
            : o$18 <= 2047
            ? (C$4[D$1 + 0] = Q$2, C$4[D$1 + 1] = Q$2)
            : o$18 <= 65535
            ? (C$4[D$1 + 0] = Q$2, C$4[D$1 + 1] = Q$2, C$4[D$1 + 2] = Q$2)
            : (C$4[D$1 + 0] = Q$2, C$4[D$1 + 1] = Q$2, C$4[D$1 + 2] = Q$2, C$4[D$1 + 3] = Q$2)),
          o$18 <= 127
            ? I$3[D$1++] = o$18
            : o$18 <= 2047
            ? (I$3[D$1++] = 192 | (1984 & o$18) >>> 6, I$3[D$1++] = 128 | (63 & o$18) >>> 0)
            : o$18 <= 65535
            ? (I$3[D$1++] = 224 | (61440 & o$18) >>> 12,
              I$3[D$1++] = 128 | (4032 & o$18) >>> 6,
              I$3[D$1++] = 128 | (63 & o$18) >>> 0)
            : (I$3[D$1++] = 240 | (1835008 & o$18) >>> 18,
              I$3[D$1++] = 128 | (258048 & o$18) >>> 12,
              I$3[D$1++] = 128 | (4032 & o$18) >>> 6,
              I$3[D$1++] = 128 | (63 & o$18) >>> 0),
          s$14 && Q$2++
      }
      this.utf16Length = B$2,
        this.utf8Length = Q$1,
        this.utf16Value = A$2,
        this.utf8Value = I$3,
        this.utf16OffsetToUtf8 = E$2,
        this.utf8OffsetToUtf16 = C$4
    }
    createString(A$2) {
      let B$2 = A$2._omalloc(this.utf8Length)
      return A$2.HEAPU8.set(this.utf8Value, B$2), B$2
    }
  },
  $A = class $A {
    constructor(A$2) {
      if (this.id = ++$A.LAST_ID, !zA) throw Error(`Must invoke loadWASM first.`)
      this._onigBinding = zA, this.content = A$2
      let B$2 = new _A(A$2)
      this.utf16Length = B$2.utf16Length,
        this.utf8Length = B$2.utf8Length,
        this.utf16OffsetToUtf8 = B$2.utf16OffsetToUtf8,
        this.utf8OffsetToUtf16 = B$2.utf8OffsetToUtf16,
        this.utf8Length < 1e4 && !$A._sharedPtrInUse
          ? ($A._sharedPtr ||= zA._omalloc(1e4),
            $A._sharedPtrInUse = !0,
            zA.HEAPU8.set(B$2.utf8Value, $A._sharedPtr),
            this.ptr = $A._sharedPtr)
          : this.ptr = B$2.createString(zA)
    }
    convertUtf8OffsetToUtf16(A$2) {
      return this.utf8OffsetToUtf16
        ? A$2 < 0 ? 0 : A$2 > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[A$2]
        : A$2
    }
    convertUtf16OffsetToUtf8(A$2) {
      return this.utf16OffsetToUtf8
        ? A$2 < 0 ? 0 : A$2 > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[A$2]
        : A$2
    }
    dispose() {
      this.ptr === $A._sharedPtr ? $A._sharedPtrInUse = !1 : this._onigBinding._ofree(this.ptr)
    }
  }
$A.LAST_ID = 0, $A._sharedPtr = 0, $A._sharedPtrInUse = !1
var AB = class {
  constructor(A$2) {
    if (!zA) throw Error(`Must invoke loadWASM first.`)
    let B$2 = [], Q$1 = []
    for (let g$4 = 0, E$3 = A$2.length; g$4 < E$3; g$4++) {
      let E$4 = new _A(A$2[g$4])
      B$2[g$4] = E$4.createString(zA), Q$1[g$4] = E$4.utf8Length
    }
    let g$3 = zA._omalloc(4 * A$2.length)
    zA.HEAPU32.set(B$2, g$3 / 4)
    let E$2 = zA._omalloc(4 * A$2.length)
    zA.HEAPU32.set(Q$1, E$2 / 4)
    let C$4 = zA._createOnigScanner(g$3, E$2, A$2.length)
    for (let Q$2 = 0, g$4 = A$2.length; Q$2 < g$4; Q$2++) zA._ofree(B$2[Q$2])
    zA._ofree(E$2),
      zA._ofree(g$3),
      C$4 === 0 && function(A$3) {
        throw Error(A$3.UTF8ToString(A$3._getLastOnigError()))
      }(zA),
      this._onigBinding = zA,
      this._ptr = C$4
  }
  dispose() {
    this._onigBinding._freeOnigScanner(this._ptr)
  }
  findNextMatchSync(A$2, B$2, Q$1) {
    let g$3 = !1, E$2 = 0
    if (
      typeof Q$1 == `number` ? (8 & Q$1 && (g$3 = !0), E$2 = Q$1) : typeof Q$1 == `boolean` && (g$3 = Q$1),
        typeof A$2 == `string`
    ) {
      A$2 = new $A(A$2)
      let Q$2 = this._findNextMatchSync(A$2, B$2, g$3, E$2)
      return A$2.dispose(), Q$2
    }
    return this._findNextMatchSync(A$2, B$2, g$3, E$2)
  }
  _findNextMatchSync(A$2, B$2, Q$1, g$3) {
    let E$2 = this._onigBinding, C$4
    if (
      C$4 = Q$1
        ? E$2._findNextOnigScannerMatchDbg(
          this._ptr,
          A$2.id,
          A$2.ptr,
          A$2.utf8Length,
          A$2.convertUtf16OffsetToUtf8(B$2),
          g$3,
        )
        : E$2._findNextOnigScannerMatch(
          this._ptr,
          A$2.id,
          A$2.ptr,
          A$2.utf8Length,
          A$2.convertUtf16OffsetToUtf8(B$2),
          g$3,
        ), C$4 === 0
    ) return null
    let I$3 = E$2.HEAPU32, D$1 = C$4 / 4, w$1 = I$3[D$1++], o$18 = I$3[D$1++], s$14 = []
    for (let B$3 = 0; B$3 < o$18; B$3++) {
      let Q$2 = A$2.convertUtf8OffsetToUtf16(I$3[D$1++]), g$4 = A$2.convertUtf8OffsetToUtf16(I$3[D$1++])
      s$14[B$3] = { start: Q$2, end: g$4, length: g$4 - Q$2 }
    }
    return { index: w$1, captureIndices: s$14 }
  }
}
let BB = !1, QB = null
function gB(A$2) {
  if (BB) return QB
  let B$2, Q$1, g$3, E$2
  if (
    BB = !0,
      function(A$3) {
        return typeof A$3.instantiator == `function`
      }(A$2)
  ) B$2 = A$2.instantiator, Q$1 = A$2.print
  else {
    let g$4
    ;(function(A$3) {
        return A$3.data !== void 0
      })(A$2)
      ? (g$4 = A$2.data, Q$1 = A$2.print)
      : g$4 = A$2,
      B$2 = (function(A$3) {
          return typeof Response < `u` && A$3 instanceof Response
        })(g$4)
        ? typeof WebAssembly.instantiateStreaming == `function`
          ? function(A$3) {
            return B$3 => WebAssembly.instantiateStreaming(A$3, B$3)
          }(g$4)
          : function(A$3) {
            return async B$3 => {
              let Q$2 = await A$3.arrayBuffer()
              return WebAssembly.instantiate(Q$2, B$3)
            }
          }(g$4)
        : function(A$3) {
          return B$3 => WebAssembly.instantiate(A$3, B$3)
        }(g$4)
  }
  return QB = new Promise((A$3, B$3) => {
    g$3 = A$3, E$2 = B$3
  }),
    function(A$3, B$3, Q$2, g$4) {
      VA({
        print: B$3,
        instantiateWasm: (B$4, Q$3) => {
          if (typeof performance > `u`) {
            let A$4 = () => Date.now()
            B$4.env.emscripten_get_now = A$4, B$4.wasi_snapshot_preview1.emscripten_get_now = A$4
          }
          return A$3(B$4).then(A$4 => Q$3(A$4.instance), g$4), {}
        },
      }).then(A$4 => {
        zA = A$4, Q$2()
      })
    }(B$2, Q$1, g$3, E$2),
    QB
}
function EB(A$2) {
  return new $A(A$2)
}
function CB(A$2) {
  return new AB(A$2)
}
function IB(A$2) {
  let B$2 = n[A$2]
  if (!B$2) return
  let { id: Q$1 } = N[B$2]
  return { id: Q$1, scopeName: B$2 }
}
const DB = new Map()
let wB, oB
async function sB(Q$1) {
  if (DB.has(Q$1)) return DB.get(Q$1)
  let g$3 = function(A$2) {
    return N[A$2]
  }(Q$1)
  if (!g$3) return Promise.resolve(void 0)
  let E$2
  if (
    wB === void 0 && (E$2 = A(g$3.id), wB = E$2.then(() => !0).catch(() => !1)), oB === void 0 && (oB = await wB), oB
  ) {
    let B$2 = E$2 || A(g$3.id)
    return DB.set(Q$1, B$2), B$2
  }
  let C$4 = B(`grammars/${g$3.id}`)
  g$3.embeddedScopes.forEach(A$2 => {
    if (!DB.has(A$2)) {
      let B$2 = C$4.then(B$3 => B$3?.find(B$4 => B$4.scopeName === A$2))
      DB.set(A$2, B$2)
    }
  })
  let I$3 = C$4.then(A$2 => A$2?.find(A$3 => A$3.scopeName === Q$1))
  return DB.set(Q$1, I$3), I$3
}
const eB = 30720,
  cB = 16744448,
  iB = 16775168,
  tB = 11,
  MB = 15,
  hB = { NotSet: -1, None: 0, Italic: 1, Bold: 2, Underline: 4, Strikethrough: 8 }
function FB(A$2, B$2, Q$1, g$3) {
  let { tokens: E$2, ruleStack: C$4 } = A$2.tokenizeLine2(Q$1, B$2), I$3 = [], D$1 = Q$1.length
  for (let A$3 = E$2.length - 2; A$3 >= 0; A$3 -= 2) {
    let B$3 = E$2[A$3], g$4 = E$2[A$3 + 1], C$5 = Q$1.slice(B$3, D$1)
    I$3.unshift({ content: C$5, metadata: g$4 }), D$1 = B$3
  }
  let w$1 = []
  if (g$3?.preserveWhitespace) w$1 = I$3
  else {for (let A$3 = 0; A$3 < I$3.length; A$3++) {
      let B$3 = I$3[A$3]
      if (B$3.content.trim() !== ``) {
        let A$4 = w$1[w$1.length - 1]
        A$4 && (A$4.metadata & iB) == (B$3.metadata & iB) ? A$4.content += B$3.content : w$1.push(B$3)
      } else {w$1.length > 0
          ? w$1[w$1.length - 1].content += B$3.content
          : A$3 < I$3.length - 1
          ? I$3[A$3 + 1].content = B$3.content + I$3[A$3 + 1].content
          : w$1.push(B$3)}
    }}
  return { rawTokens: w$1, nextStack: C$4 }
}
function GB(A$2, B$2, Q$1) {
  let g$3 = null
  return A$2.split(/\r?\n|\r/g).map(A$3 => {
    let { rawTokens: E$2, nextStack: C$4 } = FB(B$2, g$3, A$3, { preserveWhitespace: !0 }),
      I$3 = E$2.map(({ content: A$4, metadata: B$3 }) => ({ content: A$4, style: aB(B$3, Q$1) })),
      D$1 = function(A$4, B$3, Q$2, g$4) {
        let { tokens: E$3 } = Q$2.tokenizeLine(A$4, B$3), C$5 = []
        for (let B$4 = 0; B$4 < E$3.length; B$4++) {
          let { startIndex: Q$3, endIndex: I$4, scopes: D$2 } = E$3[B$4],
            w$1 = 0,
            o$18 = g$4.find(A$5 => {
              if (w$1 += A$5.content.length, Q$3 < w$1) return !0
            })
          C$5.push(Object.assign(Object.assign({}, o$18), { content: A$4.slice(Q$3, I$4), scopes: D$2.reverse() }))
        }
        return C$5
      }(A$3, g$3, B$2, I$3)
    return g$3 = C$4, D$1
  })
}
function aB(A$2, B$2) {
  let Q$1 = { color: B$2[(A$2 & cB) >>> MB] }, g$3 = (A$2 & eB) >>> tB
  return g$3 & hB.Italic && (Q$1.fontStyle = `italic`),
    g$3 & hB.Bold && (Q$1.fontWeight = `bold`),
    g$3 & hB.Underline && (Q$1.textDecoration = `underline`),
    g$3 & hB.Strikethrough && (Q$1.textDecoration = `line-through`),
    Q$1
}
var nB = function(A$2) {
  var B$2 = null
  if (typeof process < `u` && process.versions != null && process.versions.node != null) {
    B$2 = Buffer.from(A$2, `base64`)
  } else {
    var Q$1 = globalThis.atob(A$2), g$3 = Q$1.length
    B$2 = new Uint8Array(new ArrayBuffer(g$3))
    for (var E$2 = 0; E$2 < g$3; E$2++) B$2[E$2] = Q$1.charCodeAt(E$2)
  }
  return B$2
}(`AGFzbQEAAAABoQEWYAJ/fwF/YAF/AX9gA39/fwF/YAR/f39/AX9gAX8AYAV/f39/fwF/YAN/f38AYAJ/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAAF/YAl/f39/f39/f38Bf2AIf39/f39/f38Bf2AAAGAEf39/fwBgA39+fwF+YAZ/fH9/f38Bf2AAAXxgBn9/f39/fwBgAnx/AXxgAn5/AX9gBX9/f39/AAJ1BANlbnYVZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAYDZW52EmVtc2NyaXB0ZW5fZ2V0X25vdwARFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfd3JpdGUAAwNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAABA9MB0QENBAABAAECAgsCAAIEBAACAQEAAQMCAwkCBgUDBQgCAwwMAwkJAwgDAQIFAwMEAQUHCwgCAgsABQUBAgQCBgIAAQACBAIABwMHBgcAAwACAAICAAQBAgcAAgUCAAEBBgYABgQACAUICQsJDAAAAAAAAAACAgIDAAIDAgADAQABAAACBQICAAESAQEEAgIGAgUDAQUAAgEBAAoBAAEAAwMCAAACBgIOAgEPAQEBChMCBQkGAQ4UFRAHAwIBAAEECggCAQgIBwcNAQQABwABCgQBBQQFAXABMzMFBwEBgAKAgAIGDgJ/AUHQj9MCC38BQQALB5QCDwZtZW1vcnkCABFfX3dhc21fY2FsbF9jdG9ycwAEGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBABBfX2Vycm5vX2xvY2F0aW9uALABB29tYWxsb2MAwAEFb2ZyZWUAwQEQZ2V0TGFzdE9uaWdFcnJvcgDCARFjcmVhdGVPbmlnU2Nhbm5lcgDEAQ9mcmVlT25pZ1NjYW5uZXIAxQEYZmluZE5leHRPbmlnU2Nhbm5lck1hdGNoAMYBG2ZpbmROZXh0T25pZ1NjYW5uZXJNYXRjaERiZwDHAQlzdGFja1NhdmUA0QEMc3RhY2tSZXN0b3JlANIBCnN0YWNrQWxsb2MA0wEMZHluQ2FsbF9qaWppANQBCVIBAEEBCzIFCgsPHC9vcHRxcnN1ugG7Ab0BBgcICYABfoEBggGDAX97fIUBmwF9hAFvnAFvnQGeAZ8BoAGhAZIBogGYAZcBowGkAaUBqwGqAawB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ACADNgIEIA0oAgBBATYCCEEADwsgACgCDCABEE8iA0EASARAIAMPCyACIAIoAowBIgVBAWo2AowBIAFBOxBRIgQNCyABKAIIIANBBWo2AgQgAUHNABBRIgQNCyABKAIIIAU2AgQgASgCCEEANgIIIAAoAgwgASACEEIiBA0LIAFBPhBRIgAhBCAADQsgASgCCCAFNgIEIAFBPRBRIgAhBCAADQsgAUE5EFEPCyMAQRBrIgkkAAJAIAAoAhQgACgCGEYEQCACIAIoAowBIgdBAWo2AowBAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiBkEATARAQXUhAwwDC0F7IQMgASgCACAEQShsEM0BIgVFDQIgASAFNgIAIAEoAgQgBEEDdBDNASIERQ0CIAEgBjYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akHNADYCACABKAIIIAc2AgQgASgCCEEANgIIAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiBkEATARAQXUhAwwDC0F7IQMgASgCACAEQShsEM0BIgVFDQIgASAFNgIAIAEoAgQgBEEDdBDNASIERQ0CIAEgBjYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akHKADYCACABKAIIIAAoAhQ2AgQgASgCCEEANgIIIAEoAghBATYCDCAAKAIMIAEgAhBCIgMNAQJAIAEoAgwiACABKAIQIgJJDQAgAkUNACACQQF0IgBBAEwEQEF1IQMMAwtBeyEDIAEoAgAgAkEobBDNASIERQ0CIAEgBDYCACABKAIEIAJBA3QQzQEiAkUNAiABIAA2AhAgASACNgIEIAEoAgwhAAsgASAAQQFqNgIMIAEgASgCACAAQRRsaiIANgIIQQAhAyAAQQA2AhAgAEIANwIIIABCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQcwANgIAIAEoAgggBzYCBCABKAIIQQA2AggMAQsgACgCICIDBEAgAyABIAkgAkEAEF0iA0EASA0BAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiB0EATARAQXUhAwwDC0F7IQMgASgCACAEQShsEM0BIgZFDQIgASAGNgIAIAEoAgQgBEEDdBDNASIERQ0CIAEgBzYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akHJADYCACABKAIIQQAgCSgCAGs2AgQgACgCICABIAIQQiIDDQELIAIgAigCjAEiB0EBajYCjAECQCABKAIMIgMgASgCECIESQ0AIARFDQAgBEEBdCIGQQBMBEBBdSEDDAILQXshAyABKAIAIARBKGwQzQEiBUUNASABIAU2AgAgASgCBCAEQQN0EM0BIgRFDQEgASAGNgIQIAEgBDYCBCABKAIMIQMLIAEgA0EBajYCDCABIAEoAgAgA0EUbGoiAzYCCCADQQA2AhAgA0IANwIIIANCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQc4ANgIAIAEoAghBAjYCBCABKAIIIAc2AggCQCABKAIMIgMgASgCECIESQ0AIARFDQAgBEEBdCIGQQBMBEBBdSEDDAILQXshAyABKAIAIARBKGwQzQEiBUUNASABIAU2AgAgASgCBCAEQQN0EM0BIgRFDQEgASAGNgIQIAEgBDYCBCABKAIMIQMLIAEgA0EBajYCDCABIAEoAgAgA0EUbGoiAzYCCCADQQA2AhAgA0IANwIIIANCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQc8ANgIAIAEoAghBBDYCBCACIAIoAowBIgZBAWo2AowBAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiBUEATARAQXUhAwwCC0F7IQMgASgCACAEQShsEM0BIghFDQEgASAINgIAIAEoAgQgBEEDdBDNASIERQ0BIAEgBTYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akHNADYCACABKAIIIAY2AgQgASgCCEEANgIIAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiBUEATARAQXUhAwwCC0F7IQMgASgCACAEQShsEM0BIghFDQEgASAINgIAIAEoAgQgBEEDdBDNASIERQ0BIAEgBTYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akE7NgIAIAEoAghBAjYCBAJAIAEoAgwiAyABKAIQIgRJDQAgBEUNACAEQQF0IgVBAEwEQEF1IQMMAgtBeyEDIAEoAgAgBEEobBDNASIIRQ0BIAEgCDYCACABKAIEIARBA3QQzQEiBEUNASABIAU2AhAgASAENgIEIAEoAgwhAwsgASADQQFqNgIMIAEgASgCACADQRRsaiIDNgIIIANBADYCECADQgA3AgggA0IANwIAIAEoAgQgASgCCCABKAIAa0EUbUECdGpBOjYCACABKAIIQQM2AgQCQCABKAIMIgMgASgCECIESQ0AIARFDQAgBEEBdCIFQQBMBEBBdSEDDAILQXshAyABKAIAIARBKGwQzQEiCEUNASABIAg2AgAgASgCBCAEQQN0EM0BIgRFDQEgASAFNgIQIAEgBDYCBCABKAIMIQMLIAEgA0EBajYCDCABIAEoAgAgA0EUbGoiAzYCCCADQQA2AhAgA0IANwIIIANCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQc8ANgIAIAEoAghBAjYCBCABKAIIIAc2AgggASgCCEEANgIMAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiBUEATARAQXUhAwwCC0F7IQMgASgCACAEQShsEM0BIghFDQEgASAINgIAIAEoAgQgBEEDdBDNASIERQ0BIAEgBTYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akE5NgIAIAFBygAQUSIDDQAgACgCGCEDIAEoAgggACgCFCIENgIEIAEoAghBfyADIARrIANBf0YbNgIIIAEoAghBAjYCDCABQcsAEFEiAw0AIAAoAgwgASACEEIiAw0AIAFBKBBRIgMNACABKAIIQQE2AgQgAUHMABBRIgMNACABKAIIIAY2AgQgASgCCEEANgIIIAFBzwAQUSIDDQAgASgCCEECNgIEIAEoAgggBzYCCCABKAIIQQE2AgxBACEDCyAJQRBqJAAgAw8LIwBBEGsiCiQAIAAoAgwgARBPIQggACgCGCEGIAAoAhQhBSACIAIoAowBIgdBAWo2AowBIAEoAhAhBCABKAIMIQMCQCAFIAZGBEACQCADIARJDQAgBEUNACAEQQF0IgZBAEwEQEF1IQMMAwtBeyEDIAEoAgAgBEEobBDNASIFRQ0CIAEgBTYCACABKAIEIARBA3QQzQEiBEUNAiABIAY2AhAgASAENgIEIAEoAgwhAwsgASADQQFqNgIMIAEgASgCACADQRRsaiIDNgIIIANBADYCECADQgA3AgggA0IANwIAIAEoAgQgASgCCCABKAIAa0EUbUECdGpBzQA2AgAgASgCCCAHNgIEIAEoAghBADYCCAJAIAEoAgwiAyABKAIQIgRJDQAgBEUNACAEQQF0IgZBAEwEQEF1IQMMAwtBeyEDIAEoAgAgBEEobBDNASIFRQ0CIAEgBTYCACABKAIEIARBA3QQzQEiBEUNAiABIAY2AhAgASAENgIEIAEoAgwhAwsgASADQQFqNgIMIAEgASgCACADQRRsaiIDNgIIIANBADYCECADQgA3AgggA0IANwIAIAEoAgQgASgCCCABKAIAa0EUbUECdGpBOzYCACABKAIIIAhBBGo2AgQCQCABKAIMIgMgASgCECIESQ0AIARFDQAgBEEBdCIGQQBMBEBBdSEDDAMLQXshAyABKAIAIARBKGwQzQEiBUUNAiABIAU2AgAgASgCBCAEQQN0EM0BIgRFDQIgASAGNgIQIAEgBDYCBCABKAIMIQMLIAEgA0EBajYCDCABIAEoAgAgA0EUbGoiAzYCCCADQQA2AhAgA0IANwIIIANCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQcoANgIAIAEoAgggACgCFDYCBCABKAIIQQA2AgggASgCCEEBNgIMIAAoAgwgASACEEIiAw0BAkAgASgCDCIAIAEoAhAiAkkNACACRQ0AIAJBAXQiAEEATARAQXUhAwwDC0F7IQMgASgCACACQShsEM0BIgRFDQIgASAENgIAIAEoAgQgAkEDdBDNASICRQ0CIAEgADYCECABIAI2AgQgASgCDCEACyABIABBAWo2AgwgASABKAIAIABBFGxqIgA2AgggAEEANgIQIABCADcCCCAAQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akE+NgIAIAEoAgggBzYCBAJAIAEoAgwiACABKAIQIgJJDQAgAkUNACACQQF0IgBBAEwEQEF1IQMMAwtBeyEDIAEoAgAgAkEobBDNASIERQ0CIAEgBDYCACABKAIEIAJBA3QQzQEiAkUNAiABIAA2AhAgASACNgIEIAEoAgwhAAsgASAAQQFqNgIMIAEgASgCACAAQRRsaiIANgIIIABBADYCECAAQgA3AgggAEIANwIAIAEoAgQgASgCCCABKAIAa0EUbUECdGpBOTYCAAJAIAEoAgwiACABKAIQIgJJDQAgAkUNACACQQF0IgBBAEwEQEF1IQMMAwtBeyEDIAEoAgAgAkEobBDNASIERQ0CIAEgBDYCACABKAIEIAJBA3QQzQEiAkUNAiABIAA2AhAgASACNgIEIAEoAgwhAAsgASAAQQFqNgIMIAEgASgCACAAQRRsaiIANgIIQQAhAyAAQQA2AhAgAEIANwIIIABCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQT02AgAMAQsCQCADIARJDQAgBEUNACAEQQF0IgZBAEwEQEF1IQMMAgtBeyEDIAEoAgAgBEEobBDNASIFRQ0BIAEgBTYCACABKAIEIARBA3QQzQEiBEUNASABIAY2AhAgASAENgIEIAEoAgwhAwsgASADQQFqNgIMIAEgASgCACADQRRsaiIDNgIIIANBADYCECADQgA3AgggA0IANwIAIAEoAgQgASgCCCABKAIAa0EUbUECdGpBzgA2AgAgASgCCEECNgIEIAEoAgggBzYCCAJAIAEoAgwiAyABKAIQIgRJDQAgBEUNACAEQQF0IgZBAEwEQEF1IQMMAgtBeyEDIAEoAgAgBEEobBDNASIFRQ0BIAEgBTYCACABKAIEIARBA3QQzQEiBEUNASABIAY2AhAgASAENgIEIAEoAgwhAwsgASADQQFqNgIMIAEgASgCACADQRRsaiIDNgIIIANBADYCECADQgA3AgggA0IANwIAIAEoAgQgASgCCCABKAIAa0EUbUECdGpBzwA2AgAgASgCCEEENgIEIAIgAigCjAEiBkEBajYCjAECQCABKAIMIgMgASgCECIESQ0AIARFDQAgBEEBdCIFQQBMBEBBdSEDDAILQXshAyABKAIAIARBKGwQzQEiCUUNASABIAk2AgAgASgCBCAEQQN0EM0BIgRFDQEgASAFNgIQIAEgBDYCBCABKAIMIQMLIAEgA0EBajYCDCABIAEoAgAgA0EUbGoiAzYCCCADQQA2AhAgA0IANwIIIANCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQc0ANgIAIAEoAgggBjYCBCABKAIIQQA2AggCQCABKAIMIgMgASgCECIESQ0AIARFDQAgBEEBdCIFQQBMBEBBdSEDDAILQXshAyABKAIAIARBKGwQzQEiCUUNASABIAk2AgAgASgCBCAEQQN0EM0BIgRFDQEgASAFNgIQIAEgBDYCBCABKAIMIQMLIAEgA0EBajYCDCABIAEoAgAgA0EUbGoiAzYCCCADQQA2AhAgA0IANwIIIANCADcCACABKAIEIAEoAgggASgCAGtBFG1BAnRqQTs2AgAgASgCCCAIQQhqNgIEIAAoAiAiAwRAIAMgARBPIQMgASgCCCIEIAMgBCgCBGpBAWo2AgQgACgCICABIAogAkEAEF0iA0EASA0BAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiBUEATARAQXUhAwwDC0F7IQMgASgCACAEQShsEM0BIghFDQIgASAINgIAIAEoAgQgBEEDdBDNASIERQ0CIAEgBTYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akHJADYCACABKAIIQQAgCigCAGs2AgQgACgCICABIAIQQiIDDQELAkAgASgCDCIDIAEoAhAiBEkNACAERQ0AIARBAXQiBUEATARAQXUhAwwCC0F7IQMgASgCACAEQShsEM0BIghFDQEgASAINgIAIAEoAgQgBEEDdBDNASIERQ0BIAEgBTYCECABIAQ2AgQgASgCDCEDCyABIANBAWo2AgwgASABKAIAIANBFGxqIgM2AgggA0EANgIQIANCADcCCCADQgA3AgAgASgCBCABKAIIIAEoAgBrQRRtQQJ0akHKADYCACAAKAIYIQMgASgCCCAA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AgANACAAKAIwDQAgACgCDCECIAAgAEEYaiIENgIMIAAgBCAAKAIQIAJrajYCEAsgBSgCAA0BIAUoAjANASAFKAIMIQAgBSAFQRhqIgI2AgwgBSACIAUoAhAgAGtqNgIQIAMQEAwGCyAGQcACaiIFIABBMGoiAikCADcDACAGQbgCaiIEIABBKGoiASkCADcDACAGQbACaiIJIABBIGoiCykCADcDACAGQagCaiIHIABBGGoiCikCADcDACAGQaACaiIOIABBEGoiDSkCADcDACAGQZgCaiIQIABBCGoiDCkCADcDACAGIAApAgA3A5ACIAIgA0EwaiIVKQIANwIAIAEgA0EoaiICKQIANwIAIAsgA0EgaiIBKQIANwIAIAogA0EYaiILKQIANwIAIA0gA0EQaiIKKQIANwIAIAwgA0EIaiINKQIANwIAIAAgAykCADcCACAVIAUpAwA3AgAgAiAEKQMANwIAIAEgCSkDADcCACALIAcpAwA3AgAgCiAOKQMANwIAIA0gECkDADcCACADIAYpA5ACNwIAAkAgACgCAA0AIAAoAjANACAAKAIMIQUgACAAQRhqIgI2AgwgACACIAAoAhAgBWtqNgIQCyADKAIADQAgAygCMA0AIAMoAgwhBSADIANBGGoiADYCDCADIAAgAygCECAFa2o2AhALIAMQEAwECyAGQcACaiIFIABBMGoiAikCADcDACAGQbgCaiIEIABBKGoiAykCADcDACAGQbACaiIBIABBIGoiCSkCADcDACAGQagCaiILIABBGGoiBykCADcDACAGQaACaiIKIABBEGoiDikCADcDACAGQZgCaiINIABBCGoiECkCADcDACAGIAApAgA3A5ACIAIgCEEwaiIMKQIANwIAIAMgCEEoaiICKQIANwIAIAkgCEEgaiIDKQIANwIAIAcgCEEYaiIJKQIANwIAIA4gCEEQaiIHKQIANwIAIBAgCEEIaiIOKQIANwIAIAAgCCkCADcCACAMIAUpAwA3AgAgAiAEKQMANwIAIAMgASkDADcCACAJIAspAwA3AgAgByAKKQMANwIAIA4gDSkDADcCACAIIAYpA5ACNwIAAkAgACgCAA0AIAAoAjANACAAKAIMIQUgACAAQRhqIgI2AgwgACACIAAoAhAgBWtqNgIQCwJAIAgoAgANACAIKAIwDQAgCCgC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QQFrQQZ0aiIBKAIAIAUoAhhHBEAgAUIANwIAIAFCADcCOCABQgA3AjAgAUIANwIoIAFCADcCICABQgA3AhggAUIANwIQIAFCADcCCCABIAUoAhg2AgALIAEoAghBACABKAIEGyECCyAAKAIIIgFBAEwNACAAKAIoKAIoIgUoAhwiBiABQQFrIghBBnRqIgEoAgAgBSgCGEcEQCABQgA3AgAgAUIANwI4IAFCADcCMCABQgA3AiggAUIANwIgIAFCADcCGCABQgA3AhAgAUIANwIIIAEgBSgCGDYCAAsCQCABKAIERQRAIAAoAgwgACgCCBAOIgFFDQIgASgCBEEBRw0CIAEoAkQiAyABKAJIIgUgBygCRCgCFBEAACEIQQAhBiAFIAMgBygCRCgCABEBACADaiIBSwRAIAEgBSAHKAJEKAIUEQAAIQZBmH4hAyABIAcoAkQoAgARAQAgAWogBUcNAwtBmH4hAwJ/AkACQAJAAkAgCEEhaw4eAQcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHAgADBwtBACAGQT1GDQMaDAYLQQEgBkE9Rg0CGgwFC0EEIAZBPUYNARogBg0EQQIMAQtBBSAGQT1GDQAaIAYNA0EDCyEBQWIhAyAAKAIIIgdBAEwNAiAAKAIoKAIoIgMoAhwgB0EGdGpBQGoiAEEBNgIEIAAgBTYCDCAAIAE2AgggACADKAIYNgIADAELIAYgCEEGdGooAgghAQtBACEAAkACQAJAAkACQAJAAkAgAQ4GAAECAwQFBgsgAiAERiEADAULIAIgBEchAAwECyACIARKIQAMAwsgAiAESCEADAILIAIgBE4hAAwBCyACIARMIQALIABBAXMhAwsgAws/AQF/AkAgACgCDCIAIAIgAWsiA2oQywEiAkUNACACIAEgAxCmASEBIABBAEwNACABIANqQQAgABCoARoLIAILJgAgAiABIAIgACgCOBEAACIBSwR/IAEgACgCABEBACABagUgAQsLHgEBfyABIAJJBH8gASACQQFrIAAoAjgRAAAFIAMLCzsAAkAgAkUNAANAIANBAEwEQCACDwsgASACTw0BIANBAWshAyABIAJBAWsgACgCOBEAACICDQALC0EAC2gBBH8gASECA0ACQCACLQAADQAgACgCDCIDQQFHBEAgAiEEIANBAkgNAQNAIAQtAAENAiAEQQFqIQQgA0ECSiEFIANBAWshAyAFDQALCyACIAFrDwsgAiAAKAIAEQEAIAJqIQIMAAsAC3UBBH8jAEEQayIAJAACQANAIAAgBEEDdEHQJWoiAygCBCIFNgIMIAMoAgAiBiAAQQxqQQEgAiABEQMAIgMNASAAIAY2AgwgBSAAQQxqQQEgAiABEQMAIgMNASAEQQFqIgRBGkcNAAtBACEDCyAAQRBqJAAgAwtOAEEgIQACfyABLQAAIgJBwQBrQf8BcUEaTwRAQWAhAEEAIAJB4QBrQf8BcUEZSw0BGgsgA0KBgICAEDcCACADIAAgAS0AAGo2AghBAQsLBABBfgscAAJ/IAAgAUkEQEEBIAAtAABBCkYNARoLQQALCyUAIAMgASgCAC0AAEHQH2otAAA6AAAgASABKAIAQQFqNgIAQQELBABBAQsHACAALQAACw4AQQFB8HwgAEGAAkkbCwsAIAEgADoAAEEBCwQAIAELzgEBBn8gASACSQRAIAEhAwNAIAVBAWohBSADIAAoAgARAQAgA2oiAyACSQ0ACwtBAEHAmhFqIQMgBEHHCWohBANAAkAgBSADIgYuAQgiB0cNACAFIQggASEDAkAgB0EATA0AA0AgAiADSwRAIAMgAiAAKAIUEQAAIAQtAABHDQMgBEEBaiEEIAMgACgCABEBACADaiEDIAhBAUshByAIQQFrIQggBw0BDAILCyAELQAADQELIAYoAgQPCyAGQQxqIQMgBigCDCIEDQALQaF+C2gBAX8CQCAEQQBKBEADQCABIAJPBEAgAy0AAA8LIAEgAiAAKAIUEQAAIQUgAy0AACAFayIFDQIgA0EBaiEDIAEgACgCABEBACABaiEBIARBAUshBSAEQQFrIQQgBQ0ACwtBACEFCyAFCy4BAX8gASACIAAoAhQRAAAiAEH/AE0EfyAAQQF0QdAhai8BAEEMdkEBcQUgAwsLPgEDfwJAIAJBAEwNAANAIAAgA0ECdCIFaigCACABIAVqKAIARgRAIAIgA0EBaiIDRw0BDAILC0F/IQQLIAQLJwEBfyAAIAFBA20iAkECdGooAgBBECABIAJBA2xrQQN0a3ZB/wFxC7YIAQF/Qc0JIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9ANqDvQDTU5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTkxOTktKMzZOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTklIR0ZFRENCQUA/Pj08Ozo5ODc1NE4yMTAvLi0sKyopKE5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk4nJiUkIyIhIB8eHRwbGhkYThcWFRQTEhFOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk4QTk5OTk5ODw4NTgcGBQQDDAsKCU5OTk4IAk4BAE9OC0GzDA8LQbMNDwtBjQ4PC0GEDw8LQfAPDwtByRAPC0G+EQ8LQf8RDwtBwBIPC0HnEg8LQZYTDwtBuhMPC0HkEw8LQf4TDwtBvBQPC0GEFQ8LQZcVDwtBrhUPC0HNFQ8LQewVDwtBnhYPC0HyFg8LQYoXDwtBoBcPC0G5Fw8LQdUXDwtB9BcPC0GYGA8LQbsYDwtB7BgPC0GgJw8LQcUnDwtB3CcPC0H4Jw8LQZ8oDwtBtCgPC0HLKA8LQeAoDwtB+ygPC0GaKQ8LQb0pDwtBzCkPC0HsKQ8LQZgqDwtBsioPC0HlKg8LQZIrDwtBsisPC0HJKw8LQeUrDwtBliwPC0GoLA8LQcAsDwtB2SwPC0HsLA8LQYUtDwtBmS0P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AUYNAQsLIAILoQEBBH9BASEEAkAgACABTw0AA0BBACEEIAAtAAAiAkHAAXFBgAFGDQEgAEEBaiEDAkAgAkHAAWtBNEsEQCADIQAMAQsgAEECIAJBAnRBkIoRaigCACICIAJBAkwbIgVqIQBBASECA0AgASADRg0DIAMtAABBwAFxQYABRw0DIANBAWohAyACQQFqIgIgBUcNAAsLIAAgAUkNAAtBASEECyAEC4AEAQN/IAJBgARPBEAgACABIAIQACAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAvoAgECfwJAIAAgAUYNACABIAAgAmoiA2tBACACQQF0a00EQCAAIAEgAhCmARoPCyAAIAFzQQNxIQQCQAJAIAAgAUkEQCAEBEAgACEDDAMLIABBA3FFBEAgACEDDAILIAAhAwNAIAJFDQQgAyABLQAAOgAAIAFBAWohASACQQFrIQIgA0EBaiIDQQNxDQALDAELAkAgBA0AIANBA3EEQANAIAJFDQUgACACQQFrIgJqIgMgASACai0AADoAACADQQNxDQALCyACQQNNDQADQCAAIAJBBGsi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AmogASACQf////8Hc0obIQELIAAgA0EBajYCACABIQIgAywAARCvAQ0ACyABC7YEAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgABAgUDBAYHCAkKCwwNDg8QERILIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASsDADkDAA8LIAAgAiADEQcACwuDAQIDfwF+AkAgAEKAgICAEFQEQCAAIQUMAQsDQCABQQFrIgEgACAAQgqAIgVCCn59p0EwcjoAACAAQv////+fAVYhAiAFIQAgAg0ACwsgBaciAgRAA0AgAUEBayIBIAIgAkEKbiIDQQpsa0EwcjoAACACQQlLIQQgAyECIAQNAAsLIAELcgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiAhsQqAEaIAJFBEADQCAAIAVBgAIQtQEgA0GAAmsiA0H/AUsNAAsLIAAgBSADELUBCyAFQYACaiQAC8kYAxJ/AXwCfiMAQbAEayIKJAAgCkEANgIsAkAgAb0iGUIAUwRA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IQsgBUEgcSEIIAooAiwhByAGQQJrIg0gBUEPajoAACAGQQFrQS1BKyAHQQBIGzoAACAEQQhxIQkgCkEQaiEHA0AgByIGAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIgdB4JURai0AACAIcjoAACABIAe3oUQAAAAAAAAwQKIhAQJAIAZBAWoiByAKQRBqa0EBRw0AAkAgCQ0AIANBAEoNACABRAAAAAAAAAAAYQ0BCyAGQS46AAEgBkECaiEHCyABRAAAAAAAAAAAYg0AC0F/IQlB/f///wcgCyASIA1rIhBqIgZrIANIDQAgAEEgIAICfwJAIANFDQAgByAKQRBqayIIQQJrIANODQAgA0ECagwBCyAHIApBEGprIggLIgcgBmoiBiAEELkBIAAgDiALELUBIABBMCACIAYgBEGAgARzELkBIAAgCkEQaiAIELUBIABBMCAHIAhrQQBBABC5ASAAIA0gEBC1ASAAQSAgAiAGIARBgMAAcxC5ASAGIAIgAiAGSBshCQsgCkGwBGokACAJC40FAgZ+An8gASABKAIAQQdqQXhxIgFBEGo2AgAgACABKQMAIQQgASkDCCEFIwBBIGsiACQAAkAgBUL///////////8AgyIDQoCAgICAgMCAPH0gA0KAgICAgIDA/8MAfVQEQCAFQgSGIARCPIiEIQMgBEL//////////w+DIgRCgYCAgICAgIAIWgRAIANCgYCAgICAgIDAAHwhAgwCCyADQoCAgICAgICAQH0hAiAEQoCAgICAgICACFINASACIANCAYN8IQIMAQsgBFAgA0KAgICAgIDA//8AVCADQoCAgICAgMD//wBRG0UEQCAFQgSGIARCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiADQv///////7//wwBWDQBCACECIANCMIinIgFBkfcASQ0AIABBEGohCSAEIQIgBUL///////8/g0KAgICAgIDAAIQiAyEGAkAgAUGB9wBrIghBwABxBEAgAiAIQUBqrYYhBkIAIQIMAQsgCEUNACAGIAitIgeGIAJBwAAgCGutiIQhBiACIAeGIQILIAkgAjcDACAJIAY3AwgCQEGB+AAgAWsiAUHAAHEEQCADIAFBQGqtiCEEQgAhAwwBCyABRQ0AIANBwAAgAWuthiAEIAGtIgKIhCEEIAMgAoghAwsgACAENwMAIAAgAzcDCCAAKQMIQgSGIAApAwAiA0I8iIQhAiAAKQMQIAApAxiEQgBSrSADQv//////////D4OEIgNCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyADQoCAgICAgICACFINACACQgGDIAJ8IQILIABBIGokACACIAVCgICAgICAgICAf4OEvzkDAAugAQECfyMAQaABayIEJABBfyEFIAQgAUEBa0EAIAEbNgKUASAEIAAgBEGeAWogARsiADYCkAEgBEEAQZABEKgBIgRBfzYCTCAEQRA2AiQgBEF/NgJQIAQgBEGfAWo2AiwgBCAEQZABajYCVAJAIAFBAEgEQEHoyhJBPTYCAAwBCyAAQQA6AAAgBCACIANBDkEPELMBIQULIARBoAFqJAAgBQurAQEEfyAAKAJUIgMoAgQiBSAAKAIUIAAoAhwiBmsiBCAEIAVLGyIEBEAgAygCACAGIAQQpgEaIAMgAygCACAEajYCACADIAMoAgQgBGsiBTYCBAsgAygCACEEIAUgAiACIAVLGyIFBEAgBCABIAUQpgEaIAMgAygCACAFaiIENgIAIAMgAygCBCAFazYCBAsgBEEAOgAAIAAgACgCLCIDNgIcIAAgAzYCFCACCxYAIABFBEBBAA8LQejKEiAANgIAQX8LogIAIABFBEBBAA8LAn8CQCAABH8gAUH/AE0NAQJAQfzLEigCACgCAEUEQCABQYB/cUGAvwNGDQNB6MoSQRk2AgAMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAgwECyABQYBAcUGAwANHIAFBgLADT3FFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAwwECyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBAwEC0HoyhJBGTYCAAtBfwVBAQsMAQsgACABOgAAQQELCwcAIAAQywELBwAgABDMAQu9BQEJfyMAQRBrIggkACAIQZjMEjYCAEGUzBIoAgAhByMAQYABayIBJAAgASAINgJcAkAgB0GhfkcgB0HcAWpBBk9xRQRAIAEgASgCXCICQQRqNgJcAn9BACACKAIAIgAoAgQiAkUNABogACgCCCEEIAAoAgAiBigCDEECTgRAA0ACQCACIARPDQACfyACIAQgBigCFBEAACIAQYABTwRAAkAgAEGAgARJDQAgA0ERSg0AIAEgAEEYdjYCMCABQeAAaiADaiIFQQVBqzIgAUEwahCpASABIABBEHZB/wFxNgIgIAVBBGpBA0GmMiABQSBqEKkBIAEgAEEIdkH/AXE2AhAgBUEGakEDQaYyIAFBEGoQqQEgASAAQf8BcTYCACAFQQhqQQNBpjIgARCpASADQQpqDAILIANBFUoNAiABIABBCHZB/wFxNgJQIAFB4ABqIANqIgVBBUGrMiABQdAAahCpASABIABB/wFxNgJAIAVBBGpBA0GmMiABQUBrEKkBIANBBmoMAQsgAUHgAGogA2ogADoAACADQQFqCyEDIAIgBigCABEBACACaiECIANBG0gNAQsLIAIgBEkMAQsgAUHgAGogAkEbIAQgAmsiACAAQRtOGyIDEKYBGiAAQRtKCyEFIAcQigEhAkGwzBIhAANAAkACQCACLQAAIgRBJUcEQCAERQ0BDAILIAJBAWohBiACLQABIgRB7gBHBEAgBiECDAILIAAgAUHgAGogAxCmASADaiEAIAUEQCAAQaIyLwAAOwAAIABBpDItAAA6AAIgAEEDaiEACyAGQQFqIQIMAgsgAEEAOgAADAMLIAAgBDoAACAAQQFqIQAgAkEBaiECDAALAAtBlL0SIAcQigEiABB6IQJBsMwSIAAgAhCmASACakEAOgAACyABQYABaiQAIAhBEGokAEGwzBIL4wEBAX8CQAJAAkACfyAALQAQBEBBACEBIABBDGogACgCCCACIAIgA2oiBiACIARqIAYgACgCDCAFEG1BAE4NARpBACEGDAMLAkAgACgCFCABRw0AIAAoAhwgBUcNACAAKAIYIARKDQAgAC0AIEUEQEEADwsgACgCDCIGKAIIKAIAIARODQQLIAAgBTYCHCAAIAQ2AhggACABNgIUQQAhASAAKAIIIAIgAiADaiIGIAIgBGogBiAAKAIMIAUQbUEASA0BIABBDGoLKAIAIQZBASEBDAELQQAhBgsgACABOgAgCyAGC7gzARp/IwBBEGsiGCQAIAJBAnQiChDLASEbIAoQywEhGSACQQBK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JyB3aXRob3V0IGVzY2FwZQBXb3JkAEFscGhhAEVVQy1DTgBGQUlMAChudWxsKQAARgBBAEkATAAAAEYAQQBJAEwAAAAAYWJvcnQAQmxhbmsAIyVkAEFscGhhAFsATUlTTUFUQ0gAAE0ASQBTAE0AQQBUAEMASAAAAE0ASQBTAE0AQQBUAEMASAAAAAAtMFgrMFggMFgtMHgrMHggMHgAZmFpbCB0byBtZW1vcnkgYWxsb2NhdGlvbgBDbnRybABIaXJhZ2FuYQBNQVgALQBPTklHLU1PTklUT1I6ICUtNHMgJXMgYXQ6ICVkIFslZCAtICVkXSBsZW46ICVkCgAATQBBAFgAAABNAEEAWAAAAABEaWdpdABtYXRjaC1zdGFjayBsaW1pdCBvdmVyAEFsbnVtAGluZgBjaGFyYWN0ZXIgY2xhc3MgaGFzICclcycgd2l0aG91dCBlc2NhcGUARVJST1IAPT4AAEUAUgBSAE8AUgAAAEUAUgBSAE8AUgAAAABwYXJzZSBkZXB0aCBsaW1pdCBvdmVyAGFsbnVtAEdyYXBoAEthdGFrYW5hAENPVU5UAElORgA8PQAAQwBPAFUATgBUAAAAQwBPAFUATgBUAAAAAExvd2VyAHJldHJ5LWxpbWl0LWluLW1hdGNoIG92ZXIAbmFuAGFscGhhAFRPVEFMX0NPVU5UAEFTQ0lJAABUAE8AVABBAEwAXwBDAE8AVQBOAFQAAABUAE8AVABBAEwAXwBDAE8AVQBOAFQAAAAAUHJpbnQAWERpZ2l0AHJldHJ5LWxpbWl0LWluLXNlYXJjaCBvdmVyAGJsYW5rAENNUABOQU4AAEMATQBQAAAAQwBNAFAAAAAAUHVuY3QAc3ViZXhwLWNhbGwtbGltaXQtaW4tc2VhcmNoIG92ZXIAY250cmwAQ250cmwALgBkaWdpdABCbGFuawBTcGFjZQB1bmRlZmluZWQgdHlwZSAoYnVnKQBQdW5jdABVcHBlcgBncmFwaABpbnRlcm5hbCBwYXJzZXIgZXJyb3IgKGJ1ZykAUHJpbnQAWERpZ2l0AGxvd2VyAHN0YWNrIGVycm9yIChidWcpAHByaW50AFVwcGVyAEFTQ0lJAHVuZGVmaW5lZCBieXRlY29kZSAoYnVnKQBwdW5jdABTcGFjZQBXb3JkAHVuZXhwZWN0ZWQgYnl0ZWNvZGUgKGJ1ZykAZGVmYXVsdCBtdWx0aWJ5dGUtZW5jb2RpbmcgaXMgbm90IHNldABMb3dlcgBzcGFjZQB1cHBlcgBHcmFwaABjYW4ndCBjb252ZXJ0IHRvIHdpZGUtY2hhciBvbiBzcGVjaWZpZWQgbXVsdGlieXRlLWVuY29kaW5nAHhkaWdpdABEaWdpdABmYWlsIHRvIGluaXRpYWxpemUAaW52YWxpZCBhcmd1bWVudABhc2NpaQBlbmQgcGF0dGVybiBhdCBsZWZ0IGJyYWNlAHdvcmQAZW5kIHBhdHRlcm4gYXQgbGVmdCBicmFja2V0ADpdAGVtcHR5IGNoYXItY2xhc3MAcmVkdW5kYW50IG5lc3RlZCByZXBlYXQgb3BlcmF0b3IAcHJlbWF0dXJlIGVuZCBvZiBjaGFyLWNsYXNzAG5lc3RlZCByZXBlYXQgb3BlcmF0b3IgJXMgYW5kICVzIHdhcyByZXBsYWNlZCB3aXRoICclcycAZW5kIHBhdHRlcm4gYXQgZXNjYXBlAD8AZW5kIHBhdHRlcm4gYXQgbWV0YQAqAGVuZCBwYXR0ZXJuIGF0IGNvbnRyb2wAKwBpbnZhbGlkIG1ldGEtY29kZSBzeW50YXgAPz8AaW52YWxpZCBjb250cm9sLWNvZGUgc3ludGF4ACo/AGNoYXItY2xhc3MgdmFsdWUgYXQgZW5kIG9mIHJhbmdlACs/AGNoYXItY2xhc3MgdmFsdWUgYXQgc3RhcnQgb2YgcmFuZ2UAdW5tYXRjaGVkIHJhbmdlIHNwZWNpZmllciBpbiBjaGFyLWNsYXNzACsgYW5kID8/AHRhcmdldCBvZiByZXBlYXQgb3BlcmF0b3IgaXMgbm90IHNwZWNpZmllZAArPyBhbmQgPwAPAAAADgAAAHQ+AwB8PgMA6AP0AU0B+gDIAKcAjwB9AG8AZABbAFMATQBHAEMAPwA7ADgANQAyADAALQArACoAKAAmACUAJAAiACEAIAAfAB4AHQAdABwAGwAaABoAGQAYABgAFwAXABYAFgAVABUAFAAUABQAEwATABMAEgASABIAEQARABEAEAAQABAAEAAPAA8ADwAPAA4ADgAOAA4ADgAOAA0ADQANAA0ADQANAAwADAAMAAwADAAMAAsACwALAAsACwALAAsACwALAAoACgAKAAoA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b2RlIHJhbmdlcyBhcmUgc3BlY2lmaWVkAHRvbyBzaG9ydCBtdWx0aWJ5dGUgY29kZSBzdHJpbmcAdG9vIGJpZyBiYWNrcmVmIG51bWJlcgBpbnZhbGlkIGJhY2tyZWYgbnVtYmVyL25hbWUAbnVtYmVyZWQgYmFja3JlZi9jYWxsIGlzIG5vdCBhbGxvd2VkLiAodXNlIG5hbWUpAHRvbyBtYW55IGNhcHR1cmVzAHRvbyBiaWcgd2lkZS1jaGFyIHZhbHVlAHRvbyBsb25nIHdpZGUtY2hhciB2YWx1ZQB1bmRlZmluZWQgb3BlcmF0b3IAaW52YWxpZCBjb2RlIHBvaW50IHZhbHVlAGdyb3VwIG5hbWUgaXMgZW1wdHkAaW52YWxpZCBncm91cCBuYW1lIDwlbj4AaW52YWxpZCBjaGFyIGluIGdyb3VwIG5hbWUgPCVuPgB1bmRlZmluZWQgbmFtZSA8JW4+IHJlZmVyZW5jZQB1bmRlZmluZWQgZ3JvdXAgPCVuPiByZWZlcmVuY2UAbXVsdGlwbGV4IGRlZmluZWQgbmFtZSA8JW4+AG11bHRpcGxleCBkZWZpbml0aW9uIG5hbWUgPCVuPiBjYWxsAG5ldmVyIGVuZGluZyByZWN1cnNpb24AZ3JvdXAgbnVtYmVyIGlzIHRvbyBiaWcgZm9yIGNhcHR1cmUgaGlzdG9yeQBpbnZhbGlkIGNoYXJhY3RlciBwcm9wZXJ0eSBuYW1lIHslbn0AaW52YWxpZCBpZi1lbHNlIHN5bnRheABpbnZhbGlkIGFic2VudCBncm91cCBwYXR0ZXJuAGludmFsaWQgYWJzZW50IGdyb3VwIGdlbmVyYXRvciBwYXR0ZXJuAGludmFsaWQgY2FsbG91dCBwYXR0ZXJuAGludmFsaWQgY2FsbG91dCBuYW1lAHVuZGVmaW5lZCBjYWxsb3V0IG5hbWUAaW52YWxpZCBjYWxsb3V0IGJvZHkAaW52YWxpZCBjYWxsb3V0IHRhZyBuYW1lAGludmFsaWQgY2FsbG91dCBhcmcAbm90IHN1cHBvcnRlZCBlbmNvZGluZyBjb21iaW5hdGlvbgBpbnZhbGlkIGNvbWJpbmF0aW9uIG9mIG9wdGlvbnMAdmVyeSBpbmVmZmljaWVudCBwYXR0ZXJuAGxpYnJhcnkgaXMgbm90IGluaXRpYWxpemVkAHVuZGVmaW5lZCBlcnJvciBjb2RlAC4uLgAlMDJ4AFx4JTAyeAAAAAEAQcAyCxUBAAAAAQAAAAEAAAABAAAAAQAAAAEAQeAyC3ALAAAAEwAAACUAAABDAAAAgwAAABsBAAAJAgAACQQAAAUIAAADEAAAGyAAACtAAAADgAAALQABAB0AAgADAAQAFQAIAAcAEAARACAADwBAAAkAgAArAAABIwAAAg8AAAQdAAAIAwAAEAsAACBVAABAAEHgMwvRZAhACEAIQAhACEAIQAhACEAIQIxCiUKIQohCiEIIQAhACEAIQAhACEAIQAhACEAIQAhACEAIQAhACEAIQAhACECEQqBBoEGgQaBBoEGgQaBBoEGgQaBBoEGgQaBBoEGgQbB4sHiweLB4sHiweLB4sHiweLB4oEGgQaBBoEGgQaBBoEGifKJ8onyifKJ8onyidKJ0onSidKJ0onSidKJ0onSidKJ0onSidKJ0onSidKJ0onSidKJ0oEGgQaBBoEGgUaBB4njieOJ44njieOJ44nDicOJw4nDicOJw4nDicOJw4nDicOJw4nDicOJw4nDicOJw4nDicKBBoEGgQaBBCEAIAAgACAAIAAgAiAIIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAhAKgAaAAoACgAKAAoACgAKAAoADiMKABoACoAKAAoACgAKAAoBCgEKAA4jCgAKABoACgEOIwoAGgEKAQoBCgAaI0ojSiNKI0ojSiNKI0ojSiNKI0ojSiNKI0ojSiNKI0ojSiNKI0ojSiNKI0ojSgAKI0ojSiNKI0ojSiNKI04jDiMOIw4jDiMOIw4jDiMOIw4jDiMOIw4jDiMOIw4jDiMOIw4jDiMOIw4jDiMOIwoADiMOIw4jDiMOIw4jDiMOIwCgAAAAoAAAAJAAAACwAAAAwAAAANAAAADQAAAA0AAAACAAAAIAAAACAAAAARAAAAIgAAACIAAAADAAAAJwAAACcAAAAQAAAALAAAACwAAAALAAAALgAAAC4AAAAMAAAAMAAAADkAAAAOAAAAOgAAADoAAAAKAAAAOwAAADsAAAALAAAAQQAAAFoAAAABAAAAXwAAAF8AAAAFAAAAYQAAAHoAAAABAAAAhQAAAIUAAAANAAAAqgAAAKoAAAABAAAArQAAAK0AAAAGAAAAtQAAALUAAAABAAAAtwAAALcAAAAKAAAAugAAALoAAAABAAAAwAAAANYAAAABAAAA2AAAAPYAAAABAAAA+AAAANcCAAABAAAA3gIAAP8CAAABAAAAAAMAAG8DAAAEAAAAcAMAAHQDAAABAAAAdgMAAHcDAAABAAAAegMAAH0DAAABAAAAfgMAAH4DAAALAAAAfwMAAH8DAAABAAAAhgMAAIYDAAABAAAAhwMAAIcDAAAKAAAAiAMAAIoDAAABAAAAjAMAAIwDAAABAAAAjgMAAKEDAAABAAAAowMAAPUDAAABAAAA9wMAAIEEAAABAAAAgwQAAIkEAAAEAAAAigQAAC8FAAABAAAAMQUAAFYFAAABAAAAWQUAAFwFAAABAAAAXgUAAF4FAAABAAAAXwUAAF8FAAAKAAAAYAUAAIgFAAABAAAAiQUAAIkFAAALAAAAigUAAIoFAAABAAAAkQUAAL0FAAAEAAAAvwUAAL8FAAAEAAAAwQUAAMIFAAAEAAAAxAUAAMUFAAAEAAAAxwUAAMcFAAAEAAAA0AUAAOoFAAAHAAAA7wUAAPIFAAAHAAAA8wUAAPMFAAABAAAA9AUAAPQFAAAKAAAAAAYAAAUGAAAGAAAADAYAAA0GAAALAAAAEAYAABoGAAAEAAAAHAYAABwGAAAGAAAAIAYAAEoGAAABAAAASwYAAF8GAAAEAAAAYAYAAGkGAAAOAAAAawYAAGsGAAAOAAAAbAYAAGwGAAALAAAAbgYAAG8GAAABAAAAcAYAAHAGAAAEAAAAcQYAANMGAAABAAAA1QYAANUGAAABAAAA1gYAANwGAAAEAAAA3QYAAN0GAAAGAAAA3wYAAOQGAAAEAAAA5QYAAOYGAAABAAAA5wYAAOgGAAAEAAAA6gYAAO0GAAAEAAAA7gYAAO8GAAABAAAA8AYAAPkGAAAOAAAA+gYAAPwGAAABAAAA/wYAAP8GAAABAAAADwcAAA8HAAAGAAAAEAcAABAHAAABAAAAEQcAABEHAAAEAAAAEgcAAC8HAAABAAAAMAcAAEoHAAAEAAAATQcAAKUHAAABAAAApgcAALAHAAAEAAAAsQcAALEHAAABAAAAwAcAAMkHAAAOAAAAygcAAOoHAAABAAAA6wcAAPMHAAAEAAAA9AcAAPUHAAABAAAA+AcAAPgHAAALAAAA+gcAAPoHAAABAAAA/QcAAP0HAAAEAAAAAAgAABUIAAABAAAAFggAABkIAAAEAAAAGggAABoIAAABAAAAGwgAACMIAAAEAAAAJAgAACQIAAABAAAAJQgAACcIAAAEAAAAKAgAACgIAAABAAAAKQgAAC0IAAAEAAAAQAgAAFgIAAABAAAAWQgAAFsIAAAEAAAAYAgAAGoIAAABAAAAcAgAAIcIAAABAAAAiQgAAI4IAAABAAAAkAgAAJEIAAAGAAAAmAgAAJ8IAAAEAAAAoAgAAMkIAAABAAAAyggAAOEIAAAEAAAA4ggAAOIIAAAGAAAA4wgAAAMJAAAEAAAABAkAADkJAAABAAAAOgkAADwJAAAEAAAAPQkAAD0JAAABAAAAPgkAAE8JAAAEAAAAUAkAAFAJAAABAAAAUQkAAFcJAAAEAAAAWAkAAGEJAAABAAAAYgkAAGMJAAAEAAAAZgkAAG8JAAAOAAAAcQkAAIAJAAABAAAAgQkAAIMJAAAEAAAAhQkAAIwJAAABAAAAjwkAAJAJAAABAAAAkwkAAKgJAAABAAAAqgkAALAJAAABAAAAsgkAALIJAAABAAAAtgkAALkJAAABAAAAvAkAALwJAAAEAAAAvQkAAL0JAAABAAAAvgkAAMQJAAAEAAAAxwkAAMgJAAAEAAAAywkAAM0JAAAEAAAAzgkAAM4JAAABAAAA1wkAANcJAAAEAAAA3AkAAN0JAAABAAAA3wkAAOEJAAABAAAA4gkAAOMJAAAEAAAA5gkAAO8JAAAOAAAA8AkAAPEJAAABAAAA/AkAAPwJAAABAAAA/gkAAP4JAAAEAAAAAQoAAAMKAAAEAAAABQoAAAoKAAABAAAADwoAABAKAAABAAAAEwoAACgKAAABAAAAKgoAADAKAAABAAAAMgoAADMKAAABAAAANQoAADYKAAABAAAAOAoAADkKAAABAAAAPAoAADwKAAAEAAAAPgoAAEIKAAAEAAAARwoAAEgKAAAEAAAASwoAAE0KAAAEAAAAUQoAAFEKAAAEAAAAWQoAAFwKAAABAAAAXgoAAF4KAAABAAAAZgoAAG8KAAAOAAAAcAoAAHEKAAAEAAAAcgoAAHQKAAABAAAAdQoAAHUKAAAEAAAAgQoAAIMKAAAEAAAAhQoAAI0KAAABAAAAjwoAAJEKAAABAAAAkwoAAKgKAAABAAAAqgoAALAKAAABAAAAsgoAALMKAAABAAAAtQoAALkKAAABAAAAvAoAALwKAAAEAAAAvQoAAL0KAAABAAAAvgoAAMUKAAAEAAAAxwoAAMkKAAAEAAAAywoAAM0KAAAEAAAA0AoAANAKAAABAAAA4AoAAOEKAAABAAAA4goAAOMKAAAEAAAA5goAAO8KAAAOAAAA+QoAAPkKAAABAAAA+goAAP8KAAAEAAAAAQsAAAMLAAAEAAAABQsAAAwLAAABAAAADwsAABALAAABAAAAEwsAACgLAAABAAAAKgsAADALAAABAAAAMgsAADMLAAABAAAANQsAADkLAAABAAAAPAsAADwLAAAEAAAAPQsAAD0LAAABAAAAPgsAAEQLAAAEAAAARwsAAEgLAAAEAAAASwsAAE0LAAAEAAAAVQsAAFcLAAAEAAAAXAsAAF0LAAABAAAAXwsAAGELAAABAAAAYgsAAGMLAAAEAAAAZgsAAG8LAAAOAAAAcQsAAHELAAABAAAAggsAAIILAAAEAAAAgwsAAIMLAAABAAAAhQsAAIoLAAABAAAAjgsAAJALAAABAAAAkgsAAJULAAABAAAAmQsAAJoLAAABAAAAnAsAAJwLAAABAAAAngsAAJ8LAAABAAAAowsAAKQLAAABAAAAqAsAAKoLAAABAAAArgsAALkLAAABAAAAvgsAAMILAAAEAAAAxgsAAMgLAAAEAAAAygsAAM0LAAAEAAAA0AsAANALAAABAAAA1wsAANcLAAAEAAAA5gsAAO8LAAAOAAAAAAwAAAQMAAAEAAAABQwAAAwMAAABAAAADgwAABAMAAABAAAAEgwAACgMAAABAAAAKgwAADkMAAABAAAAPAwAADwMAAAEAAAAPQwAAD0MAAABAAAAPgwAAEQMAAAEAAAARgwAAEgMAAAEAAAASgwAAE0MAAAEAAAAVQwAAFYMAAAEAAAAWAwAAFoMAAABAAAAXQwAAF0MAAABAAAAYAwAAGEMAAABAAAAYgwAAGMMAAAEAAAAZgwAAG8MAAAOAAAAgAwAAIAMAAABAAAAgQwAAIMMAAAEAAAAhQwAAIwMAAABAAAAjgwAAJAMAAABAAAAkgwAAKgMAAABAAAAqgwAALMMAAABAAAAtQwAALkMAAABAAAAvAwAALwMAAAEAAAAvQwAAL0MAAABAAAAvgwAAMQMAAAEAAAAxgwAAMgMAAAEAAAAygwAAM0MAAAEAAAA1QwAANYMAAAEAAAA3QwAAN4MAAABAAAA4AwAAOEMAAABAAAA4gwAAOMMAAAEAAAA5gwAAO8MAAAOAAAA8QwAAPIMAAABAAAAAA0AAAMNAAAEAAAABA0AAAwNAAABAAAADg0AABANAAABAAAAEg0AADoNAAABAAAAOw0AADwNAAAEAAAAPQ0AAD0NAAABAAAAPg0AAEQNAAAEAAAARg0AAEgNAAAEAAAASg0AAE0NAAAEAAAATg0AAE4NAAABAAAAVA0AAFYNAAABAAAAVw0AAFcNAAAEAAAAXw0AAGENAAABAAAAYg0AAGMNAAAEAAAAZg0AAG8NAAAOAAAAeg0AAH8NAAABAAAAgQ0AAIMNAAAEAAAAhQ0AAJYNAAABAAAAmg0AALENAAABAAAAsw0AALsNAAABAAAAvQ0AAL0NAAABAAAAwA0AAMYNAAABAAAAyg0AAMoNAAAEAAAAzw0AANQNAAAEAAAA1g0AANYNAAAEAAAA2A0AAN8NAAAEAAAA5g0AAO8NAAAOAAAA8g0AAPMNAAAEAAAAMQ4AADEOAAAEAAAANA4AADoOAAAEAAAARw4AAE4OAAAEAAAAUA4AAFkOAAAOAAAAsQ4AALEOAAAEAAAAtA4AALwOAAAEAAAAyA4AAM0OAAAEAAAA0A4AANkOAAAOAAAAAA8AAAAPAAABAAAAGA8AABkPAAAEAAAAIA8AACkPAAAOAAAANQ8AADUPAAAEAAAANw8AADcPAAAEAAAAOQ8AADkPAAAEAAAAPg8AAD8PAAAEAAAAQA8AAEcPAAABAAAASQ8AAGwPAAABAAAAcQ8AAIQPAAAEAAAAhg8AAIcPAAAEAAAAiA8AAIwPAAABAAAAjQ8AAJcPAAAEAAAAmQ8AALwPAAAEAAAAxg8AAMYPAAAEAAAAKxAAAD4QAAAEAAAAQBAAAEkQAAAOAAAAVhAAAFkQAAAEAAAAXhAAAGAQAAAEAAAAYhAAAGQQAAAEAAAAZxAAAG0QAAAEAAAAcRAAAHQQAAAEAAAAghAAAI0QAAAEAAAAjxAAAI8QAAAEAAAAkBAAAJkQAAAOAAAAmhAAAJ0QAAAEAAAAoBAAAMUQAAABAAAAxxAAAMcQAAABAAAAzRAAAM0QAAABAAAA0BAAAPoQAAABAAAA/BAAAEgSAAABAAAAShIAAE0SAAABAAAAUBIAAFYSAAABAAAAWBIAAFgSAAABAAAAWhIAAF0SAAABAAAAYBIAAIgSAAABAAAAihIAAI0SAAABAAAAkBIAALASAAABAAAAshIAALUSAAABAAAAuBIAAL4SAAABAAAAwBIAAMASAAABAAAAwhIAAMUSAAABAAAAyBIAANYSAAABAAAA2BIAABATAAABAAAAEhMAABUTAAABAAAAGBMAAFoTAAABAAAAXRMAAF8TAAAEAAAAgBMAAI8TAAABAAAAoBMAAPUTAAABAAAA+BMAAP0TAAABAAAAARQAAGwWAAABAAAAbxYAAH8WAAABAAAAgBYAAIAWAAARAAAAgRYAAJoWAAABAAAAoBYAAOoWAAABAAAA7hYAAPgWAAABAAAAABcAABEXAAABAAAAEhcAABUXAAAEAAAAHxcAADEXAAABAAAAMhcAADQXAAAEAAAAQBcAAFEXAAABAAAAUhcAAFMXAAAEAAAAYBcAAGwXAAABAAAAbhcAAHAXAAABAAAAchcAAHMXAAAEAAAAtBcAANMXAAAEAAAA3RcAAN0XAAAEAAAA4BcAAOkXAAAOAAAACxgAAA0YAAAEAAAADhgAAA4YAAAGAAAADxgAAA8YAAAEAAAAEBgAABkYAAAOAAAAIBgAAHgYAAABAAAAgBgAAIQYAAABAAAAhRgAAIYYAAAEAAAAhxgAAKgYAAABAAAAqRgAAKkYAAAEAAAAqhgAAKoYAAABAAAAsBgAAPUYAAABAAAAABkAAB4ZAAABAAAAIBkAACsZAAAEAAAAMBkAADsZAAAEAAAARhkAAE8ZAAAOAAAA0BkAANkZAAAOAAAAABoAABYaAAABAAAAFxoAABsaAAAEAAAAVRoAAF4aAAAEAAAAYBoAAHwaAAAEAAAAfxoAAH8aAAAEAAAAgBoAAIkaAAAOAAAAkBoAAJkaAAAOAAAAsBoAAM4aAAAEAAAAABsAAAQbAAAEAAAABRsAADMbAAABAAAANBsAAEQbAAAEAAAARRsAAEwbAAABAAAAUBsAAFkbAAAOAAAAaxsAAHMbAAAEAAAAgBsAAIIbAAAEAAAAgxsAAKAbAAABAAAAoRsAAK0bAAAEAAAArhsAAK8bAAABAAAAsBsAALkbAAAOAAAAuhsAAOUbAAABAAAA5hsAAPMbAAAEAAAAABwAACMcAAABAAAAJBwAADccAAAEAAAAQBwAAEkcAAAOAAAATRwAAE8cAAABAAAAUBwAAFkcAAAOAAAAWhwAAH0cAAABAAAAgBwAAIgcAAABAAAAkBwAALocAAABAAAAvRwAAL8cAAABAAAA0BwAANIcAAAEAAAA1BwAAOgcAAAEAAAA6RwAAOwcAAABAAAA7RwAAO0cAAAEAAAA7hwAAPMcAAABAAAA9BwAAPQcAAAEAAAA9RwAAPYcAAABAAAA9xwAAPkcAAAEAAAA+hwAAPocAAABAAAAAB0AAL8dAAABAAAAwB0AAP8dAAAEAAAAAB4AABUfAAABAAAAGB8AAB0fAAABAAAAIB8AAEUfAAABAAAASB8AAE0fAAABAAAAUB8AAFcfAAABAAAAWR8AAFkfAAABAAAAWx8AAFsfAAABAAAAXR8AAF0fAAABAAAAXx8AAH0fAAABAAAAgB8AALQfAAABAAAAth8AALwfAAABAAAAvh8AAL4fAAABAAAAwh8AAMQfAAABAAAAxh8AAMwfAAABAAAA0B8AANMfAAABAAAA1h8AANsfAAABAAAA4B8AAOwfAAABAAAA8h8AAPQfAAABAAAA9h8AAPwfAAABAAAAACAAAAYgAAARAAAACCAAAAogAAARAAAADCAAAAwgAAAEAAAADSAAAA0gAAASAAAADiAAAA8gAAAGAAAAGCAAABkgAAAMAAAAJCAAACQgAAAMAAAAJyAAACcgAAAKAAAAKCAAACkgAAANAAAAKiAAAC4gAAAGAAAALyAAAC8gAAAFAAAAPyAAAEAgAAAFAAAARCAAAEQgAAALAAAAVCAAAFQgAAAFAAAAXyAAAF8gAAARAAAAYCAAAGQgAAAGAAAAZiAAAG8gAAAGAAAAcSAAAHEgAAABAAAAfyAAAH8gAAABAAAAkCAAAJwgAAABAAAA0CAAAPAgAAAEAAAAAiEAAAIhAAABAAAAByEAAAchAAABAAAACiEAABMhAAABAAAAFSEAABUhAAABAAAAGSEAAB0hAAABAAAAJCEAACQhAAABAAAAJiEAACYhAAABAAAAKCEAACghAAABAAAAKiEAAC0hAAABAAAALyEAADkhAAABAAAAPCEAAD8hAAABAAAARSEAAEkhAAABAAAATiEAAE4hAAABAAAAYCEAAIghAAABAAAAtiQAAOkkAAABAAAAACwAAOQsAAABAAAA6ywAAO4sAAABAAAA7ywAAPEsAAAEAAAA8iwAAPMsAAABAAAAAC0AACUtAAABAAAAJy0AACctAAABAAAALS0AAC0tAAABAAAAMC0AAGctAAABAAAAby0AAG8tAAABAAAAfy0AAH8tAAAEAAAAgC0AAJYtAAABAAAAoC0AAKYtAAABAAAAqC0AAK4tAAABAAAAsC0AALYtAAABAAAAuC0AAL4tAAABAAAAwC0AAMYtAAABAAAAyC0AAM4tAAABAAAA0C0AANYtAAABAAAA2C0AAN4tAAABAAAA4C0AAP8tAAAEAAAALy4AAC8uAAABAAAAADAAAAAwAAARAAAABTAAAAUwAAABAAAAKjAAAC8wAAAEAAAAMTAAADUwAAAIAAAAOzAAADwwAAABAAAAmTAAAJowAAAEAAAAmzAAAJwwAAAIAAAAoDAAAPowAAAIAAAA/DAAAP8wAAAIAAAABTEAAC8xAAABAAAAMTEAAI4xAAABAAAAoDEAAL8xAAABAAAA8DEAAP8xAAAIAAAA0DIAAP4yAAAIAAAAADMAAFczAAAIAAAAAKAAAIykAAABAAAA0KQAAP2kAAABAAAAAKUAAAymAAABAAAAEKYAAB+mAAABAAAAIKYAACmmAAAOAAAAKqYAACumAAABAAAAQKYAAG6mAAABAAAAb6YAAHKmAAAEAAAAdKYAAH2mAAAEAAAAf6YAAJ2mAAABAAAAnqYAAJ+mAAAEAAAAoKYAAO+mAAABAAAA8KYAAPGmAAAEAAAACKcAAMqnAAABAAAA0KcAANGnAAABAAAA06cAANOnAAABAAAA1acAANmnAAABAAAA8qcAAAGoAAABAAAAAqgAAAKoAAAEAAAAA6gAAAWoAAABAAAABqgAAAaoAAAEAAAAB6gAAAqoAAABAAAAC6gAAAuoAAAEAAAADKgAACKoAAABAAAAI6gAACeoAAAEAAAALKgAACyoAAAEAAAAQKgAAHOoAAABAAAAgKgAAIGoAAAEAAAAgqgAALOoAAABAAAAtKgAAMWoAAAEAAAA0KgAANmoAAAOAAAA4KgAAPGoAAAEAAAA8qgAAPeoAAABAAAA+6gAAPuoAAABAAAA/agAAP6oAAABAAAA/6gAAP+oAAAEAAAAAKkAAAmpAAAOAAAACqkAACWpAAABAAAAJqkAAC2pAAAEAAAAMKkAAEapAAABAAAAR6kAAFOpAAAEAAAAYKkAAHypAAABAAAAgKkAAIOpAAAEAAAAhKkAALKpAAABAAAAs6kAAMCpAAAEAAAAz6kAAM+pAAABAAAA0KkAANmpAAAOAAAA5akAAOWpAAAEAAAA8KkAAPmpAAAOAAAAAKoAACiqAAABAAAAKaoAADaqAAAEAAAAQKoAAEKqAAABAAAAQ6oAAEOqAAAEAAAARKoAAEuqAAABAAAATKoAAE2qAAAEAAAAUKoAAFmqAAAOAAAAe6oAAH2qAAAEAAAAsKoAALCqAAAEAAAAsqoAALSqAAAEAAAAt6oAALiqAAAEAAAAvqoAAL+qAAAEAAAAwaoAAMGqAAAEAAAA4KoAAOqqAAABAAAA66oAAO+qAAAEAAAA8qoAAPSqAAABAAAA9aoAAPaqAAAEAAAAAasAAAarAAABAAAACasAAA6rAAABAAAAEasAABarAAABAAAAIKsAACarAAABAAAAKKsAAC6rAAABAAAAMKsAAGmrAAABAAAAcKsAAOKrAAABAAAA46sAAOqrAAAEAAAA7KsAAO2rAAAEAAAA8KsAAPmrAAAOAAAAAKwAAKPXAAABAAAAsNcAAMbXAAABAAAAy9cAAPvXAAABAAAAAPsAAAb7AAABAAAAE/sAABf7AAABAAAAHfsAAB37AAAHAAAAHvsAAB77AAAEAAAAH/sAACj7AAAHAAAAKvsAADb7AAAHAAAAOPsAADz7AAAHAAAAPvsAAD77AAAHAAAAQPsAAEH7AAAHAAAAQ/sAAET7AAAHAAAARvsAAE/7AAAHAAAAUPsAALH7AAABAAAA0/sAAD39AAABAAAAUP0AAI/9AAABAAAAkv0AAMf9AAABAAAA8P0AAPv9AAABAAAAAP4AAA/+AAAEAAAAEP4AABD+AAALAAAAE/4AABP+AAAKAAAAFP4AABT+AAALAAAAIP4AAC/+AAAEAAAAM/4AADT+AAAFAAAATf4AAE/+AAAFAAAAUP4AAFD+AAALAAAAUv4AAFL+AAAMAAAAVP4AAFT+AAALAAAAVf4AAFX+AAAKAAAAcP4AAHT+AAABAAAAdv4AAPz+AAABAAAA//4AAP/+AAAGAAAAB/8AAAf/AAAMAAAADP8AAAz/AAALAAAADv8AAA7/AAAMAAAAEP8AABn/AAAOAAAAGv8AABr/AAAKAAAAG/8AABv/AAALAAAAIf8AADr/AAABAAAAP/8AAD//AAAFAAAAQf8AAFr/AAABAAAAZv8AAJ3/AAAIAAAAnv8AAJ//AAAEAAAAoP8AAL7/AAABAAAAwv8AAMf/AAABAAAAyv8AAM//AAABAAAA0v8AANf/AAABAAAA2v8AANz/AAABAAAA+f8AAPv/AAAGAAAAAAABAAsAAQABAAAADQABACYAAQABAAAAKAABADoAAQABAAAAPAABAD0AAQABAAAAPwABAE0AAQABAAAAUAABAF0AAQABAAAAgAABAPoAAQABAAAAQAEBAHQBAQABAAAA/QEBAP0BAQAEAAAAgAIBAJwCAQABAAAAoAIBANACAQABAAAA4AIBAOACAQAEAAAAAAMBAB8DAQABAAAALQMBAEoDAQABAAAAUAMBAHUDAQABAAAAdgMBAHoDAQAEAAAAgAMBAJ0DAQABAAAAoAMBAMMDAQABAAAAyAMBAM8DAQABAAAA0QMBANUDAQABAAAAAAQBAJ0EAQABAAAAoAQBAKkEAQAOAAAAsAQBANMEAQABAAAA2AQBAPsEAQABAAAAAAUBACcFAQABAAAAMAUBAGMFAQABAAAAcAUBAHoFAQABAAAAfAUBAIoFAQABAAAAjAUBAJIFAQABAAAAlAUBAJUFAQABAAAAlwUBAKEFAQABAAAAowUBALEFAQABAAAAswUBALkFAQABAAAAuwUBALwFAQABAAAAAAYBADYHAQABAAAAQAcBAFUHAQABAAAAYAcBAGcHAQABAAAAgAcBAIUHAQABAAAAhwcBALAHAQABAAAAsgcBALoHAQABAAAAAAgBAAUIAQABAAAACAgBAAgIAQABAAAACggBADUIAQABAAAANwgBADgIAQABAAAAPAgBADwIAQABAAAAPwgBAFUIAQABAAAAYAgBAHYIAQABAAAAgAgBAJ4IAQABAAAA4AgBAPIIAQABAAAA9AgBAPUIAQABAAAAAAkBABUJAQABAAAAIAkBADkJAQABAAAAgAkBALcJAQABAAAAvgkBAL8JAQABAAAAAAoBAAAKAQABAAAAAQoBAAMKAQAEAAAABQoBAAYKAQAEAAAADAoBAA8KAQAEAAAAEAoBABMKAQABAAAAFQoBABcKAQABAAAAGQoBADUKAQABAAAAOAoBADoKAQAEAAAAPwoBAD8KAQAEAAAAYAoBAHwKAQABAAAAgAoBAJwKAQABAAAAwAoBAMcKAQABAAAAyQoBAOQKAQABAAAA5QoBAOYKAQAEAAAAAAsBADULAQABAAAAQAsBAFULAQABAAAAYAsBAHILAQABAAAAgAsBAJELAQABAAAAAAwBAEgMAQABAAAAgAwBALIMAQABAAAAwAwBAPIMAQABAAAAAA0BACMNAQABAAAAJA0BACcNAQAEAAAAMA0BADkNAQAOAAAAgA4BAKkOAQABAAAAqw4BAKwOAQAEAAAAsA4BALEOAQABAAAAAA8BABwPAQABAAAAJw8BACcPAQABAAAAMA8BAEUPAQABAAAARg8BAFAPAQAEAAAAcA8BAIEPAQABAAAAgg8BAIUPAQAEAAAAsA8BAMQPAQABAAAA4A8BAPYPAQABAAAAABABAAIQAQAEAAAAAxABADcQAQABAAAAOBABAEYQAQAEAAAAZhABAG8QAQAOAAAAcBABAHAQAQAEAAAAcRABAHIQAQABAAAAcxABAHQQAQAEAAAAdRABAHUQAQABAAAAfxABAIIQAQAEAAAAgxABAK8QAQABAAAAsBABALoQAQAEAAAAvRABAL0QAQAGAAAAwhABAMIQAQAEAAAAzRABAM0QAQAGAAAA0BABAOgQAQABAAAA8BABAPkQAQAOAAAAABEBAAIRAQAEAAAAAxEBACYRAQABAAAAJxEBADQRAQAEAAAANhEBAD8RAQAOAAAARBEBAEQRAQABAAAARREBAEYRAQAEAAAARxEBAEcRAQABAAAAUBEBAHIRAQABAAAAcxEBAHMRAQAEAAAAdhEBAHYRAQABAAAAgBEBAIIRAQAEAAAAgxEBALIRAQABAAAAsxEBAMARAQAEAAAAwREBAMQRAQABAAAAyREBAMwRAQAEAAAAzhEBAM8RAQAEAAAA0BEBANkRAQAOAAAA2hEBANoRAQABAAAA3BEBANwRAQABAAAAABIBABESAQABAAAAExIBACsSAQABAAAALBIBADcSAQAEAAAAPhIBAD4SAQAEAAAAgBIBAIYSAQABAAAAiBIBAIgSAQABAAAAihIBAI0SAQABAAAAjxIBAJ0SAQABAAAAnxIBAKgSAQABAAAAsBIBAN4SAQABAAAA3xIBAOoSAQAEAAAA8BIBAPkSAQAOAAAAABMBAAMTAQAEAAAABRMBAAwTAQABAAAADxMBABATAQABAAAAExMBACgTAQABAAAAKhMBADATAQABAAAAMhMBADMTAQABAAAANRMBADkTAQABAAAAOxMBADwTAQAEAAAAPRMBAD0TAQABAAAAPhMBAEQTAQAEAAAARxMBAEgTAQAEAAAASxMBAE0TAQAEAAAAUBMBAFATAQABAAAAVxMBAFcTAQAEAAAAXRMBAGETAQABAAAAYhMBAGMTAQAEAAAAZhMBAGwTAQAEAAAAcBMBAHQTAQAEAAAAABQBADQUAQABAAAANRQBAEYUAQAEAAAARxQBAEoUAQABAAAAUBQBAFkUAQAOAAAAXhQBAF4UAQAEAAAAXxQBAGEUAQABAAAAgBQBAK8UAQABAAAAsBQBAMMUAQAEAAAAxBQBAMUUAQABAAAAxxQBAMcUAQABAAAA0BQBANkUAQAOAAAAgBUBAK4VAQABAAAArxUBALUVAQAEAAAAuBUBAMAVAQAEAAAA2BUBANsVAQABAAAA3BUBAN0VAQAEAAAAABYBAC8WAQABAAAAMBYBAEAWAQAEAAAARBYBAEQWAQABAAAAUBYBAFkWAQAOAAAAgBYBAKoWAQABAAAAqxYBALcWAQAEAAAAuBYBALgWAQABAAAAwBYBAMkWAQAOAAAAHRcBACsXAQAEAAAAMBcBADkXAQAOAAAAABgBACsYAQABAAAALBgBADoYAQAEAAAAoBgBAN8YAQABAAAA4BgBAOkYAQAOAAAA/xgBAAYZAQABAAAACRkBAAkZAQABAAAADBkBABMZAQABAAAAFRkBABYZAQABAAAAGBkBAC8ZAQABAAAAMBkBADUZAQAEAAAANxkBADgZAQAEAAAAOxkBAD4ZAQAEAAAAPxkBAD8ZAQABAAAAQBkBAEAZAQAEAAAAQRkBAEEZAQABAAAAQhkBAEMZAQAEAAAAUBkBAFkZAQAOAAAAoBkBAKcZAQABAAAAqhkBANAZAQABAAAA0RkBANcZAQAEAAAA2hkBAOAZAQAEAAAA4RkBAOEZAQABAAAA4xkBAOMZAQABAAAA5BkBAOQZAQAEAAAAABoBAAAaAQABAAAAARoBAAoaAQAEAAAACxoBADIaAQABAAAAMxoBADkaAQAEAAAAOhoBADoaAQABAAAAOxoBAD4aAQAEAAAARxoBAEcaAQAEAAAAUBoBAFAaAQABAAAAURoBAFsaAQAEAAAAXBoBAIkaAQABAAAAihoBAJkaAQAEAAAAnRoBAJ0aAQABAAAAsBoBAPgaAQABAAAAABwBAAgcAQABAAAAChwBAC4cAQABAAAALxwBADYcAQAEAAAAOBwBAD8cAQAEAAAAQBwBAEAcAQABAAAAUBwBAFkcAQAOAAAAchwBAI8cAQABAAAAkhwBAKccAQAEAAAAqRwBALYcAQAEAAAAAB0BAAYdAQABAAAACB0BAAkdAQABAAAACx0BADAdAQABAAAAMR0BADYdAQAEAAAAOh0BADodAQAEAAAAPB0BAD0dAQAEAAAAPx0BAEUdAQAEAAAARh0BAEYdAQABAAAARx0BAEcdAQAEAAAAUB0BAFkdAQAOAAAAYB0BAGUdAQABAAAAZx0BAGgdAQABAAAAah0BAIkdAQABAAAAih0BAI4dAQAEAAAAkB0BAJEdAQAEAAAAkx0BAJcdAQAEAAAAmB0BAJgdAQABAAAAoB0BAKkdAQAOAAAA4B4BAPIeAQABAAAA8x4BAPYeAQAEAAAAsB8BALAfAQABAAAAACABAJkjAQABAAAAACQBAG4kAQABAAAAgCQBAEMlAQABAAAAkC8BAPAvAQABAAAAADABAC40AQABAAAAMDQBADg0AQAGAAAAAEQBAEZGAQABAAAAAGgBADhqAQABAAAAQGoBAF5qAQABAAAAYGoBAGlqAQAOAAAAcGoBAL5qAQABAAAAwGoBAMlqAQAOAAAA0GoBAO1qAQABAAAA8GoBAPRqAQAEAAAAAGsBAC9rAQABAAAAMGsBADZrAQAEAAAAQGsBAENrAQABAAAAUGsBAFlrAQAOAAAAY2sBAHdrAQABAAAAfWsBAI9rAQABAAAAQG4BAH9uAQABAAAAAG8BAEpvAQABAAAAT28BAE9vAQAEAAAAUG8BAFBvAQABAAAAUW8BAIdvAQAEAAAAj28BAJJvAQAEAAAAk28BAJ9vAQABAAAA4G8BAOFvAQABAAAA428BAONvAQABAAAA5G8BAORvAQAEAAAA8G8BAPFvAQAEAAAA8K8BAPOvAQAIAAAA9a8BAPuvAQAIAAAA/a8BAP6vAQAIAAAAALABAACwAQAIAAAAILEBACKxAQAIAAAAZLEBAGexAQAIAAAAALwBAGq8AQABAAAAcLwBAHy8AQABAAAAgLwBAIi8AQABAAAAkLwBAJm8AQABAAAAnbwBAJ68AQAEAAAAoLwBAKO8AQAGAAAAAM8BAC3PAQAEAAAAMM8BAEbPAQAEAAAAZdEBAGnRAQAEAAAAbdEBAHLRAQAEAAAAc9EBAHrRAQAGAAAAe9EBAILRAQAEAAAAhdEBAIvRAQAEAAAAqtEBAK3RAQAEAAAAQtIBAETSAQAEAAAAANQBAFTUAQABAAAAVtQBAJzUAQABAAAAntQBAJ/UAQABAAAAotQBAKLUAQABAAAApdQBAKbUAQABAAAAqdQBAKzUAQABAAAArtQBALnUAQABAAAAu9QBALvUAQABAAAAvdQBAMPUAQABAAAAxdQBAAXVAQABAAAAB9UBAArVAQABAAAADdUBABTVAQABAAAAFtUBABzVAQABAAAAHtUBADnVAQABAAAAO9UBAD7VAQABAAAAQNUBAETVAQABAAAARtUBAEbVAQABAAAAStUBAFDVAQABAAAAUtUBAKXWAQABAAAAqNYBAMDWAQABAAAAwtYBANrWAQABAAAA3NYBAPrWAQABAAAA/NYBABTXAQABAAAAFtcBADTXAQABAAAANtcBAE7XAQABAAAAUNcBAG7XAQABAAAAcNcBAIjXAQABAAAAitcBAKjXAQABAAAAqtcBAMLXAQABAAAAxNcBAMvXAQABAAAAztcBAP/XAQAOAAAAANoBADbaAQAEAAAAO9oBAGzaAQAEAAAAddoBAHXaAQAEAAAAhNoBAITaAQAEAAAAm9oBAJ/aAQAEAAAAodoBAK/aAQAEAAAAAN8BAB7fAQABAAAAAOABAAbgAQAEAAAACOABABjgAQAEAAAAG+ABACHgAQAEAAAAI+ABACTgAQAEAAAAJuABACrgAQAEAAAAAOEBACzhAQABAAAAMOEBADbhAQAEAAAAN+EBAD3hAQABAAAAQOEBAEnhAQAOAAAATuEBAE7hAQABAAAAkOIBAK3iAQABAAAAruIBAK7iAQAEAAAAwOIBAOviAQABAAAA7OIBAO/iAQAEAAAA8OIBAPniAQAOAAAA4OcBAObnAQABAAAA6OcBAOvnAQABAAAA7ecBAO7nAQABAAAA8OcBAP7nAQABAAAAAOgBAMToAQABAAAA0OgBANboAQAEAAAAAOkBAEPpAQABAAAAROkBAErpAQAEAAAAS+kBAEvpAQABAAAAUOkBAFnpAQAOAAAAAO4BAAPuAQABAAAABe4BAB/uAQABAAAAIe4BACLuAQABAAAAJO4BACTuAQABAAAAJ+4BACfuAQABAAAAKe4BADLuAQABAAAANO4BADfuAQABAAAAOe4BADnuAQABAAAAO+4BADvuAQABAAAAQu4BAELuAQABAAAAR+4BAEfuAQABAAAASe4BAEnuAQABAAAAS+4BAEvuAQABAAAATe4BAE/uAQABAAAAUe4BAFLuAQABAAAAVO4BAFTuAQABAAAAV+4BAFfuAQABAAAAWe4BAFnuAQABAAAAW+4BAFvuAQABAAAAXe4BAF3uAQABAAAAX+4BAF/uAQABAAAAYe4BAGLuAQABAAAAZO4BAGTuAQABAAAAZ+4BAGruAQABAAAAbO4BAHLuAQABAAAAdO4BAHfuAQABAAAAee4BAHzuAQABAAAAfu4BAH7uAQABAAAAgO4BAInuAQABAAAAi+4BAJvuAQABAAAAoe4BAKPuAQABAAAApe4BAKnuAQABAAAAq+4BALvuAQABAAAAMPEBAEnxAQABAAAAUPEBAGnxAQABAAAAcPEBAInxAQABAAAA5vEBAP/xAQAPAAAA+/MBAP/zAQAEAAAA8PsBAPn7AQAOAAAAAQAOAAEADgAGAAAAIAAOAH8ADgAEAAAAAAEOAO8BDgAEAEHEmAELn6wBCQAAAAMAAAAKAAAACgAAAAIAAAALAAAADAAAAAMAAAANAAAADQAAAAEAAAAOAAAAHwAAAAMAAAB/AAAAnwAAAAMAAACtAAAArQAAAAMAAAAAAwAAbwMAAAQAAACDBAAAiQQAAAQAAACRBQAAvQUAAAQAAAC/BQAAvwUAAAQAAADBBQAAwgUAAAQAAADEBQAAxQUAAAQAAADHBQAAxwUAAAQAAAAABgAABQYAAAUAAAAQBgAAGgYAAAQAAAAcBgAAHAYAAAMAAABLBgAAXwYAAAQAAABwBgAAcAYAAAQAAADWBgAA3AYAAAQAAADdBgAA3QYAAAUAAADfBgAA5AYAAAQAAADnBgAA6AYAAAQAAADqBgAA7QYAAAQAAAAPBwAADwcAAAUAAAARBwAAEQcAAAQAAAAwBwAASgcAAAQAAACmBwAAsAcAAAQAAADrBwAA8wcAAAQAAAD9BwAA/QcAAAQAAAAWCAAAGQgAAAQAAAAbCAAAIwgAAAQAAAAlCAAAJwgAAAQAAAApCAAALQgAAAQAAABZCAAAWwgAAAQAAACQCAAAkQgAAAUAAACYCAAAnwgAAAQAAADKCAAA4QgAAAQAAADiCAAA4ggAAAUAAADjCAAAAgkAAAQAAAADCQAAAwkAAAcAAAA6CQAAOgkAAAQAAAA7CQAAOwkAAAcAAAA8CQAAPAkAAAQAAAA+CQAAQAkAAAcAAABBCQAASAkAAAQAAABJCQAATAkAAAcAAABNCQAATQkAAAQAAABOCQAATwkAAAcAAABRCQAAVwkAAAQAAABiCQAAYwkAAAQAAACBCQAAgQkAAAQAAACCCQAAgwkAAAcAAAC8CQAAvAkAAAQAAAC+CQAAvgkAAAQAAAC/CQAAwAkAAAcAAADBCQAAxAkAAAQAAADHCQAAyAkAAAcAAADLCQAAzAkAAAcAAADNCQAAzQkAAAQAAADXCQAA1wkAAAQAAADiCQAA4wkAAAQAAAD+CQAA/gkAAAQAAAABCgAAAgoAAAQAAAADCgAAAwoAAAcAAAA8CgAAPAoAAAQAAAA+CgAAQAoAAAcAAABBCgAAQgoAAAQAAABHCgAASAoAAAQAAABLCgAATQoAAAQAAABRCgAAUQoAAAQAAABwCgAAcQoAAAQAAAB1CgAAdQoAAAQAAACBCgAAggoAAAQAAACDCgAAgwoAAAcAAAC8CgAAvAoAAAQAAAC+CgAAwAoAAAcAAADBCgAAxQoAAAQAAADHCgAAyAoAAAQAAADJCgAAyQoAAAcAAADLCgAAzAoAAAcAAADNCgAAzQoAAAQAAADiCgAA4woAAAQAAAD6CgAA/woAAAQAAAABCwAAAQsAAAQAAAACCwAAAwsAAAcAAAA8CwAAPAsAAAQAAAA+CwAAPwsAAAQAAABACwAAQAsAAAcAAABBCwAARAsAAAQAAABHCwAASAsAAAcAAABLCwAATAsAAAcAAABNCwAATQsAAAQAAABVCwAAVwsAAAQAAABiCwAAYwsAAAQAAACCCwAAggsAAAQAAAC+CwAAvgsAAAQAAAC/CwAAvwsAAAcAAADACwAAwAsAAAQAAADBCwAAwgsAAAcAAADGCwAAyAsAAAcAAADKCwAAzAsAAAcAAADNCwAAzQsAAAQAAADXCwAA1wsAAAQAAAAADAAAAAwAAAQAAAABDAAAAwwAAAcAAAAEDAAABAwAAAQAAAA8DAAAPAwAAAQAAAA+DAAAQAwAAAQAAABBDAAARAwAAAcAAABGDAAASAwAAAQAAABKDAAATQwAAAQAAABVDAAAVgwAAAQAAABiDAAAYwwAAAQAAACBDAAAgQwAAAQAAACCDAAAgwwAAAcAAAC8DAAAvAwAAAQAAAC+DAAAvgwAAAcAAAC/DAAAvwwAAAQAAADADAAAwQwAAAcAAADCDAAAwgwAAAQAAADDDAAAxAwAAAcAAADGDAAAxgwAAAQAAADHDAAAyAwAAAcAAADKDAAAywwAAAcAAADMDAAAzQwAAAQAAADVDAAA1gwAAAQAAADiDAAA4wwAAAQAAAAADQAAAQ0AAAQAAAACDQAAAw0AAAcAAAA7DQAAPA0AAAQAAAA+DQAAPg0AAAQAAAA/DQAAQA0AAAcAAABBDQAARA0AAAQAAABGDQAASA0AAAcAAABKDQAATA0AAAcAAABNDQAATQ0AAAQAAABODQAATg0AAAUAAABXDQAAVw0AAAQAAABiDQAAYw0AAAQAAACBDQAAgQ0AAAQAAACCDQAAgw0AAAcAAADKDQAAyg0AAAQAAADPDQAAzw0AAAQAAADQDQAA0Q0AAAcAAADSDQAA1A0AAAQAAADWDQAA1g0AAAQAAADYDQAA3g0AAAcAAADfDQAA3w0AAAQAAADyDQAA8w0AAAcAAAAxDgAAMQ4AAAQAAAAzDgAAMw4AAAcAAAA0DgAAOg4AAAQAAABHDgAATg4AAAQAAACxDgAAsQ4AAAQAAACzDgAAsw4AAAcAAAC0DgAAvA4AAAQAAADIDgAAzQ4AAAQAAAAYDwAAGQ8AAAQAAAA1DwAANQ8AAAQAAAA3DwAANw8AAAQAAAA5DwAAOQ8AAAQAAAA+DwAAPw8AAAcAAABxDwAAfg8AAAQAAAB/DwAAfw8AAAcAAACADwAAhA8AAAQAAACGDwAAhw8AAAQAAACNDwAAlw8AAAQAAACZDwAAvA8AAAQAAADGDwAAxg8AAAQAAAAtEAAAMBAAAAQAAAAxEAAAMRAAAAcAAAAyEAAANxAAAAQAAAA5EAAAOhAAAAQAAAA7EAAAPBAAAAcAAAA9EAAAPhAAAAQAAABWEAAAVxAAAAcAAABYEAAAWRAAAAQAAABeEAAAYBAAAAQAAABxEAAAdBAAAAQAAACCEAAAghAAAAQAAACEEAAAhBAAAAcAAACFEAAAhhAAAAQAAACNEAAAjRAAAAQAAACdEAAAnRAAAAQAAAAAEQAAXxEAAA0AAABgEQAApxEAABEAAACoEQAA/xEAABAAAABdEwAAXxMAAAQAAAASFwAAFBcAAAQAAAAVFwAAFRcAAAcAAAAyFwAAMxcAAAQAAAA0FwAANBcAAAcAAABSFwAAUxcAAAQAAAByFwAAcxcAAAQAAAC0FwAAtRcAAAQAAAC2FwAAthcAAAcAAAC3FwAAvRcAAAQAAAC+FwAAxRcAAAcAAADGFwAAxhcAAAQAAADHFwAAyBcAAAcAAADJFwAA0xcAAAQAAADdFwAA3RcAAAQAAAALGAAADRgAAAQAAAAOGAAADhgAAAMAAAAPGAAADxgAAAQAAACFGAAAhhgAAAQAAACpGAAAqRgAAAQAAAAgGQAAIhkAAAQAAAAjGQAAJhkAAAcAAAAnGQAAKBkAAAQAAAApGQAAKxkAAAcAAAAwGQAAMRkAAAcAAAAyGQAAMhkAAAQAAAAzGQAAOBkAAAcAAAA5GQAAOxkAAAQAAAAXGgAAGBoAAAQAAAAZGgAAGhoAAAcAAAAbGgAAGxoAAAQAAABVGgAAVRoAAAcAAABWGgAAVhoAAAQAAABXGgAAVxoAAAcAAABYGgAAXhoAAAQAAABgGgAAYBoAAAQAAABiGgAAYhoAAAQAAABlGgAAbBoAAAQAAABtGgAAchoAAAcAAABzGgAAfBoAAAQAAAB/GgAAfxoAAAQAAACwGgAAzhoAAAQAAAAAGwAAAxsAAAQAAAAEGwAABBsAAAcAAAA0GwAAOhsAAAQAAAA7GwAAOxsAAAcAAAA8GwAAPBsAAAQAAAA9GwAAQRsAAAcAAABCGwAAQhsAAAQAAABDGwAARBsAAAcAAABrGwAAcxsAAAQAAACAGwAAgRsAAAQAAACCGwAAghsAAAcAAAChGwAAoRsAAAcAAACiGwAApRsAAAQAAACmGwAApxsAAAcAAACoGwAAqRsAAAQAAACqGwAAqhsAAAcAAACrGwAArRsAAAQAAADmGwAA5hsAAAQAAADnGwAA5xsAAAcAAADoGwAA6RsAAAQAAADqGwAA7BsAAAcAAADtGwAA7RsAAAQAAADuGwAA7hsAAAcAAADvGwAA8RsAAAQAAADyGwAA8xsAAAcAAAAkHAAAKxwAAAcAAAAsHAAAMxwAAAQAAAA0HAAANRwAAAcAAAA2HAAANxwAAAQAAADQHAAA0hwAAAQAAADUHAAA4BwAAAQAAADhHAAA4RwAAAcAAADiHAAA6BwAAAQAAADtHAAA7RwAAAQAAAD0HAAA9BwAAAQAAAD3HAAA9xwAAAcAAAD4HAAA+RwAAAQAAADAHQAA/x0AAAQAAAALIAAACyAAAAMAAAAMIAAADCAAAAQAAAANIAAADSAAAAgAAAAOIAAADyAAAAMAAAAoIAAALiAAAAMAAABgIAAAbyAAAAMAAADQIAAA8CAAAAQAAADvLAAA8SwAAAQAAAB/LQAAfy0AAAQAAADgLQAA/y0AAAQAAAAqMAAALzAAAAQAAACZMAAAmjAAAAQAAABvpgAAcqYAAAQAAAB0pgAAfaYAAAQAAACepgAAn6YAAAQAAADwpgAA8aYAAAQAAAACqAAAAqgAAAQAAAAGqAAABqgAAAQAAAALqAAAC6gAAAQAAAAjqAAAJKgAAAcAAAAlqAAAJqgAAAQAAAAnqAAAJ6gAAAcAAAAsqAAALKgAAAQAAACAqAAAgagAAAcAAAC0qAAAw6gAAAcAAADEqAAAxagAAAQAAADgqAAA8agAAAQAAAD/qAAA/6gAAAQAAAAmqQAALakAAAQAAABHqQAAUakAAAQAAABSqQAAU6kAAAcAAABgqQAAfKkAAA0AAACAqQAAgqkAAAQAAACDqQAAg6kAAAcAAACzqQAAs6kAAAQAAAC0qQAAtakAAAcAAAC2qQAAuakAAAQAAAC6qQAAu6kAAAcAAAC8qQAAvakAAAQAAAC+qQAAwKkAAAcAAADlqQAA5akAAAQAAAApqgAALqoAAAQAAAAvqgAAMKoAAAcAAAAxqgAAMqoAAAQAAAAzqgAANKoAAAcAAAA1qgAANqoAAAQAAABDqgAAQ6oAAAQAAABMqgAATKoAAAQAAABNqgAATaoAAAcAAAB8qgAAfKoAAAQAAACwqgAAsKoAAAQAAACyqgAAtKoAAAQAAAC3qgAAuKoAAAQAAAC+qgAAv6oAAAQAAADBqgAAwaoAAAQAAADrqgAA66oAAAcAAADsqgAA7aoAAAQAAADuqgAA76oAAAcAAAD1qgAA9aoAAAcAAAD2qgAA9qoAAAQAAADjqwAA5KsAAAcAAADlqwAA5asAAAQAAADmqwAA56sAAAcAAADoqwAA6KsAAAQAAADpqwAA6qsAAAcAAADsqwAA7KsAAAcAAADtqwAA7asAAAQAAAAArAAAAKwAAA4AAAABrAAAG6wAAA8AAAAcrAAAHKwAAA4AAAAdrAAAN6wAAA8AAAA4rAAAOKwAAA4AAAA5rAAAU6wAAA8AAABUrAAAVKwAAA4AAABVrAAAb6wAAA8AAABwrAAAcKwAAA4AAABxrAAAi6wAAA8AAACMrAAAjKwAAA4AAACNrAAAp6wAAA8AAACorAAAqKwAAA4AAACprAAAw6wAAA8AAADErAAAxKwAAA4AAADFrAAA36wAAA8AAADgrAAA4KwAAA4AAADhrAAA+6wAAA8AAAD8rAAA/KwAAA4AAAD9rAAAF60AAA8AAAAYrQAAGK0AAA4AAAAZrQAAM60AAA8AAAA0rQAANK0AAA4AAAA1rQAAT60AAA8AAABQrQAAUK0AAA4AAABRrQAAa60AAA8AAABsrQAAbK0AAA4AAABtrQAAh60AAA8AAACIrQAAiK0AAA4AAACJrQAAo60AAA8AAACkrQAApK0AAA4AAAClrQAAv60AAA8AAADArQAAwK0AAA4AAADBrQAA260AAA8AAADcrQAA3K0AAA4AAADdrQAA960AAA8AAAD4rQAA+K0AAA4AAAD5rQAAE64AAA8AAAAUrgAAFK4AAA4AAAAVrgAAL64AAA8AAAAwrgAAMK4AAA4AAAAxrgAAS64AAA8AAABMrgAATK4AAA4AAABNrgAAZ64AAA8AAABorgAAaK4AAA4AAABprgAAg64AAA8AAACErgAAhK4AAA4AAACFrgAAn64AAA8AAACgrgAAoK4AAA4AAAChrgAAu64AAA8AAAC8rgAAvK4AAA4AAAC9rgAA164AAA8AAADYrgAA2K4AAA4AAADZrgAA864AAA8AAAD0rgAA9K4AAA4AAAD1rgAAD68AAA8AAAAQrwAAEK8AAA4AAAARrwAAK68AAA8AAAAsrwAALK8AAA4AAAAtrwAAR68AAA8AAABIrwAASK8AAA4AAABJrwAAY68AAA8AAABkrwAAZK8AAA4AAABlrwAAf68AAA8AAACArwAAgK8AAA4AAACBrwAAm68AAA8AAACcrwAAnK8AAA4AAACdrwAAt68AAA8AAAC4rwAAuK8AAA4AAAC5rwAA068AAA8AAADUrwAA1K8AAA4AAADVrwAA768AAA8AAADwrwAA8K8AAA4AAADxrwAAC7AAAA8AAAAMsAAADLAAAA4AAAANsAAAJ7AAAA8AAAAosAAAKLAAAA4AAAApsAAAQ7AAAA8AAABEsAAARLAAAA4AAABFsAAAX7AAAA8AAABgsAAAYLAAAA4AAABhsAAAe7AAAA8AAAB8sAAAfLAAAA4AAAB9sAAAl7AAAA8AAACYsAAAmLAAAA4AAACZsAAAs7AAAA8AAAC0sAAAtLAAAA4AAAC1sAAAz7AAAA8AAADQsAAA0LAAAA4AAADRsAAA67AAAA8AAADssAAA7LAAAA4AAADtsAAAB7EAAA8AAAAIsQAACLEAAA4AAAAJsQAAI7EAAA8AAAAksQAAJLEAAA4AAAAlsQAAP7EAAA8AAABAsQAAQLEAAA4AAABBsQAAW7EAAA8AAABcsQAAXLEAAA4AAABdsQAAd7EAAA8AAAB4sQAAeLEAAA4AAAB5sQAAk7EAAA8AAACUsQAAlLEAAA4AAACVsQAAr7EAAA8AAACwsQAAsLEAAA4AAACxsQAAy7EAAA8AAADMsQAAzLEAAA4AAADNsQAA57EAAA8AAADosQAA6LEAAA4AAADpsQAAA7IAAA8AAAAEsgAABLIAAA4AAAAFsgAAH7IAAA8AAAAgsgAAILIAAA4AAAAhsgAAO7IAAA8AAAA8sgAAPLIAAA4AAAA9sgAAV7IAAA8AAABYsgAAWLIAAA4AAABZsgAAc7IAAA8AAAB0sgAAdLIAAA4AAAB1sgAAj7IAAA8AAACQsgAAkLIAAA4AAACRsgAAq7IAAA8AAACssgAArLIAAA4AAACtsgAAx7IAAA8AAADIsgAAyLIAAA4AAADJsgAA47IAAA8AAADksgAA5LIAAA4AAADlsgAA/7IAAA8AAAAAswAAALMAAA4AAAABswAAG7MAAA8AAAAcswAAHLMAAA4AAAAdswAAN7MAAA8AAAA4swAAOLMAAA4AAAA5swAAU7MAAA8AAABUswAAVLMAAA4AAABVswAAb7MAAA8AAABwswAAcLMAAA4AAABxswAAi7MAAA8AAACMswAAjLMAAA4AAACNswAAp7MAAA8AAACoswAAqLMAAA4AAACpswAAw7MAAA8AAADEswAAxLMAAA4AAADFswAA37MAAA8AAADgswAA4LMAAA4AAADhswAA+7MAAA8AAAD8swAA/LMAAA4AAAD9swAAF7QAAA8AAAAYtAAAGLQAAA4AAAAZtAAAM7QAAA8AAAA0tAAANLQAAA4AAAA1tAAAT7QAAA8AAABQtAAAULQAAA4AAABRtAAAa7QAAA8AAABstAAAbLQAAA4AAABttAAAh7QAAA8AAACItAAAiLQAAA4AAACJtAAAo7QAAA8AAACktAAApLQAAA4AAACltAAAv7QAAA8AAADAtAAAwLQAAA4AAADBtAAA27QAAA8AAADctAAA3LQAAA4AAADdtAAA97QAAA8AAAD4tAAA+LQAAA4AAAD5tAAAE7UAAA8AAAAUtQAAFLUAAA4AAAAVtQAAL7UAAA8AAAAwtQAAMLUAAA4AAAAxtQAAS7UAAA8AAABMtQAATLUAAA4AAABNtQAAZ7UAAA8AAABotQAAaLUAAA4AAABptQAAg7UAAA8AAACEtQAAhLUAAA4AAACFtQAAn7UAAA8AAACgtQAAoLUAAA4AAAChtQAAu7UAAA8AAAC8tQAAvLUAAA4AAAC9tQAA17UAAA8AAADYtQAA2LUAAA4AAADZtQAA87UAAA8AAAD0tQAA9LUAAA4AAAD1tQAAD7YAAA8AAAAQtgAAELYAAA4AAAARtgAAK7YAAA8AAAAstgAALLYAAA4AAAAttgAAR7YAAA8AAABItgAASLYAAA4AAABJtgAAY7YAAA8AAABktgAAZLYAAA4AAABltgAAf7YAAA8AAACAtgAAgLYAAA4AAACBtgAAm7YAAA8AAACctgAAnLYAAA4AAACdtgAAt7YAAA8AAAC4tgAAuLYAAA4AAAC5tgAA07YAAA8AAADUtgAA1LYAAA4AAADVtgAA77YAAA8AAADwtgAA8LYAAA4AAADxtgAAC7cAAA8AAAAMtwAADLcAAA4AAAANtwAAJ7cAAA8AAAAotwAAKLcAAA4AAAAptwAAQ7cAAA8AAABEtwAARLcAAA4AAABFtwAAX7cAAA8AAABgtwAAYLcAAA4AAABhtwAAe7cAAA8AAAB8twAAfLcAAA4AAAB9twAAl7cAAA8AAACYtwAAmLcAAA4AAACZtwAAs7cAAA8AAAC0twAAtLcAAA4AAAC1twAAz7cAAA8AAADQtwAA0LcAAA4AAADRtwAA67cAAA8AAADstwAA7LcAAA4AAADttwAAB7gAAA8AAAAIuAAACLgAAA4AAAAJuAAAI7gAAA8AAAAkuAAAJLgAAA4AAAAluAAAP7gAAA8AAABAuAAAQLgAAA4AAABBuAAAW7gAAA8AAABcuAAAXLgAAA4AAABduAAAd7gAAA8AAAB4uAAAeLgAAA4AAAB5uAAAk7gAAA8AAACUuAAAlLgAAA4AAACVuAAAr7gAAA8AAACwuAAAsLgAAA4AAACxuAAAy7gAAA8AAADMuAAAzLgAAA4AAADNuAAA57gAAA8AAADouAAA6LgAAA4AAADpuAAAA7kAAA8AAAAEuQAABLkAAA4AAAAFuQAAH7kAAA8AAAAguQAAILkAAA4AAAAhuQAAO7kAAA8AAAA8uQAAPLkAAA4AAAA9uQAAV7kAAA8AAABYuQAAWLkAAA4AAABZuQAAc7kAAA8AAAB0uQAAdLkAAA4AAAB1uQAAj7kAAA8AAACQuQAAkLkAAA4AAACRuQAAq7kAAA8AAACsuQAArLkAAA4AAACtuQAAx7kAAA8AAADIuQAAyLkAAA4AAADJuQAA47kAAA8AAADkuQAA5LkAAA4AAADluQAA/7kAAA8AAAAAugAAALoAAA4AAAABugAAG7oAAA8AAAAcugAAHLoAAA4AAAAdugAAN7oAAA8AAAA4ugAAOLoAAA4AAAA5ugAAU7oAAA8AAABUugAAVLoAAA4AAABVugAAb7oAAA8AAABwugAAcLoAAA4AAABxugAAi7oAAA8AAACMugAAjLoAAA4AAACNugAAp7oAAA8AAACougAAqLoAAA4AAACpugAAw7oAAA8AAADEugAAxLoAAA4AAADFugAA37oAAA8AAADgugAA4LoAAA4AAADhugAA+7oAAA8AAAD8ugAA/LoAAA4AAAD9ugAAF7sAAA8AAAAYuwAAGLsAAA4AAAAZuwAAM7sAAA8AAAA0uwAANLsAAA4AAAA1uwAAT7sAAA8AAABQuwAAULsAAA4AAABRuwAAa7sAAA8AAABsuwAAbLsAAA4AAABtuwAAh7sAAA8AAACIuwAAiLsAAA4AAACJuwAAo7sAAA8AAACkuwAApLsAAA4AAACluwAAv7sAAA8AAADAuwAAwLsAAA4AAADBuwAA27sAAA8AAADcuwAA3LsAAA4AAADduwAA97sAAA8AAAD4uwAA+LsAAA4AAAD5uwAAE7wAAA8AAAAUvAAAFLwAAA4AAAAVvAAAL7wAAA8AAAAwvAAAMLwAAA4AAAAxvAAAS7wAAA8AAABMvAAATLwAAA4AAABNvAAAZ7wAAA8AAABovAAAaLwAAA4AAABpvAAAg7wAAA8AAACEvAAAhLwAAA4AAACFvAAAn7wAAA8AAACgvAAAoLwAAA4AAAChvAAAu7wAAA8AAAC8vAAAvLwAAA4AAAC9vAAA17wAAA8AAADYvAAA2LwAAA4AAADZvAAA87wAAA8AAAD0vAAA9LwAAA4AAAD1vAAAD70AAA8AAAAQvQAAEL0AAA4AAAARvQAAK70AAA8AAAAsvQAALL0AAA4AAAAtvQAAR70AAA8AAABIvQAASL0AAA4AAABJvQAAY70AAA8AAABkvQAAZL0AAA4AAABlvQAAf70AAA8AAACAvQAAgL0AAA4AAACBvQAAm70AAA8AAACcvQAAnL0AAA4AAACdvQAAt70AAA8AAAC4vQAAuL0AAA4AAAC5vQAA070AAA8AAADUvQAA1L0AAA4AAADVvQAA770AAA8AAADwvQAA8L0AAA4AAADxvQAAC74AAA8AAAAMvgAADL4AAA4AAAANvgAAJ74AAA8AAAAovgAAKL4AAA4AAAApvgAAQ74AAA8AAABEvgAARL4AAA4AAABFvgAAX74AAA8AAABgvgAAYL4AAA4AAABhvgAAe74AAA8AAAB8vgAAfL4AAA4AAAB9vgAAl74AAA8AAACYvgAAmL4AAA4AAACZvgAAs74AAA8AAAC0vgAAtL4AAA4AAAC1vgAAz74AAA8AAADQvgAA0L4AAA4AAADRvgAA674AAA8AAADsvgAA7L4AAA4AAADtvgAAB78AAA8AAAAIvwAACL8AAA4AAAAJvwAAI78AAA8AAAAkvwAAJL8AAA4AAAAlvwAAP78AAA8AAABAvwAAQL8AAA4AAABBvwAAW78AAA8AAABcvwAAXL8AAA4AAABdvwAAd78AAA8AAAB4vwAAeL8AAA4AAAB5vwAAk78AAA8AAACUvwAAlL8AAA4AAACVvwAAr78AAA8AAACwvwAAsL8AAA4AAACxvwAAy78AAA8AAADMvwAAzL8AAA4AAADNvwAA578AAA8AAADovwAA6L8AAA4AAADpvwAAA8AAAA8AAAAEwAAABMAAAA4AAAAFwAAAH8AAAA8AAAAgwAAAIMAAAA4AAAAhwAAAO8AAAA8AAAA8wAAAPMAAAA4AAAA9wAAAV8AAAA8AAABYwAAAWMAAAA4AAABZwAAAc8AAAA8AAAB0wAAAdMAAAA4AAAB1wAAAj8AAAA8AAACQwAAAkMAAAA4AAACRwAAAq8AAAA8AAACswAAArMAAAA4AAACtwAAAx8AAAA8AAADIwAAAyMAAAA4AAADJwAAA48AAAA8AAADkwAAA5MAAAA4AAADlwAAA/8AAAA8AAAAAwQAAAMEAAA4AAAABwQAAG8EAAA8AAAAcwQAAHMEAAA4AAAAdwQAAN8EAAA8AAAA4wQAAOMEAAA4AAAA5wQAAU8EAAA8AAABUwQAAVMEAAA4AAABVwQAAb8EAAA8AAABwwQAAcMEAAA4AAABxwQAAi8EAAA8AAACMwQAAjMEAAA4AAACNwQAAp8EAAA8AAACowQAAqMEAAA4AAACpwQAAw8EAAA8AAADEwQAAxMEAAA4AAADFwQAA38EAAA8AAADgwQAA4MEAAA4AAADhwQAA+8EAAA8AAAD8wQAA/MEAAA4AAAD9wQAAF8IAAA8AAAAYwgAAGMIAAA4AAAAZwgAAM8IAAA8AAAA0wgAANMIAAA4AAAA1wgAAT8IAAA8AAABQwgAAUMIAAA4AAABRwgAAa8IAAA8AAABswgAAbMIAAA4AAABtwgAAh8IAAA8AAACIwgAAiMIAAA4AAACJwgAAo8IAAA8AAACkwgAApMIAAA4AAAClwgAAv8IAAA8AAADAwgAAwMIAAA4AAADBwgAA28IAAA8AAADcwgAA3MIAAA4AAADdwgAA98IAAA8AAAD4wgAA+MIAAA4AAAD5wgAAE8MAAA8AAAAUwwAAFMMAAA4AAAAVwwAAL8MAAA8AAAAwwwAAMMMAAA4AAAAxwwAAS8MAAA8AAABMwwAATMMAAA4AAABNwwAAZ8MAAA8AAABowwAAaMMAAA4AAABpwwAAg8MAAA8AAACEwwAAhMMAAA4AAACFwwAAn8MAAA8AAACgwwAAoMMAAA4AAAChwwAAu8MAAA8AAAC8wwAAvMMAAA4AAAC9wwAA18MAAA8AAADYwwAA2MMAAA4AAADZwwAA88MAAA8AAAD0wwAA9MMAAA4AAAD1wwAAD8QAAA8AAAAQxAAAEMQAAA4AAAARxAAAK8QAAA8AAAAsxAAALMQAAA4AAAAtxAAAR8QAAA8AAABIxAAASMQAAA4AAABJxAAAY8QAAA8AAABkxAAAZMQAAA4AAABlxAAAf8QAAA8AAACAxAAAgMQAAA4AAACBxAAAm8QAAA8AAACcxAAAnMQAAA4AAACdxAAAt8QAAA8AAAC4xAAAuMQAAA4AAAC5xAAA08QAAA8AAADUxAAA1MQAAA4AAADVxAAA78QAAA8AAADwxAAA8MQAAA4AAADxxAAAC8UAAA8AAAAMxQAADMUAAA4AAAANxQAAJ8UAAA8AAAAoxQAAKMUAAA4AAAApxQAAQ8UAAA8AAABExQAARMUAAA4AAABFxQAAX8UAAA8AAABgxQAAYMUAAA4AAABhxQAAe8UAAA8AAAB8xQAAfMUAAA4AAAB9xQAAl8UAAA8AAACYxQAAmMUAAA4AAACZxQAAs8UAAA8AAAC0xQAAtMUAAA4AAAC1xQAAz8UAAA8AAADQxQAA0MUAAA4AAADRxQAA68UAAA8AAADsxQAA7MUAAA4AAADtxQAAB8YAAA8AAAAIxgAACMYAAA4AAAAJxgAAI8YAAA8AAAAkxgAAJMYAAA4AAAAlxgAAP8YAAA8AAABAxgAAQMYAAA4AAABBxgAAW8YAAA8AAABcxgAAXMYAAA4AAABdxgAAd8YAAA8AAAB4xgAAeMYAAA4AAAB5xgAAk8YAAA8AAACUxgAAlMYAAA4AAACVxgAAr8YAAA8AAACwxgAAsMYAAA4AAACxxgAAy8YAAA8AAADMxgAAzMYAAA4AAADNxgAA58YAAA8AAADoxgAA6MYAAA4AAADpxgAAA8cAAA8AAAAExwAABMcAAA4AAAAFxwAAH8cAAA8AAAAgxwAAIMcAAA4AAAAhxwAAO8cAAA8AAAA8xwAAPMcAAA4AAAA9xwAAV8cAAA8AAABYxwAAWMcAAA4AAABZxwAAc8cAAA8AAAB0xwAAdMcAAA4AAAB1xwAAj8cAAA8AAACQxwAAkMcAAA4AAACRxwAAq8cAAA8AAACsxwAArMcAAA4AAACtxwAAx8cAAA8AAADIxwAAyMcAAA4AAADJxwAA48cAAA8AAADkxwAA5McAAA4AAADlxwAA/8cAAA8AAAAAyAAAAMgAAA4AAAAByAAAG8gAAA8AAAAcyAAAHMgAAA4AAAAdyAAAN8gAAA8AAAA4yAAAOMgAAA4AAAA5yAAAU8gAAA8AAABUyAAAVMgAAA4AAABVyAAAb8gAAA8AAABwyAAAcMgAAA4AAABxyAAAi8gAAA8AAACMyAAAjMgAAA4AAACNyAAAp8gAAA8AAACoyAAAqMgAAA4AAACpyAAAw8gAAA8AAADEyAAAxMgAAA4AAADFyAAA38gAAA8AAADgyAAA4MgAAA4AAADhyAAA+8gAAA8AAAD8yAAA/MgAAA4AAAD9yAAAF8kAAA8AAAAYyQAAGMkAAA4AAAAZyQAAM8kAAA8AAAA0yQAANMkAAA4AAAA1yQAAT8kAAA8AAABQyQAAUMkAAA4AAABRyQAAa8kAAA8AAABsyQAAbMkAAA4AAABtyQAAh8kAAA8AAACIyQAAiMkAAA4AAACJyQAAo8kAAA8AAACkyQAApMkAAA4AAAClyQAAv8kAAA8AAADAyQAAwMkAAA4AAADByQAA28kAAA8AAADcyQAA3MkAAA4AAADdyQAA98kAAA8AAAD4yQAA+MkAAA4AAAD5yQAAE8oAAA8AAAAUygAAFMoAAA4AAAAVygAAL8oAAA8AAAAwygAAMMoAAA4AAAAxygAAS8oAAA8AAABMygAATMoAAA4AAABNygAAZ8oAAA8AAABoygAAaMoAAA4AAABpygAAg8oAAA8AAACEygAAhMoAAA4AAACFygAAn8oAAA8AAACgygAAoMoAAA4AAAChygAAu8oAAA8AAAC8ygAAvMoAAA4AAAC9ygAA18oAAA8AAADYygAA2MoAAA4AAADZygAA88oAAA8AAAD0ygAA9MoAAA4AAAD1ygAAD8sAAA8AAAAQywAAEMsAAA4AAAARywAAK8sAAA8AAAAsywAALMsAAA4AAAAtywAAR8sAAA8AAABIywAASMsAAA4AAABJywAAY8sAAA8AAABkywAAZMsAAA4AAABlywAAf8sAAA8AAACAywAAgMsAAA4AAACBywAAm8sAAA8AAACcywAAnMsAAA4AAACdywAAt8sAAA8AAAC4ywAAuMsAAA4AAAC5ywAA08sAAA8AAADUywAA1MsAAA4AAADVywAA78sAAA8AAADwywAA8MsAAA4AAADxywAAC8wAAA8AAAAMzAAADMwAAA4AAAANzAAAJ8wAAA8AAAAozAAAKMwAAA4AAAApzAAAQ8wAAA8AAABEzAAARMwAAA4AAABFzAAAX8wAAA8AAABgzAAAYMwAAA4AAABhzAAAe8wAAA8AAAB8zAAAfMwAAA4AAAB9zAAAl8wAAA8AAACYzAAAmMwAAA4AAACZzAAAs8wAAA8AAAC0zAAAtMwAAA4AAAC1zAAAz8wAAA8AAADQzAAA0MwAAA4AAADRzAAA68wAAA8AAADszAAA7MwAAA4AAADtzAAAB80AAA8AAAAIzQAACM0AAA4AAAAJzQAAI80AAA8AAAAkzQAAJM0AAA4AAAAlzQAAP80AAA8AAABAzQAAQM0AAA4AAABBzQAAW80AAA8AAABczQAAXM0AAA4AAABdzQAAd80AAA8AAAB4zQAAeM0AAA4AAAB5zQAAk80AAA8AAACUzQAAlM0AAA4AAACVzQAAr80AAA8AAACwzQAAsM0AAA4AAACxzQAAy80AAA8AAADMzQAAzM0AAA4AAADNzQAA580AAA8AAADozQAA6M0AAA4AAADpzQAAA84AAA8AAAAEzgAABM4AAA4AAAAFzgAAH84AAA8AAAAgzgAAIM4AAA4AAAAhzgAAO84AAA8AAAA8zgAAPM4AAA4AAAA9zgAAV84AAA8AAABYzgAAWM4AAA4AAABZzgAAc84AAA8AAAB0zgAAdM4AAA4AAAB1zgAAj84AAA8AAACQzgAAkM4AAA4AAACRzgAAq84AAA8AAACszgAArM4AAA4AAACtzgAAx84AAA8AAADIzgAAyM4AAA4AAADJzgAA484AAA8AAADkzgAA5M4AAA4AAADlzgAA/84AAA8AAAAAzwAAAM8AAA4AAAABzwAAG88AAA8AAAAczwAAHM8AAA4AAAAdzwAAN88AAA8AAAA4zwAAOM8AAA4AAAA5zwAAU88AAA8AAABUzwAAVM8AAA4AAABVzwAAb88AAA8AAABwzwAAcM8AAA4AAABxzwAAi88AAA8AAACMzwAAjM8AAA4AAACNzwAAp88AAA8AAACozwAAqM8AAA4AAACpzwAAw88AAA8AAADEzwAAxM8AAA4AAADFzwAA388AAA8AAADgzwAA4M8AAA4AAADhzwAA+88AAA8AAAD8zwAA/M8AAA4AAAD9zwAAF9AAAA8AAAAY0AAAGNAAAA4AAAAZ0AAAM9AAAA8AAAA00AAANNAAAA4AAAA10AAAT9AAAA8AAABQ0AAAUNAAAA4AAABR0AAAa9AAAA8AAABs0AAAbNAAAA4AAABt0AAAh9AAAA8AAACI0AAAiNAAAA4AAACJ0AAAo9AAAA8AAACk0AAApNAAAA4AAACl0AAAv9AAAA8AAADA0AAAwNAAAA4AAADB0AAA29AAAA8AAADc0AAA3NAAAA4AAADd0AAA99AAAA8AAAD40AAA+NAAAA4AAAD50AAAE9EAAA8AAAAU0QAAFNEAAA4AAAAV0QAAL9EAAA8AAAAw0QAAMNEAAA4AAAAx0QAAS9EAAA8AAABM0QAATNEAAA4AAABN0QAAZ9EAAA8AAABo0QAAaNEAAA4AAABp0QAAg9EAAA8AAACE0QAAhNEAAA4AAACF0QAAn9EAAA8AAACg0QAAoNEAAA4AAACh0QAAu9EAAA8AAAC80QAAvNEAAA4AAAC90QAA19EAAA8AAADY0QAA2NEAAA4AAADZ0QAA89EAAA8AAAD00QAA9NEAAA4AAAD10QAAD9IAAA8AAAAQ0gAAENIAAA4AAAAR0gAAK9IAAA8AAAAs0gAALNIAAA4AAAAt0gAAR9IAAA8AAABI0gAASNIAAA4AAABJ0gAAY9IAAA8AAABk0gAAZNIAAA4AAABl0gAAf9IAAA8AAACA0gAAgNIAAA4AAACB0gAAm9IAAA8AAACc0gAAnNIAAA4AAACd0gAAt9IAAA8AAAC40gAAuNIAAA4AAAC50gAA09IAAA8AAADU0gAA1NIAAA4AAADV0gAA79IAAA8AAADw0gAA8NIAAA4AAADx0gAAC9MAAA8AAAAM0wAADNMAAA4AAAAN0wAAJ9MAAA8AAAAo0wAAKNMAAA4AAAAp0wAAQ9MAAA8AAABE0wAARNMAAA4AAABF0wAAX9MAAA8AAABg0wAAYNMAAA4AAABh0wAAe9MAAA8AAAB80wAAfNMAAA4AAAB90wAAl9MAAA8AAACY0wAAmNMAAA4AAACZ0wAAs9MAAA8AAAC00wAAtNMAAA4AAAC10wAAz9MAAA8AAADQ0wAA0NMAAA4AAADR0wAA69MAAA8AAADs0wAA7NMAAA4AAADt0wAAB9QAAA8AAAAI1AAACNQAAA4AAAAJ1AAAI9QAAA8AAAAk1AAAJNQAAA4AAAAl1AAAP9QAAA8AAABA1AAAQNQAAA4AAABB1AAAW9QAAA8AAABc1AAAXNQAAA4AAABd1AAAd9QAAA8AAAB41AAAeNQAAA4AAAB51AAAk9QAAA8AAACU1AAAlNQAAA4AAACV1AAAr9QAAA8AAACw1AAAsNQAAA4AAACx1AAAy9QAAA8AAADM1AAAzNQAAA4AAADN1AAA59QAAA8AAADo1AAA6NQAAA4AAADp1AAAA9UAAA8AAAAE1QAABNUAAA4AAAAF1QAAH9UAAA8AAAAg1QAAINUAAA4AAAAh1QAAO9UAAA8AAAA81QAAPNUAAA4AAAA91QAAV9UAAA8AAABY1QAAWNUAAA4AAABZ1QAAc9UAAA8AAAB01QAAdNUAAA4AAAB11QAAj9UAAA8AAACQ1QAAkNUAAA4AAACR1QAAq9UAAA8AAACs1QAArNUAAA4AAACt1QAAx9UAAA8AAADI1QAAyNUAAA4AAADJ1QAA49UAAA8AAADk1QAA5NUAAA4AAADl1QAA/9UAAA8AAAAA1gAAANYAAA4AAAAB1gAAG9YAAA8AAAAc1gAAHNYAAA4AAAAd1gAAN9YAAA8AAAA41gAAONYAAA4AAAA51gAAU9YAAA8AAABU1gAAVNYAAA4AAABV1gAAb9YAAA8AAABw1gAAcNYAAA4AAABx1gAAi9YAAA8AAACM1gAAjNYAAA4AAACN1gAAp9YAAA8AAACo1gAAqNYAAA4AAACp1gAAw9YAAA8AAADE1gAAxNYAAA4AAADF1gAA39YAAA8AAADg1gAA4NYAAA4AAADh1gAA+9YAAA8AAAD81gAA/NYAAA4AAAD91gAAF9cAAA8AAAAY1wAAGNcAAA4AAAAZ1wAAM9cAAA8AAAA01wAANNcAAA4AAAA11wAAT9cAAA8AAABQ1wAAUNcAAA4AAABR1wAAa9cAAA8AAABs1wAAbNcAAA4AAABt1wAAh9cAAA8AAACI1wAAiNcAAA4AAACJ1wAAo9cAAA8AAACw1wAAxtcAABEAAADL1wAA+9cAABAAAAAe+wAAHvsAAAQAAAAA/gAAD/4AAAQAAAAg/gAAL/4AAAQAAAD//gAA//4AAAMAAACe/wAAn/8AAAQAAADw/wAA+/8AAAMAAAD9AQEA/QEBAAQAAADgAgEA4AIBAAQAAAB2AwEAegMBAAQAAAABCgEAAwoBAAQAAAAFCgEABgoBAAQAAAAMCgEADwoBAAQAAAA4CgEAOgoBAAQAAAA/CgEAPwoBAAQAAADlCgEA5goBAAQAAAAkDQEAJw0BAAQAAACrDgEArA4BAAQAAABGDwEAUA8BAAQAAACCDwEAhQ8BAAQAAAAAEAEAABABAAcAAAABEAEAARABAAQAAAACEAEAAhABAAcAAAA4EAEARhABAAQAAABwEAEAcBABAAQAAABzEAEAdBABAAQAAAB/EAEAgRABAAQAAACCEAEAghABAAcAAACwEAEAshABAAcAAACzEAEAthABAAQAAAC3EAEAuBABAAcAAAC5EAEAuhABAAQAAAC9EAEAvRABAAUAAADCEAEAwhABAAQAAADNEAEAzRABAAUAAAAAEQEAAhEBAAQAAAAnEQEAKxEBAAQAAAAsEQEALBEBAAcAAAAtEQEANBEBAAQAAABFEQEARhEBAAcAAABzEQEAcxEBAAQAAACAEQEAgREBAAQAAACCEQEAghEBAAcAAACzEQEAtREBAAcAAAC2EQEAvhEBAAQAAAC/EQEAwBEBAAcAAADCEQEAwxEBAAUAAADJEQEAzBEBAAQAAADOEQEAzhEBAAcAAADPEQEAzxEBAAQAAAAsEgEALhIBAAcAAAAvEgEAMRIBAAQAAAAyEgEAMxIBAAcAAAA0EgEANBIBAAQAAAA1EgEANRIBAAcAAAA2EgEANxIBAAQAAAA+EgEAPhIBAAQAAADfEgEA3xIBAAQAAADgEgEA4hIBAAcAAADjEgEA6hIBAAQAAAAAEwEAARMBAAQAAAACEwEAAxMBAAcAAAA7EwEAPBMBAAQAAAA+EwEAPhMBAAQAAAA/EwEAPxMBAAcAAABAEwEAQBMBAAQAAABBEwEARBMBAAcAAABHEwEASBMBAAcAAABLEwEATRMBAAcAAABXEwEAVxMBAAQAAABiEwEAYxMBAAcAAABmEwEAbBMBAAQAAABwEwEAdBMBAAQAAAA1FAEANxQBAAcAAAA4FAEAPxQBAAQAAABAFAEAQRQBAAcAAABCFAEARBQBAAQAAABFFAEARRQBAAcAAABGFAEARhQBAAQAAABeFAEAXhQBAAQAAACwFAEAsBQBAAQAAACxFAEAshQBAAcAAACzFAEAuBQBAAQAAAC5FAEAuRQBAAcAAAC6FAEAuhQBAAQAAAC7FAEAvBQBAAcAAAC9FAEAvRQBAAQAAAC+FAEAvhQBAAcAAAC/FAEAwBQBAAQAAADBFAEAwRQBAAcAAADCFAEAwxQBAAQAAACvFQEArxUBAAQAAACwFQEAsRUBAAcAAACyFQEAtRUBAAQAAAC4FQEAuxUBAAcAAAC8FQEAvRUBAAQAAAC+FQEAvhUBAAcAAAC/FQEAwBUBAAQAAADcFQEA3RUBAAQAAAAwFgEAMhYBAAcAAAAzFgEAOhYBAAQAAAA7FgEAPBYBAAcAAAA9FgEAPRYBAAQAAAA+FgEAPhYBAAcAAAA/FgEAQBYBAAQAAACrFgEAqxYBAAQAAACsFgEArBYBAAcAAACtFgEArRYBAAQAAACuFgEArxYBAAcAAACwFgEAtRYBAAQAAAC2FgEAthYBAAcAAAC3FgEAtxYBAAQAAAAdFwEAHxcBAAQAAAAiFwEAJRcBAAQAAAAmFwEAJhcBAAcAAAAnFwEAKxcBAAQAAAAsGAEALhgBAAcAAAAvGAEANxgBAAQAAAA4GAEAOBgBAAcAAAA5GAEAOhgBAAQAAAAwGQEAMBkBAAQAAAAxGQEANRkBAAcAAAA3GQEAOBkBAAcAAAA7GQEAPBkBAAQAAAA9GQEAPRkBAAcAAAA+GQEAPhkBAAQAAAA/GQEAPxkBAAUAAABAGQEAQBkBAAcAAABBGQEAQRkBAAUAAABCGQEAQhkBAAcAAABDGQEAQxkBAAQAAADRGQEA0xkBAAcAAADUGQEA1xkBAAQAAADaGQEA2xkBAAQAAADcGQEA3xkBAAcAAADgGQEA4BkBAAQAAADkGQEA5BkBAAcAAAABGgEAChoBAAQAAAAzGgEAOBoBAAQAAAA5GgEAORoBAAcAAAA6GgEAOhoBAAUAAAA7GgEAPhoBAAQAAABHGgEARxoBAAQAAABRGgEAVhoBAAQAAABXGgEAWBoBAAcAAABZGgEAWxoBAAQAAACEGgEAiRoBAAUAAACKGgEAlhoBAAQAAACXGgEAlxoBAAcAAACYGgEAmRoBAAQAAAAvHAEALxwBAAcAAAAwHAEANhwBAAQAAAA4HAEAPRwBAAQAAAA+HAEAPhwBAAcAAAA/HAEAPxwBAAQAAACSHAEApxwBAAQAAACpHAEAqRwBAAcAAACqHAEAsBwBAAQAAACxHAEAsRwBAAcAAACyHAEAsxwBAAQAAAC0HAEAtBwBAAcAAAC1HAEAthwBAAQAAAAxHQEANh0BAAQAAAA6HQEAOh0BAAQAAAA8HQEAPR0BAAQAAAA/HQEARR0BAAQAAABGHQEARh0BAAUAAABHHQEARx0BAAQAAACKHQEAjh0BAAcAAACQHQEAkR0BAAQAAACTHQEAlB0BAAcAAACVHQEAlR0BAAQAAACWHQEAlh0BAAcAAACXHQEAlx0BAAQAAADzHgEA9B4BAAQAAAD1HgEA9h4BAAcAAAAwNAEAODQBAAMAAADwagEA9GoBAAQAAAAwawEANmsBAAQAAABPbwEAT28BAAQAAABRbwEAh28BAAcAAACPbwEAkm8BAAQAAADkbwEA5G8BAAQAAADwbwEA8W8BAAcAAACdvAEAnrwBAAQAAACgvAEAo7wBAAMAAAAAzwEALc8BAAQAAAAwzwEARs8BAAQAAABl0QEAZdEBAAQAAABm0QEAZtEBAAcAAABn0QEAadEBAAQAAABt0QEAbdEBAAcAAABu0QEActEBAAQAAABz0QEAetEBAAMAAAB70QEAgtEBAAQAAACF0QEAi9EBAAQAAACq0QEArdEBAAQAAABC0gEARNIBAAQAAAAA2gEANtoBAAQAAAA72gEAbNoBAAQAAAB12gEAddoBAAQAAACE2gEAhNoBAAQAAACb2gEAn9oBAAQAAACh2gEAr9oBAAQAAAAA4AEABuABAAQAAAAI4AEAGOABAAQAAAAb4AEAIeABAAQAAAAj4AEAJOABAAQAAAAm4AEAKuABAAQAAAAw4QEANuEBAAQAAACu4gEAruIBAAQAAADs4gEA7+IBAAQAAADQ6AEA1ugBAAQAAABE6QEASukBAAQAAADm8QEA//EBAAYAAAD78wEA//MBAAQAAAAAAA4AHwAOAAMAAAAgAA4AfwAOAAQAAACAAA4A/wAOAAMAAAAAAQ4A7wEOAAQAAADwAQ4A/w8OAAMAAAABAAAACgAAAAoAAADSAgAAQQAAAFoAAABhAAAAegAAAKoAAACqAAAAtQAAALUAAAC6AAAAugAAAMAAAADWAAAA2AAAAPYAAAD4AAAAwQIAAMYCAADRAgAA4AIAAOQCAADsAgAA7AIAAO4CAADuAgAARQMAAEUDAABwAwAAdAMAAHYDAAB3AwAAegMAAH0DAAB/AwAAfwMAAIYDAACGAwAAiAMAAIoDAACMAwAAjAMAAI4DAAChAwAAowMAAPUDAAD3AwAAgQQAAIoEAAAvBQAAMQUAAFYFAABZBQAAWQUAAGAFAACIBQAAsAUAAL0FAAC/BQAAvwUAAMEFAADCBQAAxAUAAMUFAADHBQAAxwUAANAFAADqBQAA7wUAAPIFAAAQBgAAGgYAACAGAABXBgAAWQYAAF8GAABuBgAA0wYAANUGAADcBgAA4QYAAOgGAADtBgAA7wYAAPoGAAD8BgAA/wYAAP8GAAAQBwAAPwcAAE0HAACxBwAAygcAAOoHAAD0BwAA9QcAAPoHAAD6BwAAAAgAABcIAAAaCAAALAgAAEAIAABYCAAAYAgAAGoIAABwCAAAhwgAAIkIAACOCAAAoAgAAMkIAADUCAAA3wgAAOMIAADpCAAA8AgAADsJAAA9CQAATAkAAE4JAABQCQAAVQkAAGMJAABxCQAAgwkAAIUJAACMCQAAjwkAAJAJAACTCQAAqAkAAKoJAACwCQAAsgkAALIJAAC2CQAAuQkAAL0JAADECQAAxwkAAMgJAADLCQAAzAkAAM4JAADOCQAA1wkAANcJAADcCQAA3QkAAN8JAADjCQAA8AkAAPEJAAD8CQAA/AkAAAEKAAADCgAABQoAAAoKAAAPCgAAEAoAABMKAAAoCgAAKgoAADAKAAAyCgAAMwoAADUKAAA2CgAAOAoAADkKAAA+CgAAQgoAAEcKAABICgAASwoAAEwKAABRCgAAUQoAAFkKAABcCgAAXgoAAF4KAABwCgAAdQoAAIEKAACDCgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvQoAAMUKAADHCgAAyQoAAMsKAADMCgAA0AoAANAKAADgCgAA4woAAPkKAAD8CgAAAQsAAAMLAAAFCwAADAsAAA8LAAAQCwAAEwsAACgLAAAqCwAAMAsAADILAAAzCwAANQsAADkLAAA9CwAARAsAAEcLAABICwAASwsAAEwLAABWCwAAVwsAAFwLAABdCwAAXwsAAGMLAABxCwAAcQsAAIILAACDCwAAhQsAAIoLAACOCwAAkAsAAJILAACVCwAAmQsAAJoLAACcCwAAnAsAAJ4LAACfCwAAowsAAKQLAACoCwAAqgsAAK4LAAC5CwAAvgsAAMILAADGCwAAyAsAAMoLAADMCwAA0AsAANALAADXCwAA1wsAAAAMAAADDAAABQwAAAwMAAAODAAAEAwAABIMAAAoDAAAKgwAADkMAAA9DAAARAwAAEYMAABIDAAASgwAAEwMAABVDAAAVgwAAFgMAABaDAAAXQwAAF0MAABgDAAAYwwAAIAMAACDDAAAhQwAAIwMAACODAAAkAwAAJIMAACoDAAAqgwAALMMAAC1DAAAuQwAAL0MAADEDAAAxgwAAMgMAADKDAAAzAwAANUMAADWDAAA3QwAAN4MAADgDAAA4wwAAPEMAADyDAAAAA0AAAwNAAAODQAAEA0AABINAAA6DQAAPQ0AAEQNAABGDQAASA0AAEoNAABMDQAATg0AAE4NAABUDQAAVw0AAF8NAABjDQAAeg0AAH8NAACBDQAAgw0AAIUNAACWDQAAmg0AALENAACzDQAAuw0AAL0NAAC9DQAAwA0AAMYNAADPDQAA1A0AANYNAADWDQAA2A0AAN8NAADyDQAA8w0AAAEOAAA6DgAAQA4AAEYOAABNDgAATQ4AAIEOAACCDgAAhA4AAIQOAACGDgAAig4AAIwOAACjDgAApQ4AAKUOAACnDgAAuQ4AALsOAAC9DgAAwA4AAMQOAADGDgAAxg4AAM0OAADNDgAA3A4AAN8OAAAADwAAAA8AAEAPAABHDwAASQ8AAGwPAABxDwAAgQ8AAIgPAACXDwAAmQ8AALwPAAAAEAAANhAAADgQAAA4EAAAOxAAAD8QAABQEAAAjxAAAJoQAACdEAAAoBAAAMUQAADHEAAAxxAAAM0QAADNEAAA0BAAAPoQAAD8EAAASBIAAEoSAABNEgAAUBIAAFYSAABYEgAAWBIAAFoSAABdEgAAYBIAAIgSAACKEgAAjRIAAJASAACwEgAAshIAALUSAAC4EgAAvhIAAMASAADAEgAAwhIAAMUSAADIEgAA1hIAANgSAAAQEwAAEhMAABUTAAAYEwAAWhMAAIATAACPEwAAoBMAAPUTAAD4EwAA/RMAAAEUAABsFgAAbxYAAH8WAACBFgAAmhYAAKAWAADqFgAA7hYAAPgWAAAAFwAAExcAAB8XAAAzFwAAQBcAAFMXAABgFwAAbBcAAG4XAABwFwAAchcAAHMXAACAFwAAsxcAALYXAADIFwAA1xcAANcXAADcFwAA3BcAACAYAAB4GAAAgBgAAKoYAACwGAAA9RgAAAAZAAAeGQAAIBkAACsZAAAwGQAAOBkAAFAZAABtGQAAcBkAAHQZAACAGQAAqxkAALAZAADJGQAAABoAABsaAAAgGgAAXhoAAGEaAAB0GgAApxoAAKcaAAC/GgAAwBoAAMwaAADOGgAAABsAADMbAAA1GwAAQxsAAEUbAABMGwAAgBsAAKkbAACsGwAArxsAALobAADlGwAA5xsAAPEbAAAAHAAANhwAAE0cAABPHAAAWhwAAH0cAACAHAAAiBwAAJAcAAC6HAAAvRwAAL8cAADpHAAA7BwAAO4cAADzHAAA9RwAAPYcAAD6HAAA+hwAAAAdAAC/HQAA5x0AAPQdAAAAHgAAFR8AABgfAAAdHwAAIB8AAEUfAABIHwAATR8AAFAfAABXHwAAWR8AAFkfAABbHwAAWx8AAF0fAABdHwAAXx8AAH0fAACAHwAAtB8AALYfAAC8HwAAvh8AAL4fAADCHwAAxB8AAMYfAADMHwAA0B8AANMfAADWHwAA2x8AAOAfAADsHwAA8h8AAPQfAAD2HwAA/B8AAHEgAABxIAAAfyAAAH8gAACQIAAAnCAAAAIhAAACIQAAByEAAAchAAAKIQAAEyEAABUhAAAVIQAAGSEAAB0hAAAkIQAAJCEAACYhAAAmIQAAKCEAACghAAAqIQAALSEAAC8hAAA5IQAAPCEAAD8hAABFIQAASSEAAE4hAABOIQAAYCEAAIghAAC2JAAA6SQAAAAsAADkLAAA6ywAAO4sAADyLAAA8ywAAAAtAAAlLQAAJy0AACctAAAtLQAALS0AADAtAABnLQAAby0AAG8tAACALQAAli0AAKAtAACmLQAAqC0AAK4tAACwLQAAti0AALgtAAC+LQAAwC0AAMYtAADILQAAzi0AANAtAADWLQAA2C0AAN4tAADgLQAA/y0AAC8uAAAvLgAABTAAAAcwAAAhMAAAKTAAADEwAAA1MAAAODAAADwwAABBMAAAljAAAJ0wAACfMAAAoTAAAPowAAD8MAAA/zAAAAUxAAAvMQAAMTEAAI4xAACgMQAAvzEAAPAxAAD/MQAAADQAAL9NAAAATgAAjKQAANCkAAD9pAAAAKUAAAymAAAQpgAAH6YAACqmAAArpgAAQKYAAG6mAAB0pgAAe6YAAH+mAADvpgAAF6cAAB+nAAAipwAAiKcAAIunAADKpwAA0KcAANGnAADTpwAA06cAANWnAADZpwAA8qcAAAWoAAAHqAAAJ6gAAECoAABzqAAAgKgAAMOoAADFqAAAxagAAPKoAAD3qAAA+6gAAPuoAAD9qAAA/6gAAAqpAAAqqQAAMKkAAFKpAABgqQAAfKkAAICpAACyqQAAtKkAAL+pAADPqQAAz6kAAOCpAADvqQAA+qkAAP6pAAAAqgAANqoAAECqAABNqgAAYKoAAHaqAAB6qgAAvqoAAMCqAADAqgAAwqoAAMKqAADbqgAA3aoAAOCqAADvqgAA8qoAAPWqAAABqwAABqsAAAmrAAAOqwAAEasAABarAAAgqwAAJqsAACirAAAuqwAAMKsAAFqrAABcqwAAaasAAHCrAADqqwAAAKwAAKPXAACw1wAAxtcAAMvXAAD71wAAAPkAAG36AABw+gAA2foAAAD7AAAG+wAAE/sAABf7AAAd+wAAKPsAACr7AAA2+wAAOPsAADz7AAA++wAAPvsAAED7AABB+wAAQ/sAAET7AABG+wAAsfsAANP7AAA9/QAAUP0AAI/9AACS/QAAx/0AAPD9AAD7/QAAcP4AAHT+AAB2/gAA/P4AACH/AAA6/wAAQf8AAFr/AABm/wAAvv8AAML/AADH/wAAyv8AAM//AADS/wAA1/8AANr/AADc/wAAAAABAAsAAQANAAEAJgABACgAAQA6AAEAPAABAD0AAQA/AAEATQABAFAAAQBdAAEAgAABAPoAAQBAAQEAdAEBAIACAQCcAgEAoAIBANACAQAAAwEAHwMBAC0DAQBKAwEAUAMBAHoDAQCAAwEAnQMBAKADAQDDAwEAyAMBAM8DAQDRAwEA1QMBAAAEAQCdBAEAsAQBANMEAQDYBAEA+wQBAAAFAQAnBQEAMAUBAGMFAQBwBQEAegUBAHwFAQCKBQEAjAUBAJIFAQCUBQEAlQUBAJcFAQChBQEAowUBALEFAQCzBQEAuQUBALsFAQC8BQEAAAYBADYHAQBABwEAVQcBAGAHAQBnBwEAgAcBAIUHAQCHBwEAsAcBALIHAQC6BwEAAAgBAAUIAQAICAEACAgBAAoIAQA1CAEANwgBADgIAQA8CAEAPAgBAD8IAQBVCAEAYAgBAHYIAQCACAEAnggBAOAIAQDyCAEA9AgBAPUIAQAACQEAFQkBACAJAQA5CQEAgAkBALcJAQC+CQEAvwkBAAAKAQADCgEABQoBAAYKAQAMCgEAEwoBABUKAQAXCgEAGQoBADUKAQBgCgEAfAoBAIAKAQCcCgEAwAoBAMcKAQDJCgEA5AoBAAALAQA1CwEAQAsBAFULAQBgCwEAcgsBAIALAQCRCwEAAAwBAEgMAQCADAEAsgwBAMAMAQDyDAEAAA0BACcNAQCADgEAqQ4BAKsOAQCsDgEAsA4BALEOAQAADwEAHA8BACcPAQAnDwEAMA8BAEUPAQBwDwEAgQ8BALAPAQDEDwEA4A8BAPYPAQAAEAEARRABAHEQAQB1EAEAghABALgQAQDCEAEAwhABANAQAQDoEAEAABEBADIRAQBEEQEARxEBAFARAQByEQEAdhEBAHYRAQCAEQEAvxEBAMERAQDEEQEAzhEBAM8RAQDaEQEA2hEBANwRAQDcEQEAABIBABESAQATEgEANBIBADcSAQA3EgEAPhIBAD4SAQCAEgEAhhIBAIgSAQCIEgEAihIBAI0SAQCPEgEAnRIBAJ8SAQCoEgEAsBIBAOgSAQAAEwEAAxMBAAUTAQAMEwEADxMBABATAQATEwEAKBMBACoTAQAwEwEAMhMBADMTAQA1EwEAORMBAD0TAQBEEwEARxMBAEgTAQBLEwEATBMBAFATAQBQEwEAVxMBAFcTAQBdEwEAYxMBAAAUAQBBFAEAQxQBAEUUAQBHFAEAShQBAF8UAQBhFAEAgBQBAMEUAQDEFAEAxRQBAMcUAQDHFAEAgBUBALUVAQC4FQEAvhUBANgVAQDdFQEAABYBAD4WAQBAFgEAQBYBAEQWAQBEFgEAgBYBALUWAQC4FgEAuBYBAAAXAQAaFwEAHRcBACoXAQBAFwEARhcBAAAYAQA4GAEAoBgBAN8YAQD/GAEABhkBAAkZAQAJGQEADBkBABMZAQAVGQEAFhkBABgZAQA1GQEANxkBADgZAQA7GQEAPBkBAD8ZAQBCGQEAoBkBAKcZAQCqGQEA1xkBANoZAQDfGQEA4RkBAOEZAQDjGQEA5BkBAAAaAQAyGgEANRoBAD4aAQBQGgEAlxoBAJ0aAQCdGgEAsBoBAPgaAQAAHAEACBwBAAocAQA2HAEAOBwBAD4cAQBAHAEAQBwBAHIcAQCPHAEAkhwBAKccAQCpHAEAthwBAAAdAQAGHQEACB0BAAkdAQALHQEANh0BADodAQA6HQEAPB0BAD0dAQA/HQEAQR0BAEMdAQBDHQEARh0BAEcdAQBgHQEAZR0BAGcdAQBoHQEAah0BAI4dAQCQHQEAkR0BAJMdAQCWHQEAmB0BAJgdAQDgHgEA9h4BALAfAQCwHwEAACABAJkjAQAAJAEAbiQBAIAkAQBDJQEAkC8BAPAvAQAAMAEALjQBAABEAQBGRgEAAGgBADhqAQBAagEAXmoBAHBqAQC+agEA0GoBAO1qAQAAawEAL2sBAEBrAQBDawEAY2sBAHdrAQB9awEAj2sBAEBuAQB/bgEAAG8BAEpvAQBPbwEAh28BAI9vAQCfbwEA4G8BAOFvAQDjbwEA428BAPBvAQDxbwEAAHABAPeHAQAAiAEA1YwBAACNAQAIjQEA8K8BAPOvAQD1rwEA+68BAP2vAQD+rwEAALABACKxAQBQsQEAUrEBAGSxAQBnsQEAcLEBAPuyAQAAvAEAarwBAHC8AQB8vAEAgLwBAIi8AQCQvAEAmbwBAJ68AQCevAEAANQBAFTUAQBW1AEAnNQBAJ7UAQCf1AEAotQBAKLUAQCl1AEAptQBAKnUAQCs1AEArtQBALnUAQC71AEAu9QBAL3UAQDD1AEAxdQBAAXVAQAH1QEACtUBAA3VAQAU1QEAFtUBABzVAQAe1QEAOdUBADvVAQA+1QEAQNUBAETVAQBG1QEARtUBAErVAQBQ1QEAUtUBAKXWAQCo1gEAwNYBAMLWAQDa1gEA3NYBAPrWAQD81gEAFNcBABbXAQA01wEANtcBAE7XAQBQ1wEAbtcBAHDXAQCI1wEAitcBAKjXAQCq1wEAwtcBAMTXAQDL1wEAAN8BAB7fAQAA4AEABuABAAjgAQAY4AEAG+ABACHgAQAj4AEAJOABACbgAQAq4AEAAOEBACzhAQA34QEAPeEBAE7hAQBO4QEAkOIBAK3iAQDA4gEA6+IBAODnAQDm5wEA6OcBAOvnAQDt5wEA7ucBAPDnAQD+5wEAAOgBAMToAQAA6QEAQ+kBAEfpAQBH6QEAS+kBAEvpAQAA7gEAA+4BAAXuAQAf7gEAIe4BACLuAQAk7gEAJO4BACfuAQAn7gEAKe4BADLuAQA07gEAN+4BADnuAQA57gEAO+4BADvuAQBC7gEAQu4BAEfuAQBH7gEASe4BAEnuAQBL7gEAS+4BAE3uAQBP7gEAUe4BAFLuAQBU7gEAVO4BAFfuAQBX7gEAWe4BAFnuAQBb7gEAW+4BAF3uAQBd7gEAX+4BAF/uAQBh7gEAYu4BAGTuAQBk7gEAZ+4BAGruAQBs7gEAcu4BAHTuAQB37gEAee4BAHzuAQB+7gEAfu4BAIDuAQCJ7gEAi+4BAJvuAQCh7gEAo+4BAKXuAQCp7gEAq+4BALvuAQAw8QEASfEBAFDxAQBp8QEAcPEBAInxAQAAAAIA36YCAACnAgA4twIAQLcCAB24AgAguAIAoc4CALDOAgDg6wIAAPgCAB36AgAAAAMAShMDAEHwxAILQggAAAAJAAAACQAAACAAAAAgAAAAoAAAAKAAAACAFgAAgBYAAAAgAAAKIAAALyAAAC8gAABfIAAAXyAAAAAwAAAAMABBwMUCCxECAAAAAAAAAB8AAAB/AAAAnwBB4MUCC/MDPgAAADAAAAA5AAAAYAYAAGkGAADwBgAA+QYAAMAHAADJBwAAZgkAAG8JAADmCQAA7wkAAGYKAABvCgAA5goAAO8KAABmCwAAbwsAAOYLAADvCwAAZgwAAG8MAADmDAAA7wwAAGYNAABvDQAA5g0AAO8NAABQDgAAWQ4AANAOAADZDgAAIA8AACkPAABAEAAASRAAAJAQAACZEAAA4BcAAOkXAAAQGAAAGRgAAEYZAABPGQAA0BkAANkZAACAGgAAiRoAAJAaAACZGgAAUBsAAFkbAACwGwAAuRsAAEAcAABJHAAAUBwAAFkcAAAgpgAAKaYAANCoAADZqAAAAKkAAAmpAADQqQAA2akAAPCpAAD5qQAAUKoAAFmqAADwqwAA+asAABD/AAAZ/wAAoAQBAKkEAQAwDQEAOQ0BAGYQAQBvEAEA8BABAPkQAQA2EQEAPxEBANARAQDZEQEA8BIBAPkSAQBQFAEAWRQBANAUAQDZFAEAUBYBAFkWAQDAFgEAyRYBADAXAQA5FwEA4BgBAOkYAQBQGQEAWRkBAFAcAQBZHAEAUB0BAFkdAQCgHQEAqR0BAGBqAQBpagEAwGoBAMlqAQBQawEAWWsBAM7XAQD/1wEAQOEBAEnhAQDw4gEA+eIBAFDpAQBZ6QEA8PsBAPn7AQBB4MkCC+NVvwIAACEAAAB+AAAAoQAAAHcDAAB6AwAAfwMAAIQDAACKAwAAjAMAAIwDAACOAwAAoQMAAKMDAAAvBQAAMQUAAFYFAABZBQAAigUAAI0FAACPBQAAkQUAAMcFAADQBQAA6gUAAO8FAAD0BQAAAAYAAA0HAAAPBwAASgcAAE0HAACxBwAAwAcAAPoHAAD9BwAALQgAADAIAAA+CAAAQAgAAFsIAABeCAAAXggAAGAIAABqCAAAcAgAAI4IAACQCAAAkQgAAJgIAACDCQAAhQkAAIwJAACPCQAAkAkAAJMJAACoCQAAqgkAALAJAACyCQAAsgkAALYJAAC5CQAAvAkAAMQJAADHCQAAyAkAAMsJAADOCQAA1wkAANcJAADcCQAA3QkAAN8JAADjCQAA5gkAAP4JAAABCgAAAwoAAAUKAAAKCgAADwoAABAKAAATCgAAKAoAACoKAAAwCgAAMgoAADMKAAA1CgAANgoAADgKAAA5CgAAPAoAADwKAAA+CgAAQgoAAEcKAABICgAASwoAAE0KAABRCgAAUQoAAFkKAABcCgAAXgoAAF4KAABmCgAAdgoAAIEKAACDCgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvAoAAMUKAADHCgAAyQoAAMsKAADNCgAA0AoAANAKAADgCgAA4woAAOYKAADxCgAA+QoAAP8KAAABCwAAAwsAAAULAAAMCwAADwsAABALAAATCwAAKAsAACoLAAAwCwAAMgsAADMLAAA1CwAAOQsAADwLAABECwAARwsAAEgLAABLCwAATQsAAFULAABXCwAAXAsAAF0LAABfCwAAYwsAAGYLAAB3CwAAggsAAIMLAACFCwAAigsAAI4LAACQCwAAkgsAAJULAACZCwAAmgsAAJwLAACcCwAAngsAAJ8LAACjCwAApAsAAKgLAACqCwAArgsAALkLAAC+CwAAwgsAAMYLAADICwAAygsAAM0LAADQCwAA0AsAANcLAADXCwAA5gsAAPoLAAAADAAADAwAAA4MAAAQDAAAEgwAACgMAAAqDAAAOQwAADwMAABEDAAARgwAAEgMAABKDAAATQwAAFUMAABWDAAAWAwAAFoMAABdDAAAXQwAAGAMAABjDAAAZgwAAG8MAAB3DAAAjAwAAI4MAACQDAAAkgwAAKgMAACqDAAAswwAALUMAAC5DAAAvAwAAMQMAADGDAAAyAwAAMoMAADNDAAA1QwAANYMAADdDAAA3gwAAOAMAADjDAAA5gwAAO8MAADxDAAA8gwAAAANAAAMDQAADg0AABANAAASDQAARA0AAEYNAABIDQAASg0AAE8NAABUDQAAYw0AAGYNAAB/DQAAgQ0AAIMNAACFDQAAlg0AAJoNAACxDQAAsw0AALsNAAC9DQAAvQ0AAMANAADGDQAAyg0AAMoNAADPDQAA1A0AANYNAADWDQAA2A0AAN8NAADmDQAA7w0AAPINAAD0DQAAAQ4AADoOAAA/DgAAWw4AAIEOAACCDgAAhA4AAIQOAACGDgAAig4AAIwOAACjDgAApQ4AAKUOAACnDgAAvQ4AAMAOAADEDgAAxg4AAMYOAADIDgAAzQ4AANAOAADZDgAA3A4AAN8OAAAADwAARw8AAEkPAABsDwAAcQ8AAJcPAACZDwAAvA8AAL4PAADMDwAAzg8AANoPAAAAEAAAxRAAAMcQAADHEAAAzRAAAM0QAADQEAAASBIAAEoSAABNEgAAUBIAAFYSAABYEgAAWBIAAFoSAABdEgAAYBIAAIgSAACKEgAAjRIAAJASAACwEgAAshIAALUSAAC4EgAAvhIAAMASAADAEgAAwhIAAMUSAADIEgAA1hIAANgSAAAQEwAAEhMAABUTAAAYEwAAWhMAAF0TAAB8EwAAgBMAAJkTAACgEwAA9RMAAPgTAAD9EwAAABQAAH8WAACBFgAAnBYAAKAWAAD4FgAAABcAABUXAAAfFwAANhcAAEAXAABTFwAAYBcAAGwXAABuFwAAcBcAAHIXAABzFwAAgBcAAN0XAADgFwAA6RcAAPAXAAD5FwAAABgAABkYAAAgGAAAeBgAAIAYAACqGAAAsBgAAPUYAAAAGQAAHhkAACAZAAArGQAAMBkAADsZAABAGQAAQBkAAEQZAABtGQAAcBkAAHQZAACAGQAAqxkAALAZAADJGQAA0BkAANoZAADeGQAAGxoAAB4aAABeGgAAYBoAAHwaAAB/GgAAiRoAAJAaAACZGgAAoBoAAK0aAACwGgAAzhoAAAAbAABMGwAAUBsAAH4bAACAGwAA8xsAAPwbAAA3HAAAOxwAAEkcAABNHAAAiBwAAJAcAAC6HAAAvRwAAMccAADQHAAA+hwAAAAdAAAVHwAAGB8AAB0fAAAgHwAARR8AAEgfAABNHwAAUB8AAFcfAABZHwAAWR8AAFsfAABbHwAAXR8AAF0fAABfHwAAfR8AAIAfAAC0HwAAth8AAMQfAADGHwAA0x8AANYfAADbHwAA3R8AAO8fAADyHwAA9B8AAPYfAAD+HwAACyAAACcgAAAqIAAALiAAADAgAABeIAAAYCAAAGQgAABmIAAAcSAAAHQgAACOIAAAkCAAAJwgAACgIAAAwCAAANAgAADwIAAAACEAAIshAACQIQAAJiQAAEAkAABKJAAAYCQAAHMrAAB2KwAAlSsAAJcrAADzLAAA+SwAACUtAAAnLQAAJy0AAC0tAAAtLQAAMC0AAGctAABvLQAAcC0AAH8tAACWLQAAoC0AAKYtAACoLQAAri0AALAtAAC2LQAAuC0AAL4tAADALQAAxi0AAMgtAADOLQAA0C0AANYtAADYLQAA3i0AAOAtAABdLgAAgC4AAJkuAACbLgAA8y4AAAAvAADVLwAA8C8AAPsvAAABMAAAPzAAAEEwAACWMAAAmTAAAP8wAAAFMQAALzEAADExAACOMQAAkDEAAOMxAADwMQAAHjIAACAyAACMpAAAkKQAAMakAADQpAAAK6YAAECmAAD3pgAAAKcAAMqnAADQpwAA0acAANOnAADTpwAA1acAANmnAADypwAALKgAADCoAAA5qAAAQKgAAHeoAACAqAAAxagAAM6oAADZqAAA4KgAAFOpAABfqQAAfKkAAICpAADNqQAAz6kAANmpAADeqQAA/qkAAACqAAA2qgAAQKoAAE2qAABQqgAAWaoAAFyqAADCqgAA26oAAPaqAAABqwAABqsAAAmrAAAOqwAAEasAABarAAAgqwAAJqsAACirAAAuqwAAMKsAAGurAABwqwAA7asAAPCrAAD5qwAAAKwAAKPXAACw1wAAxtcAAMvXAAD71wAAAOAAAG36AABw+gAA2foAAAD7AAAG+wAAE/sAABf7AAAd+wAANvsAADj7AAA8+wAAPvsAAD77AABA+wAAQfsAAEP7AABE+wAARvsAAML7AADT+wAAj/0AAJL9AADH/QAAz/0AAM/9AADw/QAAGf4AACD+AABS/gAAVP4AAGb+AABo/gAAa/4AAHD+AAB0/gAAdv4AAPz+AAD//gAA//4AAAH/AAC+/wAAwv8AAMf/AADK/wAAz/8AANL/AADX/wAA2v8AANz/AADg/wAA5v8AAOj/AADu/wAA+f8AAP3/AAAAAAEACwABAA0AAQAmAAEAKAABADoAAQA8AAEAPQABAD8AAQBNAAEAUAABAF0AAQCAAAEA+gABAAABAQACAQEABwEBADMBAQA3AQEAjgEBAJABAQCcAQEAoAEBAKABAQDQAQEA/QEBAIACAQCcAgEAoAIBANACAQDgAgEA+wIBAAADAQAjAwEALQMBAEoDAQBQAwEAegMBAIADAQCdAwEAnwMBAMMDAQDIAwEA1QMBAAAEAQCdBAEAoAQBAKkEAQCwBAEA0wQBANgEAQD7BAEAAAUBACcFAQAwBQEAYwUBAG8FAQB6BQEAfAUBAIoFAQCMBQEAkgUBAJQFAQCVBQEAlwUBAKEFAQCjBQEAsQUBALMFAQC5BQEAuwUBALwFAQAABgEANgcBAEAHAQBVBwEAYAcBAGcHAQCABwEAhQcBAIcHAQCwBwEAsgcBALoHAQAACAEABQgBAAgIAQAICAEACggBADUIAQA3CAEAOAgBADwIAQA8CAEAPwgBAFUIAQBXCAEAnggBAKcIAQCvCAEA4AgBAPIIAQD0CAEA9QgBAPsIAQAbCQEAHwkBADkJAQA/CQEAPwkBAIAJAQC3CQEAvAkBAM8JAQDSCQEAAwoBAAUKAQAGCgEADAoBABMKAQAVCgEAFwoBABkKAQA1CgEAOAoBADoKAQA/CgEASAoBAFAKAQBYCgEAYAoBAJ8KAQDACgEA5goBAOsKAQD2CgEAAAsBADULAQA5CwEAVQsBAFgLAQByCwEAeAsBAJELAQCZCwEAnAsBAKkLAQCvCwEAAAwBAEgMAQCADAEAsgwBAMAMAQDyDAEA+gwBACcNAQAwDQEAOQ0BAGAOAQB+DgEAgA4BAKkOAQCrDgEArQ4BALAOAQCxDgEAAA8BACcPAQAwDwEAWQ8BAHAPAQCJDwEAsA8BAMsPAQDgDwEA9g8BAAAQAQBNEAEAUhABAHUQAQB/EAEAwhABAM0QAQDNEAEA0BABAOgQAQDwEAEA+RABAAARAQA0EQEANhEBAEcRAQBQEQEAdhEBAIARAQDfEQEA4REBAPQRAQAAEgEAERIBABMSAQA+EgEAgBIBAIYSAQCIEgEAiBIBAIoSAQCNEgEAjxIBAJ0SAQCfEgEAqRIBALASAQDqEgEA8BIBAPkSAQAAEwEAAxMBAAUTAQAMEwEADxMBABATAQATEwEAKBMBACoTAQAwEwEAMhMBADMTAQA1EwEAORMBADsTAQBEEwEARxMBAEgTAQBLEwEATRMBAFATAQBQEwEAVxMBAFcTAQBdEwEAYxMBAGYTAQBsEwEAcBMBAHQTAQAAFAEAWxQBAF0UAQBhFAEAgBQBAMcUAQDQFAEA2RQBAIAVAQC1FQEAuBUBAN0VAQAAFgEARBYBAFAWAQBZFgEAYBYBAGwWAQCAFgEAuRYBAMAWAQDJFgEAABcBABoXAQAdFwEAKxcBADAXAQBGFwEAABgBADsYAQCgGAEA8hgBAP8YAQAGGQEACRkBAAkZAQAMGQEAExkBABUZAQAWGQEAGBkBADUZAQA3GQEAOBkBADsZAQBGGQEAUBkBAFkZAQCgGQEApxkBAKoZAQDXGQEA2hkBAOQZAQAAGgEARxoBAFAaAQCiGgEAsBoBAPgaAQAAHAEACBwBAAocAQA2HAEAOBwBAEUcAQBQHAEAbBwBAHAcAQCPHAEAkhwBAKccAQCpHAEAthwBAAAdAQAGHQEACB0BAAkdAQALHQEANh0BADodAQA6HQEAPB0BAD0dAQA/HQEARx0BAFAdAQBZHQEAYB0BAGUdAQBnHQEAaB0BAGodAQCOHQEAkB0BAJEdAQCTHQEAmB0BAKAdAQCpHQEA4B4BAPgeAQCwHwEAsB8BAMAfAQDxHwEA/x8BAJkjAQAAJAEAbiQBAHAkAQB0JAEAgCQBAEMlAQCQLwEA8i8BAAAwAQAuNAEAMDQBADg0AQAARAEARkYBAABoAQA4agEAQGoBAF5qAQBgagEAaWoBAG5qAQC+agEAwGoBAMlqAQDQagEA7WoBAPBqAQD1agEAAGsBAEVrAQBQawEAWWsBAFtrAQBhawEAY2sBAHdrAQB9awEAj2sBAEBuAQCabgEAAG8BAEpvAQBPbwEAh28BAI9vAQCfbwEA4G8BAORvAQDwbwEA8W8BAABwAQD3hwEAAIgBANWMAQAAjQEACI0BAPCvAQDzrwEA9a8BAPuvAQD9rwEA/q8BAACwAQAisQEAULEBAFKxAQBksQEAZ7EBAHCxAQD7sgEAALwBAGq8AQBwvAEAfLwBAIC8AQCIvAEAkLwBAJm8AQCcvAEAo7wBAADPAQAtzwEAMM8BAEbPAQBQzwEAw88BAADQAQD10AEAANEBACbRAQAp0QEA6tEBAADSAQBF0gEA4NIBAPPSAQAA0wEAVtMBAGDTAQB40wEAANQBAFTUAQBW1AEAnNQBAJ7UAQCf1AEAotQBAKLUAQCl1AEAptQBAKnUAQCs1AEArtQBALnUAQC71AEAu9QBAL3UAQDD1AEAxdQBAAXVAQAH1QEACtUBAA3VAQAU1QEAFtUBABzVAQAe1QEAOdUBADvVAQA+1QEAQNUBAETVAQBG1QEARtUBAErVAQBQ1QEAUtUBAKXWAQCo1gEAy9cBAM7XAQCL2gEAm9oBAJ/aAQCh2gEAr9oBAADfAQAe3wEAAOABAAbgAQAI4AEAGOABABvgAQAh4AEAI+ABACTgAQAm4AEAKuABAADhAQAs4QEAMOEBAD3hAQBA4QEASeEBAE7hAQBP4QEAkOIBAK7iAQDA4gEA+eIBAP/iAQD/4gEA4OcBAObnAQDo5wEA6+cBAO3nAQDu5wEA8OcBAP7nAQAA6AEAxOgBAMfoAQDW6AEAAOkBAEvpAQBQ6QEAWekBAF7pAQBf6QEAcewBALTsAQAB7QEAPe0BAADuAQAD7gEABe4BAB/uAQAh7gEAIu4BACTuAQAk7gEAJ+4BACfuAQAp7gEAMu4BADTuAQA37gEAOe4BADnuAQA77gEAO+4BAELuAQBC7gEAR+4BAEfuAQBJ7gEASe4BAEvuAQBL7gEATe4BAE/uAQBR7gEAUu4BAFTuAQBU7gEAV+4BAFfuAQBZ7gEAWe4BAFvuAQBb7gEAXe4BAF3uAQBf7gEAX+4BAGHuAQBi7gEAZO4BAGTuAQBn7gEAau4BAGzuAQBy7gEAdO4BAHfuAQB57gEAfO4BAH7uAQB+7gEAgO4BAInuAQCL7gEAm+4BAKHuAQCj7gEApe4BAKnuAQCr7gEAu+4BAPDuAQDx7gEAAPABACvwAQAw8AEAk/ABAKDwAQCu8AEAsfABAL/wAQDB8AEAz/ABANHwAQD18AEAAPEBAK3xAQDm8QEAAvIBABDyAQA78gEAQPIBAEjyAQBQ8gEAUfIBAGDyAQBl8gEAAPMBANf2AQDd9gEA7PYBAPD2AQD89gEAAPcBAHP3AQCA9wEA2PcBAOD3AQDr9wEA8PcBAPD3AQAA+AEAC/gBABD4AQBH+AEAUPgBAFn4AQBg+AEAh/gBAJD4AQCt+AEAsPgBALH4AQAA+QEAU/oBAGD6AQBt+gEAcPoBAHT6AQB4+gEAfPoBAID6AQCG+gEAkPoBAKz6AQCw+gEAuvoBAMD6AQDF+gEA0PoBANn6AQDg+gEA5/oBAPD6AQD2+gEAAPsBAJL7AQCU+wEAyvsBAPD7AQD5+wEAAAACAN+mAgAApwIAOLcCAEC3AgAduAIAILgCAKHOAgCwzgIA4OsCAAD4AgAd+gIAAAADAEoTAwABAA4AAQAOACAADgB/AA4AAAEOAO8BDgAAAA8A/f8PAAAAEAD9/xAAAAAAAJwCAABhAAAAegAAAKoAAACqAAAAtQAAALUAAAC6AAAAugAAAN8AAAD2AAAA+AAAAP8AAAABAQAAAQEAAAMBAAADAQAABQEAAAUBAAAHAQAABwEAAAkBAAAJAQAACwEAAAsBAAANAQAADQEAAA8BAAAPAQAAEQEAABEBAAATAQAAEwEAABUBAAAVAQAAFwEAABcBAAAZAQAAGQEAABsBAAAbAQAAHQEAAB0BAAAfAQAAHwEAACEBAAAhAQAAIwEAACMBAAAlAQAAJQEAACcBAAAnAQAAKQEAACkBAAArAQAAKwEAAC0BAAAtAQAALwEAAC8BAAAxAQAAMQEAADMBAAAzAQAANQEAADUBAAA3AQAAOAEAADoBAAA6AQAAPAEAADwBAAA+AQAAPgEAAEABAABAAQAAQgEAAEIBAABEAQAARAEAAEYBAABGAQAASAEAAEkBAABLAQAASwEAAE0BAABNAQAATwEAAE8BAABRAQAAUQEAAFMBAABTAQAAVQEAAFUBAABXAQAAVwEAAFkBAABZAQAAWwEAAFsBAABdAQAAXQEAAF8BAABfAQAAYQEAAGEBAABjAQAAYwEAAGUBAABlAQAAZwEAAGcBAABpAQAAaQEAAGsBAABrAQAAbQEAAG0BAABvAQAAbwEAAHEBAABxAQAAcwEAAHMBAAB1AQAAdQEAAHcBAAB3AQAAegEAAHoBAAB8AQAAfAEAAH4BAACAAQAAgwEAAIMBAACFAQAAhQEAAIgBAACIAQAAjAEAAI0BAACSAQAAkgEAAJUBAACVAQAAmQEAAJsBAACeAQAAngEAAKEBAAChAQAAowEAAKMBAAClAQAApQEAAKgBAACoAQAAqgEAAKsBAACtAQAArQEAALABAACwAQAAtAEAALQBAAC2AQAAtgEAALkBAAC6AQAAvQEAAL8BAADGAQAAxgEAAMkBAADJAQAAzAEAAMwBAADOAQAAzgEAANABAADQAQAA0gEAANIBAADUAQAA1AEAANYBAADWAQAA2AEAANgBAADaAQAA2gEAANwBAADdAQAA3wEAAN8BAADhAQAA4QEAAOMBAADjAQAA5QEAAOUBAADnAQAA5wEAAOkBAADpAQAA6wEAAOsBAADtAQAA7QEAAO8BAADwAQAA8wEAAPMBAAD1AQAA9QEAAPkBAAD5AQAA+wEAAPsBAAD9AQAA/QEAAP8BAAD/AQAAAQIAAAECAAADAgAAAwIAAAUCAAAFAgAABwIAAAcCAAAJAgAACQIAAAsCAAALAgAADQIAAA0CAAAPAgAADwIAABECAAARAgAAEwIAABMCAAAVAgAAFQIAABcCAAAXAgAAGQIAABkCAAAbAgAAGwIAAB0CAAAdAgAAHwIAAB8CAAAhAgAAIQIAACMCAAAjAgAAJQIAACUCAAAnAgAAJwIAACkCAAApAgAAKwIAACsCAAAtAgAALQIAAC8CAAAvAgAAMQIAADECAAAzAgAAOQIAADwCAAA8AgAAPwIAAEACAABCAgAAQgIAAEcCAABHAgAASQIAAEkCAABLAgAASwIAAE0CAABNAgAATwIAAJMCAACVAgAAuAIAAMACAADBAgAA4AIAAOQCAABFAwAARQMAAHEDAABxAwAAcwMAAHMDAAB3AwAAdwMAAHoDAAB9AwAAkAMAAJADAACsAwAAzgMAANADAADRAwAA1QMAANcDAADZAwAA2QMAANsDAADbAwAA3QMAAN0DAADfAwAA3wMAAOEDAADhAwAA4wMAAOMDAADlAwAA5QMAAOcDAADnAwAA6QMAAOkDAADrAwAA6wMAAO0DAADtAwAA7wMAAPMDAAD1AwAA9QMAAPgDAAD4AwAA+wMAAPwDAAAwBAAAXwQAAGEEAABhBAAAYwQAAGMEAABlBAAAZQQAAGcEAABnBAAAaQQAAGkEAABrBAAAawQAAG0EAABtBAAAbwQAAG8EAABxBAAAcQQAAHMEAABzBAAAdQQAAHUEAAB3BAAAdwQAAHkEAAB5BAAAewQAAHsEAAB9BAAAfQQAAH8EAAB/BAAAgQQAAIEEAACLBAAAiwQAAI0EAACNBAAAjwQAAI8EAACRBAAAkQQAAJMEAACTBAAAlQQAAJUEAACXBAAAlwQAAJkEAACZBAAAmwQAAJsEAACdBAAAnQQAAJ8EAACfBAAAoQQAAKEEAACjBAAAowQAAKUEAAClBAAApwQAAKcEAACpBAAAqQQAAKsEAACrBAAArQQAAK0EAACvBAAArwQAALEEAACxBAAAswQAALMEAAC1BAAAtQQAALcEAAC3BAAAuQQAALkEAAC7BAAAuwQAAL0EAAC9BAAAvwQAAL8EAADCBAAAwgQAAMQEAADEBAAAxgQAAMYEAADIBAAAyAQAAMoEAADKBAAAzAQAAMwEAADOBAAAzwQAANEEAADRBAAA0wQAANMEAADVBAAA1QQAANcEAADXBAAA2QQAANkEAADbBAAA2wQAAN0EAADdBAAA3wQAAN8EAADhBAAA4QQAAOMEAADjBAAA5QQAAOUEAADnBAAA5wQAAOkEAADpBAAA6wQAAOsEAADtBAAA7QQAAO8EAADvBAAA8QQAAPEEAADzBAAA8wQAAPUEAAD1BAAA9wQAAPcEAAD5BAAA+QQAAPsEAAD7BAAA/QQAAP0EAAD/BAAA/wQAAAEFAAABBQAAAwUAAAMFAAAFBQAABQUAAAcFAAAHBQAACQUAAAkFAAALBQAACwUAAA0FAAANBQAADwUAAA8FAAARBQAAEQUAABMFAAATBQAAFQUAABUFAAAXBQAAFwUAABkFAAAZBQAAGwUAABsFAAAdBQAAHQUAAB8FAAAfBQAAIQUAACEFAAAjBQAAIwUAACUFAAAlBQAAJwUAACcFAAApBQAAKQUAACsFAAArBQAALQUAAC0FAAAvBQAALwUAAGAFAACIBQAA0BAAAPoQAAD9EAAA/xAAAPgTAAD9EwAAgBwAAIgcAAAAHQAAvx0AAAEeAAABHgAAAx4AAAMeAAAFHgAABR4AAAceAAAHHgAACR4AAAkeAAALHgAACx4AAA0eAAANHgAADx4AAA8eAAARHgAAER4AABMeAAATHgAAFR4AABUeAAAXHgAAFx4AABkeAAAZHgAAGx4AABseAAAdHgAAHR4AAB8eAAAfHgAAIR4AACEeAAAjHgAAIx4AACUeAAAlHgAAJx4AACceAAApHgAAKR4AACseAAArHgAALR4AAC0eAAAvHgAALx4AADEeAAAxHgAAMx4AADMeAAA1HgAANR4AADceAAA3HgAAOR4AADkeAAA7HgAAOx4AAD0eAAA9HgAAPx4AAD8eAABBHgAAQR4AAEMeAABDHgAARR4AAEUeAABHHgAARx4AAEkeAABJHgAASx4AAEseAABNHgAATR4AAE8eAABPHgAAUR4AAFEeAABTHgAAUx4AAFUeAABVHgAAVx4AAFceAABZHgAAWR4AAFseAABbHgAAXR4AAF0eAABfHgAAXx4AAGEeAABhHgAAYx4AAGMeAABlHgAAZR4AAGceAABnHgAAaR4AAGkeAABrHgAAax4AAG0eAABtHgAAbx4AAG8eAABxHgAAcR4AAHMeAABzHgAAdR4AAHUeAAB3HgAAdx4AAHkeAAB5HgAAex4AAHseAAB9HgAAfR4AAH8eAAB/HgAAgR4AAIEeAACDHgAAgx4AAIUeAACFHgAAhx4AAIceAACJHgAAiR4AAIseAACLHgAAjR4AAI0eAACPHgAAjx4AAJEeAACRHgAAkx4AAJMeAACVHgAAnR4AAJ8eAACfHgAAoR4AAKEeAACjHgAAox4AAKUeAAClHgAApx4AAKceAACpHgAAqR4AAKseAACrHgAArR4AAK0eAACvHgAArx4AALEeAACxHgAAsx4AALMeAAC1HgAAtR4AALceAAC3HgAAuR4AALkeAAC7HgAAux4AAL0eAAC9HgAAvx4AAL8eAADBHgAAwR4AAMMeAADDHgAAxR4AAMUeAADHHgAAxx4AAMkeAADJHgAAyx4AAMseAADNHgAAzR4AAM8eAADPHgAA0R4AANEeAADTHgAA0x4AANUeAADVHgAA1x4AANceAADZHgAA2R4AANseAADbHgAA3R4AAN0eAADfHgAA3x4AAOEeAADhHgAA4x4AAOMeAADlHgAA5R4AAOceAADnHgAA6R4AAOkeAADrHgAA6x4AAO0eAADtHgAA7x4AAO8eAADxHgAA8R4AAPMeAADzHgAA9R4AAPUeAAD3HgAA9x4AAPkeAAD5HgAA+x4AAPseAAD9HgAA/R4AAP8eAAAHHwAAEB8AABUfAAAgHwAAJx8AADAfAAA3HwAAQB8AAEUfAABQHwAAVx8AAGAfAABnHwAAcB8AAH0fAACAHwAAhx8AAJAfAACXHwAAoB8AAKcfAACwHwAAtB8AALYfAAC3HwAAvh8AAL4fAADCHwAAxB8AAMYfAADHHwAA0B8AANMfAADWHwAA1x8AAOAfAADnHwAA8h8AAPQfAAD2HwAA9x8AAHEgAABxIAAAfyAAAH8gAACQIAAAnCAAAAohAAAKIQAADiEAAA8hAAATIQAAEyEAAC8hAAAvIQAANCEAADQhAAA5IQAAOSEAADwhAAA9IQAARiEAAEkhAABOIQAATiEAAHAhAAB/IQAAhCEAAIQhAADQJAAA6SQAADAsAABfLAAAYSwAAGEsAABlLAAAZiwAAGgsAABoLAAAaiwAAGosAABsLAAAbCwAAHEsAABxLAAAcywAAHQsAAB2LAAAfSwAAIEsAACBLAAAgywAAIMsAACFLAAAhSwAAIcsAACHLAAAiSwAAIksAACLLAAAiywAAI0sAACNLAAAjywAAI8sAACRLAAAkSwAAJMsAACTLAAAlSwAAJUsAACXLAAAlywAAJksAACZLAAAmywAAJssAACdLAAAnSwAAJ8sAACfLAAAoSwAAKEsAACjLAAAoywAAKUsAAClLAAApywAAKcsAACpLAAAqSwAAKssAACrLAAArSwAAK0sAACvLAAArywAALEsAACxLAAAsywAALMsAAC1LAAAtSwAALcsAAC3LAAAuSwAALksAAC7LAAAuywAAL0sAAC9LAAAvywAAL8sAADBLAAAwSwAAMMsAADDLAAAxSwAAMUsAADHLAAAxywAAMksAADJLAAAyywAAMssAADNLAAAzSwAAM8sAADPLAAA0SwAANEsAADTLAAA0ywAANUsAADVLAAA1ywAANcsAADZLAAA2SwAANssAADbLAAA3SwAAN0sAADfLAAA3ywAAOEsAADhLAAA4ywAAOQsAADsLAAA7CwAAO4sAADuLAAA8ywAAPMsAAAALQAAJS0AACctAAAnLQAALS0AAC0tAABBpgAAQaYAAEOmAABDpgAARaYAAEWmAABHpgAAR6YAAEmmAABJpgAAS6YAAEumAABNpgAATaYAAE+mAABPpgAAUaYAAFGmAABTpgAAU6YAAFWmAABVpgAAV6YAAFemAABZpgAAWaYAAFumAABbpgAAXaYAAF2mAABfpgAAX6YAAGGmAABhpgAAY6YAAGOmAABlpgAAZaYAAGemAABnpgAAaaYAAGmmAABrpgAAa6YAAG2mAABtpgAAgaYAAIGmAACDpgAAg6YAAIWmAACFpgAAh6YAAIemAACJpgAAiaYAAIumAACLpgAAjaYAAI2mAACPpgAAj6YAAJGmAACRpgAAk6YAAJOmAACVpgAAlaYAAJemAACXpgAAmaYAAJmmAACbpgAAnaYAACOnAAAjpwAAJacAACWnAAAnpwAAJ6cAACmnAAAppwAAK6cAACunAAAtpwAALacAAC+nAAAxpwAAM6cAADOnAAA1pwAANacAADenAAA3pwAAOacAADmnAAA7pwAAO6cAAD2nAAA9pwAAP6cAAD+nAABBpwAAQacAAEOnAABDpwAARacAAEWnAABHpwAAR6cAAEmnAABJpwAAS6cAAEunAABNpwAATacAAE+nAABPpwAAUacAAFGnAABTpwAAU6cAAFWnAABVpwAAV6cAAFenAABZpwAAWacAAFunAABbpwAAXacAAF2nAABfpwAAX6cAAGGnAABhpwAAY6cAAGOnAABlpwAAZacAAGenAABnpwAAaacAAGmnAABrpwAAa6cAAG2nAABtpwAAb6cAAHinAAB6pwAAeqcAAHynAAB8pwAAf6cAAH+nAACBpwAAgacAAIOnAACDpwAAhacAAIWnAACHpwAAh6cAAIynAACMpwAAjqcAAI6nAACRpwAAkacAAJOnAACVpwAAl6cAAJenAACZpwAAmacAAJunAACbpwAAnacAAJ2nAACfpwAAn6cAAKGnAAChpwAAo6cAAKOnAAClpwAApacAAKenAACnpwAAqacAAKmnAACvpwAAr6cAALWnAAC1pwAAt6cAALenAAC5pwAAuacAALunAAC7pwAAvacAAL2nAAC/pwAAv6cAAMGnAADBpwAAw6cAAMOnAADIpwAAyKcAAMqnAADKpwAA0acAANGnAADTpwAA06cAANWnAADVpwAA16cAANenAADZpwAA2acAAPanAAD2pwAA+KcAAPqnAAAwqwAAWqsAAFyrAABoqwAAcKsAAL+rAAAA+wAABvsAABP7AAAX+wAAQf8AAFr/AAAoBAEATwQBANgEAQD7BAEAlwUBAKEFAQCjBQEAsQUBALMFAQC5BQEAuwUBALwFAQCABwEAgAcBAIMHAQCFBwEAhwcBALAHAQCyBwEAugcBAMAMAQDyDAEAwBgBAN8YAQBgbgEAf24BABrUAQAz1AEATtQBAFTUAQBW1AEAZ9QBAILUAQCb1AEAttQBALnUAQC71AEAu9QBAL3UAQDD1AEAxdQBAM/UAQDq1AEAA9UBAB7VAQA31QEAUtUBAGvVAQCG1QEAn9UBALrVAQDT1QEA7tUBAAfWAQAi1gEAO9YBAFbWAQBv1gEAitYBAKXWAQDC1gEA2tYBANzWAQDh1gEA/NYBABTXAQAW1wEAG9cBADbXAQBO1wEAUNcBAFXXAQBw1wEAiNcBAIrXAQCP1wEAqtcBAMLXAQDE1wEAydcBAMvXAQDL1wEAAN8BAAnfAQAL3wEAHt8BACLpAQBD6QEAQdCfAwvjK7wCAAAgAAAAfgAAAKAAAAB3AwAAegMAAH8DAACEAwAAigMAAIwDAACMAwAAjgMAAKEDAACjAwAALwUAADEFAABWBQAAWQUAAIoFAACNBQAAjwUAAJEFAADHBQAA0AUAAOoFAADvBQAA9AUAAAAGAAANBwAADwcAAEoHAABNBwAAsQcAAMAHAAD6BwAA/QcAAC0IAAAwCAAAPggAAEAIAABbCAAAXggAAF4IAABgCAAAaggAAHAIAACOCAAAkAgAAJEIAACYCAAAgwkAAIUJAACMCQAAjwkAAJAJAACTCQAAqAkAAKoJAACwCQAAsgkAALIJAAC2CQAAuQkAALwJAADECQAAxwkAAMgJAADLCQAAzgkAANcJAADXCQAA3AkAAN0JAADfCQAA4wkAAOYJAAD+CQAAAQoAAAMKAAAFCgAACgoAAA8KAAAQCgAAEwoAACgKAAAqCgAAMAoAADIKAAAzCgAANQoAADYKAAA4CgAAOQoAADwKAAA8CgAAPgoAAEIKAABHCgAASAoAAEsKAABNCgAAUQoAAFEKAABZCgAAXAoAAF4KAABeCgAAZgoAAHYKAACBCgAAgwoAAIUKAACNCgAAjwoAAJEKAACTCgAAqAoAAKoKAACwCgAAsgoAALMKAAC1CgAAuQoAALwKAADFCgAAxwoAAMkKAADLCgAAzQoAANAKAADQCgAA4AoAAOMKAADmCgAA8QoAAPkKAAD/CgAAAQsAAAMLAAAFCwAADAsAAA8LAAAQCwAAEwsAACgLAAAqCwAAMAsAADILAAAzCwAANQsAADkLAAA8CwAARAsAAEcLAABICwAASwsAAE0LAABVCwAAVwsAAFwLAABdCwAAXwsAAGMLAABmCwAAdwsAAIILAACDCwAAhQsAAIoLAACOCwAAkAsAAJILAACVCwAAmQsAAJoLAACcCwAAnAsAAJ4LAACfCwAAowsAAKQLAACoCwAAqgsAAK4LAAC5CwAAvgsAAMILAADGCwAAyAsAAMoLAADNCwAA0AsAANALAADXCwAA1wsAAOYLAAD6CwAAAAwAAAwMAAAODAAAEAwAABIMAAAoDAAAKgwAADkMAAA8DAAARAwAAEYMAABIDAAASgwAAE0MAABVDAAAVgwAAFgMAABaDAAAXQwAAF0MAABgDAAAYwwAAGYMAABvDAAAdwwAAIwMAACODAAAkAwAAJIMAACoDAAAqgwAALMMAAC1DAAAuQwAALwMAADEDAAAxgwAAMgMAADKDAAAzQwAANUMAADWDAAA3QwAAN4MAADgDAAA4wwAAOYMAADvDAAA8QwAAPIMAAAADQAADA0AAA4NAAAQDQAAEg0AAEQNAABGDQAASA0AAEoNAABPDQAAVA0AAGMNAABmDQAAfw0AAIENAACDDQAAhQ0AAJYNAACaDQAAsQ0AALMNAAC7DQAAvQ0AAL0NAADADQAAxg0AAMoNAADKDQAAzw0AANQNAADWDQAA1g0AANgNAADfDQAA5g0AAO8NAADyDQAA9A0AAAEOAAA6DgAAPw4AAFsOAACBDgAAgg4AAIQOAACEDgAAhg4AAIoOAACMDgAAow4AAKUOAAClDgAApw4AAL0OAADADgAAxA4AAMYOAADGDgAAyA4AAM0OAADQDgAA2Q4AANwOAADfDgAAAA8AAEcPAABJDwAAbA8AAHEPAACXDwAAmQ8AALwPAAC+DwAAzA8AAM4PAADaDwAAABAAAMUQAADHEAAAxxAAAM0QAADNEAAA0BAAAEgSAABKEgAATRIAAFASAABWEgAAWBIAAFgSAABaEgAAXRIAAGASAACIEgAAihIAAI0SAACQEgAAsBIAALISAAC1EgAAuBIAAL4SAADAEgAAwBIAAMISAADFEgAAyBIAANYSAADYEgAAEBMAABITAAAVEwAAGBMAAFoTAABdEwAAfBMAAIATAACZEwAAoBMAAPUTAAD4EwAA/RMAAAAUAACcFgAAoBYAAPgWAAAAFwAAFRcAAB8XAAA2FwAAQBcAAFMXAABgFwAAbBcAAG4XAABwFwAAchcAAHMXAACAFwAA3RcAAOAXAADpFwAA8BcAAPkXAAAAGAAAGRgAACAYAAB4GAAAgBgAAKoYAACwGAAA9RgAAAAZAAAeGQAAIBkAACsZAAAwGQAAOxkAAEAZAABAGQAARBkAAG0ZAABwGQAAdBkAAIAZAACrGQAAsBkAAMkZAADQGQAA2hkAAN4ZAAAbGgAAHhoAAF4aAABgGgAAfBoAAH8aAACJGgAAkBoAAJkaAACgGgAArRoAALAaAADOGgAAABsAAEwbAABQGwAAfhsAAIAbAADzGwAA/BsAADccAAA7HAAASRwAAE0cAACIHAAAkBwAALocAAC9HAAAxxwAANAcAAD6HAAAAB0AABUfAAAYHwAAHR8AACAfAABFHwAASB8AAE0fAABQHwAAVx8AAFkfAABZHwAAWx8AAFsfAABdHwAAXR8AAF8fAAB9HwAAgB8AALQfAAC2HwAAxB8AAMYfAADTHwAA1h8AANsfAADdHwAA7x8AAPIfAAD0HwAA9h8AAP4fAAAAIAAAJyAAACogAABkIAAAZiAAAHEgAAB0IAAAjiAAAJAgAACcIAAAoCAAAMAgAADQIAAA8CAAAAAhAACLIQAAkCEAACYkAABAJAAASiQAAGAkAABzKwAAdisAAJUrAACXKwAA8ywAAPksAAAlLQAAJy0AACctAAAtLQAALS0AADAtAABnLQAAby0AAHAtAAB/LQAAli0AAKAtAACmLQAAqC0AAK4tAACwLQAAti0AALgtAAC+LQAAwC0AAMYtAADILQAAzi0AANAtAADWLQAA2C0AAN4tAADgLQAAXS4AAIAuAACZLgAAmy4AAPMuAAAALwAA1S8AAPAvAAD7LwAAADAAAD8wAABBMAAAljAAAJkwAAD/MAAABTEAAC8xAAAxMQAAjjEAAJAxAADjMQAA8DEAAB4yAAAgMgAAjKQAAJCkAADGpAAA0KQAACumAABApgAA96YAAACnAADKpwAA0KcAANGnAADTpwAA06cAANWnAADZpwAA8qcAACyoAAAwqAAAOagAAECoAAB3qAAAgKgAAMWoAADOqAAA2agAAOCoAABTqQAAX6kAAHypAACAqQAAzakAAM+pAADZqQAA3qkAAP6pAAAAqgAANqoAAECqAABNqgAAUKoAAFmqAABcqgAAwqoAANuqAAD2qgAAAasAAAarAAAJqwAADqsAABGrAAAWqwAAIKsAACarAAAoqwAALqsAADCrAABrqwAAcKsAAO2rAADwqwAA+asAAACsAACj1wAAsNcAAMbXAADL1wAA+9cAAADgAABt+gAAcPoAANn6AAAA+wAABvsAABP7AAAX+wAAHfsAADb7AAA4+wAAPPsAAD77AAA++wAAQPsAAEH7AABD+wAARPsAAEb7AADC+wAA0/sAAI/9AACS/QAAx/0AAM/9AADP/QAA8P0AABn+AAAg/gAAUv4AAFT+AABm/gAAaP4AAGv+AABw/gAAdP4AAHb+AAD8/gAA//4AAP/+AAAB/wAAvv8AAML/AADH/wAAyv8AAM//AADS/wAA1/8AANr/AADc/wAA4P8AAOb/AADo/wAA7v8AAPn/AAD9/wAAAAABAAsAAQANAAEAJgABACgAAQA6AAEA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AAIBAAACAQAABAEAAAQBAAAGAQAABgEAAAgBAAAIAQAACgEAAAoBAAAMAQAADAEAAA4BAAAOAQAAEAEAABABAAASAQAAEgEAABQBAAAUAQAAFgEAABYBAAAYAQAAGAEAABoBAAAaAQAAHAEAABwBAAAeAQAAHgEAACABAAAgAQAAIgEAACIBAAAkAQAAJAEAACYBAAAmAQAAKAEAACgBAAAqAQAAKgEAACwBAAAsAQAALgEAAC4BAAAwAQAAMAEAADIBAAAyAQAANAEAADQBAAA2AQAANgEAADkBAAA5AQAAOwEAADsBAAA9AQAAPQEAAD8BAAA/AQAAQQEAAEEBAABDAQAAQwEAAEUBAABFAQAARwEAAEcBAABKAQAASgEAAEwBAABMAQAATgEAAE4BAABQAQAAUAEAAFIBAABSAQAAVAEAAFQBAABWAQAAVgEAAFgBAABYAQAAWgEAAFoBAABcAQAAXAEAAF4BAABeAQAAYAEAAGABAABiAQAAYgEAAGQBAABkAQAAZgEAAGYBAABoAQAAaAEAAGoBAABqAQAAbAEAAGwBAABuAQAAbgEAAHABAABwAQAAcgEAAHIBAAB0AQAAdAEAAHYBAAB2AQAAeAEAAHkBAAB7AQAAewEAAH0BAAB9AQAAgQEAAIIBAACEAQAAhAEAAIYBAACHAQAAiQEAAIsBAACOAQAAkQEAAJMBAACUAQAAlgEAAJgBAACcAQAAnQEAAJ8BAACgAQAAogEAAKIBAACkAQAApAEAAKYBAACnAQAAqQEAAKkBAACsAQAArAEAAK4BAACvAQAAsQEAALMBAAC1AQAAtQEAALcBAAC4AQAAvAEAALwBAADEAQAAxAEAAMcBAADHAQAAygEAAMoBAADNAQAAzQEAAM8BAADPAQAA0QEAANEBAADTAQAA0wEAANUBAADVAQAA1wEAANcBAADZAQAA2QEAANsBAADbAQAA3gEAAN4BAADgAQAA4AEAAOIBAADiAQAA5AEAAOQBAADmAQAA5gEAAOgBAADoAQAA6gEAAOoBAADsAQAA7AEAAO4BAADuAQAA8QEAAPEBAAD0AQAA9AEAAPYBAAD4AQAA+gEAAPoBAAD8AQAA/AEAAP4BAAD+AQAAAAIAAAACAAACAgAAAgIAAAQCAAAEAgAABgIAAAYCAAAIAgAACAIAAAoCAAAKAgAADAIAAAwCAAAOAgAADgIAABACAAAQAgAAEgIAABICAAAUAgAAFAIAABYCAAAWAgAAGAIAABgCAAAaAgAAGgIAABwCAAAcAgAAHgIAAB4CAAAgAgAAIAIAACICAAAiAgAAJAIAACQCAAAmAgAAJgIAACgCAAAoAgAAKgIAACoCAAAsAgAALAIAAC4CAAAuAgAAMAIAADACAAAyAgAAMgIAADoCAAA7AgAAPQIAAD4CAABBAgAAQQIAAEMCAABGAgAASAIAAEgCAABKAgAASgIAAEwCAABMAgAATgIAAE4CAABwAwAAcAMAAHIDAAByAwAAdgMAAHYDAAB/AwAAfwMAAIYDAACGAwAAiAMAAIoDAACMAwAAjAMAAI4DAACPAwAAkQMAAKEDAACjAwAAqwMAAM8DAADPAwAA0gMAANQDAADYAwAA2AMAANoDAADaAwAA3AMAANwDAADeAwAA3gMAAOADAADgAwAA4gMAAOIDAADkAwAA5AMAAOYDAADmAwAA6AMAAOgDAADqAwAA6gMAAOwDAADsAwAA7gMAAO4DAAD0AwAA9AMAAPcDAAD3AwAA+QMAAPoDAAD9AwAALwQAAGAEAABgBAAAYgQAAGIEAABkBAAAZAQAAGYEAABmBAAAaAQAAGgEAABqBAAAagQAAGwEAABsBAAAbgQAAG4EAABwBAAAcAQAAHIEAAByBAAAdAQAAHQEAAB2BAAAdgQAAHgEAAB4BAAAegQAAHoEAAB8BAAAfAQAAH4EAAB+BAAAgAQAAIAEAACKBAAAigQAAIwEAACMBAAAjgQAAI4EAACQBAAAkAQAAJIEAACSBAAAlAQAAJQEAACWBAAAlgQAAJgEAACYBAAAmgQAAJoEAACcBAAAnAQAAJ4EAACeBAAAoAQAAKAEAACiBAAAogQAAKQEAACkBAAApgQAAKYEAACoBAAAqAQAAKoEAACqBAAArAQAAKwEAACuBAAArgQAALAEAACwBAAAsgQAALIEAAC0BAAAtAQAALYEAAC2BAAAuAQAALgEAAC6BAAAugQAALwEAAC8BAAAvgQAAL4EAADABAAAwQQAAMMEAADDBAAAxQQAAMUEAADHBAAAxwQAAMkEAADJBAAAywQAAMsEAADNBAAAzQQAANAEAADQBAAA0gQAANIEAADUBAAA1AQAANYEAADWBAAA2AQAANgEAADaBAAA2gQAANwEAADcBAAA3gQAAN4EAADgBAAA4AQAAOIEAADiBAAA5AQAAOQEAADmBAAA5gQAAOgEAADoBAAA6gQAAOoEAADsBAAA7AQAAO4EAADuBAAA8AQAAPAEAADyBAAA8gQAAPQEAAD0BAAA9gQAAPYEAAD4BAAA+AQAAPoEAAD6BAAA/AQAAPwEAAD+BAAA/gQAAAAFAAAABQAAAgUAAAIFAAAEBQAABAUAAAYFAAAGBQAACAUAAAgFAAAKBQAACgUAAAwFAAAMBQAADgUAAA4FAAAQBQAAEAUAABIFAAASBQAAFAUAABQFAAAWBQAAFgUAABgFAAAYBQAAGgUAABoFAAAcBQAAHAUAAB4FAAAeBQAAIAUAACAFAAAiBQAAIgUAACQFAAAkBQAAJgUAACYFAAAoBQAAKAUAACoFAAAqBQAALAUAACwFAAAuBQAALgUAADEFAABWBQAAoBAAAMUQAADHEAAAxxAAAM0QAADNEAAAoBMAAPUTAACQHAAAuhwAAL0cAAC/HAAAAB4AAAAeAAACHgAAAh4AAAQeAAAEHgAABh4AAAYeAAAIHgAACB4AAAoeAAAKHgAADB4AAAweAAAOHgAADh4AABAeAAAQHgAAEh4AABIeAAAUHgAAFB4AABYeAAAWHgAAGB4AABgeAAAaHgAAGh4AABweAAAcHgAAHh4AAB4eAAAgHgAAIB4AACIeAAAiHgAAJB4AACQeAAAmHgAAJh4AACgeAAAoHgAAKh4AACoeAAAsHgAALB4AAC4eAAAuHgAAMB4AADAeAAAyHgAAMh4AADQeAAA0HgAANh4AADYeAAA4HgAAOB4AADoeAAA6HgAAPB4AADweAAA+HgAAPh4AAEAeAABAHgAAQh4AAEIeAABEHgAARB4AAEYeAABGHgAASB4AAEgeAABKHgAASh4AAEweAABMHgAATh4AAE4eAABQHgAAUB4AAFIeAABSHgAAVB4AAFQeAABWHgAAVh4AAFgeAABYHgAAWh4AAFoeAABcHgAAXB4AAF4eAABeHgAAYB4AAGAeAABiHgAAYh4AAGQeAABkHgAAZh4AAGYeAABoHgAAaB4AAGoeAABqHgAAbB4AAGweAABuHgAAbh4AAHAeAABwHgAAch4AAHIeAAB0HgAAdB4AAHYeAAB2HgAAeB4AAHgeAAB6HgAAeh4AAHweAAB8HgAAfh4AAH4eAACAHgAAgB4AAIIeAACCHgAAhB4AAIQeAACGHgAAhh4AAIgeAACIHgAAih4AAIoeAACMHgAAjB4AAI4eAACOHgAAkB4AAJAeAACSHgAAkh4AAJQeAACUHgAAnh4AAJ4eAACgHgAAoB4AAKIeAACiHgAApB4AAKQeAACmHgAAph4AAKgeAACoHgAAqh4AAKoeAACsHgAArB4AAK4eAACuHgAAsB4AALAeAACyHgAAsh4AALQeAAC0HgAAth4AALYeAAC4HgAAuB4AALoeAAC6HgAAvB4AALweAAC+HgAAvh4AAMAeAADAHgAAwh4AAMIeAADEHgAAxB4AAMYeAADGHgAAyB4AAMgeAADKHgAAyh4AAMweAADMHgAAzh4AAM4eAADQHgAA0B4AANIeAADSHgAA1B4AANQeAADWHgAA1h4AANgeAADYHgAA2h4AANoeAADcHgAA3B4AAN4eAADeHgAA4B4AAOAeAADiHgAA4h4AAOQeAADkHgAA5h4AAOYeAADoHgAA6B4AAOoeAADqHgAA7B4AAOweAADuHgAA7h4AAPAeAADwHgAA8h4AAPIeAAD0HgAA9B4AAPYeAAD2HgAA+B4AAPgeAAD6HgAA+h4AAPweAAD8HgAA/h4AAP4eAAAIHwAADx8AABgfAAAdHwAAKB8AAC8fAAA4HwAAPx8AAEgfAABNHwAAWR8AAFkfAABbHwAAWx8AAF0fAABdHwAAXx8AAF8fAABoHwAAbx8AALgfAAC7HwAAyB8AAMsfAADYHwAA2x8AAOgfAADsHwAA+B8AAPsfAAACIQAAAiEAAAchAAAHIQAACyEAAA0hAAAQIQAAEiEAABUhAAAVIQAAGSEAAB0hAAAkIQAAJCEAACYhAAAmIQAAKCEAACghAAAqIQAALSEAADAhAAAzIQAAPiEAAD8hAABFIQAARSEAAGAhAABvIQAAgyEAAIMhAAC2JAAAzyQAAAAsAAAvLAAAYCwAAGAsAABiLAAAZCwAAGcsAABnLAAAaSwAAGksAABrLAAAaywAAG0sAABwLAAAciwAAHIsAAB1LAAAdSwAAH4sAACALAAAgiwAAIIsAACELAAAhCwAAIYsAACGLAAAiCwAAIgsAACKLAAAiiwAAIwsAACMLAAAjiwAAI4sAACQLAAAkCwAAJIsAACSLAAAlCwAAJQsAACWLAAAliwAAJgsAACYLAAAmiwAAJosAACcLAAAnCwAAJ4sAACeLAAAoCwAAKAsAACiLAAAoiwAAKQsAACkLAAApiwAAKYsAACoLAAAqCwAAKosAACqLAAArCwAAKwsAACuLAAAriwAALAsAACwLAAAsiwAALIsAAC0LAAAtCwAALYsAAC2LAAAuCwAALgsAAC6LAAAuiwAALwsAAC8LAAAviwAAL4sAADALAAAwCwAAMIsAADCLAAAxCwAAMQsAADGLAAAxiwAAMgsAADILAAAyiwAAMosAADMLAAAzCwAAM4sAADOLAAA0CwAANAsAADSLAAA0iwAANQsAADULAAA1iwAANYsAADYLAAA2CwAANosAADaLAAA3CwAANwsAADeLAAA3iwAAOAsAADgLAAA4iwAAOIsAADrLAAA6ywAAO0sAADtLAAA8iwAAPIsAABApgAAQKYAAEKmAABCpgAARKYAAESmAABGpgAARqYAAEimAABIpgAASqYAAEqmAABMpgAATKYAAE6mAABOpgAAUKYAAFCmAABSpgAAUqYAAFSmAABUpgAAVqYAAFamAABYpgAAWKYAAFqmAABapgAAXKYAAFymAABepgAAXqYAAGCmAABgpgAAYqYAAGKmAABkpgAAZKYAAGamAABmpgAAaKYAAGimAABqpgAAaqYAAGymAABspgAAgKYAAICmAACCpgAAgqYAAISmAACEpgAAhqYAAIamAACIpgAAiKYAAIqmAACKpgAAjKYAAIymAACOpgAAjqYAAJCmAACQpgAAkqYAAJKmAACUpgAAlKYAAJamAACWpgAAmKYAAJimAACapgAAmqYAACKnAAAipwAAJKcAACSnAAAmpwAAJqcAACinAAAopwAAKqcAACqnAAAspwAALKcAAC6nAAAupwAAMqcAADKnAAA0pwAANKcAADanAAA2pwAAOKcAADinAAA6pwAAOqcAADynAAA8pwAAPqcAAD6nAABApwAAQKcAAEKnAABCpwAARKcAAESnAABGpwAARqcAAEinAABIpwAASqcAAEqnAABMpwAATKcAAE6nAABOpwAAUKcAAFCnAABSpwAAUqcAAFSnAABUpwAAVqcAAFanAABYpwAAWKcAAFqnAABapwAAXKcAAFynAABepwAAXqcAAGCnAABgpwAAYqcAAGKnAABkpwAAZKcAAGanAABmpwAAaKcAAGinAABqpwAAaqcAAGynAABspwAAbqcAAG6nAAB5pwAAeacAAHunAAB7pwAAfacAAH6nAACApwAAgKcAAIKnAACCpwAAhKcAAISnAACGpwAAhqcAAIunAACLpwAAjacAAI2nAACQpwAAkKcAAJKnAACSpwAAlqcAAJanAACYpwAAmKcAAJqnAACapwAAnKcAAJynAACepwAAnqcAAKCnAACgpwAAoqcAAKKnAACkpwAApKcAAKanAACmpwAAqKcAAKinAACqpwAArqcAALCnAAC0pwAAtqcAALanAAC4pwAAuKcAALqnAAC6pwAAvKcAALynAAC+pwAAvqcAAMCnAADApwAAwqcAAMKnAADEpwAAx6cAAMmnAADJpwAA0KcAANCnAADWpwAA1qcAANinAADYpwAA9acAAPWnAAAh/wAAOv8AAAAEAQAnBAEAsAQBANMEAQBwBQEAegUBAHwFAQCKBQEAjAUBAJIFAQCUBQEAlQUBAIAMAQCyDAEAoBgBAL8YAQBAbgEAX24BAADUAQAZ1AEANNQBAE3UAQBo1AEAgdQBAJzUAQCc1AEAntQBAJ/UAQCi1AEAotQBAKXUAQCm1AEAqdQBAKzUAQCu1AEAtdQBANDUAQDp1AEABNUBAAXVAQAH1QEACtUBAA3VAQAU1QEAFtUBABzVAQA41QEAOdUBADvVAQA+1QEAQNUBAETVAQBG1QEARtUBAErVAQBQ1QEAbNUBAIXVAQCg1QEAudUBANTVAQDt1QEACNYBACHWAQA81gEAVdYBAHDWAQCJ1gEAqNYBAMDWAQDi1gEA+tYBABzXAQA01wEAVtcBAG7XAQCQ1wEAqNcBAMrXAQDK1wEAAOkBACHpAQAw8QEASfEBAFDxAQBp8QEAcPEBAInxAQAAAAAAAwAAADAAAAA5AAAAQQAAAEYAAABhAAAAZgAAAAAAAAD2AgAAMAAAADkAAABBAAAAWgAAAF8AAABfAAAAYQAAAHoAAACqAAAAqgAAALUAAAC1AAAAugAAALoAAADAAAAA1gAAANgAAAD2AAAA+AAAAMECAADGAgAA0QIAAOACAADkAgAA7AIAAOwCAADuAgAA7gIAAAADAAB0AwAAdgMAAHcDAAB6AwAAfQMAAH8DAAB/AwAAhgMAAIYDAACIAwAAigMAAIwDAACMAwAAjgMAAKEDAACjAwAA9QMAAPcDAACBBAAAgwQAAC8FAAAxBQAAVgUAAFkFAABZBQAAYAUAAIgFAACRBQAAvQUAAL8FAAC/BQAAwQUAAMIFAADEBQAAxQUAAMcFAADHBQAA0AUAAOoFAADvBQAA8gUAABAGAAAaBgAAIAYAAGkGAABuBgAA0wYAANUGAADcBgAA3wYAAOgGAADqBgAA/AYAAP8GAAD/BgAAEAcAAEoHAABNBwAAsQcAAMAHAAD1BwAA+gcAAPoHAAD9BwAA/QcAAAAIAAAtCAAAQAgAAFsIAABgCAAAaggAAHAIAACHCAAAiQgAAI4IAACYCAAA4QgAAOMIAABjCQAAZgkAAG8JAABxCQAAgwkAAIUJAACMCQAAjwkAAJAJAACTCQAAqAkAAKoJAACwCQAAsgkAALIJAAC2CQAAuQkAALwJAADECQAAxwkAAMgJAADLCQAAzgkAANcJAADXCQAA3AkAAN0JAADfCQAA4wkAAOYJAADxCQAA/AkAAPwJAAD+CQAA/gkAAAEKAAADCgAABQoAAAoKAAAPCgAAEAoAABMKAAAoCgAAKgoAADAKAAAyCgAAMwoAADUKAAA2CgAAOAoAADkKAAA8CgAAPAoAAD4KAABCCgAARwoAAEgKAABLCgAATQoAAFEKAABRCgAAWQoAAFwKAABeCgAAXgoAAGYKAAB1CgAAgQoAAIMKAACFCgAAjQoAAI8KAACRCgAAkwoAAKgKAACqCgAAsAoAALIKAACzCgAAtQoAALkKAAC8CgAAxQoAAMcKAADJCgAAywoAAM0KAADQCgAA0AoAAOAKAADjCgAA5goAAO8KAAD5CgAA/woAAAELAAADCwAABQsAAAwLAAAPCwAAEAsAABMLAAAoCwAAKgsAADALAAAyCwAAMwsAADULAAA5CwAAPAsAAEQLAABHCwAASAsAAEsLAABNCwAAVQsAAFcLAABcCwAAXQsAAF8LAABjCwAAZgsAAG8LAABxCwAAcQsAAIILAACDCwAAhQsAAIoLAACOCwAAkAsAAJILAACVCwAAmQsAAJoLAACcCwAAnAsAAJ4LAACfCwAAowsAAKQLAACoCwAAqgsAAK4LAAC5CwAAvgsAAMILAADGCwAAyAsAAMoLAADNCwAA0AsAANALAADXCwAA1wsAAOYLAADvCwAAAAwAAAwMAAAODAAAEAwAABIMAAAoDAAAKgwAADkMAAA8DAAARAwAAEYMAABIDAAASgwAAE0MAABVDAAAVgwAAFgMAABaDAAAXQwAAF0MAABgDAAAYwwAAGYMAABvDAAAgAwAAIMMAACFDAAAjAwAAI4MAACQDAAAkgwAAKgMAACqDAAAswwAALUMAAC5DAAAvAwAAMQMAADGDAAAyAwAAMoMAADNDAAA1QwAANYMAADdDAAA3gwAAOAMAADjDAAA5gwAAO8MAADxDAAA8gwAAAANAAAMDQAADg0AABANAAASDQAARA0AAEYNAABIDQAASg0AAE4NAABUDQAAVw0AAF8NAABjDQAAZg0AAG8NAAB6DQAAfw0AAIENAACDDQAAhQ0AAJYNAACaDQAAsQ0AALMNAAC7DQAAvQ0AAL0NAADADQAAxg0AAMoNAADKDQAAzw0AANQNAADWDQAA1g0AANgNAADfDQAA5g0AAO8NAADyDQAA8w0AAAEOAAA6DgAAQA4AAE4OAABQDgAAWQ4AAIEOAACCDgAAhA4AAIQOAACGDgAAig4AAIwOAACjDgAApQ4AAKUOAACnDgAAvQ4AAMAOAADEDgAAxg4AAMYOAADIDgAAzQ4AANAOAADZDgAA3A4AAN8OAAAADwAAAA8AABgPAAAZDwAAIA8AACkPAAA1DwAANQ8AADcPAAA3DwAAOQ8AADkPAAA+DwAARw8AAEkPAABsDwAAcQ8AAIQPAACGDwAAlw8AAJkPAAC8DwAAxg8AAMYPAAAAEAAASRAAAFAQAACdEAAAoBAAAMUQAADHEAAAxxAAAM0QAADNEAAA0BAAAPoQAAD8EAAASBIAAEoSAABNEgAAUBIAAFYSAABYEgAAWBIAAFoSAABdEgAAYBIAAIgSAACKEgAAjRIAAJASAACwEgAAshIAALUSAAC4EgAAvhIAAMASAADAEgAAwhIAAMUSAADIEgAA1hIAANgSAAAQEwAAEhMAABUTAAAYEwAAWhMAAF0TAABfEwAAgBMAAI8TAACgEwAA9RMAAPgTAAD9EwAAARQAAGwWAABvFgAAfxYAAIEWAACaFgAAoBYAAOoWAADuFgAA+BYAAAAXAAAVFwAAHxcAADQXAABAFwAAUxcAAGAXAABsFwAAbhcAAHAXAAByFwAAcxcAAIAXAADTFwAA1xcAANcXAADcFwAA3RcAAOAXAADpFwAACxgAAA0YAAAPGAAAGRgAACAYAAB4GAAAgBgAAKoYAACwGAAA9RgAAAAZAAAeGQAAIBkAACsZAAAwGQAAOxkAAEYZAABtGQAAcBkAAHQZAACAGQAAqxkAALAZAADJGQAA0BkAANkZAAAAGgAAGxoAACAaAABeGgAAYBoAAHwaAAB/GgAAiRoAAJAaAACZGgAApxoAAKcaAACwGgAAzhoAAAAbAABMGwAAUBsAAFkbAABrGwAAcxsAAIAbAADzGwAAABwAADccAABAHAAASRwAAE0cAAB9HAAAgBwAAIgcAACQHAAAuhwAAL0cAAC/HAAA0BwAANIcAADUHAAA+hwAAAAdAAAVHwAAGB8AAB0fAAAgHwAARR8AAEgfAABNHwAAUB8AAFcfAABZHwAAWR8AAFsfAABbHwAAXR8AAF0fAABfHwAAfR8AAIAfAAC0HwAAth8AALwfAAC+HwAAvh8AAMIfAADEHwAAxh8AAMwfAADQHwAA0x8AANYfAADbHwAA4B8AAOwfAADyHwAA9B8AAPYfAAD8HwAAPyAAAEAgAABUIAAAVCAAAHEgAABxIAAAfyAAAH8gAACQIAAAnCAAANAgAADwIAAAAiEAAAIhAAAHIQAAByEAAAohAAATIQAAFSEAABUhAAAZIQAAHSEAACQhAAAkIQAAJiEAACYhAAAoIQAAKCEAACohAAAtIQAALyEAADkhAAA8IQAAPyEAAEUhAABJIQAATiEAAE4hAABgIQAAiCEAALYkAADpJAAAACwAAOQsAADrLAAA8ywAAAAtAAAlLQAAJy0AACctAAAtLQAALS0AADAtAABnLQAAby0AAG8tAAB/LQAAli0AAKAtAACmLQAAqC0AAK4tAACwLQAAti0AALgtAAC+LQAAwC0AAMYtAADILQAAzi0AANAtAADWLQAA2C0AAN4tAADgLQAA/y0AAC8uAAAvLgAABTAAAAcwAAAhMAAALzAAADEwAAA1MAAAODAAADwwAABBMAAAljAAAJkwAACaMAAAnTAAAJ8wAAChMAAA+jAAAPwwAAD/MAAABTEAAC8xAAAxMQAAjjEAAKAxAAC/MQAA8DEAAP8xAAAANAAAv00AAABOAACMpAAA0KQAAP2kAAAApQAADKYAABCmAAArpgAAQKYAAHKmAAB0pgAAfaYAAH+mAADxpgAAF6cAAB+nAAAipwAAiKcAAIunAADKpwAA0KcA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AIQDAACKAwAAjAMAAIwDAACOAwAAoQMAAKMDAAAvBQAAMQUAAFYFAABZBQAAigUAAI0FAACPBQAAkQUAAMcFAADQBQAA6gUAAO8FAAD0BQAAAAYAAA0HAAAPBwAASgcAAE0HAACxBwAAwAcAAPoHAAD9BwAALQgAADAIAAA+CAAAQAgAAFsIAABeCAAAXggAAGAIAABqCAAAcAgAAI4IAACQCAAAkQgAAJgIAACDCQAAhQkAAIwJAACPCQAAkAkAAJMJAACoCQAAqgkAALAJAACyCQAAsgkAALYJAAC5CQAAvAkAAMQJAADHCQAAyAkAAMsJAADOCQAA1wkAANcJAADcCQAA3QkAAN8JAADjCQAA5gkAAP4JAAABCgAAAwoAAAUKAAAKCgAADwoAABAKAAATCgAAKAoAACoKAAAwCgAAMgoAADMKAAA1CgAANgoAADgKAAA5CgAAPAoAADwKAAA+CgAAQgoAAEcKAABICgAASwoAAE0KAABRCgAAUQoAAFkKAABcCgAAXgoAAF4KAABmCgAAdgoAAIEKAACDCgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvAoAAMUKAADHCgAAyQoAAMsKAADNCgAA0AoAANAKAADgCgAA4woAAOYKAADxCgAA+QoAAP8KAAABCwAAAwsAAAULAAAMCwAADwsAABALAAATCwAAKAsAACoLAAAwCwAAMgsAADMLAAA1CwAAOQsAADwLAABECwAARwsAAEgLAABLCwAATQsAAFULAABXCwAAXAsAAF0LAABfCwAAYwsAAGYLAAB3CwAAggsAAIMLAACFCwAAigsAAI4LAACQCwAAkgsAAJULAACZCwAAmgsAAJwLAACcCwAAngsAAJ8LAACjCwAApAsAAKgLAACqCwAArgsAALkLAAC+CwAAwgsAAMYLAADICwAAygsAAM0LAADQCwAA0AsAANcLAADXCwAA5gsAAPoLAAAADAAADAwAAA4MAAAQDAAAEgwAACgMAAAqDAAAOQwAADwMAABEDAAARgwAAEgMAABKDAAATQwAAFUMAABWDAAAWAwAAFoMAABdDAAAXQwAAGAMAABjDAAAZgwAAG8MAAB3DAAAjAwAAI4MAACQDAAAkgwAAKgMAACqDAAAswwAALUMAAC5DAAAvAwA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AMUJAADGCQAAyQkAAMoJAADPCQAA1gkAANgJAADbCQAA3gkAAN4JAADkCQAA5QkAAP8JAAAACgAABAoAAAQKAAALCgAADgoAABEKAAASCgAAKQoAACkKAAAxCgAAMQoAADQKAAA0CgAANwoAADcKAAA6CgAAOwoAAD0KAAA9CgAAQwoAAEYKAABJCgAASgoAAE4KAABQCgAAUgoAAFgKAABdCgAAXQoAAF8KAABlCgAAdwoAAIAKAACECgAAhAoAAI4KAACOCgAAkgoAAJIKAACpCgAAqQoAALEKAACxCgAAtAoAALQKAAC6CgAAuwoAAMYKAADGCgAAygoAAMoKAADOCgAAzwoAANEKAADfCgAA5AoAAOUKAADyCgAA+AoAAAALAAAACwAABAsAAAQLAAANCwAADgsAABELAAASCwAAKQsAACkLAAAxCwAAMQsAADQLAAA0CwAAOgsAADsLAABFCwAARgsAAEkLAABKCwAATgsAAFQLAABYCwAAWwsAAF4LAABeCwAAZAsAAGULAAB4CwAAgQsAAIQLAACECwAAiwsAAI0LAACRCwAAkQsAAJYLAACYCwAAmwsAAJsLAACdCwAAnQsAAKALAACiCwAApQsAAKcLAACrCwAArQsAALoLAAC9CwAAwwsAAMULAADJCwAAyQsAAM4LAADPCwAA0QsAANYLAADYCwAA5QsAAPsLAAD/CwAADQwAAA0MAAARDAAAEQwAACkMAAApDAAAOgwAADsMAABFDAAARQwAAEkMAABJDAAATgwAAFQMAABXDAAAVwwAAFsMAABcDAAAXgwAAF8MAABkDAAAZQwAAHAMAAB2DAAAjQwAAI0MAACRDAAAkQwAAKkMAACpDAAAtAwAALQMAAC6DAAAuwwAAMUMAADFDAAAyQwAAMkMAADODAAA1AwAANcMAADcDAAA3wwAAN8MAADkDAAA5QwAAPAMAADwDAAA8wwAAP8MAAANDQAADQ0AABENAAARDQAARQ0AAEUNAABJDQAASQ0AAFANAABTDQAAZA0AAGUNAACADQAAgA0AAIQNAACEDQAAlw0AAJkNAACyDQAAsg0AALwNAAC8DQAAvg0AAL8NAADHDQAAyQ0AAMsNAADODQAA1Q0AANUNAADXDQAA1w0AAOANAADlDQAA8A0AAPENAAD1DQAAAA4AADsOAAA+DgAAXA4A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AQAAcAEAAHIBAAByAQAAdAEAAHQBAAB2AQAAdgEAAHgBAAB5AQAAewEAAHsBAAB9AQAAfQEAAH8BAAB/AQAAgQEAAIIBAACEAQAAhAEAAIYBAACHAQAAiQEAAIsBAACOAQAAkQEAAJMBAACUAQAAlgEAAJgBAACcAQAAnQEAAJ8BAACgAQAAogEAAKIBAACkAQAApAEAAKYBAACnAQAAqQEAAKkBAACsAQAArAEAAK4BAACvAQAAsQEAALMBAAC1AQAAtQEAALcBAAC4AQAAvAEAALwBAADEAQAAxQEAAMcBAADIAQAAygEAAMsBAADNAQAAzQEAAM8BAADPAQAA0QEAANEBAADTAQAA0wEAANUBAADVAQAA1wEAANcBAADZAQAA2QEAANsBAADbAQAA3gEAAN4BAADgAQAA4AEAAOIBAADiAQAA5AEAAOQBAADmAQAA5gEAAOgBAADoAQAA6gEAAOoBAADsAQAA7AEAAO4BAADuAQAA8QEAAPIBAAD0AQAA9AEAAPYBAAD4AQAA+gEAAPoBAAD8AQAA/AEAAP4BAAD+AQAAAAIAAAACAAACAgAAAgIAAAQCAAAEAgAABgIAAAYCAAAIAgAACAIAAAoCAAAKAgAADAIAAAwCAAAOAgAADgIAABACAAAQAgAAEgIAABICAAAUAgAAFAIAABYCAAAWAgAAGAIAABgCAAAaAgAAGgIAABwCAAAcAgAAHgIAAB4CAAAgAgAAIAIAACICAAAiAgAAJAIAACQCAAAmAgAAJgIAACgCAAAoAgAAKgIAACoCAAAsAgAALAIAAC4CAAAuAgAAMAIAADACAAAyAgAAMgIAADoCAAA7AgAAPQIAAD4CAABBAgAAQQIAAEMCAABGAgAASAIAAEgCAABKAgAASgIAAEwCAABMAgAATgIAAE4CAABFAwAARQMAAHADAABwAwAAcgMAAHIDAAB2AwAAdgMAAH8DAAB/AwAAhgMAAIYDAACIAwAAigMAAIwDAACMAwAAjgMAAI8DAACRAwAAoQMAAKMDAACrAwAAwgMAAMIDAADPAwAA0QMAANUDAADWAwAA2AMAANgDAADaAwAA2gMAANwDAADcAwAA3gMAAN4DAADgAwAA4AMAAOIDAADiAwAA5AMAAOQDAADmAwAA5gMAAOgDAADoAwAA6gMAAOoDAADsAwAA7AMAAO4DAADuAwAA8AMAAPEDAAD0AwAA9QMAAPcDAAD3AwAA+QMAAPoDAAD9AwAALwQAAGAEAABgBAAAYgQAAGIEAABkBAAAZAQAAGYEAABmBAAAaAQAAGgEAABqBAAAagQAAGwEAABsBAAAbgQAAG4EAABwBAAAcAQAAHIEAAByBAAAdAQAAHQEAAB2BAAAdgQAAHgEAAB4BAAAegQAAHoEAAB8BAAAfAQAAH4EAAB+BAAAgAQAAIAEAACKBAAAigQAAIwEAACMBAAAjgQAAI4EAACQBAAAkAQAAJIEAACSBAAAlAQAAJQEAACWBAAAlgQAAJgEAACYBAAAmgQAAJoEAACcBAAAnAQAAJ4EAACeBAAAoAQAAKAEAACiBAAAogQAAKQEAACkBAAApgQAAKYEAACoBAAAqAQAAKoEAACqBAAArAQAAKwEAACuBAAArgQAALAEAACwBAAAsgQAALIEAAC0BAAAtAQAALYEAAC2BAAAuAQAALgEAAC6BAAAugQAALwEAAC8BAAAvgQAAL4EAADABAAAwQQAAMMEAADDBAAAxQQAAMUEAADHBAAAxwQAAMkEAADJBAAAywQAAMsEAADNBAAAzQQAANAEAADQBAAA0gQAANIEAADUBAAA1AQAANYEAADWBAAA2AQAANgEAADaBAAA2gQAANwEAADcBAAA3gQAAN4EAADgBAAA4AQAAOIEAADiBAAA5AQAAOQEAADmBAAA5gQAAOgEAADoBAAA6gQAAOoEAADsBAAA7AQAAO4EAADuBAAA8AQAAPAEAADyBAAA8gQAAPQEAAD0BAAA9gQAAPYEAAD4BAAA+AQAAPoEAAD6BAAA/AQAAPwEAAD+BAAA/gQAAAAFAAAABQAAAgUAAAIFAAAEBQAABAUAAAYFAAAGBQAACAUAAAgFAAAKBQAACgUAAAwFAAAMBQAADgUAAA4FAAAQBQAAEAUAABIFAAASBQAAFAUAABQFAAAWBQAAFgUAABgFAAAYBQAAGgUAABoFAAAcBQAAHAUAAB4FAAAeBQAAIAUAACAFAAAiBQAAIgUAACQFAAAkBQAAJgUAACYFAAAoBQAAKAUAACoFAAAqBQAALAUAACwFAAAuBQAALgUAADEFAABWBQAAhwUAAIcFAACgEAAAxRAAAMcQAADHEAAAzRAAAM0QAAD4EwAA/RMAAIAcAACIHAAAkBwAALocAAC9HAAAvxwAAAAeAAAAHgAAAh4AAAIeAAAEHgAABB4AAAYeAAAGHgAACB4AAAgeAAAKHgAACh4AAAweAAAMHgAADh4AAA4eAAAQHgAAEB4AABIeAAASHgAAFB4AABQeAAAWHgAAFh4AABgeAAAYHgAAGh4AABoeAAAcHgAAHB4AAB4eAAAeHgAAIB4AACAeAAAiHgAAIh4AACQeAAAkHgAAJh4AACYeAAAoHgAAKB4AACoeAAAqHgAALB4AACweAAAuHgAALh4AADAeAAAwHgAAMh4AADIeAAA0HgAANB4AADYeAAA2HgAAOB4AADgeAAA6HgAAOh4AADweAAA8HgAAPh4AAD4eAABAHgAAQB4AAEIeAABCHgAARB4AAEQeAABGHgAARh4AAEgeAABIHgAASh4AAEoeAABMHgAATB4AAE4eAABOHgAAUB4AAFAeAABSHgAAUh4AAFQeAABUHgAAVh4AAFYeAABYHgAAWB4AAFoeAABaHgAAXB4AAFweAABeHgAAXh4AAGAeAABgHgAAYh4AAGIeAABkHgAAZB4AAGYeAABmHgAAaB4AAGgeAABqHgAAah4AAGweAABsHgAAbh4AAG4eAABwHgAAcB4AAHIeAAByHgAAdB4AAHQeAAB2HgAAdh4AAHgeAAB4HgAAeh4AAHoeAAB8HgAAfB4AAH4eAAB+HgAAgB4AAIAeAACCHgAAgh4AAIQeAACEHgAAhh4AAIYeAACIHgAAiB4AAIoeAACKHgAAjB4AAIweAACOHgAAjh4AAJAeAACQHgAAkh4AAJIeAACUHgAAlB4AAJoeAACbHgAAnh4AAJ4eAACgHgAAoB4AAKIeAACiHgAApB4AAKQeAACmHgAAph4AAKgeAACoHgAAqh4AAKoeAACsHgAArB4AAK4eAACuHgAAsB4AALAeAACyHgAAsh4AALQeAAC0HgAAth4AALYeAAC4HgAAuB4AALoeAAC6HgAAvB4AALweAAC+HgAAvh4AAMAeAADAHgAAwh4AAMIeAADEHgAAxB4AAMYeAADGHgAAyB4AAMgeAADKHgAAyh4AAMweAADMHgAAzh4AAM4eAADQHgAA0B4AANIeAADSHgAA1B4AANQeAADWHgAA1h4AANgeAADYHgAA2h4AANoeAADcHgAA3B4AAN4eAADeHgAA4B4AAOAeAADiHgAA4h4AAOQeAADkHgAA5h4AAOYeAADoHgAA6B4AAOoeAADqHgAA7B4AAOweAADuHgAA7h4AAPAeAADwHgAA8h4AAPIeAAD0HgAA9B4AAPYeAAD2HgAA+B4AAPgeAAD6HgAA+h4AAPweAAD8HgAA/h4AAP4eAAAIHwAADx8AABgfAAAdHwAAKB8AAC8fAAA4HwAAPx8AAEgfAABNHwAAWR8AAFkfAABbHwAAWx8AAF0fAABdHwAAXx8AAF8fAABoHwAAbx8AAIAfAACvHwAAsh8AALQfAAC3HwAAvB8AAMIfAADEHwAAxx8AAMwfAADYHwAA2x8AAOgfAADsHwAA8h8AAPQfAAD3HwAA/B8AACYhAAAmIQAAKiEAACshAAAyIQAAMiEAAGAhAABvIQAAgyEAAIMhAAC2JAAAzyQAAAAsAAAvLAAAYCwAAGAsAABiLAAAZCwAAGcsAABnLAAAaSwAAGksAABrLAAAaywAAG0sAABwLAAAciwAAHIsAAB1LAAAdSwAAH4sAACALAAAgiwAAIIsAACELAAAhCwAAIYsAACGLAAAiCwAAIgsAACKLAAAiiwAAIwsAACMLAAAjiwAAI4sAACQLAAAkCwAAJIsAACSLAAAlCwAAJQsAACWLAAAliwAAJgsAACYLAAAmiwAAJosAACcLAAAnCwAAJ4sAACeLAAAoCwAAKAsAACiLAAAoiwAAKQsAACkLAAApiwAAKYsAACoLAAAqCwAAKosAACqLAAArCwAAKwsAACuLAAAriwAALAsAACwLAAAsiwAALIsAAC0LAAAtCwAALYsAAC2LAAAuCwAALgsAAC6LAAAuiwAALwsAAC8LAAAviwAAL4sAADALAAAwCwAAMIsAADCLAAAxCwAAMQsAADGLAAAxiwAAMgsAADILAAAyiwAAMosAADMLAAAzCwAAM4sAADOLAAA0CwAANAsAADSLAAA0iwAANQsAADULAAA1iwAANYsAADYLAAA2CwAANosAADaLAAA3CwAANwsAADeLAAA3iwAAOAsAADgLAAA4iwAAOIsAADrLAAA6ywAAO0sAADtLAAA8iwAAPIsAABApgAAQKYAAEKmAABCpgAARKYAAESmAABGpgAARqYAAEimAABIpgAASqYAAEqmAABMpgAATKYAAE6mAABOpgAAUKYAAFCmAABSpgAAUqYAAFSmAABUpgAAVqYAAFamAABYpgAAWKYAAFqmAABapgAAXKYAAFymAABepgAAXqYAAGCmAABgpgAAYqYAAGKmAABkpgAAZKYAAGamAABmpgAAaKYAAGimAABqpgAAaqYAAGymAABspgAAgKYAAICmAACCpgAAgqYAAISmAACEpgAAhqYAAIamAACIpgAAiKYAAIqmAACKpgAAjKYAAIymAACOpgAAjqYAAJCmAACQpgAAkqYAAJKmAACUpgAAlKYAAJamAACWpgAAmKYAAJimAACapgAAmqYAACKnAAAipwAAJKcAACSnAAAmpwAAJqcAACinAAAopwAAKqcAACqnAAAspwAALKcAAC6nAAAupwAAMqcAADKnAAA0pwAANKcAADanAAA2pwAAOKcAADinAAA6pwAAOqcAADynAAA8pwAAPqcAAD6nAABApwAAQKcAAEKnAABCpwAARKcAAESnAABGpwAARqcAAEinAABIpwAASqcAAEqnAABMpwAATKcAAE6nAABOpwAAUKcAAFCnAABSpwAAUqcAAFSnAABUpwAAVqcAAFanAABYpwAAWKcAAFqnAABapwAAXKcAAFynAABepwAAXqcAAGCnAABgpwAAYqcAAGKnAABkpwAAZKcAAGanAABmpwAAaKcAAGinAABqpwAAaqcAAGynAABspwAAbqcAAG6nAAB5pwAAeacAAHunAAB7pwAAfacAAH6nAACApwAAgKcAAIKnAACCpwAAhKcAAISnAACGpwAAhqcAAIunAACLpwAAjacAAI2nAACQpwAAkKcAAJKnAACSpwAAlqcAAJanAACYpwAAmKcAAJqnAACapwAAnKcAAJynAACepwAAnqcAAKCnAACgpwAAoqcAAKKnAACkpwAApKcAAKanAACmpwAAqKcAAKinAACqpwAArqcAALCnAAC0pwAAtqcAALanAAC4pwAAuKcAALqnAAC6pwAAvKcAALynAAC+pwAAvqcAAMCnAADApwAAwqcAAMKnAADEpwAAx6cAAMmnAADJpwAA0KcAANCnAADWpwAA1qcAANinAADYpwAA9acAAPWnAABwqwAAv6sAAAD7AAAG+wAAE/sAABf7AAAh/wAAOv8AAAAEAQAnBAEAsAQBANMEAQBwBQEAegUBAHwFAQCKBQEAjAUBAJIFAQCUBQEAlQUBAIAMAQCyDAEAoBgBAL8YAQBAbgEAX24BAADpAQAh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AABOHgAAUB4AAFAeAABSHgAAUh4AAFQeAABUHgAAVh4AAFYeAABYHgAAWB4AAFoeAABaHgAAXB4AAFweAABeHgAAXh4AAGAeAABgHgAAYh4AAGIeAABkHgAAZB4AAGYeAABmHgAAaB4AAGgeAABqHgAAah4AAGweAABsHgAAbh4AAG4eAABwHgAAcB4AAHIeAAByHgAAdB4AAHQeAAB2HgAAdh4AAHgeAAB4HgAAeh4AAHoeAAB8HgAAfB4AAH4eAAB+HgAAgB4AAIAeAACCHgAAgh4AAIQeAACEHgAAhh4AAIYeAACIHgAAiB4AAIoeAACKHgAAjB4AAIweAACOHgAAjh4AAJAeAACQHgAAkh4AAJIeAACUHgAAlB4AAJ4eAACeHgAAoB4AAKAeAACiHgAAoh4AAKQeAACkHgAAph4AAKYeAACoHgAAqB4AAKoeAACqHgAArB4AAKweAACuHgAArh4AALAeAACwHgAAsh4AALIeAAC0HgAAtB4AALYeAAC2HgAAuB4AALgeAAC6HgAAuh4AALweAAC8HgAAvh4AAL4eAADAHgAAwB4AAMIeAADCHgAAxB4AAMQeAADGHgAAxh4AAMgeAADIHgAAyh4AAMoeAADMHgAAzB4AAM4eAADOHgAA0B4AANAeAADSHgAA0h4AANQeAADUHgAA1h4AANYeAADYHgAA2B4AANoeAADaHgAA3B4AANweAADeHgAA3h4AAOAeAADgHgAA4h4AAOIeAADkHgAA5B4AAOYeAADmHgAA6B4AAOgeAADqHgAA6h4AAOweAADsHgAA7h4AAO4eAADwHgAA8B4AAPIeAADyHgAA9B4AAPQeAAD2HgAA9h4AAPgeAAD4HgAA+h4AAPoeAAD8HgAA/B4AAP4eAAD+HgAACB8AAA8fAAAYHwAAHR8AACgfAAAvHwAAOB8AAD8fAABIHwAATR8AAFkfAABZHwAAWx8AAFsfAABdHwAAXR8AAF8fAABfHwAAaB8AAG8fAACIHwAAjx8AAJgfAACfHwAAqB8AAK8fAAC4HwAAvB8AAMgfAADMHwAA2B8AANsfAADoHwAA7B8AAPgfAAD8HwAAJiEAACYhAAAqIQAAKyEAADIhAAAyIQAAYCEAAG8hAACDIQAAgyEAALYkAADPJAAAACwAAC8sAABgLAAAYCwAAGIsAABkLAAAZywAAGcsAABpLAAAaSwAAGssAABrLAAAbSwAAHAsAAByLAAAciwAAHUsAAB1LAAAfiwAAIAsAACCLAAAgiwAAIQsAACELAAAhiwAAIYsAACILAAAiCwAAIosAACKLAAAjCwAAIwsAACOLAAAjiwAAJAsAACQLAAAkiwAAJIsAACULAAAlCwAAJYsAACWLAAAmCwAAJgsAACaLAAAmiwAAJwsAACcLAAAniwAAJ4sAACgLAAAoCwAAKIsAACiLAAApCwAAKQsAACmLAAApiwAAKgsAACoLAAAqiwAAKosAACsLAAArCwAAK4sAACuLAAAsCwAALAsAACyLAAAsiwAALQsAAC0LAAAtiwAALYsAAC4LAAAuCwAALosAAC6LAAAvCwAALwsAAC+LAAAviwAAMAsAADALAAAwiwAAMIsAADELAAAxCwAAMYsAADGLAAAyCwAAMgsAADKLAAAyiwAAMwsAADMLAAAziwAAM4sAADQLAAA0CwAANIsAADSLAAA1CwAANQsAADWLAAA1iwAANgsAADYLAAA2iwAANosAADcLAAA3CwAAN4sAADeLAAA4CwAAOAsAADiLAAA4iwAAOssAADrLAAA7SwAAO0sAADyLAAA8iwAAECmAABApgAAQqYAAEKmAABEpgAARKYAAEamAABGpgAASKYAAEimAABKpgAASqYAAEymAABMpgAATqYAAE6mAABQpgAAUKYAAFKmAABSpgAAVKYAAFSmAABWpgAAVqYAAFimAABYpgAAWqYAAFqmAABcpgAAXKYAAF6mAABepgAAYKYAAGCmAABipgAAYqYAAGSmAABkpgAAZqYAAGamAABopgAAaKYAAGqmAABqpgAAbKYAAGymAACApgAAgKYAAIKmAACCpgAAhKYAAISmAACGpgAAhqYAAIimAACIpgAAiqYAAIqmAACMpgAAjKYAAI6mAACOpgAAkKYAAJCmAACSpgAAkqYAAJSmAACUpgAAlqYAAJamAACYpgAAmKYAAJqmAACapgAAIqcAACKnAAAkpwAAJKcAACanAAAmpwAAKKcAACinAAAqpwAAKqcAACynAAAspwAALqcAAC6nAAAypwAAMqcAADSnAAA0pwAANqcAADanAAA4pwAAOKcAADqnAAA6pwAAPKcAADynAAA+pwAAPqcAAECnAABApwAAQqcAAEKnAABEpwAARKcAAEan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AAC/HgAAwR4AAMEeAADDHgAAwx4AAMUeAADFHgAAxx4AAMceAADJHgAAyR4AAMseAADLHgAAzR4AAM0eAADPHgAAzx4AANEeAADRHgAA0x4AANMeAADVHgAA1R4AANceAADXHgAA2R4AANkeAADbHgAA2x4AAN0eAADdHgAA3x4AAN8eAADhHgAA4R4AAOMeAADjHgAA5R4AAOUeAADnHgAA5x4AAOkeAADpHgAA6x4AAOseAADtHgAA7R4AAO8eAADvHgAA8R4AAPEeAADzHgAA8x4AAPUeAAD1HgAA9x4AAPceAAD5HgAA+R4AAPseAAD7HgAA/R4AAP0eAAD/HgAABx8AABAfAAAVHwAAIB8AACcfAAAwHwAANx8AAEAfAABFHwAAUB8AAFcfAABgHwAAZx8AAHAfAAB9HwAAgB8AAIcfAACQHwAAlx8AAKAfAACnHwAAsB8AALQfAAC2HwAAtx8AAL4fAAC+HwAAwh8AAMQfAADGHwAAxx8AANAfAADTHwAA1h8AANcfAADgHwAA5x8AAPIfAAD0HwAA9h8AAPcfAABOIQAATiEAAHAhAAB/IQAAhCEAAIQhAADQJAAA6SQAADAsAABfLAAAYSwAAGEsAABlLAAAZiwAAGgsAABoLAAAaiwAAGosAABsLAAAbCwAAHMsAABzLAAAdiwAAHYsAACBLAAAgSwAAIMsAACDLAAAhSwAAIUsAACHLAAAhywAAIksAACJLAAAiywAAIssAACNLAAAjSwAAI8sAACPLAAAkSwAAJEsAACTLAAAkywAAJUsAACVLAAAlywAAJcsAACZLAAAmSwAAJssAACbLAAAnSwAAJ0sAACfLAAAnywAAKEsAAChLAAAoywAAKMsAAClLAAApSwAAKcsAACnLAAAqSwAAKksAACrLAAAqywAAK0sAACtLAAArywAAK8sAACxLAAAsSwAALMsAACzLAAAtSwAALUsAAC3LAAAtywAALksAAC5LAAAuywAALssAAC9LAAAvSwAAL8sAAC/LAAAwSwAAMEsAADDLAAAwywAAMUsAADFLAAAxywAAMcsAADJLAAAySwAAMssAADLLAAAzSwAAM0sAADPLAAAzywAANEsAADRLAAA0ywAANMsAADVLAAA1SwAANcsAADXLAAA2SwAANksAADbLAAA2ywAAN0sAADdLAAA3ywAAN8sAADhLAAA4SwAAOMsAADjLAAA7CwAAOwsAADuLAAA7iwAAPMsAADzLAAAAC0AACUtAAAnLQAAJy0AAC0tAAAtLQAAQaYAAEGmAABDpgAAQ6YAAEWmAABFpgAAR6YAAEemAABJpgAASaYAAEumAABLpgAATaYAAE2mAABPpgAAT6YAAFGmAABRpgAAU6YAAFOmAABVpgAAVaYAAFemAABXpgAAWaYAAFmmAABbpgAAW6YAAF2mAABdpgAAX6YAAF+mAABhpgAAYaYAAGOmAABjpgAAZaYAAGWmAABnpgAAZ6YAAGmmAABppgAAa6YAAGumAABtpgAAbaYAAIGmAACBpgAAg6YAAIOmAACFpgAAhaYAAIemAACHpgAAiaYAAImmAACLpgAAi6YAAI2mAACNpgAAj6YAAI+mAACRpgAAkaYAAJOmAACTpgAAlaYAAJWmAACXpgAAl6YAAJmmAACZpgAAm6YAAJumAAAjpwAAI6cAACWnAAAlpwAAJ6cAACenAAAppwAAKacAACunAAArpwAALacAAC2nAAAvpwAAL6cAADOnAAAzpwAANacAADWnAAA3pwAAN6cAADmnAAA5pwAAO6cAADunAAA9pwAAPacAAD+nAAA/pwAAQacAAEGnAABDpwAAQ6cAAEWnAABFpwAAR6cAAEenAABJpwAASacAAEunAABLpwAATacAAE2nAABPpwAAT6cAAFGnAABRpwAAU6cAAFOnAABVpwAAVacAAFenAABXpwAAWacAAFmnAABbpwAAW6cAAF2nAABdpwAAX6cAAF+nAABhpwAAYacAAGOnAABjpwAAZacAAGWnAABnpwAAZ6cAAGmnAABppwAAa6cAAGunAABtpwAAbacAAG+nAABvpwAAeqcAAHqnAAB8pwAAfKcAAH+nAAB/pwAAgacAAIGnAACDpwAAg6cAAIWnAACFpwAAh6cAAIenAACMpwAAjKcAAJGnAACRpwAAk6cAAJSnAACXpwAAl6cAAJmnAACZpwAAm6cAAJunAACdpwAAnacAAJ+nAACfpwAAoacAAKGnAACjpwAAo6cAAKWnAAClpwAAp6cAAKenAACppwAAqacAALWnAAC1pwAAt6cAALenAAC5pwAAuacAALunAAC7pwAAvacAAL2nAAC/pwAAv6cAAMGnAADBpwAAw6cAAMOnAADIpwAAyKcAAMqnAADKpwAA0acAANGnAADXpwAA16cAANmnAADZpwAA9qcAAPanAABTqwAAU6sAAHCrAAC/qwAAAPsAAAb7AAAT+wAAF/sAAEH/AABa/wAAKAQBAE8EAQDYBAEA+wQBAJcFAQChBQEAowUBALEFAQCzBQEAuQUBALsFAQC8BQEAwAwBAPIMAQDAGAEA3xgBAGBuAQB/bgEAIukBAEPpAQBBoOQGC8cncwIAAGEAAAB6AAAAtQAAALUAAADfAAAA9gAAAPgAAAD/AAAAAQEAAAEBAAADAQAAAwEAAAUBAAAFAQAABwEAAAcBAAAJAQAACQEAAAsBAAALAQAADQEAAA0BAAAPAQAADwEAABEBAAARAQAAEwEAABMBAAAVAQAAFQEAABcBAAAXAQAAGQEAABkBAAAbAQAAGwEAAB0BAAAdAQAAHwEAAB8BAAAhAQAAIQEAACMBAAAjAQAAJQEAACUBAAAnAQAAJwEAACkBAAApAQAAKwEAACsBAAAtAQAALQEAAC8BAAAvAQAAMQEAADEBAAAzAQAAMwEAADUBAAA1AQAANwEAADcBAAA6AQAAOgEAADwBAAA8AQAAPgEAAD4BAABAAQAAQAEAAEIBAABCAQAARAEAAEQBAABGAQAARgEAAEgBAABJAQAASwEAAEsBAABNAQAATQEAAE8BAABPAQAAUQEAAFEBAABTAQAAUwEAAFUBAABVAQAAVwEAAFcBAABZAQAAWQEAAFsBAABbAQAAXQEAAF0BAABfAQAAXwEAAGEBAABhAQAAYwEAAGMBAABlAQAAZQEAAGcBAABnAQAAaQEAAGkBAABrAQAAawEAAG0BAABtAQAAbwEAAG8BAABxAQAAcQEAAHMBAABzAQAAdQEAAHUBAAB3AQAAdwEAAHoBAAB6AQAAfAEAAHwBAAB+AQAAgAEAAIMBAACDAQAAhQEAAIUBAACIAQAAiAEAAIwBAACMAQAAkgEAAJIBAACVAQAAlQEAAJkBAACaAQAAngEAAJ4BAAChAQAAoQEAAKMBAACjAQAApQEAAKUBAACoAQAAqAEAAK0BAACtAQAAsAEAALABAAC0AQAAtAEAALYBAAC2AQAAuQEAALkBAAC9AQAAvQEAAL8BAAC/AQAAxQEAAMYBAADIAQAAyQEAAMsBAADMAQAAzgEAAM4BAADQAQAA0AEAANIBAADSAQAA1AEAANQBAADWAQAA1gEAANgBAADYAQAA2gEAANoBAADcAQAA3QEAAN8BAADfAQAA4QEAAOEBAADjAQAA4wEAAOUBAADlAQAA5wEAAOcBAADpAQAA6QEAAOsBAADrAQAA7QEAAO0BAADvAQAA8AEAAPIBAADzAQAA9QEAAPUBAAD5AQAA+QEAAPsBAAD7AQAA/QEAAP0BAAD/AQAA/wEAAAECAAABAgAAAwIAAAMCAAAFAgAABQIAAAcCAAAHAgAACQIAAAkCAAALAgAACwIAAA0CAAANAgAADwIAAA8CAAARAgAAEQIAABMCAAATAgAAFQIAABUCAAAXAgAAFwIAABkCAAAZAgAAGwIAABsCAAAdAgAAHQIAAB8CAAAfAgAAIwIAACMCAAAlAgAAJQIAACcCAAAnAgAAKQIAACkCAAArAgAAKwIAAC0CAAAtAgAALwIAAC8CAAAxAgAAMQIAADMCAAAzAgAAPAIAADwCAAA/AgAAQAIAAEICAABCAgAARwIAAEcCAABJAgAASQIAAEsCAABLAgAATQIAAE0CAABPAgAAVAIAAFYCAABXAgAAWQIAAFkCAABbAgAAXAIAAGACAABhAgAAYwIAAGMCAABlAgAAZgIAAGgCAABsAgAAbwIAAG8CAABxAgAAcgIAAHUCAAB1AgAAfQIAAH0CAACAAgAAgAIAAIICAACDAgAAhwIAAIwCAACSAgAAkgIAAJ0CAACeAgAARQMAAEUDAABxAwAAcQMAAHMDAABzAwAAdwMAAHcDAAB7AwAAfQMAAJADAACQAwAArAMAAM4DAADQAwAA0QMAANUDAADXAwAA2QMAANkDAADbAwAA2wMAAN0DAADdAwAA3wMAAN8DAADhAwAA4QMAAOMDAADjAwAA5QMAAOUDAADnAwAA5wMAAOkDAADpAwAA6wMAAOsDAADtAwAA7QMAAO8DAADzAwAA9QMAAPUDAAD4AwAA+AMAAPsDAAD7AwAAMAQAAF8EAABhBAAAYQQAAGMEAABjBAAAZQQAAGUEAABnBAAAZwQAAGkEAABpBAAAawQAAGsEAABtBAAAbQQAAG8EAABvBAAAcQQAAHEEAABzBAAAcwQAAHUEAAB1BAAAdwQAAHcEAAB5BAAAeQQAAHsEAAB7BAAAfQQAAH0EAAB/BAAAfwQAAIEEAACBBAAAiwQAAIsEAACNBAAAjQQAAI8EAACPBAAAkQQAAJEEAACTBAAAkwQAAJUEAACVBAAAlwQAAJcEAACZBAAAmQQAAJsEAACbBAAAnQQAAJ0EAACfBAAAnwQAAKEEAAChBAAAowQAAKMEAAClBAAApQQAAKcEAACnBAAAqQQAAKkEAACrBAAAqwQAAK0EAACtBAAArwQAAK8EAACxBAAAsQQAALMEAACzBAAAtQQAALUEAAC3BAAAtwQAALkEAAC5BAAAuwQAALsEAAC9BAAAvQQAAL8EAAC/BAAAwgQAAMIEAADEBAAAxAQAAMYEAADGBAAAyAQAAMgEAADKBAAAygQAAMwEAADMBAAAzgQAAM8EAADRBAAA0QQAANMEAADTBAAA1QQAANUEAADXBAAA1wQAANkEAADZBAAA2wQAANsEAADdBAAA3QQAAN8EAADfBAAA4QQAAOEEAADjBAAA4wQAAOUEAADlBAAA5wQAAOcEAADpBAAA6QQAAOsEAADrBAAA7QQAAO0EAADvBAAA7wQAAPEEAADxBAAA8wQAAPMEAAD1BAAA9QQAAPcEAAD3BAAA+QQAAPkEAAD7BAAA+wQAAP0EAAD9BAAA/wQAAP8EAAABBQAAAQUAAAMFAAADBQAABQUAAAUFAAAHBQAABwUAAAkFAAAJBQAACwUAAAsFAAANBQAADQUAAA8FAAAPBQAAEQUAABEFAAATBQAAEwUAABUFAAAVBQAAFwUAABcFAAAZBQAAGQUAABsFAAAbBQAAHQUAAB0FAAAfBQAAHwUAACEFAAAhBQAAIwUAACMFAAAlBQAAJQUAACcFAAAnBQAAKQUAACkFAAArBQAAKwUAAC0FAAAtBQAALwUAAC8FAABhBQAAhwUAANAQAAD6EAAA/RAAAP8QAAD4EwAA/RMAAIAcAACIHAAAeR0AAHkdAAB9HQAAfR0AAI4dAACOHQAAAR4AAAEeAAADHgAAAx4AAAUeAAAFHgAABx4AAAceAAAJHgAACR4AAAseAAALHgAADR4AAA0eAAAPHgAADx4AABEeAAARHgAAEx4AABMeAAAVHgAAFR4AABceAAAXHgAAGR4AABkeAAAbHgAAGx4AAB0eAAAdHgAAHx4AAB8eAAAhHgAAIR4AACMeAAAjHgAAJR4AACUeAAAnHgAAJx4AACkeAAApHgAAKx4AACseAAAtHgAALR4AAC8eAAAvHgAAMR4AADEeAAAzHgAAMx4AADUeAAA1HgAANx4AADceAAA5HgAAOR4AADseAAA7HgAAPR4AAD0eAAA/HgAAPx4AAEEeAABBHgAAQx4AAEMeAABFHgAARR4AAEceAABHHgAASR4AAEkeAABLHgAASx4AAE0eAABNHgAATx4AAE8eAABRHgAAUR4AAFMeAABTHgAAVR4AAFUeAABXHgAAVx4AAFkeAABZHgAAWx4AAFseAABdHgAAXR4AAF8eAABfHgAAYR4AAGEeAABjHgAAYx4AAGUeAABlHgAAZx4AAGceAABpHgAAaR4AAGseAABrHgAAbR4AAG0eAABvHgAAbx4AAHEeAABxHgAAcx4AAHMeAAB1HgAAdR4AAHceAAB3HgAAeR4AAHkeAAB7HgAAex4AAH0eAAB9HgAAfx4AAH8eAACBHgAAgR4AAIMeAACDHgAAhR4AAIUeAACHHgAAhx4AAIkeAACJHgAAix4AAIseAACNHgAAjR4AAI8eAACPHgAAkR4AAJEeAACTHgAAkx4AAJUeAACbHgAAoR4AAKEeAACjHgAAox4AAKUeAAClHgAApx4AAKceAACpHgAAqR4AAKseAACrHgAArR4AAK0eAACvHgAArx4AALEeAACxHgAAsx4AALMeAAC1HgAAtR4AALceAAC3HgAAuR4AALkeAAC7HgAAux4AAL0eAAC9HgAAvx4AAL8eAADBHgAAwR4AAMMeAADDHgAAxR4AAMUeAADHHgAAxx4AAMkeAADJHgAAyx4AAMseAADNHgAAzR4AAM8eAADPHgAA0R4AANEeAADTHgAA0x4AANUeAADVHgAA1x4AANceAADZHgAA2R4AANseAADbHgAA3R4AAN0eAADfHgAA3x4AAOEeAADhHgAA4x4AAOMeAADlHgAA5R4AAOceAADnHgAA6R4AAOkeAADrHgAA6x4AAO0eAADtHgAA7x4AAO8eAADxHgAA8R4AAPMeAADzHgAA9R4AAPUeAAD3HgAA9x4AAPkeAAD5HgAA+x4AAPseAAD9HgAA/R4AAP8eAAAHHwAAEB8AABUfAAAgHwAAJx8AADAfAAA3HwAAQB8AAEUfAABQHwAAVx8AAGAfAABnHwAAcB8AAH0fAACAHwAAtB8AALYfAAC3HwAAvB8AALwfAAC+HwAAvh8AAMIfAADEHwAAxh8AAMcfAADMHwAAzB8AANAfAADTHwAA1h8AANcfAADgHwAA5x8AAPIfAAD0HwAA9h8AAPcfAAD8HwAA/B8AAE4hAABOIQAAcCEAAH8hAACEIQAAhCEAANAkAADpJAAAMCwAAF8sAABhLAAAYSwAAGUsAABmLAAAaCwAAGgsAABqLAAAaiwAAGwsAABsLAAAcywAAHMsAAB2LAAAdiwAAIEsAACBLAAAgywAAIMsAACFLAAAhSwAAIcsAACHLAAAiSwAAIksAACLLAAAiywAAI0sAACNLAAAjywAAI8sAACRLAAAkSwAAJMsAACTLAAAlSwAAJUsAACXLAAAlywAAJksAACZLAAAmywAAJssAACdLAAAnSwAAJ8sAACfLAAAoSwAAKEsAACjLAAAoywAAKUsAAClLAAApywAAKcsAACpLAAAqSwAAKssAACrLAAArSwAAK0sAACvLAAArywAALEsAACxLAAAsywAALMsAAC1LAAAtSwAALcsAAC3LAAAuSwAALksAAC7LAAAuywAAL0sAAC9LAAAvywAAL8sAADBLAAAwSwAAMMsAADDLAAAxSwAAMUsAADHLAAAxywAAMksAADJLAAAyywAAMssAADNLAAAzSwAAM8sAADPLAAA0SwAANEsAADTLAAA0ywAANUsAADVLAAA1ywAANcsAADZLAAA2SwAANssAADbLAAA3SwAAN0sAADfLAAA3ywAAOEsAADhLAAA4ywAAOMsAADsLAAA7CwAAO4sAADuLAAA8ywAAPMsAAAALQAAJS0AACctAAAnLQAALS0AAC0tAABBpgAAQaYAAEOmAABDpgAARaYAAEWmAABHpgAAR6YAAEmmAABJpgAAS6YAAEumAABNpgAATaYAAE+mAABPpgAAUaYAAFGmAABTpgAAU6YAAFWmAABVpgAAV6YAAFemAABZpgAAWaYAAFumAABbpgAAXaYAAF2mAABfpgAAX6YAAGGmAABhpgAAY6YAAGOmAABlpgAAZaYAAGemAABnpgAAaaYAAGmmAABrpgAAa6YAAG2mAABtpgAAgaYAAIGmAACDpgAAg6YAAIWmAACFpgAAh6YAAIemAACJpgAAiaYAAIumAACLpgAAjaYAAI2mAACPpgAAj6YAAJGmAACRpgAAk6YAAJOmAACVpgAAlaYAAJemAACXpgAAmaYAAJmmAACbpgAAm6YAACOnAAAjpwAAJacAACWnAAAnpwAAJ6cAACmnAAAppwAAK6cAACunAAAtpwAALacAAC+nAAAvpwAAM6cAADOnAAA1pwAANacAADenAAA3pwAAOacAADmnAAA7pwAAO6cAAD2nAAA9pwAAP6cAAD+nAABBpwAAQacAAEOnAABDpwAARacAAEWnAABHpwAAR6cAAEmnAABJpwAAS6cAAEunAABNpwAATacAAE+nAABPpwAAUacAAFGnAABTpwAAU6cAAFWnAABVpwAAV6cAAFenAABZpwAAWacAAFunAABbpwAAXacAAF2nAABfpwAAX6cAAGGnAABhpwAAY6cAAGOnAABlpwAAZacAAGenAABnpwAAaacAAGmnAABrpwAAa6cAAG2nAABtpwAAb6cAAG+nAAB6pwAAeqcAAHynAAB8pwAAf6cAAH+nAACBpwAAgacAAIOnAACDpwAAhacAAIWnAACHpwAAh6cAAIynAACMpwAAkacAAJGnAACTpwAAlKcAAJenAACXpwAAmacAAJmnAACbpwAAm6cAAJ2nAACdpwAAn6cAAJ+nAAChpwAAoacAAKOnAACjpwAApacAAKWnAACnpwAAp6cAAKmnAACppwAAtacAALWnAAC3pwAAt6cAALmnAAC5pwAAu6cAALunAAC9pwAAvacAAL+nAAC/pwAAwacAAMGnAADDpwAAw6cAAMinAADIpwAAyqcAAMqnAADRpwAA0acAANenAADXpwAA2acAANmnAAD2pwAA9qcAAFOrAABTqwAAcKsAAL+rAAAA+wAABvsAABP7AAAX+wAAQf8AAFr/AAAoBAEATwQBANgEAQD7BAEAlwUBAKEFAQCjBQEAsQUBALMFAQC5BQEAuwUBALwFAQDADAEA8gwBAMAYAQDfGAEAYG4BAH9uAQAi6QEAQ+kBAAAAAAADAAAAoBMAAPUTAAD4EwAA/RMAAHCrAAC/qwAAAQAAALAPAQDLDwEAQfCLBwvTK7oCAAB4AwAAeQMAAIADAACDAwAAiwMAAIsDAACNAwAAjQMAAKIDAACiAwAAMAUAADAFAABXBQAAWAUAAIsFAACMBQAAkAUAAJAFAADIBQAAzwUAAOsFAADuBQAA9QUAAP8FAAAOBwAADgcAAEsHAABMBwAAsgcAAL8HAAD7BwAA/AcAAC4IAAAvCAAAPwgAAD8IAABcCAAAXQgAAF8IAABfCAAA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CQAAggkAAIMJAACFCQAAjAkAAI8JAACQCQAAkwkAAKgJAACqCQAAsAkAALIJAACyCQAAtgkAALkJAAC9CQAAvQkAAL8JAADACQAAxwkAAMgJAADLCQAAzAkAAM4JAADOCQAA3AkAAN0JAADfCQAA4QkAAOYJAAD9CQAAAwoAAAMKAAAFCgAACgoAAA8KAAAQCgAAEwoAACgKAAAqCgAAMAoAADIKAAAzCgAANQoAADYKAAA4CgAAOQoAAD4KAABACgAAWQoAAFwKAABeCgAAXgoAAGYKAABvCgAAcgoAAHQKAAB2CgAAdgoAAIMKAACDCgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvQoAAMAKAADJCgAAyQoAAMsKAADMCgAA0AoAANAKAADgCgAA4QoAAOYKAADxCgAA+QoAAPkKAAACCwAAAwsAAAULAAAMCwAADwsAABALAAATCwAAKAsAACoLAAAwCwAAMgsAADMLAAA1CwAAOQsAAD0LAAA9CwAAQAsAAEALAABHCwAASAsAAEsLAABMCwAAXAsAAF0LAABfCwAAYQsAAGYLAAB3CwAAgwsAAIMLAACFCwAAigsAAI4LAACQCwAAkgsAAJULAACZCwAAmgsAAJwLAACcCwAAngsAAJ8LAACjCwAApAsAAKgLAACqCwAArgsAALkLAAC/CwAAvwsAAMELAADCCwAAxgsAAMgLAADKCwAAzAsAANALAADQCwAA5gsAAPoLAAABDAAAAwwAAAUMAAAMDAAADgwAABAMAAASDAAAKAwAACoMAAA5DAAAPQwAAD0MAABBDAAARAwAAFgMAABaDAAAXQwAAF0MAABgDAAAYQwAAGYMAABvDAAAdwwAAIAMAACCDAAAjAwAAI4MAACQDAAAkgwAAKgMAACqDAAAswwAALUMAAC5DAAAvQwAAL4MAADADAAAwQwAAMMMAADEDAAAxwwAAMgMAADKDAAAywwAAN0MAADeDAAA4AwAAOEMAADmDAAA7wwAAPEMAADyDAAAAg0AAAwNAAAODQAAEA0AABINAAA6DQAAPQ0AAD0NAAA/DQAAQA0AAEYNAABIDQAASg0AAEwNAABODQAATw0AAFQNAABWDQAAWA0AAGENAABmDQAAfw0AAIINAACDDQAAhQ0AAJYNAACa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CgAANgoAADgKAAA5CgAAPAoAADwKAAA+CgAAQgoAAEcKAABICgAASwoAAE0KAABRCgAAUQoAAFkKAABcCgAAXgoAAF4KAABmCgAAdQoAAIEKAACDCgAAhQoAAI0KAACPCgAAkQoAAJMKAACoCgAAqgoAALAKAACyCgAAswoAALUKAAC5CgAAvAoAAMUKAADHCgAAyQoAAMsKAADNCgAA0AoAANAKAADgCgAA4woAAOYKAADvCgAA+QoAAP8KAAABCwAAAwsAAAULAAAMCwAADwsAABALAAATCwAAKAsAACoLAAAwCwAAMgsAADMLAAA1CwAAOQsAADwLAABECwAARwsAAEgLAABLCwAATQsAAFULAABXCwAAXAsAAF0LAABfCwAAYwsAAGYLAABvCwAAcQsAAHELAACCCwAAgwsAAIULAACKCwAAjgsAAJALAACSCwAAlQsAAJkLAACaCwAAnAsAAJwLAACeCwAAnwsAAKMLAACkCwAAqAsAAKoLAACuCwAAuQsAAL4LAADCCwAAxgsAAMgLAADKCwAAzQsAANALAADQCwAA1wsAANcLAADmCwAA7wsAAAAMAAAMDAAADgwAABAMAAASDAAAKAwAACoMAAA5DAAAPAwAAEQMAABGDAAASAwAAEoMAABNDAAAVQwAAFYMAABYDAAAWgwAAF0MAABdDAAAYAwAAGMMAABmDAAAbwwAAIAMAACDDAAAhQwAAIwMAACODAAAkAwAAJIMAACoDAAAqgwAALMMAAC1DAAAuQwAALwMAADEDAAAxgwAAMgMAADKDAAAzQwAANUMAADWDAAA3QwAAN4MAADgDAAA4wwAAOYMAADvDAAA8QwAAPIMAAAADQAADA0AAA4NAAAQDQAAEg0AAEQNAABGDQAASA0AAEoNAABODQAAVA0AAFcNAABfDQAAYw0AAGYNAABvDQAAeg0AAH8NAACBDQAAgw0AAIUNAACWDQAAmg0AALENAACzDQAAuw0AAL0NAAC9DQAAwA0AAMYNAADKDQAAyg0AAM8NAADUDQAA1g0AANYNAADYDQAA3w0AAOYNAADvDQAA8g0AAPMNAAABDgAAOg4AAEAOAABODgAAUA4AAFkOAACBDgAAgg4AAIQOAACEDgAAhg4AAIoOAACMDgAAow4AAKUOAAClDgAApw4AAL0OAADADgAAxA4AAMYOAADG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vx4AAMEeAADBHgAAwx4AAMMeAADFHgAAxR4AAMceAADHHgAAyR4AAMkeAADLHgAAyx4AAM0eAADNHgAAzx4AAM8eAADRHgAA0R4AANMeAADTHgAA1R4AANUeAADXHgAA1x4AANkeAADZHgAA2x4AANseAADdHgAA3R4AAN8eAADfHgAA4R4AAOEeAADjHgAA4x4AAOUeAADlHgAA5x4AAOceAADpHgAA6R4AAOseAADrHgAA7R4AAO0eAADvHgAA7x4AAPEeAADxHgAA8x4AAPMeAAD1HgAA9R4AAPceAAD3HgAA+R4AAPkeAAD7HgAA+x4AAP0eAAD9HgAA/x4AAAcfAAAQHwAAFR8AACAfAAAnHwAAMB8AADcfAABAHwAARR8AAFAfAABXHwAAYB8AAGcfAABwHwAAfR8AAIAfAACHHwAAkB8AAJcfAACgHwAApx8AALAfAAC0HwAAth8AALcfAAC+HwAAvh8AAMIfAADEHwAAxh8AAMcfAADQHwAA0x8AANYfAADXHwAA4B8AAOcfAADyHwAA9B8AAPYfAAD3HwAACiEAAAohAAAOIQAADyEAABMhAAATIQAALyEAAC8hAAA0IQAANCEAADkhAAA5IQAAPCEAAD0hAABGIQAASSEAAE4hAABOIQAAhCEAAIQhAAAwLAAAXywAAGEsAABhLAAAZSwAAGYsAABoLAAAaCwAAGosAABqLAAAbCwAAGwsAABxLAAAcSwAAHMsAAB0LAAAdiwAAHssAACBLAAAgSwAAIMsAACDLAAAhSwAAIUsAACHLAAAhywAAIksAACJLAAAiywAAIssAACNLAAAjSwAAI8sAACPLAAAkSwAAJEsAACTLAAAkywAAJUsAACVLAAAlywAAJcsAACZLAAAmSwAAJssAACbLAAAnSwAAJ0sAACfLAAAnywAAKEsAAChLAAAoywAAKMsAAClLAAApSwAAKcsAACnLAAAqSwAAKksAACrLAAAqywAAK0sAACtLAAArywAAK8sAACxLAAAsSwAALMsAACzLAAAtSwAALUsAAC3LAAAtywAALksAAC5LAAAuywAALssAAC9LAAAvSwAAL8sAAC/LAAAwSwAAMEsAADDLAAAwywAAMUsAADFLAAAxywAAMcsAADJLAAAySwAAMssAADLLAAAzSwAAM0sAADPLAAAzywAANEsAADRLAAA0ywAANMsAADVLAAA1SwAANcsAADXLAAA2SwAANksAADbLAAA2ywAAN0sAADdLAAA3ywAAN8sAADhLAAA4SwAAOMsAADkLAAA7CwAAOwsAADuLAAA7iwAAPMsAADzLAAAAC0AACUtAAAnLQAAJy0AAC0tAAAtLQAAQaYAAEGmAABDpgAAQ6YAAEWmAABFpgAAR6YAAEemAABJpgAASaYAAEumAABLpgAATaYAAE2mAABPpgAAT6YAAFGmAABRpgAAU6YAAFOmAABVpgAAVaYAAFemAABXpgAAWaYAAFmmAABbpgAAW6YAAF2mAABdpgAAX6YAAF+mAABhpgAAYaYAAGOmAABjpgAAZaYAAGWmAABnpgAAZ6YAAGmmAABppgAAa6YAAGumAABtpgAAbaYAAIGmAACBpgAAg6YAAIOmAACFpgAAhaYAAIemAACHpgAAiaYAAImmAACLpgAAi6YAAI2mAACNpgAAj6YAAI+mAACRpgAAkaYAAJOmAACTpgAAlaYAAJWmAACXpgAAl6YAAJmmAACZpgAAm6YAAJumAAAjpwAAI6cAACWnAAAlpwAAJ6cAACenAAAppwAAKacAACunAAArpwAALacAAC2nAAAvpwAAMacAADOnAAAzpwAANacAADWnAAA3pwAAN6cAADmnAAA5pwAAO6cAADunAAA9pwAAPacAAD+nAAA/pwAAQacAAEGnAABDpwAAQ6cAAEWnAABFpwAAR6cAAEenAABJpwAASacAAEunAABLpwAATacAAE2nAABPpwAAT6cAAFGnAABRpwAAU6cAAFOnAABVpwAAVacAAFenAABXpwAAWacAAFmnAABbpwAAW6cAAF2nAABdpwAAX6cAAF+nAABhpwAAYacAAGOnAABjpwAAZacAAGWnAABnpwAAZ6cAAGmnAABppwAAa6cAAGunAABtpwAAbacAAG+nAABvpwAAcacAAHinAAB6pwAAeqcAAHynAAB8pwAAf6cAAH+nAACBpwAAgacAAIOnAACDpwAAhacAAIWnAACHpwAAh6cAAIynAACMpwAAjqcAAI6nAACRpwAAkacAAJOnAACVpwAAl6cAAJenAACZpwAAmacAAJunAACbpwAAnacAAJ2nAACfpwAAn6cAAKGnAAChpwAAo6cAAKOnAAClpwAApacAAKenAACnpwAAqacAAKmnAACvpwAA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AACmHgAAph4AAKgeAACoHgAAqh4AAKoeAACsHgAArB4AAK4eAACuHgAAsB4AALAeAACyHgAAsh4AALQeAAC0HgAAth4AALYeAAC4HgAAuB4AALoeAAC6HgAAvB4AALweAAC+HgAAvh4AAMAeAADAHgAAwh4AAMIeAADEHgAAxB4AAMYeAADGHgAAyB4AAMgeAADKHgAAyh4AAMweAADMHgAAzh4AAM4eAADQHgAA0B4AANIeAADSHgAA1B4AANQeAADWHgAA1h4AANgeAADYHgAA2h4AANoeAADcHgAA3B4AAN4eAADeHgAA4B4AAOAeAADiHgAA4h4AAOQeAADkHgAA5h4AAOYeAADoHgAA6B4AAOoeAADqHgAA7B4AAOweAADuHgAA7h4AAPAeAADwHgAA8h4AAPIeAAD0HgAA9B4AAPYeAAD2HgAA+B4AAPgeAAD6HgAA+h4AAPweAAD8HgAA/h4AAP4eAAAIHwAADx8AABgfAAAdHwAAKB8AAC8fAAA4HwAAPx8AAEgfAABNHwAAWR8AAFkfAABbHwAAWx8AAF0fAABdHwAAXx8AAF8fAABoHwAAbx8AALgfAAC7HwAAyB8AAMsfAADYHwAA2x8AAOgfAADsHwAA+B8AAPsfAAACIQAAAiEAAAchAAAHIQAACyEAAA0hAAAQIQAAEiEAABUhAAAVIQAAGSEAAB0hAAAkIQAAJCEAACYhAAAmIQAAKCEAACghAAAqIQAALSEAADAhAAAzIQAAPiEAAD8hAABFIQAARSEAAIMhAACDIQAAACwAAC8sAABgLAAAYCwAAGIsAABkLAAAZywAAGcsAABpLAAAaSwAAGssAABrLAAAbSwAAHAsAAByLAAAciwAAHUsAAB1LAAAfiwAAIAsAACCLAAAgiwAAIQsAACELAAAhiwAAIYsAACILAAAiCwAAIosAACKLAAAjCwAAIwsAACOLAAAjiwAAJAsAACQLAAAkiwAAJIsAACULAAAlCwAAJYsAACWLAAAmCwAAJgsAACaLAAAmiwAAJwsAACcLAAAniwAAJ4sAACgLAAAoCwAAKIsAACiLAAApCwAAKQsAACmLAAApiwAAKgsAACoLAAAqiwAAKosAACsLAAArCwAAK4sAACuLAAAsCwAALAsAACyLAAAsiwAALQsAAC0LAAAtiwAALYsAAC4LAAAuCwAALosAAC6LAAAvCwAALwsAAC+LAAAviwAAMAsAADALAAAwiwAAMIsAADELAAAxCwAAMYsAADGLAAAyCwAAMgsAADKLAAAyiwAAMwsAADMLAAAziwAAM4sAADQLAAA0CwAANIsAADSLAAA1CwAANQsAADWLAAA1iwAANgsAADYLAAA2iwAANosAADcLAAA3CwAAN4sAADeLAAA4CwAAOAsAADiLAAA4iwAAOssAADrLAAA7SwAAO0sAADyLAAA8iwAAECmAABApgAAQqYAAEKmAABEpgAARKYAAEamAABGpgAASKYAAEimAABKpgAASqYAAEymAABMpgAATqYAAE6mAABQpgAAUKYAAFKmAABSpgAAVKYAAFSmAABWpgAAVqYAAFimAABYpgAAWqYAAFqmAABcpgAAXKYAAF6mAABepgAAYKYAAGCmAABipgAAYqYAAGSmAABkpgAAZqYAAGamAABopgAAaKYAAGqmAABqpgAAbKYAAGymAACApgAAgKYAAIKmAACCpgAAhKYAAISmAACGpgAAhqYAAIimAACIpgAAiqYAAIqmAACMpgAAjKYAAI6mAACOpgAAkKYAAJCmAACSpgAAkqYAAJSmAACUpgAAlqYAAJamAACYpgAAmKYAAJqmAACapgAAIqcAACKnAAAkpwAAJKcAACanAAAmpwAAKKcAACinAAAqpwAAKqcAACynAAAspwAALqcAAC6nAAAypwAAMqcAADSnAAA0pwAANqcAADanAAA4pwAAOKcAADqnAAA6pwAAPKcAADynAAA+pwAAPqcAAECnAABApwAAQqcAAEKnAABEpwAARKcAAEanAABGpwAASKcAAEinAABKpwAASqcAAEynAABMpwAATqcAAE6nAABQpwAAUKcAAFKnAABSpwAAVKcAAFSnAABWpwAAVqcAAFinAABYpwAAWqcAAFqnAABcpwAAXKcAAF6nAABepwAAYKcAAGCnAABipwAAYqcAAGSnAABkpwAAZqcAAGanAABopwAAaKcAAGqnAABqpwAAbKcAAGynAABupwAAbqcAAHmnAAB5pwAAe6cAAHunAAB9pwAAfqcAAICnAACApwAAgqcAAIKnAACEpwAAhKcAAIanAACGpwAAi6cAAIunAACNpwAAjacAAJCnAACQpwAAkqcAAJKnAACWpwAAlqcAAJinAACYpwAAmqcAAJqn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ADAFAABXBQAAWAUAAIsFAACMBQAAkAUAAJAFAADIBQAAzwUAAOsFAADuBQAA9QUAAP8FAAAOBwAADgcAAEsHAABMBwAAsgcAAL8HAAD7BwAA/AcAAC4IAAAvCAAAPwgAAD8IAABcCAAAXQgAAF8IAABfCAAAawgAAG8IAACPCAAAjwgAAJIIAACXCAAAhAkAAIQJAACNCQAAjgkAAJEJAACSCQAAqQkAAKkJAACxCQAAsQkAALMJAAC1CQAAugkAALsJAADFCQAAxgkAAMkJAADKCQAAzwkAANYJAADYCQAA2wkAAN4JAADeCQAA5AkAAOUJAAD/CQAAAAoAAAQKAAAECgAACwoAAA4KAAARCgAAEgoAACkKAAApCgAAMQoAADEKAAA0CgAANAoAADcKAAA3CgAAOgoAADsKAAA9CgAAPQoAAEMKAABGCgAASQoAAEoKAABOCgAAUAoAAFIKAABYCgAAXQoAAF0KAABfCgAAZQoAAHcKAACACgAAhAoAAIQKAACOCgAAjgoAAJIKAACSCgAAqQoAAKkKAACxCgAAsQoAALQKAAC0CgAAugoAALsKAADGCgAAxgoAAMoKAADKCgAAzgoAAM8KAADRCgAA3woAAOQKAADlCgAA8goAAPgKAAAACwAAAAsAAAQLAAAECwAADQsAAA4LAAARCwAAEgsAACkLAAApCwAAMQsAADELAAA0CwAANAsAADoLAAA7CwAARQsAAEYLAABJCwAASgsAAE4LAABUCwAAWAsAAFsLAABeCwAAXgsAAGQLAABlCwAAeAsAAIELAACECwAAhAsAAIsLAACNCwAAkQsAAJELAACWCwAAmAsAAJsLAACbCwAAnQsAAJ0LAACgCwAAogsAAKULAACnCwAAqwsAAK0LAAC6CwAAvQsAAMMLAADFCwAAyQsAAMkLAADOCwAAzwsAANELAADWCwAA2AsAAOULAAD7CwAA/wsAAA0MAAANDAAAEQwAABEMAAApDAAAKQwAADoMAAA7DAAARQwAAEUMAABJDAAASQwAAE4MAABUDAAAVwwAAFcMAABbDAAAXAwAAF4MAABfDAAAZAwAAGUMAABwDAAAdgwAAI0MAACNDAAAkQwAAJEMAACpDAAAqQwAALQMAAC0DAAAugwAALsMAADFDAAAxQwAAMkMAADJDAAAzgwAANQMAADXDAAA3AwA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AD0AAwH//wAAQgCdAEcADQH//wAA//8AAP//AAD//wAA//8AAP//AABMACQB//8AAFIANwD//wAA//8AAFUAlwD//wAA//8AAP//AABYAIcA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAXABWAP//AABhANIA//8AAP//AAD//wAAZACBAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABsAI0A//8AAHEAJwB2ACcA//8AAP//AAB9ANMAgACaAP//AAD//wAAjQBaAP//AACSAM4A//8AAP//AACVAJkA//8AAKEA2AGuAFMAswBaAP//AAD//wAA//8AALkAoQC9AKEA//8AAMIAdADHAJwA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADMAI0A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAzgCUANMALQD//wAA//8AAP//AAD//wAA2ADIAf//AAD//wAA4gDbAf//AAD//wAA//8AAO8AHgH//wAA//8AAP//AAD//wAA+gATAgABGAL//wAA//8AAP//AAAHASUA//8AAP//AAD//wAA//8AAP//AAD//wAACQHtAf//AAD//wAAEgE4AP//AAD//wAAGQGRAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AACEBNwH//wAA//8AAP//AAD//wAAKwEIAv//AAD//wAA//8AAP//AAA1AW0A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AADoBGQL//wAA//8AAP//AABdAUQB//8AAP//AABlASYA//8AAGoB1AD//wAAhQGFAIgBkwD//wAA//8AAP//AAD//wAA//8AAP//AACNAcwAogE/AaoBvwH//wAAswHcAf//AAC9AY0AywEMAv//AAD//wAA//8AAP//AADsAZsA//8AAP//AAD//wAA//8AAP//AADxAegB/gG1AAMC+wEKAhgB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AABoCPAH//wAA//8AAP//AAD//wAA//8AACUC7wH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAALwKPAP//AAD//wAA//8AADcCYgH//wAA//8AAP//AAD//wAAQAJ8AP//AABDApQA//8AAP//AAD//wAAUAILAv//AAD//wAA//8AAP//AAD//wAA//8AAFwClgD//wAA//8AAF8CKwD//wAA//8AAP//AABiAgACdAIRAf//AAD//wAA//8AAIICFgD//wAA//8AAIcC1wCNAmwA//8AAP//AACSAiUB//8AAP//AAD//wAA//8AAP//AAD//wAAngIWAP//AACnAgUCsQIGAv//AADAAjkA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADFAswA//8AAP//AAD//wAA//8AAMgCbwDeAn4A//8AAP//AAD//wAA4wJ+AP//AADpAtkA//8AAP//AADsAiMB//8AAP//AAD//wAA//8AAP//AAD//wAA9QJKAf//AAD//wAABAOBAQ8DHAEaAzQB//8AACEDnwH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAKAPrAf//AAD//wAA//8AADEDEwE0A5kA//8AAP//AAD//wAA//8AAP//AAD//wAAOQPSAP//AAD//wAA//8AAEwDOgD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABPAyEB//8AAFgD1AD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAXAP6Af//AAD//wAA//8AAP//AABkA9UA//8AAP//AABnA5EA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAGwDIAL//wAA//8AAP//AAD//wAAfAOaAIEDnwD//wAAhgN0AP//AACPA2sA//8AAJQDbwD//wAA//8AAP//AACZAw0B//8AAP//AACgA34B//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAwwMLAc8DIgD//wAA//8AAP//AAD//wAA1AMOAP//AADaAzcA//8AAP//AADlAxUA//8AAP//AADsA6AB/wPjAf//AAD//wAA//8AABQEewD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAGwT/Af//AAD//wAA//8AAP//AAD//wAAKQSmAf//AAD//wAA//8AAP//AAD//wAA//8AADcE2gH//wAA//8AAEkEswFhBHMA//8AAP//AABmBHMAbgStAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAiwR7AP//AACNBPgB//8AAP//AAD//wAAlAS3Af//AAD//wAA//8AAP//AAD//wAA//8AAJ8EQQK4BDQCxwSrAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA1AQXAuIECwHnBEYC//8AAP//AAD//wAA//8AAP//AAD2BD8C//8AAP//AAD//wAA//8AAP//AAACBc0B//8AAP//AAD//wAA//8AAP//AAAMBTUB//8AAP//AAASBSEA//8AABkFwQH//wAA//8AAP//AAD//wAA//8AAP//AAAlBW0B//8AAP//AABJBaAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAFMFDAFYBdYA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAZwVZAP//AAD//wAA//8AAP//AABuBXcA//8AAP//AAD//wAAcwVPAX8F5QH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAjAVVAJMFvAH//wAA//8AAP//AACkBZsA//8AAP//AAC0BXUA//8AAP//AAC5BSsA//8AAP//AADBBcoA0wU1Av//AAD//wAA//8AAP//AAD//wAA2wXmAP//AADeBYkA//8AAP//AAD//wAA//8AAOEFJgH//wAA//8AAP//AAD//wAA//8AAOsFlgEEBk4C//8AACsG6AD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAC4GaQAyBtkB//8AAP//AAD//wAA//8AAP//AAD//wAARAbIAP//AABJBr4B//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAFIGMQL//wAA//8AAP//AAD//wAA//8AAFkGZwD//wAAawYfAnwGhgH//wAA//8AAIkG6wCOBhoA//8AAP//AAD//wAAlAZmAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AALIGOgL//wAA//8AAP//AADABhwAxQZYAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADLBhwA//8AANEGygD//wAA//8AAP//AAD//wAA//8AAP//AADXBjIB//8AAOMGkwH//wAA//8AAP//AAD//wAA//8AAP//AAD5BiECDgcbAP//AAD//wAA//8AAP//AAD//wAA//8AABMHagD//wAA//8AABcHBwD//wAA//8AAB0HuQH//wAA//8AADAHTAE6BycC//8AAP//AAD//wAA//8AAP//AABLByUC//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAGUH3QD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAGoHlQH//wAAeAf1AX8H3QD//wAA//8AAP//AACJB9wA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACLB3EAkQdlAf//AAD//wAAoweDAKgHywCtB2sB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAMQHKALiB3MB//8AAAII5wD//wAA//8AAAUIPgL//wAAKgjEAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAA1CM0A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AADgIswD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAD0IDQD//wAA//8AAP//AAD//wAA//8AAP//AABDCG0A//8AAEgI/QH//wAA//8AAP//AABVCBYB//8AAP//AAD//wAA//8AAP//AABmCJgBcwhIAf//AAB7COAB//8AAIcIaQD//wAA//8AAP//AAD//wAA//8AAJII4gH//wAA//8AAKMI3wD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAApghoAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAKsIpAG8CAYA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADCCBkA//8AAMcIgAH//wAA//8AAP//AADSCMsB5gjGAf//AAD//wAA8AgCAP//AAD//wAA9ggZAQ8JNAD//wAA//8AAP//AAAYCdUB//8AACEJ0QD//wAA//8AACwJNAD//wAAMQkdADkJkwD//wAA//8AAEEJMgL//wAA//8AAP//AAD//wAA//8AAEoJWQD//wAA//8AAFcJGQBgCWoA//8AAP//AAD//wAAaAkvAf//AABwCfIB//8AAP//AAD//wAA//8AAP//AAB6CS4A//8AAH8JLQD//wAAhglyAI0J7gGYCVcA//8AAP//AAD//wAA//8AAKUJPgH//wAA//8AAP//AACtCSkA//8AAP//AACzCaIB//8AAP//AADLCXkA0gm7Af//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADoCdsA7Ql2AP//AAD//wAA//8AAP//AADyCZIA/QmIAAcKJgD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AABoKUgEkCp0A//8AAP//AAApCjoB//8AAP//AAD//wAANAp6AP//AAD//wAA//8AAP//AAA5CjAA//8AAD4KDQL//wAA//8AAFcKhAD//wAA//8AAP//AABaChEB//8AAP//AABdCjMB//8AAP//AAD//wAA//8AAP//AABnCvMB//8AAP//AABzCgwB//8AAP//AAD//wAA//8AAHwKCwD//wAAgwofAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAiQo1AP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACUCvcB//8AAP//AAD//wAAngorAv//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAtAoRALkKNQD//wAA//8AAP//AAD//wAA//8AAL4KeADDCucB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAM8K9AH//wAA2QoaAP//AADeCm4A//8AAP//AADzClwA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD4CqAA//8AAP//AAD//wAA//8AAP0KdQEOC0kB//8AAP//AAD//wAA//8AAP//AAD//wAAGgsQAB8LyQH//wAA//8AAP//AAD//wAA//8AACcLXAE8C1MA//8AAEULdgBQC+UA//8AAP//AAD//wAA//8AAFgLeAD//wAA//8AAP//AAD//wAA//8AAF4L4AD//wAAZAt8AP//AAD//wAAcAuiAP//AAD//wAAeAtcAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAhQuVAP//AACKCx0B//8AAP//AACfCzgB//8AAKoLVQD//wAA//8AAP//AAD//wAA//8AAP//AACvC6UBxAtUAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAzwvXAN0LAgH//wAA4wuKAf//AAAEDHEAEAzbAP//AAD//wAA//8AAP//AAD//wAA//8AABYMRQH//wAA//8AAP//AAD//wAA//8AAP//AAAiDEsA//8AACgMTAJJDFYA//8AAP//AAD//wAA//8AAP//AABRDPYB//8AAFsM0wH//wAA//8AAP//AAD//wAA//8AAP//AABkDBAA//8AAP//AAD//wAAagyKAP//AABtDBwC//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAIEMcgD//wAAhgwsAf//AACRDO0A//8AAP//AAD//wAA//8AAP//AAD//wAAmwzhAf//AAD//wAA//8AAP//AACqDPUAsAwKAsIMuwDIDJABzgwhAP//AAD//wAA//8AANMMZAH//wAA7AwFAfAMBQH//wAA//8AAPUM3gD//wAA//8AAP//AAD//wAA//8AAP//AAD6DF0A//8AAP8M8gD//wAA//8AAP//AAAFDW0A//8AAA8NywD//wAA//8AABkNEAEeDQgA//8AACQNggD//wAA//8AAP//AAD//wAAKQ1dADIN9QD//wAA//8AAP//AAD//wAANw3SAf//AAD//wAA//8AAP//AABDDYQB//8AAEwNhwBiDQQC//8AAG4NSgL//wAA//8AAI8NWACeDcoB//8AAP//AACoDewB//8AAP//AAC2DV4A//8AAP//AAD//wAA//8AALoNXgC/DYAA//8AAP//AADFDTYA//8AANAN2AD//wAA//8AANgNYQD//wAA3Q2EAP//AAD//wAA//8AAP//AAD//wAA//8AAO0NAwD//wAA8w2MAf//AAD//wAACg6CAP//AAD//wAA//8AAP//AAD//wAAEg4RAv//AAApDmEA//8AAP//AAD//wAA//8AADEO8QE6DloBVA5nAf//AABsDhMA//8AAP//AACBDqQA//8AAIMOTQD//wAA//8AAJEO6QD//wAA//8AAP//AAD//wAAlA5lAP//AAD//wAA//8AAJkO4wD//wAA//8AAP//AAD//wAA//8AAP//AACeDoAA//8AAKMOHgD//wAAqA5uAP//AACtDqYA//8AAP//AAC5DqwAvA7eAP//AADHDhQC0A4yANQOHgD//wAA//8AAN4OGwHvDqoA8w6qAPgO+gD//wAA//8AAP0OvAADD7YA//8AAAgP9wD//wAADQ/3ABQPmgH//wAA//8AAB4PxgD//wAA//8AACAPLgH//wAAKA/kATEPIAE6D9QB//8AAP//AABHD8cBUQ8fAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAXQ89Av//AAB9DwkB//8AAIIPogD//wAA//8AAIcP1gGdD+UA//8AAP//AACiD+IA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAKoPfQH//wAA//8AAP//AAD//wAA//8AALsPlwD//wAAyQ8VAM4P8AH//wAA//8AAOYPIgD//wAA7g9BAf//AAD4D70A//8AAP//AAD9Dx0A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAAhAUAQ8QrwH//wAA//8AACoQPQD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAALxDZAP//AAD//wAA//8AAEEQPAJiEE4A//8AAHQQWwH//wAA//8AAP//AAD//wAA//8AAIQQfwCJEPwBkRAsAP//AAD//wAA//8AAP//AACYEIsAnRCLAP//AAD//wAApBBEAP//AACoEL0B//8AAP//AAD//wAAtxBAAP//AAD//wAAuhBFAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAL8QAwHHEFcA//8AAM4QowD//wAA//8AANMQowD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AANsQSwL//wAA/BBNAP//AAD//wAA//8AAP//AAABEWoB//8AABMRDgL//wAAIRFVAf//AAD//wAA//8AADcRAAH//wAA//8AADwRVABBEfQA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAEkRDwBXEb8A//8AAFsRxgD//wAA//8AAP//AABnEQYB//8AAP//AAD//wAAahHtAG8RAQJ5EdAB//8AAP//AAD//wAA//8AAP//AAD//wAAixFQAZMRlAH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAKQRIgL//wAA//8AAKwRNgH//wAA//8AAP//AAC2EasB//8AAP//AAD//wAA//8AAMYRYgDNEWkB//8AAP//AAD//wAA//8AAP//AAD//wAA3RHmAecRbAH//wAA//8AAPIR6QH//wAA//8AAPwRKgH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAAJEkwA//8AAP//AAD//wAAGBKHAf//AAD//wAA//8AAP//AAA1EmsAQRI5AP//AABIEmEB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAFYSYgD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAFsSiQH//wAA//8AAG4SHgL//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAfhLJAIwSGACUEikB//8AAP//AAD//wAAphLqAP//AAD//wAArhK3ALMSGgL//wAAvBI5AMESBQD//wAA//8AAP//AAD//wAAxxLBAP//AAD//wAAzBImAv//AAD//wAA5hLdAf4SRAD//wAACBPeAf//AAD//wAA//8AAP//AAAfEykC//8AAP//AAAvE54B//8AAP//AAD//wAA//8AAP//AABCE1ACSRNwAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAE4TPAD//wAAUxOmAP//AAD//wAA//8AAP//AAD//wAAWBPJAF8T8gD//wAAZBPCAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAGkT4AD//wAAehNsAP//AAD//wAA//8AAIoT+gCeE4wAoxOMAP//AACqEyAA//8AAP//AAD//wAArxNwAP//AAC4EzEA//8AALwTQwLWE8UB//8AAP//AADjE0AC//8AAP//AAD//wAA//8AAPgTbwH//wAAChSwAR8UKAD//wAA//8AAP//AAAtFI4B//8AAP//AAD//wAA//8AAP//AAD//wAAOhRUAkQUsQH//wAA//8AAP//AAD//wAAVBQ7Af//AAD//wAA//8AAP//AABpFOEA//8AAP//AAD//wAA//8AAHEUTgH//wAAfBRWAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAI4UDACTFHEB//8AALcU9gD//wAAvBSxAMEUZwD//wAA//8AAP//AADGFMMA//8AAP//AAD//wAAzRSnANsUGAD//wAA4BR6Af//AAD//wAA//8AAP//AAD0FLEA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAPwU4QD//wAA//8AAAEVKgL//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAFhWhASAVAQH//wAA//8AACUVfwH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABAFSAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAEkVjwH//wAA//8AAP//AABQFcMB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAFwV4wBkFRAB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAB0FRcA//8AAP//AAD//wAAfRWYAP//AACCFc4AkxW4AJgV6wD//wAA//8AAP//AACkFVECwxU5AdAVmADcFdAA4RUJAv//AAD//wAA8hV2AfsVJwH//wAA//8AAP//AAD//wAADhacAf//AAD//wAAJBY+AP//AAD//wAA//8AAP//AAD//wAA//8AACkWJAL//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAEMWUwH//wAA//8AAFcWWwD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAFwWMwD//wAAYBZbAP//AAD//wAA//8AAGkWlgD//wAA//8AAHUWAQB7FpAA//8AAIAW0QH//wAA//8AAIwWkAD//wAA//8AAP//AAD//wAAlhYJAP//AAD//wAAnBZRAf//AAD//wAA//8AAKUWyAD//wAA//8AAP//AAD//wAArxbsAP//AAD//wAA//8AAP//AAD//wAA//8AALQWnAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADIFjsA//8AAM0WMAH//wAA//8AANYWmQH//wAA6xbXAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD9FkIAAhf7AP//AAD//wAA//8AAP//AAAHF/sADhcjABMX/AD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAGBfqAP//AAAdF4kA//8AAP//AAD//wAALRcsAv//AAD//wAA//8AAE8XuQD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAFQXKgD//wAA//8AAP//AABmF5IB//8AAG4XQgD//wAA//8AAHYXdwGLFyMA//8AAJQXDwH//wAA//8AAP//AAD//wAA//8AAJ4XtAH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAshf/AP//AAD//wAA//8AALcX6gH//wAA//8AAP//AADAF6cA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAMMX0QD//wAA//8AAP//AAD//wAA//8AAP//AADIF6kA//8AAP//AAD//wAA//8AAM0XGgH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAOkXjgDuF18B//8AAP//AAD//wAA//8AAP//AAD//wAA//8AABQYtgD//wAAHxiOAP//AAAoGPMA//8AAP//AAD//wAAMBioADoYAAD//wAA//8AAEIY7wD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABHGPkB//8AAP//AAD//wAAXRgCAv//AAD//wAAixjiAP//AAD//wAA//8AAP//AAD//wAAkBgkAJUYBwGeGKQA//8AAP//AAD//wAApRgtArkYBgH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAyxhQAP//AADQGH8A//8AAP//AAD//wAA1xj/AP//AAD//wAA3xhgAP//AAD//wAA//8AAP//AAD//wAA//8AAOQYDwD//wAA//8AAP//AAD//wAA//8AAP//AADpGMAB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP4YCAH//wAA//8AAP//AAD//wAABRlPAv//AAD//wAA//8AAP//AAAmGXkA//8AAP//AAD//wAA//8AAP//AAD//wAAKxk7AP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAA1GSMC//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAEAZAQFJGUcC//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAGoZtQD//wAA//8AAP//AAD//wAAdBlZAf//AAD//wAA//8AAP//AAD//wAA//8AAJoZegD//wAA//8AAP//AAD//wAApBn4AKkZ7wD//wAA//8AALAZ8QD//wAA//8AAP//AAD//wAAuRmFAP//AAD//wAA//8AAP//AAD//wAAyBleAf//AADaGTAC//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADxGfYA//8AAP//AAD//wAA//8AAPcZqAD//wAA/BnCAf//AAD//wAA//8AAAUaPQEqGggB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAALxpNAVMasABYGvkAXRpoAP//AAD//wAA//8AAP//AABwGisBehqrAP//AAD//wAA//8AAP//AAB9GjoA//8AAP//AAD//wAA//8AAP//AAD//wAAhxpOAP//AAD//wAAjRpfAJIaSwH//wAA//8AAP//AAD//wAA//8AAJ0a5wCoGswB//8AAP//AACzGgcB//8AAP//AAD//wAAuBp8Af//AAD//wAA//8AAP//AAD//wAA0BotAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA2xp0AegaBwL//wAA//8AAP//AAD3GtAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP8aLwAEG60AChvBABobCgH//wAA//8AAP//AAD//wAA//8AAP//AAAlG7gBOBvkAP//AAD//wAA//8AAD0bJQD//wAA//8AAP//AAD//wAA//8AAEMbZQD//wAATBuXAVYbrABiG5sB//8AAP//AAD//wAA//8AAP//AABrG7wAcBtJAv//AAD//wAA//8AAP//AAD//wAAkRtAAZsbFQL//wAA//8AAP//AAD//wAA//8AAKYb+AD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAK0bxwCyG4gB//8AAP//AAD//wAA//8AAP//AAD//wAA0BvfAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAN8bRwH//wAA//8AAOcbQgH//wAA//8AAP//AAD//wAA//8AAO8bowEDHO4A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAAgcPwD//wAADRwJAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAAYHL4AHxyzAP//AAD//wAA//8AACkcNwL//wAA//8AAP//AAD//wAA//8AAD8cEwH//wAAThwVAf//AAD//wAA//8AAP//AABhHL4A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAHEcMAD//wAAhxy6Af//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAlxxGAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADEHCQA//8AAP//AAD//wAAyhydAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADVHD4A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADeHEYA//8AAOQcrQD//wAA//8AAP//AAD//wAA//8AAP//AAD6HKcB//8AAP//AAD//wAADB0bAP//AAAVHWAB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AACkdsgE+HTgC//8AAP//AAD//wAA//8AAP//AABkHbsA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAaR2sAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAB6HTIAkB1GAP//AAD//wAA//8AAP//AAD//wAAlR1jAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAJodQwH//wAA//8AAP//AAD//wAA//8AAP//AAClHXgB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAsB2CAf//AAD//wAA//8AAP//AAD//wAA//8AALsdtADAHdoA//8AAP//AADFHa4B4x1NAv//AAAEHkgC//8AAP//AAD//wAA//8AACAesgD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAALR7PAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAA+HgMCSh7fAf//AAD//wAA//8AAP//AAD//wAAWx4SAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAF4e1gD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAGMetQH//wAA//8AAP//AAD//wAA//8AAP//AAB+Hp4A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAI0eQwD//wAA//8AAP//AAD//wAA//8AAP//AACSHvQAlx6vAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACcHkMA//8AAP//AAD//wAA//8AAP//AACnHncA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAC5HnUA//8AAP//AAD//wAA//8AAMEeEgL//wAA0x7uAP//AAD//wAA3x79AP//AAD//wAA//8AAOQeTwD//wAA6h79AP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA8h5JAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD3Hr0A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD/Hv4B//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAAwfuQD//wAA//8AAP//AAD//wAA//8AABYfMQD//wAA//8AAP//AAD//wAALB89ADgfeQH//wAA//8AAP//AAD//wAASx9PAP//AAD//wAAXR8UAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAYR/DAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAcB+6AHUfHwF+H+kA//8AAIkfYwH//wAA//8AAKEfQgK1HzkCxB9fAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADLH1IA//8AAP//AADPH8QA1R8bAv//AAD//wAA//8AAOgfhgD//wAA//8AAPQfpQD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA+R+lAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAAMgrgAIIBIB//8AAP//AAD//wAA//8AAP//AAAbICgB//8AAP//AAD//wAA//8AAP//AAAtIC4C//8AAP//AAD//wAA//8AAP//AAA+IDMA//8AAP//AAD//wAA//8AAFQgsgBZIDsCaCAiAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAeyCLAf//AAD//wAA//8AAJMgVwH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAKggxQC3IMIA//8AAP//AAD//wAA//8AAMQgSQD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAMwgSgD//wAA//8AAP//AADRICwA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA1CA2Av//AAD//wAA6CDoAP//AAD//wAA//8AAP//AAD0IFIA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD9IFEA//8AAP//AAD//wAA//8AAP//AAAFIQoB//8AAP//AAD//wAADCHPAP//AAAPIUoA//8AAP//AAD//wAA//8AAP//AAAXIR0C//8AACohPAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAAyIdwA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAOSGRAf//AABNIV0B//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABpIY0B//8AAP//AAD//wAA//8AAP//AAD//wAAdyFYAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACWIbcA//8AAP//AAChIVQB//8AAP//AAD//wAA//8AAP//AAD//wAAtCETAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAuSEEAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAvyGoAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AANUhqgH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAPAhFgL//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA/iGwAP//AAD//wAA//8AAP//AAD//wAA//8AAAQibgH//wAA//8AABoixQD//wAA//8AACEiKgD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AACYixAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AADAirgD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AADYi7AA+IhcB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAE8iEgD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABaIkQC//8AAP//AABwInIB//8AAP//AAD//wAAlCK/AP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAsyJBAP//AAD//wAAviK0AP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAziLPAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA4SJRAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD2IgIB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAAHI8cA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAEyNFAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAB4j5AD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAKiPxAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAAvI/4A//8AAP//AAA4IwoA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAD4jtgH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAWyMEAf//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAGUjUAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABuI+YA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAfSPTAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACOI9oA//8AAJUjMwL//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAqSP+AP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAK4jZAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AALIjewH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAzCPwAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADRI84B//8AAP//AAD//wAA//8AAOIj8AD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADqI2AA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAPkjTAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP8jLwL//wAA//8AAP//AAD//wAA//8AABYkZAD//wAAHyQvAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAA1JM0A//8AAP//AAD//wAA//8AAP//AABFJLgAVSRHAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAAWiQPAv//AABwJPkA//8AAP//AAD//wAAdySKAP//AAD//wAA//8AAP//AAD//wAA//8AAIckEAL//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACqJGYA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACxJGMA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AALgkqQH//wAA//8AAMkkOAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAM4kwAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADVJMAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAOkkQQD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAO0kcAH//wAA//8AAAMlQAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAAdJYMB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAA3JboA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAEElUgL//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABgJYUB//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AABzJUUC//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AACXJa8A//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAKwl1QD//wAA//8AAP//AAD//wAA//8AAP//AAC8JUgA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AADBJUcA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAMolaAH//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA1yVIAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAOslUwJsYW5hAGxpbmEAegB5aQBtbgBjbgBtYWthAHlpaWkAbWFuaQBpbmthbm5hZGEAY2kAbG8AbGFvAGxhb28Aenp6egBtaWFvAHllemkAaW5ua28AY28AbWUAbG9lAGdyYW4AcGkAbGluZWFyYQBtYXJrAGNhcmkAY2FyaWFuAHBvAG1lbmRla2lrYWt1aQBncmVrAHBlAG1lZXRlaW1heWVrAGlua2hhcm9zaHRoaQBnZW9yAGdyZWVrAG1ybwBtcm9vAGthbmEAbWVybwBtAGdvbm0AY2FrbQBpbm9zbWFueWEAaW5tYW5pY2hhZWFuAGluYXJtZW5pYW4AaW5tcm8AaW5taWFvAGMAaW5jaGFrbWEAY29tbW9uAG1hbmRhaWMAaW5teWFubWFyAGlubWFrYXNhcgBxYWFpAGluaWRlb2dyYXBoaWNzeW1ib2xzYW5kcHVuY3R1YXRpb24AaW5raG1lcgBjYW5zAHByZXBlbmRlZGNvbmNhdGVuYXRpb25tYXJrAGxtAG1hcmMAY29ubmVjdG9ycHVuY3R1YXRpb24AaW5ydW5pYwBpbmNhcmlhbgBpbmF2ZXN0YW4AY29tYmluaW5nbWFyawBpbmN1bmVpZm9ybW51bWJlcnNhbmRwdW5jdHVhdGlvbgBtZXJjAGluY2hvcmFzbWlhbgBwZXJtAGluYWhvbQBpbmlwYWV4dGVuc2lvbnMAaW5jaGVyb2tlZQBpbnNoYXJhZGEAbWFrYXNhcgBpbmFycm93cwBsYwBtYXNhcmFtZ29uZGkAaW5jdW5laWZvcm0AbWMAY2MAaW56YW5hYmF6YXJzcXVhcmUAbGluZXNlcGFyYXRvcgBhcm1uAHFtYXJrAGFybWkAaW5zYW1hcml0YW4AYXJtZW5pYW4AaW5tYXJjaGVuAGlubWFzYXJhbWdvbmRpAHFhYWMAcGMAaW5zY3JpcHRpb25hbHBhcnRoaWFuAGxhdG4AbGF0aW4AcmkAaW50aGFhbmEAaW5raG1lcnN5bWJvbHMAaW5rYXRha2FuYQBpbmN5cmlsbGljAGludGhhaQBpbmNoYW0AaW5rYWl0aGkAenMAbXRlaQBpbml0aWFscHVuY3R1YXRpb24AY3MAaW5zeXJpYWMAcGNtAGludGFrcmkAcHMAbWFuZABpbmthbmFleHRlbmRlZGEAbWVuZABtb2RpAGthdGFrYW5hAGlkZW8AcHJ0aQB5ZXppZGkAaW5pZGVvZ3JhcGhpY2Rlc2NyaXB0aW9uY2hhcmFjdGVycwB4aWRjb250aW51ZQBicmFpAGFzY2lpAHByaXZhdGV1c2UAYXJhYmljAGlubXlhbm1hcmV4dGVuZGVkYQBpbnJ1bWludW1lcmFsc3ltYm9scwBsZXR0ZXIAaW5uYW5kaW5hZ2FyaQBpbm1lZXRlaW1heWVrAGlub2xkbm9ydGhhcmFiaWFuAGluY2prY29tcGF0aWJpbGl0eWZvcm1zAGtuZGEAa2FubmFkYQBpbmNqa2NvbXBhdGliaWxpdHlpZGVvZ3JhcGhzAGwAaW5tb2RpAGluc3BlY2lhbHMAaW50cmFuc3BvcnRhbmRtYXBzeW1ib2xzAGlubWVuZGVraWtha3VpAGxldHRlcm51bWJlcgBpbm1lZGVmYWlkcmluAHhpZGMAaW5jaGVzc3N5bWJvbHMAaW5lbW90aWNvbnMAaW5saW5lYXJhAGlubGFvAGJyYWhtaQBpbm9sZGl0YWxpYwBpbm1pc2NlbGxhbmVvdXNtYXRoZW1hdGljYWxzeW1ib2xzYQBtb25nb2xpYW4AeGlkcwBwc2FsdGVycGFobGF2aQBncmxpbmsAa2l0cwBpbnN1bmRhbmVzZQBpbm9sZHNvZ2RpYW4AZ290aGljAGluYW5jaWVudHN5bWJvbHMAbWVyb2l0aWNjdXJzaXZlAGthbGkAY29udHJvbABwYXR0ZXJud2hpdGVzcGFjZQBpbmFkbGFtAHNrAGx0AGlubWFuZGFpYwBpbmNvbW1vbmluZGljbnVtYmVyZm9ybXMAaW5jamtjb21wYXRpYmlsaXR5aWRlb2dyYXBoc3N1cHBsZW1lbnQAc28AaWRjAGlub2xkc291dGhhcmFiaWFuAHBhbG0AaW5seWNpYW4AaW50b3RvAGlkc2JpbmFyeW9wZXJhdG9yAGlua2FuYXN1cHBsZW1lbnQAaW5jamtzdHJva2VzAHNvcmEAYmFtdW0AaW5vcHRpY2FsY2hhcmFjdGVycmVjb2duaXRpb24AaW5kb21pbm90aWxlcwBiYXRrAGdyZXh0AGJhdGFrAHBhdHdzAGlubWFsYXlhbGFtAGlubW9kaWZpZXJ0b25lbGV0dGVycwBpbnNtYWxsa2FuYWV4dGVuc2lvbgBiYXNzAGlkcwBwcmludABpbmxpbmVhcmJpZGVvZ3JhbXMAaW50YWl0aGFtAGlubXVzaWNhbHN5bWJvbHMAaW56bmFtZW5ueW11c2ljYWxub3RhdGlvbgBzYW1yAGluc3lsb3RpbmFncmkAaW5uZXdhAHNhbWFyaXRhbgBzAGpvaW5jAGluY29udHJvbHBpY3R1cmVzAGxpc3UAcGF1YwBpbm1pc2NlbGxhbmVvdXNzeW1ib2xzAGluYW5jaWVudGdyZWVrbXVzaWNhbG5vdGF0aW9uAGlubWlzY2VsbGFuZW91c3N5bWJvbHNhbmRhcnJvd3MAc20AaW5taXNjZWxsYW5lb3Vzc3ltYm9sc2FuZHBpY3RvZ3JhcGhzAGludWdhcml0aWMAcGQAaXRhbABhbG51bQB6aW5oAGlud2FyYW5nY2l0aQBpbmxhdGluZXh0ZW5kZWRhAGluc2F1cmFzaHRyYQBpbnRhaWxlAGlub2xkdHVya2ljAGlkY29udGludWUAaW5oYW5pZmlyb2hpbmd5YQBzYwBpZHN0AGlubGF0aW5leHRlbmRlZGUAbG93ZXIAYmFsaQBpbmhpcmFnYW5hAGluY2F1Y2FzaWFuYWxiYW5pYW4AaW5kZXNlcmV0AGJsYW5rAGluc3BhY2luZ21vZGlmaWVybGV0dGVycwBjaGVyb2tlZQBpbmx5ZGlhbgBwaG9lbmljaWFuAGNoZXIAYmVuZ2FsaQBtYXJjaGVuAGlud2FuY2hvAGdyYXBoZW1lbGluawBiYWxpbmVzZQBpZHN0YXJ0AGludGFtaWwAaW5tdWx0YW5pAGNoYW0AY2hha21hAGthaXRoaQBpbm1haGFqYW5pAGdyYXBoZW1lYmFzZQBpbm9naGFtAGNhc2VkAGlubWVldGVpbWF5ZWtleHRlbnNpb25zAGtob2praQBpbmFuY2llbnRncmVla251bWJlcnMAcnVucgBraGFyAG1hbmljaGFlYW4AbG93ZXJjYXNlAGNhbmFkaWFuYWJvcmlnaW5hbABpbm9sY2hpa2kAcGxyZABpbmV0aGlvcGljAHNpbmQAY3djbQBpbmVhcmx5ZHluYXN0aWNjdW5laWZvcm0AbGwAemwAaW5zaW5oYWxhAGlua2h1ZGF3YWRpAHhpZHN0YXJ0AHhkaWdpdABiaWRpYwBjaG9yYXNtaWFuAGluc2lkZGhhbQBpbmNvdW50aW5ncm9kbnVtZXJhbHMAYWhvbQBjaHJzAGtobXIAaW5vbGR1eWdodXIAaW5ncmFudGhhAGJhbXUAaW5zY3JpcHRpb25hbHBhaGxhdmkAZ29uZwBtb25nAGlubGF0aW5leHRlbmRlZGMAaW5uZXd0YWlsdWUAYWRsbQBpbm9zYWdlAGluZ2VuZXJhbHB1bmN0dWF0aW9uAGdlb3JnaWFuAGtoYXJvc2h0aGkAc2luaGFsYQBraG1lcgBzdGVybQBjYXNlZGxldHRlcgBtdWx0YW5pAGd1bmphbGFnb25kaQBtYXRoAGluY3lyaWxsaWNzdXBwbGVtZW50AGluZ2VvcmdpYW4AZ290aABpbmNoZXJva2Vlc3VwcGxlbWVudABnbGFnb2xpdGljAHF1b3RhdGlvbm1hcmsAdWlkZW8AaW5jamt1bmlmaWVkaWRlb2dyYXBoc2V4dGVuc2lvbmEAam9pbmNvbnRyb2wAcnVuaWMAaW5tb25nb2xpYW4AZW1vamkAaW5jamt1bmlmaWVkaWRlb2dyYXBoc2V4dGVuc2lvbmUAZ3JhbnRoYQBpbnRpcmh1dGEAaW5oYXRyYW4AYWRsYW0AbHUAaW5raGl0YW5zbWFsbHNjcmlwdABrdGhpAGluZ3VybXVraGkAc3VuZGFuZXNlAGlub2xkaHVuZ2FyaWFuAHRha3JpAGludGFtaWxzdXBwbGVtZW50AG9yaXlhAGludmFpAGJyYWgAaW5taXNjZWxsYW5lb3VzdGVjaG5pY2FsAHZhaQB2YWlpAHNhdXIAZ3VydQB0YWlsZQBpbmhlcml0ZWQAcGF1Y2luaGF1AHphbmIAcHVuY3QAbGluYgBndXJtdWtoaQB0YWtyAGlubmFiYXRhZWFuAGlua2FuYnVuAGxvZ2ljYWxvcmRlcmV4Y2VwdGlvbgBpbmJoYWlrc3VraQBpbmNqa3VuaWZpZWRpZGVvZ3JhcGhzZXh0ZW5zaW9uYwBncmFwaGVtZWV4dGVuZABpbmVsYmFzYW4AaW5zb3Jhc29tcGVuZwBoYW4AaGFuaQBsaW1idQB1bmFzc2lnbmVkAHJhZGljYWwAaGFubwBsb3dlcmNhc2VsZXR0ZXIAY250cmwAaW5jamt1bmlmaWVkaWRlb2dyYXBocwBsaW5lYXJiAGluYW5hdG9saWFuaGllcm9nbHlwaHMAaGFudW5vbwBpbmtob2praQBpbmxhdGluZXh0ZW5kZWRhZGRpdGlvbmFsAGluZW5jbG9zZWRhbHBoYW51bWVyaWNzAGFuYXRvbGlhbmhpZXJvZ2x5cGhzAG4AZW1vamltb2RpZmllcgBzZABoaXJhAHNpZGQAbGltYgBiaGtzAHBobGkAbmFuZGluYWdhcmkAbm8Ac2F1cmFzaHRyYQBpbnRhbmdzYQBjd3QAYmhhaWtzdWtpAGluZ3JlZWthbmRjb3B0aWMAbmtvAG5rb28AdGVybQBvc2FnZQB4cGVvAHRuc2EAdGFuZ3NhAGlua2F5YWhsaQBwAGlub3JpeWEAaW55ZXppZGkAaW5hcmFiaWMAaW5waG9lbmljaWFuAGluc2hhdmlhbgBiaWRpY29udHJvbABpbmVuY2xvc2VkaWRlb2dyYXBoaWNzdXBwbGVtZW50AHdhcmEAbXVsdABpbm1lcm9pdGljaGllcm9nbHlwaHMAc2luaABzaGF2aWFuAGlua2FuZ3hpcmFkaWNhbHMAZW5jbG9zaW5nbWFyawBhcmFiAGluc2luaGFsYWFyY2hhaWNudW1iZXJzAGJyYWlsbGUAaW5oYW51bm9vAG9zbWEAYmVuZwBpbmJhc2ljbGF0aW4AaW5hcmFiaWNwcmVzZW50YXRpb25mb3Jtc2EAY3BtbgByZWdpb25hbGluZGljYXRvcgBpbmVuY2xvc2VkYWxwaGFudW1lcmljc3VwcGxlbWVudABlbW9qaW1vZGlmaWVyYmFzZQBpbmdyZWVrZXh0ZW5kZWQAbGVwYwBpbmRvZ3JhAGZvcm1hdABseWNpAGx5Y2lhbgBkaWEAaW5waGFpc3Rvc2Rpc2MAZGkAZGlhawB1bmtub3duAGdyYmFzZQBteW1yAG15YW5tYXIAaW5jamt1bmlmaWVkaWRlb2dyYXBoc2V4dGVuc2lvbmQAZW1vZABpbmdlb21ldHJpY3NoYXBlcwBpbmN5cHJvbWlub2FuAGluc3VuZGFuZXNlc3VwcGxlbWVudAB0b3RvAGdsYWcAdGFpdmlldABhc2NpaWhleGRpZ2l0AG9kaQBwdW5jdHVhdGlvbgB2cwBzdW5kAGluc295b21ibwBpbmltcGVyaWFsYXJhbWFpYwBpbmJhdGFrAGlubGF0aW5leHRlbmRlZGQAaW5udXNodQBpbnRpYmV0YW4AaW5sb3dzdXJyb2dhdGVzAGhhdHJhbgBpbmJsb2NrZWxlbWVudHMAaW5zb2dkaWFuAGluZGluZ2JhdHMAaW5lbHltYWljAGluZGV2YW5hZ2FyaQBlbW9qaWNvbXBvbmVudABpbmthdGFrYW5hcGhvbmV0aWNleHRlbnNpb25zAGlkZW9ncmFwaGljAGNvcHRpYwBpbm51bWJlcmZvcm1zAGhhdHIAaW5jamtjb21wYXRpYmlsaXR5AGlua2FuYWV4dGVuZGVkYgBwYXR0ZXJuc3ludGF4AGF2ZXN0YW4AaW5hcmFiaWNleHRlbmRlZGEAc29nZGlhbgBzb2dvAGludGFuZ3V0AGNvcHQAZ3JhcGgAb2lkYwBpbmJ5emFudGluZW11c2ljYWxzeW1ib2xzAGluaW5zY3JpcHRpb25hbHBhcnRoaWFuAGRpYWNyaXRpYwBpbmluc2NyaXB0aW9uYWxwYWhsYXZpAGlubWF5YW5udW1lcmFscwBpbm15YW5tYXJleHRlbmRlZGIAaW50YWdzAGphdmEAY3BydABuYW5kAHBhdHN5bgB0YWxlAG9pZHMAc2VudGVuY2V0ZXJtaW5hbABpbXBlcmlhbGFyYW1haWMAdGVybWluYWxwdW5jdHVhdGlvbgBseWRpAGx5ZGlhbgBib3BvAGphdmFuZXNlAGN3bABpbmdlb21ldHJpY3NoYXBlc2V4dGVuZGVkAGlub2xkcGVyc2lhbgBpbm9ybmFtZW50YWxkaW5nYmF0cwBpbmJyYWlsbGVwYXR0ZXJucwBpbnZhcmlhdGlvbnNlbGVjdG9ycwBjYXNlaWdub3JhYmxlAGlueWlyYWRpY2FscwBpbm5vYmxvY2sAaW52ZXJ0aWNhbGZvcm1zAGluZXRoaW9waWNzdXBwbGVtZW50AHNoYXJhZGEAaW5iYWxpbmVzZQBpbnZlZGljZXh0ZW5zaW9ucwB3b3JkAGlubWlzY2VsbGFuZW91c21hdGhlbWF0aWNhbHN5bWJvbHNiAHRhbWwAb2xjawBpZHNiAG9sb3dlcgBkZWNpbWFsbnVtYmVyAGF2c3QAaW5jeXJpbGxpY2V4dGVuZGVkYQBvbGNoaWtpAHNocmQAaW50YWl4dWFuamluZ3N5bWJvbHMAaW50YWl2aWV0AHVnYXIAaW5jamtzeW1ib2xzYW5kcHVuY3R1YXRpb24AYm9wb21vZm8AaW5saXN1AGlub2xkcGVybWljAHNpZGRoYW0AemFuYWJhemFyc3F1YXJlAGFzc2lnbmVkAG1lZGYAY2xvc2VwdW5jdHVhdGlvbgBzYXJiAHNvcmFzb21wZW5nAGludmFyaWF0aW9uc2VsZWN0b3Jzc3VwcGxlbWVudABpbmhhbmd1bGphbW8AbWVkZWZhaWRyaW4AcGhhZwBpbmxpc3VzdXBwbGVtZW50AGluY29wdGljAGluc3lyaWFjc3VwcGxlbWVudABpbmhhbmd1bGphbW9leHRlbmRlZGEAY3lybABpbnNob3J0aGFuZGZvcm1hdGNvbnRyb2xzAGluY3lyaWxsaWNleHRlbmRlZGMAZ3VqcgBjd3UAZ3VqYXJhdGkAc3BhY2luZ21hcmsAYWxwaGEAbWx5bQBpbnBhbG15cmVuZQBtYWxheWFsYW0Ac3BhY2UAaW5sZXBjaGEAcGFsbXlyZW5lAHNveW8AbWVyb2l0aWNoaWVyb2dseXBocwB4c3V4AGludGVsdWd1AGluZGV2YW5hZ2FyaWV4dGVuZGVkAGlubWVyb2l0aWNjdXJzaXZlAGRzcnQAdGhhYQB0aGFhbmEAYnVnaQB0aGFpAHNvZ2QAdGl0bGVjYXNlbGV0dGVyAGlubWF0aGVtYXRpY2FsYWxwaGFudW1lcmljc3ltYm9scwBvcmtoAGNhdWNhc2lhbmFsYmFuaWFuAGluYmFtdW0AZGVzZXJldABpbmdlb3JnaWFuc3VwcGxlbWVudABidWdpbmVzZQBzZXBhcmF0b3IAaW5zbWFsbGZvcm12YXJpYW50cwB0aXJoAGluYnJhaG1pAG5kAHBobngAbmV3YQBpbmNvbWJpbmluZ2RpYWNyaXRpY2FsbWFya3MAbWFoagBpbmNvbWJpbmluZ2RpYWNyaXRpY2FsbWFya3Nmb3JzeW1ib2xzAG9sZHBlcnNpYW4AbWFoYWphbmkAdGFpdGhhbQBuZXd0YWlsdWUAbmV3bGluZQBzeXJjAGlubW9uZ29saWFuc3VwcGxlbWVudABpbnVuaWZpZWRjYW5hZGlhbmFib3JpZ2luYWxzeWxsYWJpY3NleHRlbmRlZGEAc2hhdwBidWhkAHZpdGhrdXFpAG51bWJlcgBpbnN1dHRvbnNpZ253cml0aW5nAHZhcmlhdGlvbnNlbGVjdG9yAGV0aGkAbGVwY2hhAHRpcmh1dGEAcm9oZwBhaGV4AGluY29wdGljZXBhY3RudW1iZXJzAHdhbmNobwBpbmNqa3VuaWZpZWRpZGVvZ3JhcGhzZXh0ZW5zaW9uZwBraG9qAGN1bmVpZm9ybQBpbmR1cGxveWFuAHVnYXJpdGljAGluc3ltYm9sc2FuZHBpY3RvZ3JhcGhzZXh0ZW5kZWRhAG9sZHBlcm1pYwBpbmNvbWJpbmluZ2RpYWNyaXRpY2FsbWFya3NzdXBwbGVtZW50AGtodWRhd2FkaQB0YW5nAHN5cmlhYwB0YWdiYW53YQBtb2RpZmllcmxldHRlcgBpbmN1cnJlbmN5c3ltYm9scwBpbm55aWFrZW5ncHVhY2h1ZWhtb25nAHRhbWlsAHRhbHUAaW5nb3RoaWMAaW51bmlmaWVkY2FuYWRpYW5hYm9yaWdpbmFsc3lsbGFiaWNzAHdjaG8AaW5jb21iaW5pbmdkaWFjcml0aWNhbG1hcmtzZXh0ZW5kZWQAb2dhbQB0ZWx1AGlkc3RyaW5hcnlvcGVyYXRvcgBpbmJlbmdhbGkAbmwAc3Vycm9nYXRlAGViYXNlAGhhbmcAaW5idWdpbmVzZQBtYXRoc3ltYm9sAGludml0aGt1cWkAdml0aABpbmNqa3JhZGljYWxzc3VwcGxlbWVudABpbmd1amFyYXRpAGluZ2xhZ29saXRpYwBpbmd1bmphbGFnb25kaQBwaGFnc3BhAGN3Y2YAbmNoYXIAb3RoZXJpZGNvbnRpbnVlAHdoaXRlc3BhY2UAaW5saW5lYXJic3lsbGFiYXJ5AHNnbncAb3RoZXIAaGlyYWdhbmEAaW5waGFnc3BhAG90aGVybnVtYmVyAGlucmVqYW5nAG9zZ2UAaW5jamt1bmlmaWVkaWRlb2dyYXBoc2V4dGVuc2lvbmIAaW50YWdhbG9nAGluYmFzc2F2YWgAdGFuZ3V0AGhtbmcAaW5lbmNsb3NlZGNqa2xldHRlcnNhbmRtb250aHMAY3VycmVuY3lzeW1ib2wAaW5saW1idQBpbmJ1aGlkAGluZXRoaW9waWNleHRlbmRlZGEAc3lsbwBkYXNoAHdhcmFuZ2NpdGkAb2FscGhhAG9sZGl0YWxpYwBpbm90dG9tYW5zaXlhcW51bWJlcnMAc3BhY2VzZXBhcmF0b3IAaW5sYXRpbjFzdXBwbGVtZW50AG90aGVyYWxwaGFiZXRpYwBjaGFuZ2Vzd2hlbmNhc2VtYXBwZWQAaW5hZWdlYW5udW1iZXJzAGludW5pZmllZGNhbmFkaWFuYWJvcmlnaW5hbHN5bGxhYmljc2V4dGVuZGVkAGJ1aGlkAGluamF2YW5lc2UAY3lyaWxsaWMAZG9ncmEAbm9uY2hhcmFjdGVyY29kZXBvaW50AGluaGFuZ3Vsc3lsbGFibGVzAGJhc3NhdmFoAGlubGV0dGVybGlrZXN5bWJvbHMAaW5jb21iaW5pbmdoYWxmbWFya3MAaW5hcmFiaWNtYXRoZW1hdGljYWxhbHBoYWJldGljc3ltYm9scwBvcnlhAGlucHJpdmF0ZXVzZWFyZWEAY2hhbmdlc3doZW50aXRsZWNhc2VkAGRvZ3IAaGVicgBpbnRhZ2JhbndhAGludGlmaW5hZ2gAaW5ib3BvbW9mbwBuYXJiAHJqbmcAaW5hbHBoYWJldGljcHJlc2VudGF0aW9uZm9ybXMAaW5jamt1bmlmaWVkaWRlb2dyYXBoc2V4dGVuc2lvbmYAaW5zeW1ib2xzZm9ybGVnYWN5Y29tcHV0aW5nAG9sZGh1bmdhcmlhbgBmaW5hbHB1bmN0dWF0aW9uAGlucGF1Y2luaGF1AGlucHNhbHRlcnBhaGxhdmkAenAAcGhscABpbmFyYWJpY3ByZXNlbnRhdGlvbmZvcm1zYgBub25zcGFjaW5nbWFyawBkZXZhAHRhdnQAaG1ucABkZXZhbmFnYXJpAGtoaXRhbnNtYWxsc2NyaXB0AGtheWFobGkAaW5iYW11bXN1cHBsZW1lbnQAc3lsb3RpbmFncmkAdGlidABlcHJlcwB0aWJldGFuAGVsYmEAb3NtYW55YQBpbmRpdmVzYWt1cnUAb2xkdHVya2ljAGNoYW5nZXN3aGVubG93ZXJjYXNlZABjeXByb21pbm9hbgBpbmV0aGlvcGljZXh0ZW5kZWQAZW1vamlwcmVzZW50YXRpb24AYW55AG90aGVybG93ZXJjYXNlAG91Z3IAaW5oZWJyZXcAc29mdGRvdHRlZABpbm1hdGhlbWF0aWNhbG9wZXJhdG9ycwBpbmFsY2hlbWljYWxzeW1ib2xzAGlubWFoam9uZ3RpbGVzAGhhbmd1bABleHQAb21hdGgAaW50YW5ndXRjb21wb25lbnRzAG90aGVybGV0dGVyAG5iYXQAbmFiYXRhZWFuAG5zaHUAcGFyYWdyYXBoc2VwYXJhdG9yAGluYXJhYmljZXh0ZW5kZWRiAGlubGF0aW5leHRlbmRlZGcAY2hhbmdlc3doZW51cHBlcmNhc2VkAGh1bmcAaW5wbGF5aW5nY2FyZHMAaW5hcmFiaWNzdXBwbGVtZW50AGlueWlqaW5naGV4YWdyYW1zeW1ib2xzAGlucGhvbmV0aWNleHRlbnNpb25zAG90aGVydXBwZXJjYXNlAG90aGVyaWRzdGFydABlbGJhc2FuAGVseW0AY2YAaW5pbmRpY3NpeWFxbnVtYmVycwBvdGhlcnN5bWJvbABleHRlbmRlcgBleHRwaWN0AHdzcGFjZQBwZgBlbHltYWljAGludGFuZ3V0c3VwcGxlbWVudABjeXByaW90AHN5bWJvbABpbmN5cmlsbGljZXh0ZW5kZWRiAGluc3VwZXJzY3JpcHRzYW5kc3Vic2NyaXB0cwBpbnlpc3lsbGFibGVzAGlucGhvbmV0aWNleHRlbnNpb25zc3VwcGxlbWVudABvbGRzb2dkaWFuAGluZ2VvcmdpYW5leHRlbmRlZABobHV3AGRpZ2l0AGluaGFuZ3VsamFtb2V4dGVuZGVkYgBpbmhpZ2hwcml2YXRldXNlc3Vycm9nYXRlcwBpbnBhaGF3aGhtb25nAG9naGFtAGluc3VwcGxlbWVudGFsYXJyb3dzYQBvdXBwZXIAYWdoYgBvdGhlcm1hdGgAbnVzaHUAc295b21ibwBpbmxhdGluZXh0ZW5kZWRiAGFscGhhYmV0aWMAaW5zdXBwbGVtZW50YWxhcnJvd3NjAGluc3VwcGxlbWVudGFsbWF0aGVtYXRpY2Fsb3BlcmF0b3JzAG90aGVyZGVmYXVsdGlnbm9yYWJsZWNvZGVwb2ludABkZXByZWNhdGVkAG9sZG5vcnRoYXJhYmlhbgBpbmN5cHJpb3RzeWxsYWJhcnkAZXh0ZW5kZWRwaWN0b2dyYXBoaWMAdW5pZmllZGlkZW9ncmFwaABwYWhhd2hobW9uZwBkaXZlc2FrdXJ1AHNpZ253cml0aW5nAHRhZ2IAdGlmaW5hZ2gAdXBwZXIAaW5oYWxmd2lkdGhhbmRmdWxsd2lkdGhmb3JtcwB1cHBlcmNhc2UAZXRoaW9waWMAbW9kaWZpZXJzeW1ib2wAb3RoZXJwdW5jdHVhdGlvbgByZWphbmcAaW5ldGhpb3BpY2V4dGVuZGVkYgB0Zm5nAGhleABpbnN1cHBsZW1lbnRhbHB1bmN0dWF0aW9uAHRnbGcAaW5sYXRpbmV4dGVuZGVkZgB0YWdhbG9nAGhhbmlmaXJvaGluZ3lhAGVjb21wAGluZ2xhZ29saXRpY3N1cHBsZW1lbnQAaGV4ZGlnaXQAY2hhbmdlc3doZW5jYXNlZm9sZGVkAGRhc2hwdW5jdHVhdGlvbgBvbGRzb3V0aGFyYWJpYW4AZHVwbABpbmVneXB0aWFuaGllcm9nbHlwaHMAdGVsdWd1AHVwcGVyY2FzZWxldHRlcgBpbmVneXB0aWFuaGllcm9nbHlwaGZvcm1hdGNvbnRyb2xzAGh5cGhlbgBoZWJyZXcAaW5oaWdoc3Vycm9nYXRlcwB6eXl5AG9ncmV4dABvdGhlcmdyYXBoZW1lZXh0ZW5kAGRlcABpbnN1cHBsZW1lbnRhbGFycm93c2IAZGVmYXVsdGlnbm9yYWJsZWNvZGVwb2ludABpbmhhbmd1bGNvbXBhdGliaWxpdHlqYW1vAG9sZHV5Z2h1cgBpbnN1cHBsZW1lbnRhcnlwcml2YXRldXNlYXJlYWEAaW5ib3BvbW9mb2V4dGVuZGVkAGluc3VwcGxlbWVudGFsc3ltYm9sc2FuZHBpY3RvZ3JhcGhzAG55aWFrZW5ncHVhY2h1ZWhtb25nAG9wZW5wdW5jdHVh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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7KBQnJiUOBSQUBxkiHSAQOx87OwIBOxkPOw47Oxw7Ajs7Ows7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Oxg7Fjs7Czs7Ozs7BzsAOzsQOwE7OxA7OzsPOzs7Bjs7OzsAOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OwYDDg4ODg4OAQ4ODg4ODg4ODg4ADg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODgAODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODgQODgUODgQODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODgoODg4ODgkOAQ4ODg4ODg4ODg4OAA4ODggODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg44ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OAADChk4OB4AODgAFDg4OA84OBQ4HjgAADg4ODg4ODg4Dzg4ODg4GTgKODg4OAU4ADgAOAU4OBQ4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODgAAwoZODgeADg4ABQ4ODgPODgUOB44AAA4ODg4ODg4OA84ODg4OBk4Cjg4ODgFOAA4ADgFODgUODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4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AGwHAQBKbgEAzw8BABYBAADMAAEA2iwAAD8LAQDaBAAAwwQBANoeAACECAEA2h8AAF8JAQC8JAAA1AkBAJoDAAAKAwEAxBAAAMMLAQDaAAAAmQABABQEAQCnDQEAFCwAAEwKAQAUBAAAjQMBABQeAABpBwEAuiQAAM4JAQAUAQAAyQABAP///////wAAwhAAAL0LAQCOAwAARwMBABoEAQC5DQEAGiwAAF4KAQAaBAAAoAMBABoeAAByBwEAGh8AANsIAQAaAQAA0gABAP///////wAAtiQAAMIJAQD///////8AAP///////wAAigMAAOYCAQAYBAEAsw0BABgsAABYCgEAGAQAAJoDAQAYHgAAbwcBABgfAADVCAEAGAEAAM8AAQAOBAEAlQ0BAA4sAAA6CgEADgQAABEEAQAOHgAAYAcBAA4fAADPCAEADgEAAMAAAQAC6QEAFxABAP///////wAAxyQAAPUJAQAMBAEAjw0BAAwsAAA0CgEADAQAAAsEAQAMHgAAXQcBAAwfAADJCAEADAEAAL0AAQAIBAEAgw0BAAgsAAAoCgEACAQAAP8DAQAIHgAAVwcBAAgfAAC9CAEACAEAALcAAQAGBAEAfQ0BAAYsAAAiCgEABgQAAPkDAQAGHgAAVAcBAP///////wAABgEAALQAAQD///////8AAAIFAAD/BAEABAQBAHcNAQAELAAAHAoBAAQEAADzAwEABB4AAFEHAQD///////8AAAQBAACxAAEAAAQBAGsNAQAALAAAEAoBAAAEAADnAwEAAB4AAEsHAQD///////8AAAABAACrAAEA////////AAB1BQEAXg4BAJQFAQCyDgEAKiwAAI4KAQAqBAAA1AMBACoeAACKBwEAKh8AAO0IAQAqAQAA6gABACqnAABLDAEAwgMAACYDAQAmBAEA3Q0BACYsAACCCgEAJgQAAMgDAQAmHgAAhAcBALcEAQD4DQEAJgEAAOQAAQAmpwAARQwBAJ4DAAAYAwEAtx8AAAoAAwC3AQAAwgIBAJIFAQCvDgEAt6sAABUHAQD///////8AALccAAArBgEAewEAAFwBAQB7pwAAtAwBAHurAABhBgEAjAMAAEQDAQAuLAAAmgoBAC4EAADhAwEALh4AAJAHAQAuHwAA+QgBAC4BAADwAAEALqcAAFEMAQCPHwAApAACAI8BAABxAgEA////////AACPqwAAnQYBAAL7AAAMAAIAiAMAAOACAQCPDAEA5Q4BAP///////wAALCwAAJQKAQAsBAAA2wMBACweAACNBwEALB8AAPMIAQAsAQAA7QABACynAABODAEAKCwAAIgKAQAoBAAAzgMBACgeAACHBwEAKB8AAOcIAQAoAQAA5wABACinAABIDAEA////////AAD///////8AAIYFAQCODgEAJAQBANcNAQAkLAAAfAoBACQEAADCAwEAJB4AAIEHAQBHBQAAhgUBACQBAADhAAEAJKcAAEIMAQAiBAEA0Q0BACIsAAB2CgEAIgQAALoDAQAiHgAAfgcBADP/AABTDQEAIgEAAN4AAQAipwAAPwwBANoDAABTAwEAwAQBABMOAQDALAAAGAsBAMAEAACxBAEAwB4AAF0IAQAx/wAATQ0BADsCAABBAgEAwKcAAAINAQCzBAEA7A0BAMAAAABNAAEA////////AAAqIQAAGwABALMfAAA+AAIAswEAAJIBAQCzpwAAGg0BALOrAAAJBwEA////////AACzHAAAHwYBAP///////wAAJiEAADoDAQA1BQAAUAUBALcQAACcCwEAsQQBAOYNAQD///////8AALcYAQCWDwEASgIAAFMCAQCOBQEAow4BALEBAAC5AgEAsacAALACAQCxqwAAAwcBAP///////wAAsRwAABkGAQCxDAEASw8BADwFAABlBQEA////////AAAcAgAAIAIBAE4eAADABwEAigUBAJoOAQBOAQAAGgEBAE6nAAB+DAEAqx8AAOAAAgBOAAAAJQABAKunAAB3AgEAq6sAAPEGAQAWAgAAFwIBAKscAAAHBgEAqwwBADkPAQCXHgAAIgACAJcfAADMAAIAlwEAAIkCAQBOpgAA5QsBAJerAAC1BgEAggUBAIIOAQCXHAAAywUBAJcMAQD9DgEA////////AABObgEA2w8BAHEFAQBSDgEAFAIAABQCAQDEJAAA7AkBAH4sAABEAgEAfgQAAEUEAQB+HgAACQgBACr/AAA4DQEAgAUBAHwOAQB+pwAAtwwBAH6rAABqBgEAGgIAAB0CAQDCJAAA5gkBAKkfAADWAAIAqQEAAK0CAQAm/wAALA0BAKmrAADrBgEAjQUBAKAOAQCpHAAAAQYBAKkMAQAzDwEA////////AAD///////8AABgCAAAaAgEAwBAAALcLAQAgBAEAyw0BACAsAABwCgEAIAQAALMDAQAgHgAAewcBAA4CAAALAgEAIAEAANsAAQCzEAAAkAsBAP///////wAALv8AAEQNAQCzGAEAig8BAP///////wAAkR8AAK4AAgCRAQAAcQEBAAwCAAAIAgEAkasAAKMGAQD///////8AAJEcAAC5BQEAkQwBAOsOAQD///////8AAAgCAAACAgEAsRAAAIoLAQDVAQAAuQEBACz/AAA+DQEAsRgBAIQPAQDVAAAAjQABAAYCAAD/AQEAjwMAAEoDAQD///////8AACj/AAAyDQEA1CwAADYLAQDUBAAAugQBANQeAAB7CAEAjAUBAJ0OAQAEAgAA/AEBAKsQAAB4CwEAOwUAAGIFAQDUAAAAigABAKsYAQByDwEAJP8AACYNAQAAAgAA9gEBAP///////wAA////////AAAc6QEAZRABAP///////wAAiAUBAJQOAQAi/wAAIA0BAP///////wAAKgIAADICAQD///////8AAP4EAAD5BAEA/h4AALoIAQAW6QEAUxABAP4BAADzAQEA////////AABKBQAAjwUBACYCAAAsAgEAHgQBAMUNAQAeLAAAagoBAB4EAACsAwEAHh4AAHgHAQD///////8AAB4BAADYAAEA////////AACpEAAAcgsBABwFAAAmBQEAFOkBAE0QAQCpGAEAbA8BANIEAQBJDgEA0iwAADMLAQDSBAAAtwQBANIeAAB4CAEA0h8AABQAAwAuAgAAOAIBABYFAAAdBQEAGukBAF8QAQDSAAAAhAABAKcfAAD0AAIApwEAAIkBAQD///////8AAKerAADlBgEA////////AACnHAAA+wUBAKcMAQAtDwEA////////AAD///////8AABjpAQBZEAEALAIAADUCAQAUBQAAGgUBAHwEAABCBAEAfB4AAAYIAQAzBQAASgUBAA7pAQA7EAEAKAIAAC8CAQB8qwAAZAYBAEgeAAC3BwEASB8AABcJAQAaBQAAIwUBAEinAAB1DAEAMQUAAEQFAQBIAAAAFQABAAzpAQA1EAEAaywAAK8KAQAkAgAAKQIBAKsDAABBAwEAax8AAD4JAQD///////8AAAjpAQApEAEAGAUAACAFAQBIpgAA2wsBACICAAAmAgEA////////AACXAwAA/QIBAAbpAQAjEAEADgUAABEFAQBIbgEAyQ8BAP///////wAAVh4AAMwHAQBWHwAAPgADAFYBAAAmAQEAVqcAAIoMAQAE6QEAHRABAFYAAAA+AAEADAUAAA4FAQD///////8AABb7AAB9AAIA////////AAAA6QEAERABAP///////wAACAUAAAgFAQD///////8AAFamAADxCwEA////////AACpAwAAOgMBAP///////wAABgUAAAUFAQD///////8AAFZuAQDzDwEA////////AAAU+wAAbQACAP///////wAAtyQAAMUJAQD///////8AAAQFAAACBQEA4iwAAEsLAQDiBAAAzwQBAOIeAACQCAEA4h8AACQAAwDiAQAAzgEBAAAFAAD8BAEATgIAAFkCAQCnEAAAbAsBAP///////wAA////////AACnGAEAZg8BAJEDAADpAgEA////////AAAqBQAAOwUBAFQeAADJBwEAVB8AADkAAwBUAQAAIwEBAFSnAACHDAEA////////AABUAAAAOAABANUDAAAwAwEAJgUAADUFAQA5HwAAAgkBADkBAAD8AAEAEgQBAKENAQASLAAARgoBABIEAACGAwEAEh4AAGYHAQBUpgAA7gsBABIBAADGAAEAEAQBAJsNAQAQLAAAQAoBABAEAACAAwEAEB4AAGMHAQBUbgEA7Q8BABABAADDAAEA////////AABrIQAAsAkBAC4FAABBBQEAjwUBAKYOAQA/HwAAFAkBAD8BAAAFAQEABvsAAB0AAgBSHgAAxgcBAFIfAAA0AAMAUgEAACABAQBSpwAAhAwBAP///////wAAUgAAADEAAQD///////8AAAT7AAAFAAMA/gMAANcCAQAsBQAAPgUBACACAAB9AQEA////////AADAJAAA4AkBAAD7AAAEAAIAUqYAAOsLAQAoBQAAOAUBAFAeAADDBwEAUB8AAFQAAgBQAQAAHQEBAFCnAACBDAEAUm4BAOcPAQBQAAAAKwABAP///////wAAygQBADEOAQDKLAAAJwsBACQFAAAyBQEAyh4AAGwIAQDKHwAAWQkBAMoBAACpAQEA////////AABQpgAA6AsBAMoAAABsAAEAIgUAAC8FAQCnAwAANAMBAPAEAADkBAEA8B4AAKUIAQBQbgEA4Q8BAPABAAAUAAIA2CwAADwLAQDYBAAAwAQBANgeAACBCAEA2B8AAH0JAQD///////8AANinAAAUDQEA////////AADYAAAAkwABANYsAAA5CwEA1gQAAL0EAQDWHgAAfggBANYfAABMAAIA////////AADWpwAAEQ0BAP///////wAA1gAAAJAAAQDIBAEAKw4BAMgsAAAkCwEAuQQBAP4NAQDIHgAAaQgBAMgfAABTCQEAyAEAAKUBAQC5HwAAegkBAP///////wAAyAAAAGYAAQC5qwAAGwcBAP///////wAAuRwAADEGAQAeAgAAIwIBAMYEAQAlDgEAxiwAACELAQD///////8AAMYeAABmCAEAxh8AAEMAAgBOBQAAmwUBAManAABIBwEAxQQBACIOAQDGAAAAYAABAMUEAACiBAEAuwQBAAQOAQC1BAEA8g0BAMUBAAChAQEAxacAAKoCAQC7HwAAUAkBAMUAAABcAAEAtQEAAJUBAQC7qwAAIQcBALWrAAAPBwEAtQAAABEDAQC1HAAAJQYBAK8fAAD0AAIArwEAAI8BAQD///////8AAK+rAAD9BgEAaSwAAKwKAQCvHAAAEwYBAK8MAQBFDwEAaR8AADgJAQB+BQEAdg4BACDpAQBxEAEA////////AAClHwAA6gACAP///////wAASAIAAFACAQClqwAA3wYBAOIDAABfAwEApRwAAPUFAQClDAEAJw8BAP///////wAAOf8AAGUNAQCjHwAA4AACAP///////wAA////////AACjqwAA2QYBAKEfAADWAAIAoxwAAO8FAQCjDAEAIQ8BAKGrAADTBgEA////////AAChHAAA6QUBAKEMAQAbDwEAIAUAACwFAQCHHwAApAACAIcBAABrAQEA////////AACHqwAAhQYBAJEFAQCsDgEAhxwAABoEAQCHDAEAzQ4BAP///////wAA////////AAByLAAAsgoBAHIEAAAzBAEAch4AAPcHAQBNHwAAJgkBAHIBAABQAQEAuRAAAKILAQByqwAARgYBAE0AAAAiAAEAuRgBAJwPAQBwLAAAYgIBAHAEAAAwBAEAcB4AAPQHAQD///////8AAHABAABNAQEA////////AABwqwAAQAYBAG4sAACbAgEAbgQAAC0EAQBuHgAA8QcBAG4fAABHCQEAbgEAAEoBAQBupwAArgwBAE1uAQDYDwEAxRAAAMYLAQAe6QEAaxABAEUBAAAOAQEAuxAAAKgLAQC1EAAAlgsBAEUAAAAMAAEAuxgBAKIPAQC1GAEAkA8BAO4EAADhBAEA7h4AAKIIAQCvEAAAhAsBAO4BAADgAQEA////////AACvGAEAfg8BAGwEAAAqBAEAbB4AAO4HAQBsHwAAQQkBAGwBAABHAQEAbKcAAKsMAQBpIQAAqgkBAEVuAQDADwEApRAAAGYLAQD///////8AAB4FAAApBQEApRgBAGAPAQASAgAAEQIBAP///////wAA8AMAAAoDAQD///////8AAGymAAASDAEAoxAAAGALAQAQAgAADgIBANgDAABQAwEAoxgBAFoPAQChEAAAWgsBAP///////wAA////////AAChGAEAVA8BAP///////wAA////////AADWAwAAHgMBAGoEAAAnBAEAah4AAOsHAQBqHwAAOwkBAGoBAABEAQEAaqcAAKgMAQBoBAAAJAQBAGgeAADoBwEAaB8AADUJAQBoAQAAQQEBAGinAAClDAEAfAUBAHAOAQD///////8AAP///////wAARh4AALQHAQD///////8AAGqmAAAPDAEARqcAAHIMAQBIBQAAiQUBAEYAAAAPAAEA////////AABopgAADAwBAGQsAACkAgEAZAQAAB4EAQBkHgAA4gcBAP///////wAAZAEAADsBAQBkpwAAnwwBAEamAADYCwEA3iwAAEULAQDeBAAAyQQBAN4eAACKCAEAbiEAALkJAQDeAQAAyAEBAEZuAQDDDwEA////////AADeAAAApQABADAeAACTBwEAZKYAAAYMAQAwAQAABQECAFYFAACzBQEAYiwAAJICAQBiBAAAGgQBAGIeAADfBwEA////////AABiAQAAOAEBAGKnAACcDAEA////////AAD///////8AAP///////wAApQMAAC0DAQD///////8AAGwhAACzCQEARB4AALEHAQD///////8AAP///////wAARKcAAG8MAQBipgAAAwwBAEQAAAAJAAEAowMAACYDAQB5AQAAWQEBAHmnAACxDAEAeasAAFsGAQChAwAAIgMBAGAsAACgCgEAYAQAABcEAQBgHgAA2wcBAESmAADVCwEAYAEAADUBAQBgpwAAmQwBAP///////wAA////////AAAS6QEARxABAERuAQC9DwEAMh4AAJYHAQD///////8AADIBAADzAAEAMqcAAFQMAQAQ6QEAQRABAGohAACtCQEAYKYAAAAMAQBUBQAArQUBAP///////wAAcgMAAM4CAQBoIQAApwkBAM0EAQA6DgEA////////AADNBAAArgQBADkFAABcBQEA////////AADNAQAArQEBAP///////wAAcAMAAMsCAQDNAAAAdQABABIFAAAXBQEAzAQBADcOAQDMLAAAKgsBAM8EAQBADgEAzB4AAG8IAQDMHwAARwACABAFAAAUBQEAZCEAAJsJAQDPAQAAsAEBAMwAAAByAAEARQMAAAUDAQDPAAAAewABAD8FAABuBQEAywQBADQOAQDKJAAA/gkBAMsEAACrBAEAUgUAAKcFAQDLHwAAXAkBAMsBAACpAQEA7gMAAHEDAQDDBAEAHA4BAMsAAABvAAEAwwQAAJ8EAQDJBAEALg4BAMMfAABHAAIAyQQAAKgEAQBiIQAAlQkBAMkfAABWCQEAwwAAAFYAAQDJpwAACw0BAL8EAQAQDgEAyQAAAGkAAQBQBQAAoQUBAFUAAAA7AAEAvQQBAAoOAQB2BAAAOQQBAHYeAAD9BwEAv6sAAC0HAQB2AQAAVgEBAL8cAAA9BgEAdqsAAFIGAQC9qwAAJwcBAP///////wAAvRwAADcGAQD///////8AAMgkAAD4CQEA////////AAC5JAAAywkBAFVuAQDwDwEAYCEAAI8JAQCfHwAAzAACAJ8BAAChAgEAwQQBABYOAQCfqwAAzQYBAMEEAACcBAEAnxwAAOMFAQCfDAEAFQ8BADIhAACMCQEAxiQAAPIJAQBFAgAAvwIBAMEAAABQAAEAnR8AAMIAAgCdAQAAngIBAP///////wAAnasAAMcGAQDFJAAA7wkBAJ0cAADdBQEAnQwBAA8PAQC7JAAA0QkBAM0QAADMCwEAmx4AANsHAQCbHwAAuAACADD/AABKDQEA////////AACbqwAAwQYBAEMBAAALAQEAmxwAANcFAQCbDAEACQ8BAEMAAAAGAAEAmR4AACoAAgCZHwAArgACAN4DAABZAwEA////////AACZqwAAuwYBAJUfAADCAAIAmRwAANEFAQCZDAEAAw8B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ANEAAACBAAEA////////AAD0AwAAAAMBABUEAQCqDQEAFSwAAE8KAQAVBAAAkQMBABMEAQCkDQEAEywAAEkKAQATBAAAigMBAOwDAABuAwEAIf8AAB0NAQAPBAEAmA0BAA8sAAA9CgEADwQAABQEAQD///////8AAA8fAADSCAEA////////AADBJAAA4wkBAFUFAACwBQEA6gMAAGsDAQD///////8AAA0EAQCSDQEADSwAADcKAQANBAAADgQBAHYFAQBhDgEADR8AAMwIAQD///////8AAOgDAABoAwEA////////AAD///////8AADb/AABcDQEACwQBAIwNAQALLAAAMQoBAAsEAAAIBAEA////////AAALHwAAxggBAP///////wAA////////AADmAwAAZQMBAAkEAQCGDQEACSwAACsKAQAJBAAAAgQBAOQDAABiAwEACR8AAMAIAQAFBAEAeg0BAAUsAAAfCgEABQQAAPYDAQADBAEAdA0BAAMsAAAZCgEAAwQAAPADAQD///////8AANwDAABWAwEA////////AAArIQAAXAABAAEEAQBuDQEAASwAABMKAQABBAAA6gMBAPwEAAD2BAEA/B4AALcIAQD8HwAAYAACAPwBAADwAQEA////////AAD///////8AAEMFAAB6BQEA+AQAAPAEAQD4HgAAsQgBAPgfAABlCQEA+AEAAOoBAQAnBAEA4A0BACcsAACFCgEAJwQAAMsDAQCVBQEAtQ4BAPYEAADtBAEA9h4AAK4IAQD2HwAAXAACAPYBAAB0AQEAegQAAD8EAQB6HgAAAwgBAEsfAAAgCQEA////////AAA+AgAApgoBAHqrAABeBgEASwAAABsAAQAfBAEAyA0BAB8sAABtCgEAHwQAALADAQCDBQEAhQ4BAP///////wAAOP8AAGINAQD///////8AADoFAABfBQEALywAAJ0KAQAvBAAA5AMBAP///////wAALx8AAPwIAQBJBQAAjAUBAP///////wAAS24BANIPAQA0/wAAVg0BAC0sAACXCgEALQQAAN4DAQD///////8AAC0fAAD2CAEAgQUBAH8OAQB/BQEAeQ4BACv/AAA7DQEAKSwAAIsKAQApBAAA0QMBAP///////wAAKR8AAOoIAQAlBAEA2g0BACUsAAB/CgEAJQQAAMUDAQAjBAEA1A0BACMsAAB5CgEAIwQAAL8DAQARBAEAng0BABEsAABDCgEAEQQAAIMDAQAHBAEAgA0BAAcsAAAlCgEABwQAAPwDAQD///////8AAP///////wAAziQAAAoKAQD///////8AAEECAABKAgEA////////AAD///////8AAPwTAAA8BwEA////////AABCBQAAdwUBAP///////wAA////////AAD///////8AAP///////wAA+BMAADAHAQD///////8AAP///////wAA0QMAAAADAQD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAAh6QEAdBABAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAD4FAABrBQEA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAAn/wAALw0BAP///////wAA////////AAA2BQAAUwUBAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAAUwUAAKoFAQD///////8AAP///////wAA////////AABABQAAcQUBAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAC//AABHDQEA////////AAD///////8AAP///////wAAeAUBAGcOAQD///////8AABfpAQBWEAEA////////AAAt/wAAQQ0BAP///////wAAdAUBAFsOAQD///////8AAP///////wAAQQUAAHQFAQD///////8AACn/AAA1DQEA////////AAD///////8AAP///////wAA////////AAAl/wAAKQ0BAP///////wAA////////AAAj/wAAIw0BAB3pAQBoEAEA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAFEFAACkBQEA////////AAD///////8AAP///////wAA////////AAD///////8AADgFAABZBQEA////////AAD///////8AAP///////wAAG+kBAGIQAQD///////8AAP///////wAA////////AAD///////8AAP///////wAANAUAAE0FAQAZ6QEAXBABAP///////wAA////////AAD///////8AAE8FAACeBQEA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAAFekBAFAQAQD///////8AAP///////wAAE+kBAEoQAQD///////8AAP///////wAA////////AAD///////8AAA/pAQA+EAEA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAAF/sAAHUAAgD///////8AAP///////wAADekBADgQAQD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAAL6QEAMhABAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAACekBACwQAQD///////8AAP///////wAA////////AAD///////8AAAXpAQAgEAEA////////AAD///////8AAAPpAQAaEAEA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAAAekBABQQAQD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAAV+wAAcQACAP///////wAA////////AAAT+wAAeQACAP///////wAA////////AAD///////8AAB/pAQBuEAEA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAB6BQEAbQ4BAP///////wAASwUAAJIFAQD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAD///////8AABHpAQBEEAEABfsAAB0AAgD///////8AAAfpAQAmEAEAA/sAAAAAAwD///////8AAP///////wAA////////AAD///////8AAP///////wAA////////AAAB+wAACAACAP//////////cgdLB9IAqwBuDYcHzwznAG4BIwX8BEgMxgxzDjgFHQL2ATAIbwSDAS8CvwLrCuQMcA7rBycERAHACBsA8wioDEwGMQBiBZUNwwiUA3cFnwCSAiIKDwxJBp4C4gceBDsB0g8MAKMKnwznD9UIUAVGBlMJQA6uCO0EgwKVCQYMEQleDtsHFwQ1AcAPAACgCpkMRAlSDkQF+A2KCMkEyAEFBH0CRQsADI4K/g2NCMwEywG0D1AASAtXBzgJtwBxDagLWgtxAcMLXQcIBb0A/QYRBF0L+QMCApoKDgWCCsICAweGCWgNCAIKDpMI0gTRAWsCXACHC6sLBA6QCM8EzgGxC1YASwuFDnsHawHbALkC8g2HCMYExQFcDSwFQgsPB4kJaQezAskACQB9DV4GCQe9CE0FGgXmDYEIwAQrBuoIFAI8CxQN9wZgBHcBFQ+9D9wK1QxVDkEJ5Ah+CL0EGw/jBacFOQsRDTkMegHrBqoCswXpBVgOcgsWDpkI2ATXAbUOaQC/DX4LwgMLAXcN5QZMClkDEA6WCNUE1AEnD2MA7wkLBFwDlAaaBpQKIQ8bB/UF9QmfC64PVwtcASMJdwLvBbQMDw+6C5UFFQcmDewNhAjDBAMA+QjdBT8LjgZHBZYLYgMFEAAIPAQDD3EJRwABCl8DrQWzCYwFtw+lANEF+wk7CfEGdQi0BFYD/Q6ZCzALDg38D4EL6QmoBGgJfQHLBb8JCw2qCWQOYwQzD6gPUAPfCtgMWw7IAtMGgAndCQEGvA2uB78DLQ88DL4GSQpsDE0DnA/fBxoEOAH7BQYA1wmcDEMO0gtKBREDGAOTAHsLaAOAApYPAwwgCScIVwQNCgkPug/TCswMIw0+CWUD9wczBFAB1wU0ALIKBwowDAoDegX0BzAETQF1Cy4A1wJvCz0O//90BesOOgaQAOoPFw2bAnkOVglTA9YOuQVvCJgJ5A///+MJKgtQCTQOqAjnBOMBkgmHAFQLUgaiDygOogjhBOABag57ACIOnwjeBN0BxwZ1ALoI+QTzAcUJqAA+AzkHHA6cCNsE2gFABm8A//+EDy0H6AckBEEBLgZ3ECcHpQxvD5UBXAXlByEEPgGmDhIAjAKiDAwMIQdWBQ0ONw4XEMwPJhBgAIoACQx6A8YH8AMgAYIGxg95CoQM7QhKCToOqwjqBOcBKAaNAGUC3w7rCxIHPAfOAv/////MB/wDJgFNECwJhQqKDMsCaw3//0UPHwZTDT8HoAZuAj8P8QuuBK0BEwb9BzkEVgHnCEEADQYyCUcDOQ+GBT0GwwfqAx0BXw13A3MKgQwHBv//sAH//8oG9g9xA3gPXwJiCegL//9uA70LpAngDcAH5AMaASoPKQltCn4MKRD//2sD0AZ9CU0N+AUiBlkC///lC9oNvQfeAxcBuA76AmcKewzUDboH2AMUAf//JQZhCngMVgJHDeILtwtMDrQI8wTtAVMCnADeCwQKtg2rB7YDXwElAOIOQwppDEENawWbBR4Dewi6BP//NRA7DTYLzwuMDZYHigPzANsPCxAZClQM6A4aCVEP+gc2BFMBuQk7AD4CHQ22Bd8GgAVKA3gItwT//9ECoQIzCwgJ//9RCJAEmAGsDvAPDAv2DK8OXAl7D/EHLQRKAZ4JKAAvEK4M///ZBm4FwgndDYgG4QMdEJgCiwZqCu4HKgRHAYEPIgDeD6sMdgb//2gFzwcCBCkB//9mBIsKjQwSDOIK2wxhDv/////YD/cOcQKMCfQLxQJEDckH9gMjAf//xQV/CocMhAf//+QAfQP/////RQxpBGUNNQXuC+UK3gxnDv//LALxDs4NtwfRAy8J/////1sKdQz//78F/AhZDdEJyA20B8sDUAL//9sLVQpyDPMDegKQD3QQfArCDbEHxQNNArEP2AtPCm8MNQloAjUNuQ0AA7oDCAHLCQUDRgrVCy4OpQjkBP//Lw2BAOwCig9KAiYJVg2PAZgNnAeXA/kAlw4pDSUKWgwdCUgH//+SDZkHkQP2ADMHIA0fClcMeg2NB8kL7QBwBncJgQdODOEAFAk+Bf//QgwGCEIEMgU1An4H///eAA4JKQKYBT8M+w3//y8F7w2kAk0AwgHpDSYC9gi/AeMNCBBpCLwBpQF0CWAIJAtiAfAItgkbCwUNRQiEBKEFAAeDCQAL9AaaDqcC/wPuBksPXQiICugGuwb//xgLAg2pBv//GQYREFoImQSeAXMGegkVC/8MpQtXCJYEmwFUCJMEEgv8DKMGDwv5DLIO//9iDeEITgiNBP//zAudBgkL8wypDsYLPwh+BIwBlwbtA/oKkQaODnYKWQHAC0oAGA+xDP//DA+PBYUGYgIGDyMQ///mBQAP0w7aBWcGSQ7BDtQF/w///5kAzgVrCdoCSwiKBFANrQn//wYL8AyjDrANqAewA7sO2wj//z0KZgznA///8gn//3AK5gmTCzoDRALgCX8GJgP//9oJXAL//6UP///pAs8Inw8zCHIEhgGZD2wP7grnDHYOWg8iAy0IbASAAUoN///oCuEMbQ7JCF0EGwMDCD8E2QrSDE8OTwZUDxUD//+SBQ4DDwiRDmUBNgxDBrsKvQz//24QqgX9Ao0LAhC5Af//rQJuCRgMQgfgAmoGsAk0BtIHCAQsATEORBCRCpAMsw2EALMDBQFpC///QAriBnQCJQ73C4YNkweDA3gAUQtHAhMK//+ADZAH///wADYHYwv2AlEMOwIXCUEFdA2KB/UN6gD//zgCKgdLDP//Agk7Bf//Rg6xCPAE6gEyApYAHw7//xMOBw62AXIATgtmAFkAAQ6zAfoG/////1MAcgixBKsEqQFsCC0LZgj6Dv//Jwv//yELJAfcBhgHDAebDcgFmgPWBtQCBgcoCk4P///jAs0GxAYgEKUEwQb//7UGHAYIDacNQg+mA/8A/////zQK//+iBKEBYwgQBgwISATUCR4LQQK4CroMuAaLDqQF//90AxIPkw///x8ArwoVDEgIhwRlBbIG4AUDC68GnQ6VAmQGPA/0DjAPJA8xBv//1Q/uDnEQHg8KBsIF/gXyBeUO3A55BrwF2Q7sBc0O//9CCIEE/////+wJ/QpQEJQO////////iQGqDaUHqQOrD38OShA3CmMM0A7OCQoK/gn//zIQbQbICUQD+AkaEEEDjQ80A8oOWAb//8cOhw8bCEsEFBD//ysOxwp+D3UP//9+AHIP//9mDzkIeAS8AjcDJAz0Cu0Mgg42CHUECQhFBP//8QrqDHwOtwwwAzAHngUtA2kPEgjdAmgB//9bBr4KwAz/////sAX//w4QVQZjDz4AtQpgDxsM8AKDBbwJDwCmCrcI9gTwAVMFogD//9gHFAQyAYYC8w+dCpYMZgdfCcYA///DD///oQn//0cJFwX9C9UHDgQvAeYCEQKXCpMMpA2iB6MD/////0gPMQpgDJ8E3gj6C54NnwedA2MHFgbDACsKXQxUBxkOtABRBxQFsQBsAP////8FBQ4CTgcCBa4ArAb/ATwIewT8Af///wT3CtgIiA5oEP//+QHSCB4H///MCCoIWgR0ASQIVATWCv//xgjQCskM//9hBv//////////FQgzDDcGRAAtDMEKwwz//4kFOADLDZALzgMRAX0FsAJYCh4M//8rAP//jw35D40DcQX//2UJHArtD///xA6nCVkJ//8YAKwK//+bCeEPXwX/////TQmKCzYPjwIyDY8JbAsLCf//ZgucBM8PBAYVAKkK/////2ALWQXFDf//yAMOASoDiQJSCmsQrQ3//6wDAgH//8kPOgr//6YGoQ0+EKAD/AD//10PLgoYCIkNOBCGA4MNxAqAAxYK//94BxAK2AAsDSwQ//+2Av//IQwpBXUH1w3VANsD//8jApIBZAr//yYFBQmgDm8H/wjPACACbAdgB8wAwABaByAFugAhCFEEHQURBRoCzQoLBXwGFwILAh4ITgQFAr4OPg3KCtENKgzUA///UxD//14K//////////8nDP////////////////////////////9fEEUH/////////////////////////////zgN////////////////////////tAv///////9XD/////////////+uC/////////////////////////////+iC////////5wLhAv/////eAv////////////////////////////////zAv//////////////////YhD/////////////Gg3//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1wQ//////////////////////////9WEP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////0cQ/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2UQ/////////////////////1kQ//////////////////9BEP////87EAAAAAAAAGUA/QBMAB0AGADvAGAARwBcAEMABAA+AAgAOgDqAG0ApABYAFQAUADWAAAANgAFATIAaQB5AH0AAQEqACYA+QAuAHUADABxAPQA5QDgANsA0QAQAMwAxwDCAL0AuACzAK4AqQAUACIAnwCaAJUAkACLAIYAgQBB8IkRC+EIPgAvAB8AOQApABkANAAkABQAQwAPAAoABQAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMA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AAAABAUAAAcFAAABAAAABgUAAAkFAAABAAAACAUAAAsFAAABAAAACgUAAA0FAAABAAAADAUAAA8FAAABAAAADgUAABEFAAABAAAAEAUAABMFAAABAAAAEgUAABUFAAABAAAAFAUAABcFAAABAAAAFgUAABkFAAABAAAAGAUAABsFAAABAAAAGgUAAB0FAAABAAAAHAUAAB8FAAABAAAAHgUAACEFAAABAAAAIAUAACMFAAABAAAAIgUAACUFAAABAAAAJAUAACcFAAABAAAAJgUAACkFAAABAAAAKAUAACsFAAABAAAAKgUAAC0FAAABAAAALAUAAC8FAAABAAAALgUAAGEFAAABAAAAMQUAAGIFAAABAAAAMgUAAGMFAAABAAAAMwUAAGQFAAABAAAANAUAAGUFAAABAAAANQUAAGYFAAABAAAANgUAAGcFAAABAAAANwUAAGgFAAABAAAAOAUAAGkFAAABAAAAOQUAAGoFAAABAAAAOgUAAGsFAAABAAAAOwUAAGwFAAABAAAAPAUAAG0FAAABAAAAPQUAAG4FAAABAAAAPgUAAG8FAAABAAAAPwUAAHAFAAABAAAAQAUAAHEFAAABAAAAQQUAAHIFAAABAAAAQgUAAHMFAAABAAAAQwUAAHQFAAABAAAARAUAAHUFAAABAAAARQUAAHYFAAABAAAARgUAAHcFAAABAAAARwUAAHgFAAABAAAASAUAAHkFAAABAAAASQUAAHoFAAABAAAASgUAAHsFAAABAAAASwUAAHwFAAABAAAATAUAAH0FAAABAAAATQUAAH4FAAABAAAATgUAAH8FAAABAAAATwUAAIAFAAABAAAAUAUAAIEFAAABAAAAUQUAAIIFAAABAAAAUgUAAIMFAAABAAAAUwUAAIQFAAABAAAAVAUAAIUFAAABAAAAVQUAAIYFAAABAAAAVgUAANAQAAABAAAAkBwAANEQAAABAAAAkRwAANIQAAABAAAAkhwAANMQAAABAAAAkxwAANQQAAABAAAAlBwAANUQAAABAAAAlRwAANYQAAABAAAAlhwAANcQAAABAAAAlxwAANgQAAABAAAAmBwAANkQAAABAAAAmRwAANoQAAABAAAAmhwAANsQAAABAAAAmxwAANwQAAABAAAAnBwAAN0QAAABAAAAnRwAAN4QAAABAAAAnhwAAN8QAAABAAAAnxwAAOAQAAABAAAAoBwAAOEQAAABAAAAoRwAAOIQAAABAAAAohwAAOMQAAABAAAAoxwAAOQQAAABAAAApBwAAOUQAAABAAAApRwAAOYQAAABAAAAphwAAOcQAAABAAAApxwAAOgQAAABAAAAqBwAAOkQAAABAAAAqRwAAOoQAAABAAAAqhwAAOsQAAABAAAAqxwAAOwQAAABAAAArBwAAO0QAAABAAAArRwAAO4QAAABAAAArhwAAO8QAAABAAAArxwAAPAQAAABAAAAsBwAAPEQAAABAAAAsRwAAPIQAAABAAAAshwAAPMQAAABAAAAsxwAAPQQAAABAAAAtBwAAPUQAAABAAAAtRwAAPYQAAABAAAAthwAAPcQAAABAAAAtxwAAPgQAAABAAAAuBwAAPkQAAABAAAAuRwAAPoQAAABAAAAuhwAAP0QAAABAAAAvRwAAP4QAAABAAAAvhwAAP8QAAABAAAAvxwAAKATAAABAAAAcKsAAKETAAABAAAAcasAAKITAAABAAAAcqsAAKMTAAABAAAAc6sAAKQTAAABAAAAdKsAAKUTAAABAAAAdasAAKYTAAABAAAAdqsAAKcTAAABAAAAd6sAAKgTAAABAAAAeKsAAKkTAAABAAAAeasAAKoTAAABAAAAeqsAAKsTAAABAAAAe6sAAKwTAAABAAAAfKsAAK0TAAABAAAAfasAAK4TAAABAAAAfqsAAK8TAAABAAAAf6sAALATAAABAAAAgKsAALETAAABAAAAgasAALITAAABAAAAgqsAALMTAAABAAAAg6sAALQTAAABAAAAhKsAALUTAAABAAAAhasAALYTAAABAAAAhqsAALcTAAABAAAAh6sAALgTAAABAAAAiKsAALkTAAABAAAAiasAALoTAAABAAAAiqsAALsTAAABAAAAi6sAALwTAAABAAAAjKsAAL0TAAABAAAAjasAAL4TAAABAAAAjqsAAL8TAAABAAAAj6sAAMATAAABAAAAkKsAAMETAAABAAAAkasAAMITAAABAAAAkqsAAMMTAAABAAAAk6sAAMQTAAABAAAAlKsAAMUTAAABAAAAlasAAMYTAAABAAAAlqsAAMcTAAABAAAAl6sAAMgTAAABAAAAmKsAAMkTAAABAAAAmasAAMoTAAABAAAAmqsAAMsTAAABAAAAm6sAAMwTAAABAAAAnKsAAM0TAAABAAAAnasAAM4TAAABAAAAnqsAAM8TAAABAAAAn6sAANATAAABAAAAoKsAANETAAABAAAAoasAANITAAABAAAAoqsAANMTAAABAAAAo6sAANQTAAABAAAApKsAANUTAAABAAAApasAANYTAAABAAAApqsAANcTAAABAAAAp6sAANgTAAABAAAAqKsAANkTAAABAAAAqasAANoTAAABAAAAqqsAANsTAAABAAAAq6sAANwTAAABAAAArKsAAN0TAAABAAAArasAAN4TAAABAAAArqsAAN8TAAABAAAAr6sAAOATAAABAAAAsKsAAOETAAABAAAAsasAAOITAAABAAAAsqsAAOMTAAABAAAAs6sAAOQTAAABAAAAtKsAAOUTAAABAAAAtasAAOYTAAABAAAAtqsAAOcTAAABAAAAt6sAAOgTAAABAAAAuKsAAOkTAAABAAAAuasAAOoTAAABAAAAuqsAAOsTAAABAAAAu6sAAOwTAAABAAAAvKsAAO0TAAABAAAAvasAAO4TAAABAAAAvqsAAO8TAAABAAAAv6sAAPATAAABAAAA+BMAAPETAAABAAAA+RMAAPITAAABAAAA+hMAAPMTAAABAAAA+xMAAPQTAAABAAAA/BMAAPUTAAABAAAA/RMAAHkdAAABAAAAfacAAH0dAAABAAAAYywAAI4dAAABAAAAxqcAAAEeAAABAAAAAB4AAAMeAAABAAAAAh4AAAUeAAABAAAABB4AAAceAAABAAAABh4AAAkeAAABAAAACB4AAAseAAABAAAACh4AAA0eAAABAAAADB4AAA8eAAABAAAADh4AABEeAAABAAAAEB4AABMeAAABAAAAEh4AABUeAAABAAAAFB4AABceAAABAAAAFh4AABkeAAABAAAAGB4AABseAAABAAAAGh4AAB0eAAABAAAAHB4AAB8eAAABAAAAHh4AACEeAAABAAAAIB4AACMeAAABAAAAIh4AACUeAAABAAAAJB4AACceAAABAAAAJh4AACkeAAABAAAAKB4AACseAAABAAAAKh4AAC0eAAABAAAALB4AAC8eAAABAAAALh4AADEeAAABAAAAMB4AADMeAAABAAAAMh4AADUeAAABAAAANB4AADceAAABAAAANh4AADkeAAABAAAAOB4AADseAAABAAAAOh4AAD0eAAAB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LAAAAQAAABMsAABELAAAAQAAABQsAABFLAAAAQAAABUsAABGLAAAAQAAABYsAABHLAAAAQAAABcsAABILAAAAQAAABgsAABJLAAAAQAAABksAABKLAAAAQAAABosAABLLAAAAQAAABssAABMLAAAAQAAABwsAABNLAAAAQAAAB0sAABOLAAAAQAAAB4sAABPLAAAAQAAAB8sAABQLAAAAQAAACAsAABRLAAAAQAAACEsAABSLAAAAQAAACIsAABTLAAAAQAAACMsAABULAAAAQAAACQsAABVLAAAAQAAACUsAABWLAAAAQAAACYsAABXLAAAAQAAACcsAABYLAAAAQAAACgsAABZLAAAAQAAACksAABaLAAAAQAAACosAABbLAAAAQAAACssAABcLAAAAQAAACwsAABdLAAAAQAAAC0sAABeLAAAAQAAAC4sAABfLAAAAQAAAC8sAABhLAAAAQAAAGAsAABlLAAAAQAAADoCAABmLAAAAQAAAD4CAABoLAAAAQAAAGcsAABqLAAAAQAAAGksAABsLAAAAQAAAGssAABzLAAAAQAAAHIsAAB2LAAAAQAAAHUsAACBLAAAAQAAAIAsAACDLAAAAQAAAIIsAACFLAAAAQAAAIQsAACHLAAAAQAAAIYsAACJLAAAAQAAAIgsAACLLAAAAQAAAIosAACNLAAAAQAAAIwsAACPLAAAAQAAAI4sAACRLAAAAQAAAJAsAACTLAAAAQAAAJIsAACVLAAAAQAAAJQsAACXLAAAAQAAAJYsAACZLAAAAQAAAJgsAACbLAAAAQAAAJosAACdLAAAAQAAAJwsAACfLAAAAQAAAJ4sAAChLAAAAQAAAKAsAACjLAAAAQAAAKIsAAClLAAAAQAAAKQsAACnLAAAAQAAAKYsAACpLAAAAQAAAKgsAACrLAAAAQAAAKosAACtLAAAAQAAAKwsAACvLAAAAQAAAK4sAACxLAAAAQAAALAsAACzLAAAAQAAALIsAAC1LAAAAQAAALQsAAC3LAAAAQAAALYsAAC5LAAAAQAAALgsAAC7LAAAAQAAALosAAC9LAAAAQAAALwsAAC/LAAAAQAAAL4sAADBLAAAAQAAAMAsAADDLAAAAQAAAMIsAADFLAAAAQAAAMQsAADHLAAAAQAAAMYsAADJLAAAAQAAAMgsAADLLAAAAQAAAMosAADN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AgAwJgIAgCYCAOAmAgD0JgIAACcCALA+AgAAUwIAoFMCAMBTAgCwVAIA0FQCAPBUAgAMVQIAIFUCAEBVAgCwVQIAcFYCAJBWAgDgVgIAAFcCADBXAgBQVwIAcFcCAMBrAgBAcAIAoHACAOBxAgAAcgIAMHICAFByAgCQcgIAsHICAECHAgBwiQIAIJkCAOC6AABgmQIAwJkCAPStAgAArgIAIK4CAHy3AgCItwIAoLcCAOC3AgAAuAIAILgCAEC4AgCAuAIA4LwCAHDCAgCcwgIAsMICANDCAgDwwgIADMMCACDDAgBAwwIA0M0CAPDNAgAwzgIAUM4CAIDOAgCgzgIA4NICAADTAgDgogAAINMCAFDTAgBw0wIAkNMCAADUAgBA1gIA4NYCAADXAgAk1wIAMNcCAEDXAgBg1wIAdNcCAIDXAgCQ1wIApNcCALDXAgC81wIAyNcCAODXAgBg2AIAgNgCAKDYAgDw3wIAUOACACDhAgBQ4QIAgOECAFDiAgCQ5gIAwOUAAMDmAgDs5gIAAOcCAPDnAgAc6AIAMOgCAHDoAgAQ6QIAgOsCANTrAgDg6wIAAOwCAGDsAgAw8gIAcPICAPD0AgAQ9QIAgPUCAJz1AgCw9QIA0PUCAPD1AgBQ/QIAcP0CAJD9AgBA/gIAvAADAMgAAwDgAAMAAAEDACABAwCQAQMAkAIDAKAEAwCACgMAhAsDAJALAwCkCwMAsAsDAMQLAwDQCwMAAAwDACAMAwBADAMAYAwDAJAMAwCwDAMA0AwDAHANAwCQDQMAwA0DADAOAwCMEQMAoBEDAMARAwAAEgMAIBIDADQSAwBAEgMAYBIDAOASAwAQ7AAApCgDALAoAwDgKAMAMCkDAFApAwCw6wAAcCkDAFBBAwDQVQMA8FUDABBWAwBUVgMAYFYDAGxWAwCAVgMAFDABALxWAwDIVgMA1FYDAOBWAwDsVgMA+FYDAARXAwAQVwMAHFcDAChXAwA0VwMAQFcDAExXAwBYVwMAZFcDAHBXAwB8VwMAiFcDAJRXAwCgVwMArFcDALhXAwDEVwMA0FcDANxXAwDoVwMA9FcDAABYAwAMWAMAGFgDACRYAwAwWAMAPFgDAEhYAwBUWAMAYFgDAGxYAwB4WAMAhFgDAJBYAwCcWAMAqFgDALRYAwDAWAMAzFgDANhYAwDkWAMA8FgDAPxYAwAIWQMAFFkDACBZAwAsWQMAOFkDAERZAwBQWQMAXFkDAGhZAwB0WQMAgFkDAIxZAwAw1wIAmFkDAKRZAwCwWQMAvFkDAMhZAwDUWQMA4FkDAOxZAwD4WQMABFoDABBaAwAcWgMAKFoDADRaAwBAWgMATFoDAFhaAwBkWgMAcFoDAHxaAwCIWgMAlFoDAKBaAwCsWgMAuFoDAMRaAwDQWgMA3FoDABxKAQDoWgMA9FoDAABbAwAMWwMAGFsDACRbAwAwWwMAPFsDAEhbAwBUWwMAYFsDAGxbAwB4WwMAhFsDAJBbAwCcWwMAqFsDALRbAwDAWwMAzFsDANhbAwDkWwMA8FsDAPxbAwAIXAMAFFwDACBcAwAsXAMAOFwDAERcAwBQXAMAXFwDAGhcAwB0XAMAgFwDAIxcAwCYXAMApFwDALBcAwC8XAMAyFwDANRcAwDgXAMA7FwDAPhcAwAEXQMAEF0DABxdAwAoXQMANF0DAEBdAwBMXQMAWF0DAGRdAwBwXQMAfF0DAIhdAwCUXQMAoF0DAKxdAwC4XQMAxF0DANBdAwDcXQMA6F0DAPRdAwAAXgMADF4DABheAwAkXgMAMF4DADxeAwBIXgMAVF4DAGBeAwBsXgMAeF4DAIReAwCQXgMAnF4DAKheAwC0XgMAwF4DAMxeAwDYXgMA5F4DAPTjAQDIAAMA8F4DAPxeAwAIXwMAFF8DACBfAwAsXwMAOF8DAERfAwBQXwMA7OYCAFxfAwBoXwMAdF8DAIBfAwAMwwIAjF8DAJhfAwCw1wIAdNcCAKRfAwCwXwMAvF8DAMhfAwDUXwMA4F8DAOxfAwD4XwMABGADABBgAwAcYAMAKGADADRgAwBAYAMATGADAFhgAwBkYAMAcGADAHxgAwCIYAMAvAADAJRgAwCgYAMArGADALhgAwDEYAMA0GADANxgAwDoYAMA9GADAABhAwAMYQMAGGEDACRhAwAwYQMAPGEDAEhhAwBUYQMAYGEDAGxhAwB4YQMAhGEDAJBhAwCcYQMAqGEDALRhAwDAYQMAzGEDANhhAwDkYQMA8GEDAPxhAwAIYgMAFGIDACBiAwAsYgMAOGIDAERiAwBQYgMAXGIDAGhiAwB0YgMAgGIDAIxiAwCYYgMApGIDALBiAwC8YgMAyGIDANRiAwDgYgMA7GIDAPhiAwAEYwMAEGMDABxjAwAoYwMANGMDAEBjAwBMYwMAWGMDAGRjAwBwYwMAfGMDAIhjAwCUYwMAoGMDAKxjAwC4YwMAxGMDANBjAwDcYwMA6GMDAPRjAwAAZAMADGQDABhkAwAkZAMAMGQDADxkAwBIZAMAVGQDAGBkAwBsZAMAeGQDAIRkAwCQZAMAnGQDAKhkAwC0ZAMAwGQDAMxkAwDYZAMA5GQDAPBkAwD8ZAMACGUDABRlAwAgZQMALGUDADhlAwBQZQMAFQAAAAsFAAABAAAAAQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAAAAAAIwAAAAUAQey9Egs9JAAAAEMFAAAEAAAAAQAAABYAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAAIQBBtL4SCwUvAAAAHwBByL4SCwEFAEHUvhILATAAQey+EgsOMQAAADIAAABooQQAAAQAQYS/EgsBAQBBlL8SCwX/////CgBB2L8SCwPQx1Q=`)
let NB = null
function rB(A$2) {
  return A$2 == `text` || A$2 == `terminal`
}
function HB(A$2) {
  if (!NB) {
    let A$3 = gB(nB).then(() => ({ createOnigScanner: CB, createOnigString: EB }))
    NB = new jA({ onigLib: A$3, loadGrammar: A$4 => sB(A$4) })
  }
  let B$2 = A$2.filter(A$3 => !rB(A$3)).map(A$3 => {
    let B$3 = IB(A$3)
    if (!B$3) throw new kB(A$3)
    return NB.loadGrammar(B$3.scopeName)
  })
  return Promise.all(B$2)
}
function LB(A$2) {
  if (rB(A$2)) return { langId: A$2, grammar: null }
  let B$2 = IB(A$2)
  if (!B$2) throw new kB(A$2)
  let Q$1 = function(A$3) {
    let { _syncRegistry: B$3 } = NB
    return B$3?._grammars.get(A$3)
  }(B$2.scopeName)
  if (!Q$1) throw Error(`Syntax highlighting error: grammar for ${A$2} not loaded`)
  return { langId: B$2.id, grammar: Q$1 }
}
var kB = class extends Error {
  constructor(A$2) {
    super(`Unknown language: ${A$2}`), this.alias = A$2
  }
}
function RB(A$2, B$2, Q$1) {
  NB.setTheme(Q$1)
  let g$3 = function(A$3) {
    let B$3 = NB.getColorMap()
    return A$3.colorNames
      ? B$3.map(
        B$4 => Object.keys(A$3.colorNames).find(Q$2 => A$3.colorNames[Q$2].toUpperCase() === B$4.toUpperCase()) || B$4,
      )
      : B$3
  }(Q$1)
  return function(A$3, B$3, Q$2) {
    let g$4 = null
    return A$3.split(/\r?\n|\r/g).map(A$4 => {
      let { rawTokens: E$2, nextStack: C$4 } = FB(B$3, g$4, A$4)
      return g$4 = C$4, E$2.map(({ content: A$5, metadata: B$4 }) => ({ content: A$5, style: aB(B$4, Q$2) }))
    })
  }(A$2, B$2, g$3)
}
function KB(A$2) {
  return A$2.split(/\r?\n|\r/g).map(A$3 => [{ content: A$3, style: {} }])
}
function YB(A$2, B$2) {
  return PB(A$2.slice(1, -1)).map(A$3 => {
    let { from: Q$1, to: g$3 } = UB(A$3)
    return { lineNumber: B$2, fromColumn: Q$1, toColumn: g$3 }
  })
}
function UB(A$2) {
  let [B$2, Q$1] = A$2.split(`:`)
  if (!uB(B$2)) throw new yB(B$2)
  let g$3 = Number(B$2)
  if (g$3 < 1) throw new JB()
  if (Q$1) {
    if (!uB(Q$1)) throw new yB(Q$1)
    return { from: g$3, to: +Q$1 }
  }
  return { from: g$3, to: g$3 }
}
function PB(A$2) {
  return A$2.split(/,(?![^\[]*\])/g)
}
function uB(A$2) {
  A$2 = A$2.toString()
  var B$2 = Math.abs(A$2), Q$1 = parseInt(A$2, 10)
  return !isNaN(B$2) && Q$1 === B$2 && B$2.toString() === A$2
}
var yB = class extends Error {
    constructor(A$2) {
      super(`Invalid number "${A$2}" in range string`),
        this.number = A$2,
        Object.setPrototypeOf(this, new.target.prototype)
    }
  },
  JB = class extends Error {
    constructor() {
      super(`Invalid line or column number in range string`), Object.setPrototypeOf(this, new.target.prototype)
    }
  }
const SB = `#001`,
  dB = `#010`,
  lB = {
    name: `comments`,
    type: `light`,
    foreground: ``,
    background: ``,
    colors: {},
    settings: [{ settings: { foreground: `#000` } }, {
      scope: [`punctuation.definition.comment`],
      settings: { foreground: SB },
    }, { scope: `comment`, settings: { foreground: dB } }],
  }
function pB(A$2, B$2, Q$1, g$3) {
  let E$2 = B$2 ? RB(A$2, B$2, lB) : KB(A$2),
    C$4 = [],
    I$3 = 1,
    D$1 = E$2.map(A$3 => {
      let { annotations: B$3, lineWithoutComments: E$3 } = function(A$4, B$4, Q$2, g$4) {
        if (g$4 in fB && A$4.some(A$5 => A$5.style.color === dB)) {
          let B$5 = fB[g$4]
          A$4 = A$4.flatMap(A$5 => {
            if (A$5.style.color !== dB) return [A$5]
            let Q$3 = A$5.content.trimStart()
            if (Q$3.startsWith(B$5)) {
              let g$5 = Q$3.slice(B$5.length),
                E$5 = [{ content: A$5.content.slice(0, A$5.content.length - g$5.length), style: { color: SB } }]
              return g$5.length && E$5.push({ content: g$5, style: A$5.style }), E$5
            }
            return [A$5]
          })
        }
        if (!A$4.some(A$5 => A$5.style.color === SB)) return { annotations: [], lineWithoutComments: A$4 }
        let E$4 = [], C$5 = 0
        for (; C$5 < A$4.length;) {
          let g$5 = A$4[C$5]
          if (g$5.style.color !== dB) {
            C$5++
            continue
          }
          let I$5 = typeof B$4 == `function` ? B$4(g$5.content) : OB(g$5.content, B$4)
          if (!I$5) {
            C$5++
            continue
          }
          let { name: D$3, query: w$2, rangeString: o$18 } = I$5, s$14 = A$4[C$5 - 1], e$26 = A$4[C$5 + 1], c$3 = []
          s$14 && s$14.style.color === SB && c$3.push(s$14),
            c$3.push(g$5),
            e$26 && e$26.style.color === SB && c$3.push(e$26),
            E$4.push({ tokens: c$3, name: D$3, query: w$2, rangeString: o$18, lineNumber: Q$2 }),
            C$5 += 2
        }
        let I$4 = A$4
        for (let A$5 of E$4) I$4 = I$4.filter(B$5 => !A$5.tokens.includes(B$5))
        return I$4.every(A$5 => A$5.content.trim() === ``) && (I$4 = null), {
          annotations: E$4.map(
            A$5 => ({ name: A$5.name, query: A$5.query, lineNumber: A$5.lineNumber, rangeString: A$5.rangeString }),
          ),
          lineWithoutComments: I$4,
        }
      }(A$3, g$3, I$3, Q$1)
      if (C$4.push(...B$3), !E$3) return null
      let D$2 = E$3.map(A$4 => A$4.content).join(``)
      return [`mdx`, `jsx`, `tsx`].includes(Q$1) && B$3.length > 0 && D$2.trim() === `{}` ? null : (I$3++, D$2)
    }).filter(A$3 => A$3 !== null).join(`
`),
    w$1 = C$4.map(A$3 => {
      var { rangeString: B$3, lineNumber: Q$2 } = A$3,
        g$4 = function(A$4, B$4) {
          var Q$3 = {}
          for (var g$5 in A$4) {
            Object.prototype.hasOwnProperty.call(A$4, g$5) && B$4.indexOf(g$5) < 0 && (Q$3[g$5] = A$4[g$5])
          }
          if (A$4 != null && typeof Object.getOwnPropertySymbols == `function`) {
            var E$3 = 0
            for (g$5 = Object.getOwnPropertySymbols(A$4); E$3 < g$5.length; E$3++) {
              B$4.indexOf(g$5[E$3]) < 0 && Object.prototype.propertyIsEnumerable.call(A$4, g$5[E$3])
                && (Q$3[g$5[E$3]] = A$4[g$5[E$3]])
            }
          }
          return Q$3
        }(A$3, [`rangeString`, `lineNumber`])
      return Object.assign(Object.assign({}, g$4), { ranges: xB(B$3, Q$2, D$1) })
    }).filter(A$3 => A$3.ranges.length > 0)
  return { newCode: D$1, annotations: w$1 }
}
const fB = {
  'actionscript-3': `//`,
  ada: `--`,
  asm: `#`,
  dart: `//`,
  fsharp: `//`,
  graphql: `#`,
  http: `#`,
  rust: `//`,
  sparql: `#`,
  wgsl: `//`,
  jsonnet: `//`,
  kql: `//`,
  zenscript: `//`,
  kusto: `//`,
  turtle: `#`,
  abap: `*`,
  beancount: `;`,
  kotlin: `//`,
  hlsl: `//`,
  berry: `#`,
  cypher: `//`,
  elm: `--`,
  nix: `#`,
  viml: `"`,
  solidity: `//`,
  bat: `REM`,
  shaderlab: `//`,
  sas: `*`,
  clarity: `;;`,
}
function xB(A$2, B$2, Q$1) {
  return A$2 && A$2.startsWith(`(/`)
    ? function(A$3, B$3, Q$2) {
      let g$3 = B$3.match(/\(\/([\s\S]*?)\/([gimuy]*)\)/)
      if (!g$3) throw Error(`Invalid RegExp string: ${B$3}`)
      let E$2 = new RegExp(g$3[1], g$3[2]),
        C$4 = A$3.split(/\r?\n/).slice(Q$2 - 1).join(`
`)
      if (!E$2.global) {
        let A$4 = E$2.exec(C$4)
        if (!A$4) return []
        let B$4 = C$4.slice(0, A$4.index).split(`
`).length + Q$2 - 1
        return [{
          fromLineNumber: B$4,
          toLineNumber: B$4 + A$4[0].split(`
`).length - 1,
        }]
      }
      let I$3, D$1 = []
      for (; I$3 = E$2.exec(C$4);) {
        let A$4 = C$4.slice(0, I$3.index).split(`
`).length
            + Q$2 - 1,
          B$4 = A$4 + I$3[0].split(`
`).length - 1,
          g$4 = D$1[D$1.length - 1]
        g$4 && g$4.fromLineNumber === A$4 || D$1.push({ fromLineNumber: A$4, toLineNumber: B$4 })
      }
      return D$1
    }(Q$1, A$2, B$2)
    : A$2 && A$2.startsWith(`[/`)
    ? function(A$3, B$3, Q$2) {
      let g$3 = B$3.match(/\[\/([\s\S]*?)\/([gimuy]*)\]/)
      if (!g$3) throw Error(`Invalid RegExp string: ${B$3}`)
      let E$2 = g$3[2] || ``
      E$2 += `d`
      let C$4 = new RegExp(g$3[1], E$2), I$3 = A$3.split(/\r?\n/)
      I$3 = I$3.slice(Q$2 - 1), C$4.multiline || (I$3 = [I$3[0]])
      let D$1 = []
      return I$3.forEach((A$4, B$4) => {
        if (!C$4.global) {
          if (D$1.length > 0) return
          let g$5 = C$4.exec(A$4)
          if (!g$5) return
          let E$3 = g$5.indices[1] || g$5.indices[0]
          return void D$1.push({ lineNumber: B$4 + Q$2, fromColumn: E$3[0] + 1, toColumn: E$3[1] })
        }
        let g$4
        for (; g$4 = C$4.exec(A$4);) {
          let A$5 = g$4.indices[1] || g$4.indices[0]
          D$1.push({ lineNumber: B$4 + Q$2, fromColumn: A$5[0] + 1, toColumn: A$5[1] })
        }
      }),
        D$1
    }(Q$1, A$2, B$2)
    : function(A$3, B$3) {
      return A$3
        ? A$3.startsWith(`[`) ? YB(A$3, B$3) : PB(A$3.slice(1, -1)).map(A$4 => {
          if (A$4.includes(`[`)) {
            let [Q$3, g$4] = A$4.split(`[`), E$2 = Number(Q$3), C$4 = B$3 + E$2 - 1
            if (!uB(C$4)) throw new yB(Q$3)
            return YB(`[` + g$4, C$4)
          }
          let { from: Q$2, to: g$3 } = UB(A$4)
          return [{ fromLineNumber: Q$2 + B$3 - 1, toLineNumber: g$3 + B$3 - 1 }]
        }).flat()
        : [{ fromLineNumber: B$3, toLineNumber: B$3 }]
    }(A$2, B$2)
}
function OB(A$2, B$2) {
  var Q$1
  let g$3 = A$2.match(/\s*([\w-]+)?(\([^\)]*\)|\[[^\]]*\])?(.*)$/),
    E$2 = g$3[1],
    C$4 = g$3[2],
    I$3 = (Q$1 = g$3[3])?.trim()
  return B$2.includes(E$2) ? { name: E$2, rangeString: C$4, query: I$3 } : null
}
function mB(A$2, B$2) {
  let Q$1 = [], g$3 = 1
  return A$2.forEach(A$3 => {
    Q$1.push({ fromColumn: g$3, toColumn: g$3 + A$3.content.length - 1, token: A$3 }), g$3 += A$3.content.length
  }),
    B$2.forEach(A$3 => {
      Q$1 = function(A$4, B$3) {
        let { range: Q$2 } = B$3, { fromColumn: g$4, toColumn: E$2 } = Q$2, C$4 = [], I$3 = 0
        for (; I$3 < A$4.length && A$4[I$3].toColumn < g$4;) C$4.push(A$4[I$3]), I$3++
        if (I$3 === A$4.length) return A$4
        let D$1 = { annotationName: B$3.name, annotationQuery: B$3.query, fromColumn: g$4, toColumn: E$2, tokens: [] },
          w$1 = A$4[I$3]
        if (w$1.fromColumn < g$4) {
          let [A$5, B$4] = bB(w$1, g$4)
          if (C$4.push(A$5), C$4.push(D$1), B$4.toColumn > E$2) {
            let [A$6, Q$3] = bB(B$4, E$2 + 1)
            D$1.tokens.push(A$6), C$4.push(Q$3)
          } else D$1.tokens.push(B$4)
          I$3++
        } else C$4.push(D$1)
        for (; I$3 < A$4.length && A$4[I$3].toColumn <= E$2;) D$1.tokens.push(A$4[I$3]), I$3++
        if (I$3 === A$4.length) return C$4
        let o$18 = A$4[I$3]
        if (o$18.fromColumn <= E$2) {
          let [A$5, B$4] = bB(o$18, E$2 + 1)
          D$1.tokens.push(A$5), C$4.push(B$4), I$3++
        }
        for (; I$3 < A$4.length;) C$4.push(A$4[I$3]), I$3++
        return C$4
      }(Q$1, A$3)
    }),
    Q$1.map(A$3 => qB(A$3))
}
function qB(A$2) {
  return `tokens` in A$2
    ? {
      annotationName: A$2.annotationName,
      annotationQuery: A$2.annotationQuery,
      fromColumn: A$2.fromColumn,
      toColumn: A$2.toColumn,
      tokens: A$2.tokens.map(A$3 => qB(A$3)),
    }
    : A$2.token
}
function bB(A$2, B$2) {
  if (`token` in A$2) {
    let Q$1 = Object.assign(Object.assign({}, A$2.token), {
        content: A$2.token.content.slice(0, B$2 - A$2.fromColumn),
      }),
      g$3 = Object.assign(Object.assign({}, A$2.token), { content: A$2.token.content.slice(B$2 - A$2.fromColumn) })
    return [
      Object.assign(Object.assign({}, A$2), { toColumn: B$2 - 1, token: Q$1 }),
      Object.assign(Object.assign({}, A$2), { fromColumn: B$2, token: g$3 }),
    ]
  }
  {
    let Q$1 = [], g$3 = []
    return A$2.tokens.forEach(A$3 => {
      if (A$3.toColumn < B$2) Q$1.push(A$3)
      else if (A$3.fromColumn >= B$2) g$3.push(A$3)
      else {
        let [E$2, C$4] = bB(A$3, B$2)
        Q$1.push(E$2), g$3.push(C$4)
      }
    }),
      [
        Object.assign(Object.assign({}, A$2), { toColumn: B$2 - 1, tokens: Q$1 }),
        Object.assign(Object.assign({}, A$2), { fromColumn: B$2, tokens: g$3 }),
      ]
  }
}
function WB(A$2, B$2) {
  let Q$1 = A$2.map((A$3, B$3) => ({ fromLineNumber: B$3 + 1, toLineNumber: B$3 + 1, line: A$3 }))
  return B$2.forEach(A$3 => {
    Q$1 = function(A$4, B$3) {
      let { range: Q$2, name: g$3, query: E$2 } = B$3,
        { fromLineNumber: C$4, toLineNumber: I$3 } = Q$2,
        D$1 = [],
        w$1 = 0
      for (; w$1 < A$4.length && A$4[w$1].toLineNumber < C$4;) D$1.push(A$4[w$1]), w$1++
      if (w$1 === A$4.length) return D$1
      let o$18 = { annotationName: g$3, annotationQuery: E$2, fromLineNumber: C$4, toLineNumber: I$3, lines: [] },
        s$14 = A$4[w$1]
      if (s$14.fromLineNumber < C$4) {
        let [A$5, B$4] = XB(s$14, C$4)
        if (D$1.push(A$5), D$1.push(o$18), B$4.toLineNumber > I$3) {
          let [A$6, Q$3] = XB(B$4, I$3 + 1)
          o$18.lines.push(A$6), D$1.push(Q$3)
        } else o$18.lines.push(B$4)
        w$1++
      } else D$1.push(o$18)
      for (; w$1 < A$4.length && A$4[w$1].toLineNumber <= I$3;) o$18.lines.push(A$4[w$1]), w$1++
      if (w$1 === A$4.length) return D$1
      let e$26 = A$4[w$1]
      if (e$26.fromLineNumber <= I$3) {
        let [A$5, B$4] = XB(e$26, I$3 + 1)
        o$18.lines.push(A$5), D$1.push(B$4), w$1++
      }
      for (; w$1 < A$4.length;) D$1.push(A$4[w$1]), w$1++
      return D$1
    }(Q$1, A$3)
  }),
    Q$1.map(A$3 => TB(A$3))
}
function TB(A$2) {
  return `line` in A$2
    ? { lineNumber: A$2.fromLineNumber, tokens: A$2.line.tokens }
    : {
      annotationName: A$2.annotationName,
      annotationQuery: A$2.annotationQuery,
      fromLineNumber: A$2.fromLineNumber,
      toLineNumber: A$2.toLineNumber,
      lines: A$2.lines.map(A$3 => TB(A$3)),
    }
}
function XB(A$2, B$2) {
  if (`line` in A$2) {
    return [
      Object.assign(Object.assign({}, A$2), { toLineNumber: B$2 - 1 }),
      Object.assign(Object.assign({}, A$2), { fromLineNumber: B$2 }),
    ]
  }
  {
    let Q$1 = [], g$3 = []
    return A$2.lines.forEach(A$3 => {
      if (A$3.toLineNumber < B$2) Q$1.push(A$3)
      else if (A$3.fromLineNumber >= B$2) g$3.push(A$3)
      else {
        let [E$2, C$4] = XB(A$3, B$2)
        Q$1.push(E$2), g$3.push(C$4)
      }
    }),
      [
        Object.assign(Object.assign({}, A$2), { toLineNumber: B$2 - 1, lines: Q$1 }),
        Object.assign(Object.assign({}, A$2), { fromLineNumber: B$2, lines: g$3 }),
      ]
  }
}
function vB(A$2, B$2) {
  let { inlineAnnotations: Q$1, multilineAnnotations: g$3 } = function(A$3) {
    let B$3 = [], Q$2 = []
    return A$3.forEach(A$4 => {
      A$4.ranges.forEach(g$4 => {
        ;`lineNumber` in g$4
          ? B$3.push(Object.assign(Object.assign({}, A$4), { range: g$4 }))
          : Q$2.push(Object.assign(Object.assign({}, A$4), { range: g$4 }))
      })
    }),
      { inlineAnnotations: B$3, multilineAnnotations: Q$2 }
  }(B$2)
  return WB(
    A$2.map((A$3, B$3) => {
      let g$4 = Q$1.filter(A$4 => A$4.range.lineNumber === B$3 + 1)
      return { lineNumber: B$3 + 1, tokens: mB(A$3, g$4) }
    }),
    g$3,
  )
}
var ZB = [
    `black`,
    `red`,
    `green`,
    `yellow`,
    `blue`,
    `magenta`,
    `cyan`,
    `white`,
    `brightBlack`,
    `brightRed`,
    `brightGreen`,
    `brightYellow`,
    `brightBlue`,
    `brightMagenta`,
    `brightCyan`,
    `brightWhite`,
  ],
  jB = { 1: `bold`, 2: `dim`, 3: `italic`, 4: `underline`, 7: `reverse`, 9: `strikethrough` }
function VB(A$2, B$2) {
  let Q$1 = A$2.indexOf(`\x1B[`, B$2)
  if (Q$1 !== -1) {
    let B$3 = A$2.indexOf(`m`, Q$1)
    return { sequence: A$2.substring(Q$1 + 2, B$3).split(`;`), startPosition: Q$1, position: B$3 + 1 }
  }
  return { position: A$2.length }
}
function zB(A$2, B$2) {
  let Q$1 = 1, g$3 = A$2[B$2 + Q$1++], E$2
  if (g$3 === `2`) {
    let g$4 = [A$2[B$2 + Q$1++], A$2[B$2 + Q$1++], A$2[B$2 + Q$1]].map(A$3 => Number.parseInt(A$3))
    g$4.length !== 3 || g$4.some(A$3 => Number.isNaN(A$3)) || (E$2 = { type: `rgb`, rgb: g$4 })
  } else if (g$3 === `5`) {
    let g$4 = Number.parseInt(A$2[B$2 + Q$1])
    Number.isNaN(g$4) || (E$2 = { type: `table`, index: Number(g$4) })
  }
  return [Q$1, E$2]
}
function _B(A$2) {
  let B$2 = []
  for (let Q$1 = 0; Q$1 < A$2.length; Q$1++) {
    let g$3 = A$2[Q$1], E$2 = Number.parseInt(g$3)
    if (!Number.isNaN(E$2)) {
      if (E$2 === 0) B$2.push({ type: `resetAll` })
      else if (E$2 <= 9) jB[E$2] && B$2.push({ type: `setDecoration`, value: jB[E$2] })
      else if (E$2 <= 29) {
        let A$3 = jB[E$2 - 20]
        A$3 && B$2.push({ type: `resetDecoration`, value: A$3 })
      } else if (E$2 <= 37) B$2.push({ type: `setForegroundColor`, value: { type: `named`, name: ZB[E$2 - 30] } })
      else if (E$2 === 38) {
        let [g$4, E$3] = zB(A$2, Q$1)
        E$3 && B$2.push({ type: `setForegroundColor`, value: E$3 }), Q$1 += g$4
      } else if (E$2 === 39) B$2.push({ type: `resetForegroundColor` })
      else if (E$2 <= 47) B$2.push({ type: `setBackgroundColor`, value: { type: `named`, name: ZB[E$2 - 40] } })
      else if (E$2 === 48) {
        let [g$4, E$3] = zB(A$2, Q$1)
        E$3 && B$2.push({ type: `setBackgroundColor`, value: E$3 }), Q$1 += g$4
      } else {E$2 === 49
          ? B$2.push({ type: `resetBackgroundColor` })
          : E$2 >= 90 && E$2 <= 97
          ? B$2.push({ type: `setForegroundColor`, value: { type: `named`, name: ZB[E$2 - 90 + 8] } })
          : E$2 >= 100 && E$2 <= 107
            && B$2.push({ type: `setBackgroundColor`, value: { type: `named`, name: ZB[E$2 - 100 + 8] } })}
    }
  }
  return B$2
}
function $B(A$2, B$2) {
  let Q$1 = function() {
      let A$3 = null, B$3 = null, Q$2 = new Set()
      return {
        parse(g$4) {
          let E$2 = [], C$4 = 0
          do {
            let I$3 = VB(g$4, C$4), D$1 = I$3.sequence ? g$4.substring(C$4, I$3.startPosition) : g$4.substring(C$4)
            if (
              D$1.length > 0 && E$2.push({ value: D$1, foreground: A$3, background: B$3, decorations: new Set(Q$2) }),
                I$3.sequence
            ) {
              let g$5 = _B(I$3.sequence)
              for (let E$3 of g$5) {
                E$3.type === `resetAll`
                  ? (A$3 = null, B$3 = null, Q$2.clear())
                  : E$3.type === `resetForegroundColor`
                  ? A$3 = null
                  : E$3.type === `resetBackgroundColor`
                  ? B$3 = null
                  : E$3.type === `resetDecoration` && Q$2.delete(E$3.value)
              }
              for (let E$3 of g$5) {
                E$3.type === `setForegroundColor`
                  ? A$3 = E$3.value
                  : E$3.type === `setBackgroundColor`
                  ? B$3 = E$3.value
                  : E$3.type === `setDecoration` && Q$2.add(E$3.value)
              }
            }
            C$4 = I$3.position
          } while (C$4 < g$4.length)
          return E$2
        },
      }
    }(),
    g$3 = A$2.split(/\r?\n|\r/g).map(A$3 =>
      function(A$4, B$3, Q$2) {
        let g$4 = A$4.parse(B$3),
          E$2 = g$4.map(({ value: A$5, foreground: B$4, background: g$5, decorations: E$3 }) => {
            let C$4 = AQ(B$4, Q$2), I$3 = {}
            C$4 && (I$3.color = C$4)
            let D$1 = AQ(g$5, Q$2)
            return D$1 && (I$3.background = D$1),
              E$3.has(`bold`) && (I$3.fontWeight = `bold`),
              E$3.has(`italic`) && (I$3.fontStyle = `italic`),
              E$3.has(`underline`) && (I$3.textDecoration = `underline`),
              E$3.has(`strikethrough`) && (I$3.textDecoration = `line-through`),
              E$3.has(`reverse`) && (I$3.color = D$1, I$3.background = C$4),
              E$3.has(`dim`) && (I$3.opacity = .5),
              { content: A$5, style: I$3 }
          })
        return E$2
      }(Q$1, A$3, B$2)
    )
  return g$3
}
function AQ(A$2, B$2) {
  if (A$2) {
    if (A$2.type === `named`) return w(B$2, `terminal.ansi` + (A$2.name[0].toUpperCase() + A$2.name.slice(1)))
    if (A$2.type === `rgb`) {
      let [B$3, Q$1, g$3] = A$2.rgb
      return `rgb(${B$3}, ${Q$1}, ${g$3})`
    }
  }
}
async function BQ(A$2, B$2) {
  await Promise.all([HB(A$2), i(B$2)])
}
async function QQ(A$2, B$2, Q$1 = `dark-plus`, g$3 = {}) {
  let E$2 = A$2 || ``, C$4 = B$2 || `text`
  if (typeof E$2 != `string`) throw Error(`Syntax highlighter error: code must be a string`)
  if (typeof C$4 != `string`) throw Error(`Syntax highlighter error: lang must be a string`)
  return await BQ([C$4], Q$1), gQ(E$2, C$4, Q$1, g$3)
}
function gQ(A$2, B$2, Q$1 = `dark-plus`, g$3 = {}) {
  let E$2 = A$2 || ``, C$4 = B$2 || `text`
  if (typeof E$2 != `string`) throw Error(`Syntax highlighter error: code must be a string`)
  if (typeof C$4 != `string`) throw Error(`Syntax highlighter error: lang must be a string`)
  let { langId: I$3, grammar: o$18 } = LB(C$4),
    s$14 = t(Q$1),
    e$26 = I$3 == `text` ? KB(E$2) : I$3 == `terminal` ? $B(E$2, s$14) : g$3?.scopes
      ? function(A$3, B$3, Q$2) {
        return NB.setTheme(Q$2), GB(A$3, B$3, NB.getColorMap())
      }(E$2, o$18, s$14)
      : RB(E$2, o$18, s$14),
    c$3 = I$3 == `terminal`
      ? function(A$3) {
        return { color: w(A$3, `terminal.foreground`), background: w(A$3, `terminal.background`), colorScheme: D(A$3) }
      }(s$14)
      : { color: s$14.foreground, background: s$14.background, colorScheme: D(s$14) }
  return (function(A$3) {
      return `annotations` in A$3
    })(g$3)
    ? { lines: vB(e$26, g$3?.annotations || []), lang: I$3, style: c$3 }
    : { lines: e$26, lang: I$3, style: c$3 }
}
async function EQ(A$2, B$2, Q$1) {
  if (!Q$1) return { code: A$2, annotations: [] }
  await HB([B$2])
  let { grammar: g$3, langId: E$2 } = LB(B$2), { newCode: C$4, annotations: I$3 } = pB(A$2, g$3, E$2, Q$1)
  return { code: C$4, annotations: I$3 }
}
async function splitAnnotationsAndCode(code$3, lang, annotationPrefix) {
  let annotations$2 = [],
    codeWithoutAnnotations = code$3,
    { code: newCode, annotations: newAnnotations } = await extractCommentAnnotations(
      codeWithoutAnnotations,
      lang,
      annotationPrefix,
    )
  return annotations$2 = [...annotations$2, ...newAnnotations],
    codeWithoutAnnotations = newCode,
    { code: codeWithoutAnnotations, annotations: annotations$2 }
}
async function extractCommentAnnotations(code$3, lang, annotationPrefix = `!`) {
  let extractor = comment$1 => {
      var _a
      let body$2 = `(?:\\\\.|[^\\\\/])+`,
        nestedBracketRegex = RegExp(`\\s*(${annotationPrefix}?[\\w-]+)?(\\[\\/${body$2}\\/[a-zA-Z]*\\])(.*)$`),
        nestedParenRegex = RegExp(`\\s*(${annotationPrefix}?[\\w-]+)?(\\(\\/${body$2}\\/[a-zA-Z]*\\))(.*)$`),
        regex = RegExp(`\\s*(${annotationPrefix}?[\\w-]+)?(\\([^\\)]*\\)|\\[[^\\]]*\\])?(.*)$`),
        match$13 = comment$1.match(nestedBracketRegex) || comment$1.match(nestedParenRegex) || comment$1.match(regex)
      if (!match$13) return null
      let name = match$13[1], rangeString = match$13[2], query = (_a = match$13[3])?.trim()
      return !name || !name.startsWith(annotationPrefix)
        ? null
        : { name: name.slice(annotationPrefix.length), rangeString, query }
    },
    { code: codeWithoutComments, annotations: annotations$2 } = await EQ(code$3, lang, extractor)
  return { code: codeWithoutComments, annotations: annotations$2 }
}
function isBlockAnnotation(annotation) {
  return !isInlineAnnotation(annotation)
}
function isInlineAnnotation(annotation) {
  return annotation.hasOwnProperty(`lineNumber`)
}
function isWhitespace(token) {
  return typeof token == `string`
}
async function highlight(data, theme, config = {}) {
  let { value: value$2, lang = `txt` } = data
  a.includes(lang) || (console.warn(`Code Hike warning: Unknown language "${lang}"`), lang = `txt`)
  let { code: code$3, annotations: annotations$2 } = await splitAnnotationsAndCode(
      value$2,
      lang,
      config.annotationPrefix || `!`,
    ),
    { lines, lang: lighterLang, style: style$1 } = await QQ(code$3, lang, theme, { annotations: [], scopes: !1 }),
    tokens = joinLines(lines),
    splitTokens = splitWhitespace(tokens),
    joinedTokens = joinWhitespace(splitTokens)
  return {
    ...data,
    code: code$3,
    tokens: joinedTokens,
    lang: lighterLang,
    annotations: compatAnnotations(annotations$2),
    themeName: typeof theme == `string` ? theme : theme?.name || `unknown`,
    style: style$1,
  }
}
function compatAnnotations(annotations$2) {
  let newAnnotations = []
  for (let a$22 of annotations$2) {
    let { name, query, ranges } = a$22
    for (let r$26 of ranges) {
      if (r$26.lineNumber) {
        let { lineNumber, fromColumn, toColumn } = r$26
        newAnnotations.push({ name, query, lineNumber, fromColumn, toColumn })
      } else {
        let { fromLineNumber, toLineNumber } = r$26
        newAnnotations.push({ name, query, fromLineNumber, toLineNumber })
      }
    }
  }
  return newAnnotations
}
function joinLines(lines) {
  let joinedTokens = []
  return lines.forEach((lineOrGroup, i$14) => {
    if (`lines` in lineOrGroup) throw Error(`Shouldnt be groups`)
    {
      let tokens = joinTokens(lineOrGroup.tokens)
      joinedTokens.push(...tokens),
        i$14 < lines.length - 1 && joinedTokens.push(`
`)
    }
  }),
    joinedTokens
}
function joinTokens(tokens) {
  return tokens.map(tokenOrGroup => {
    if (`tokens` in tokenOrGroup) throw Error(`Shouldnt be groups`)
    {
      let t$18 = [tokenOrGroup.content], { color: color$1, ...rest } = tokenOrGroup.style || {}
      return t$18.push(color$1), Object.keys(rest).length && t$18.push(rest), t$18
    }
  })
}
function splitWhitespace(tokens) {
  let ejected = []
  return tokens.forEach(tokenOrGroup => {
    if (isWhitespace(tokenOrGroup)) ejected.push(tokenOrGroup)
    else {
      let [before$2, content$2, after$2] = splitSurroundingWhitespace(tokenOrGroup[0])
      if (before$2?.length && ejected.push(before$2), content$2.length) {
        let copy$2 = [...tokenOrGroup]
        copy$2[0] = content$2, ejected.push(copy$2)
      }
      after$2?.length && ejected.push(after$2)
    }
  }),
    ejected
}
function joinWhitespace(tokens) {
  let joinedTokens = []
  return tokens.forEach(tokenOrGroup => {
    if (isWhitespace(tokenOrGroup)) {
      let last$3 = joinedTokens[joinedTokens.length - 1]
      last$3 && isWhitespace(last$3)
        ? joinedTokens[joinedTokens.length - 1] += tokenOrGroup
        : tokenOrGroup !== `` && joinedTokens.push(tokenOrGroup)
    } else tokenOrGroup[0].length > 0 && joinedTokens.push(tokenOrGroup)
  }),
    joinedTokens
}
function splitSurroundingWhitespace(content$2) {
  let trimmed = content$2.trim(),
    before$2 = content$2.slice(0, content$2.indexOf(trimmed)),
    after$2 = content$2.slice(content$2.indexOf(trimmed) + trimmed.length)
  return [before$2, trimmed, after$2]
}
function pushProp(target, key$1, value$2) {
  if (key$1 === `children`) target.children = value$2 || target.children
  else if (key$1 === `_ref`) target._ref = value$2 || target._ref
  else if (key$1 === `data`) target.data = target.data ? { ...target.data, ...value$2 } : value$2
  else if (key$1 === `className`) target.className = [target.className, value$2].join(` `).trim()
  else if (key$1 === `style`) target.style = { ...target.style, ...value$2 }
  else if (typeof value$2 == `function`) {
    let oldFn = target[key$1]
    target[key$1] = oldFn
      ? (...args$1) => {
        oldFn(...args$1), value$2(...args$1)
      }
      : value$2
  } else if (value$2 === void 0 || typeof value$2 != `object` && value$2 === target[key$1]) return
  else if (!(key$1 in target)) target[key$1] = value$2
  else {throw Error(
      `Didnt know how to merge prop '${key$1}'. Only 'className', 'style', and event handlers are supported`,
    )}
}
function mergeProps(...props) {
  return props.length === 1 ? props[0] : props.reduce((merged, ps) => {
    for (let key$1 in ps) pushProp(merged, key$1, ps[key$1])
    return merged
  }, {})
}
const InnerPre = ({ merge: merge$9, ...rest }) => {
    let { _stack, ...result } = mergeProps(merge$9, rest), [Next, ...stack] = _stack
    if (Next) return (0, import_jsx_runtime.jsx)(Next, { _stack: stack, ...result })
    {
      let { _ref, data, children: children$3, ...props } = result
      return (0, import_jsx_runtime.jsx)(`pre`, {
        ...props,
        ref: _ref,
        'data-ch': !0,
        children: (0, import_jsx_runtime.jsx)(`div`, { style: { minWidth: `fit-content` }, children: children$3 }),
      })
    }
  },
  InnerLine = ({ merge: merge$9, ...rest }) => {
    let { _stack, ...result } = mergeProps(merge$9, rest), [next, ...stack] = _stack
    if (next) {
      let { Component: Component$7, annotation } = next
      return (0, import_jsx_runtime.jsx)(Component$7, { _stack: stack, ...result, annotation })
    } else {
      let { lineNumber, totalLines, indentation, data, annotation, ...props } = result
      return (0, import_jsx_runtime.jsx)(`div`, { ...props })
    }
  },
  InnerToken = ({ merge: merge$9, ...rest }) => {
    let { _stack, ...result } = mergeProps(merge$9, rest), [next, ...stack] = _stack
    if (next) {
      let { Component: Component$7, annotation } = next
      return (0, import_jsx_runtime.jsx)(Component$7, { _stack: stack, ...result, annotation })
    } else {
      let { value: value$2, data, ...props } = result
      return (0, import_jsx_runtime.jsx)(`span`, { ...props, children: value$2 })
    }
  },
  AddRefIfNedded = props => {
    let innerRef = (0, import_react.useRef)(null), ref = props._ref || innerRef
    return (0, import_jsx_runtime.jsx)(InnerPre, { merge: props, _ref: ref })
  }
function toLineContent(tokens, annotations$2) {
  let content$2 = tokens
  for (let i$14 = annotations$2.length - 1; i$14 >= 0; i$14--) {
    let annotation = annotations$2[i$14]
    content$2 = applyInlineAnnotation(content$2, annotation)
  }
  return content$2
}
function applyInlineAnnotation(lineContent, annotation) {
  let { fromColumn, toColumn } = annotation,
    range = [fromColumn, toColumn],
    content$2 = splitContent(lineContent, range[0])
  content$2 = splitContent(content$2, range[1] + 1)
  let before$2 = [], inside = [], after$2 = []
  return content$2.forEach(item => {
    item.range[1] < range[0] ? before$2.push(item) : item.range[0] > range[1] ? after$2.push(item) : inside.push(item)
  }),
    [
      ...before$2,
      { annotation, content: inside, range: [inside[0].range[0], inside[inside.length - 1].range[1]] },
      ...after$2,
    ]
}
function splitContent(lineContent, n$19) {
  let index$4 = lineContent.findIndex(token => token.range[0] < n$19 && n$19 <= token.range[1])
  if (index$4 === -1) return lineContent
  let item = lineContent[index$4]
  if (isGroup$1(item)) {
    let content$2 = splitContent(item.content, n$19), before$2 = [], after$2 = []
    for (let token of content$2) token.range[1] < n$19 ? before$2.push(token) : after$2.push(token)
    return [...lineContent.slice(0, index$4), { ...item, content: before$2, range: [item.range[0], n$19 - 1] }, {
      ...item,
      content: after$2,
      range: [n$19, item.range[1]],
    }, ...lineContent.slice(index$4 + 1)]
  }
  return [
    ...lineContent.slice(0, index$4),
    { ...item, value: item.value.slice(0, n$19 - item.range[0]), range: [item.range[0], n$19 - 1] },
    { ...item, value: item.value.slice(n$19 - item.range[0]), range: [n$19, item.range[1]] },
    ...lineContent.slice(index$4 + 1),
  ]
}
function isGroup$1(token) {
  return token.content !== void 0
}
function renderLineContent({ content: content$2, handlers: handlers$1, annotationStack }) {
  return content$2.map((item, i$14) =>
    isGroup$1(item)
      ? (0, import_jsx_runtime.jsx)(InlinedTokens, { annotationStack, handlers: handlers$1, group: item }, i$14)
      : item.style
      ? (0, import_jsx_runtime.jsx)(FinalToken, { annotationStack, handlers: handlers$1, token: item }, i$14)
      : item.value
  )
}
function FinalToken({ handlers: handlers$1, token, annotationStack }) {
  let stack = buildTokenStack(handlers$1, annotationStack)
  return (0, import_jsx_runtime.jsx)(InnerToken, { merge: { _stack: stack, style: token.style, value: token.value } })
}
function InlinedTokens({ group, handlers: handlers$1, annotationStack }) {
  var _a
  let { annotation, content: content$2 } = group,
    { name } = annotation,
    children$3 = renderLineContent({
      content: content$2,
      handlers: handlers$1,
      annotationStack: [...annotationStack, annotation],
    }),
    Component$7 = (_a = handlers$1.find(c$3 => c$3.name === name))?.Inline
  return Component$7 ? (0, import_jsx_runtime.jsx)(Component$7, { annotation, children: children$3 }) : children$3
}
function buildTokenStack(handlers$1, annotationStack) {
  let stack = []
  return handlers$1.forEach(({ name, Token: Token$1, AnnotatedToken }) => {
    let annotations$2 = annotationStack.filter(a$22 => a$22.name === name)
    AnnotatedToken && annotations$2.forEach(annotation => stack.push({ Component: AnnotatedToken, annotation })),
      Token$1
      && (annotations$2.length || stack.push({ Component: Token$1 }),
        annotations$2.forEach(annotation => stack.push({ Component: Token$1, annotation })))
  }),
    stack
}
const TAB_TO_SPACES = `  `
function toLines(tokens) {
  let lines = [[]], tokenStack = tokens.slice(), col = 1
  for (; tokenStack.length;) {
    let token = tokenStack.shift()
    if (typeof token == `string`) {
      let [value$2, ...tail] = token.split(`
`)
      if (value$2) {
        let start$2 = col
        col += value$2.length, lines[lines.length - 1].push({ value: value$2, range: [start$2, col] })
      }
      tail.length && (lines[lines.length - 1].push({
        value: `
`,
        range: [col, col + 1],
      }),
        lines.push([]),
        col = 1,
        tokenStack.unshift(tail.join(`
`)))
    } else {
      let [value$2, color$1, rest = {}] = token, start$2 = col
      col += value$2.length,
        lines[lines.length - 1].push({ value: value$2, style: { color: color$1, ...rest }, range: [start$2, col] })
    }
  }
  let totalLines = lines.length
  return lines.map((tokens$1, i$14) => {
    var _a, _b, _c
    return {
      tokens: tokens$1,
      range: [i$14 + 1, i$14 + 1],
      lineNumber: i$14 + 1,
      indentation: (_c = (_b = (_a = tokens$1[0])?.value)?.replace(/\t/g, TAB_TO_SPACES).match(/^\s*/))?.[0].length
        || 0,
      totalLines,
    }
  })
}
function toLineGroups(lines, annotations$2) {
  let groups = lines
  for (let i$14 = annotations$2.length - 1; i$14 >= 0; i$14--) {
    let annotation = annotations$2[i$14]
    groups = applyBlockAnnotation(groups, annotation)
  }
  return groups
}
function applyBlockAnnotation(lines, annotation) {
  let { fromLineNumber, toLineNumber } = annotation,
    range = [fromLineNumber, toLineNumber],
    groups = splitGroups(lines, range[0])
  groups = splitGroups(groups, range[1] + 1)
  let before$2 = [], inside = [], after$2 = []
  return groups.forEach(group => {
    group.range[1] < range[0]
      ? before$2.push(group)
      : group.range[0] > range[1]
      ? after$2.push(group)
      : inside.push(group)
  }),
    [
      ...before$2,
      { annotation, lines: inside, range: [inside[0].range[0], inside[inside.length - 1].range[1]] },
      ...after$2,
    ]
}
function splitGroups(groups, lineNumber) {
  let index$4 = groups.findIndex(group$1 =>
    isGroup(group$1) && group$1.range[0] < lineNumber && lineNumber <= group$1.range[1]
  )
  if (index$4 === -1) return groups
  let group = groups[index$4], lines = splitGroups(group.lines, lineNumber), before$2 = [], after$2 = []
  return lines.forEach(lineOrGroup => {
    lineOrGroup.range[1] < lineNumber ? before$2.push(lineOrGroup) : after$2.push(lineOrGroup)
  }),
    [...groups.slice(0, index$4), { ...group, lines: before$2, range: [group.range[0], lineNumber - 1] }, {
      ...group,
      lines: after$2,
      range: [lineNumber, group.range[1]],
    }, ...groups.slice(index$4 + 1)]
}
function isGroup(item) {
  return item.annotation !== void 0
}
function renderLines({ linesOrGroups, handlers: handlers$1, inlineAnnotations, annotationStack = [] }) {
  return linesOrGroups.map(group =>
    isGroup(group)
      ? (0, import_jsx_runtime.jsx)(
        LineBlock,
        { group, handlers: handlers$1, inlineAnnotations, annotationStack },
        group.range[0],
      )
      : (0, import_jsx_runtime.jsx)(
        Line,
        { line: group, handlers: handlers$1, inlineAnnotations, annotationStack },
        group.lineNumber,
      )
  )
}
function Line({ line, handlers: handlers$1, inlineAnnotations, annotationStack = [] }) {
  let { lineNumber, totalLines, indentation } = line,
    lineAnnotations = inlineAnnotations.filter(annotation => annotation.lineNumber === lineNumber),
    lineContent = toLineContent(line.tokens, lineAnnotations),
    stack = buildLineStack(handlers$1, annotationStack),
    children$3 = renderLineContent({ content: lineContent, handlers: handlers$1, annotationStack }),
    merge$9 = { lineNumber, indentation, totalLines, _stack: stack }
  return (0, import_jsx_runtime.jsx)(InnerLine, { merge: merge$9, children: children$3 }, lineNumber)
}
function LineBlock({ group, handlers: handlers$1, inlineAnnotations, annotationStack }) {
  var _a
  let { annotation, lines } = group,
    { name } = annotation,
    Component$7 = (_a = handlers$1.find(c$3 => c$3.name === name))?.Block,
    children$3 = renderLines({
      linesOrGroups: lines,
      handlers: handlers$1,
      inlineAnnotations,
      annotationStack: [...annotationStack, annotation],
    })
  return Component$7 ? (0, import_jsx_runtime.jsx)(Component$7, { annotation, children: children$3 }) : children$3
}
function buildLineStack(handlers$1, annotationStack) {
  let stack = []
  return handlers$1.forEach(({ name, Line: Line$1, AnnotatedLine }) => {
    let annotations$2 = annotationStack.filter(a$22 => a$22.name === name)
    AnnotatedLine && annotations$2.forEach(annotation => {
      stack.push({ Component: AnnotatedLine, annotation })
    }),
      Line$1 && (annotations$2.length || stack.push({ Component: Line$1 }),
        annotations$2.forEach(annotation => {
          stack.push({ Component: Line$1, annotation })
        }))
  }),
    stack
}
const Pre = (0, import_react.forwardRef)(({ code: code$3, handlers: handlers$1 = [], ...rest }, ref) => {
  let { tokens, themeName, lang, annotations: annotations$2 } = code$3
  if (!tokens) throw Error('Missing tokens in code block. Use the `highlight` function to generate the tokens.')
  handlers$1.filter(c$3 => c$3.transform).forEach(c$3 => {
    annotations$2 = annotations$2.flatMap(a$22 => c$3.name == a$22.name ? c$3.transform(a$22) || [] : a$22)
  })
  let annotationNames = new Set(annotations$2.map(a$22 => a$22.name)),
    hs = handlers$1.filter(h$2 => !h$2.onlyIfAnnotated || annotationNames.has(h$2.name)),
    stack = buildPreStack(hs),
    merge$9 = { _stack: stack, _ref: ref }
  return (0, import_jsx_runtime.jsx)(InnerPre, {
    merge: merge$9,
    'data-theme': themeName,
    'data-lang': lang,
    ...rest,
    children: (0, import_jsx_runtime.jsx)(PreContent, { tokens, handlers: hs, annotations: annotations$2 }),
  })
})
function PreContent({ tokens, handlers: handlers$1, annotations: annotations$2 }) {
  let lines = toLines(tokens),
    blockAnnotations = annotations$2.filter(isBlockAnnotation),
    inlineAnnotations = annotations$2.filter(isInlineAnnotation),
    groups = toLineGroups(lines, blockAnnotations)
  return renderLines({ linesOrGroups: groups, handlers: handlers$1, inlineAnnotations })
}
function buildPreStack(handlers$1) {
  let noRefStack = handlers$1.map(({ Pre: Pre$1 }) => Pre$1).filter(Boolean),
    refStack = handlers$1.map(({ PreWithRef }) => PreWithRef).filter(Boolean)
  return refStack.length > 0 && refStack.unshift(AddRefIfNedded), [...noRefStack, ...refStack]
}
var GraphQLErrorBoundary = class extends import_react.Component {
  constructor(props) {
    super(props), this.state = { hasError: !1 }
  }
  static getDerivedStateFromError(error) {
    return { hasError: !0, error }
  }
  componentDidCatch(error, errorInfo) {
    console.error(`GraphQL Interactive Error:`, error, errorInfo), this.props.onError?.(error, errorInfo)
  }
  render() {
    return this.state.hasError
      ? (0, import_jsx_runtime.jsxs)(p, {
        className: `graphql-error-fallback`,
        p: `4`,
        style: {
          borderRadius: `var(--radius-2)`,
          backgroundColor: `var(--gray-2)`,
          position: `relative`,
          borderLeft: `3px solid var(--red-9)`,
        },
        children: [
          (0, import_jsx_runtime.jsx)(`pre`, {
            style: { margin: 0, whiteSpace: `pre` },
            children: (0, import_jsx_runtime.jsx)(`code`, { children: this.props.fallbackCode }),
          }),
          (0, import_jsx_runtime.jsx)(`div`, {
            style: {
              position: `absolute`,
              top: `8px`,
              right: `8px`,
              fontSize: `12px`,
              color: `var(--red-11)`,
              backgroundColor: `var(--red-a3)`,
              padding: `2px 6px`,
              borderRadius: `3px`,
            },
            title: this.state.error?.message || `Interactive features failed to load`,
            children: `Interactive mode unavailable`,
          }),
        ],
      })
      : this.props.children
  }
}
const polenUrlPath = (...segments) => {
  let basePath = templateConfig.build.base, path$1 = segments.join(`/`).replace(/\/+/g, `/`).replace(/^\//, ``)
  return basePath + path$1
}
function isOutputField$1(node$1) {
  return node$1 != null && `kind` in node$1 && node$1.kind === `OutputField`
}
function isInputField(node$1) {
  return node$1 != null && `kind` in node$1 && node$1.kind === `InputField`
}
function isArgument(node$1) {
  return node$1 != null && `kind` in node$1 && node$1.kind === `Argument`
}
function isOperation(node$1) {
  return node$1 != null && `kind` in node$1 && node$1.kind === `Operation`
}
function isVariable(node$1) {
  return node$1 != null && `kind` in node$1 && node$1.kind === `Variable`
}
function isFragment(node$1) {
  return node$1 != null && `kind` in node$1 && node$1.kind === `Fragment`
}
function isInvalidField(node$1) {
  return node$1 != null && `kind` in node$1 && node$1.kind === `InvalidField`
}
function getPopoverContent(token) {
  let semantic = token.semantic
  if (!semantic) return null
  if (isInvalidField(semantic)) {
    let availableFields = Object.keys(semantic.parentType.getFields()).sort()
    return {
      title: `Field "${semantic.fieldName}" does not exist`,
      description: `Type ${semantic.parentType.name} does not have a field named "${semantic.fieldName}".`,
      typeName: semantic.parentType.name,
      typeUrl: polenUrlPath(`reference`, semantic.parentType.name),
      fieldName: semantic.fieldName,
      invalid: !0,
      availableFields,
    }
  }
  if (isOutputField$1(semantic)) {
    let fieldType = semantic.fieldDef.type.toString()
    return {
      title: semantic.fieldDef.name,
      path: [{ name: semantic.parentType.name, url: polenUrlPath(`reference`, semantic.parentType.name) }, {
        name: semantic.fieldDef.name,
        url: polenUrlPath(`reference`, `${semantic.parentType.name}#${semantic.fieldDef.name}`),
      }],
      description: semantic.fieldDef.description || void 0,
      type: `${fieldType}`,
    }
  }
  if (isInputField(semantic)) {
    let fieldType = semantic.fieldDef.type.toString()
    return {
      title: semantic.fieldDef.name,
      path: [{ name: semantic.parentType.name, url: polenUrlPath(`reference`, semantic.parentType.name) }, {
        name: semantic.fieldDef.name,
        url: polenUrlPath(`reference`, `${semantic.parentType.name}#${semantic.fieldDef.name}`),
      }],
      description: semantic.fieldDef.description || void 0,
      type: `${fieldType}`,
    }
  }
  if (isArgument(semantic)) {
    let argType = semantic.argumentDef.type.toString()
    return {
      title: semantic.argumentDef.name,
      path: [{ name: semantic.parentType.name, url: polenUrlPath(`reference`, semantic.parentType.name) }, {
        name: semantic.parentField.name,
        url: polenUrlPath(`reference`, `${semantic.parentType.name}#${semantic.parentField.name}`),
      }, {
        name: semantic.argumentDef.name,
        url: polenUrlPath(
          `reference`,
          `${semantic.parentType.name}#${semantic.parentField.name}__${semantic.argumentDef.name}`,
        ),
      }],
      description: semantic.argumentDef.description || void 0,
      type: `${argType}`,
    }
  }
  return isOperation(semantic)
    ? {
      title: semantic.name || `${semantic.type} operation`,
      path: [{ name: semantic.name || semantic.type, url: null }],
      description: `GraphQL Operation`,
      type: semantic.type.charAt(0).toUpperCase() + semantic.type.slice(1),
    }
    : isFragment(semantic)
    ? {
      title: semantic.name,
      path: [{ name: `fragment`, url: null }, { name: semantic.name, url: null }],
      description: `GraphQL Fragment`,
      type: `Fragment on ${semantic.onType?.name || `Unknown`}`,
    }
    : `name` in semantic && semantic.name
    ? {
      title: semantic.name,
      path: [{ name: semantic.name, url: polenUrlPath(`reference`, semantic.name) }],
      description: `description` in semantic && typeof semantic.description == `string` ? semantic.description : void 0,
      type: `GraphQL Type`,
    }
    : null
}
const GraphQLTokenPopover = (
    {
      token,
      children: children$3,
      open,
      pinned,
      onTriggerHover,
      onTriggerLeave,
      onTriggerClick,
      onContentHover,
      onContentLeave,
      onClose,
    },
  ) =>
  {
    let content$2 = getPopoverContent(token)
    if (!content$2) return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children$3 })
    let popoverContent = (0, import_jsx_runtime.jsxs)(`div`, {
      style: { padding: `var(--space-1)`, minWidth: `200px`, maxWidth: `400px`, position: `relative` },
      onMouseEnter: onContentHover,
      onMouseLeave: onContentLeave,
      children: [
        (0, import_jsx_runtime.jsxs)(`div`, {
          style: { display: `flex`, justifyContent: `space-between`, alignItems: `flex-start`, marginBottom: `6px` },
          children: [
            (0, import_jsx_runtime.jsxs)(`div`, {
              style: { flex: 1 },
              children: [
                content$2.path && !content$2.invalid && (0, import_jsx_runtime.jsx)(`div`, {
                  style: { fontSize: `var(--font-size-2)`, color: `var(--gray-12)`, marginBottom: `var(--space-1)` },
                  children: content$2.path.map((segment, index$4) =>
                    (0, import_jsx_runtime.jsxs)(`span`, {
                      children: [
                        index$4 > 0
                        && (0, import_jsx_runtime.jsx)(`span`, {
                          style: { color: `var(--gray-11)`, margin: `0 var(--space-1)` },
                          children: `.`,
                        }),
                        segment.url
                          ? (0, import_jsx_runtime.jsx)(`a`, {
                            href: segment.url,
                            style: { color: `#0969da`, textDecoration: `none`, cursor: `pointer` },
                            onMouseEnter: e$26 => {
                              e$26.currentTarget.style.textDecoration = `underline`
                            },
                            onMouseLeave: e$26 => {
                              e$26.currentTarget.style.textDecoration = `none`
                            },
                            onClick: e$26 => {
                              e$26.preventDefault(), segment.url && (window.location.href = segment.url)
                            },
                            children: segment.name,
                          })
                          : (0, import_jsx_runtime.jsx)(`span`, {
                            style: { color: `#24292e` },
                            children: segment.name,
                          }),
                      ],
                    }, index$4)
                  ),
                }),
                content$2.type && !content$2.invalid
                && (0, import_jsx_runtime.jsx)(`div`, {
                  style: { fontSize: `12px`, color: `#6a737d`, fontFamily: `monospace`, opacity: .8 },
                  children: content$2.type,
                }),
                content$2.invalid && (0, import_jsx_runtime.jsxs)(`div`, {
                  style: { fontSize: `14px`, color: `#d73a49`, marginBottom: `4px` },
                  children: [
                    (0, import_jsx_runtime.jsx)(`span`, { style: { fontWeight: `bold` }, children: `Error:` }),
                    ` Type`,
                    ` `,
                    (0, import_jsx_runtime.jsx)(`a`, {
                      href: content$2.typeUrl,
                      style: { color: `#0969da`, textDecoration: `none`, cursor: `pointer` },
                      onMouseEnter: e$26 => {
                        e$26.currentTarget.style.textDecoration = `underline`
                      },
                      onMouseLeave: e$26 => {
                        e$26.currentTarget.style.textDecoration = `none`
                      },
                      onClick: e$26 => {
                        e$26.preventDefault(), content$2.typeUrl && (window.location.href = content$2.typeUrl)
                      },
                      children: content$2.typeName,
                    }),
                    ` `,
                    `does not have a field named "`,
                    content$2.fieldName,
                    `".`,
                  ],
                }),
              ],
            }),
            pinned && !content$2.invalid
            && (0, import_jsx_runtime.jsx)(o$3, {
              variant: `ghost`,
              size: `1`,
              onClick: onClose,
              style: { marginLeft: `8px`, padding: `2px`, minWidth: `auto`, height: `auto` },
              children: (0, import_jsx_runtime.jsx)(Cross1Icon, { width: `12`, height: `12` }),
            }),
          ],
        }),
        content$2.description && !content$2.invalid
        && (0, import_jsx_runtime.jsx)(`div`, {
          style: { fontSize: `13px`, color: `#24292e`, lineHeight: `1.4`, opacity: .9 },
          children: content$2.description,
        }),
        content$2.invalid && content$2.availableFields && (0, import_jsx_runtime.jsxs)(`div`, {
          style: {
            marginTop: `8px`,
            backgroundColor: `#f6f8fa`,
            border: `1px solid #e1e4e8`,
            borderRadius: `4px`,
            fontSize: `12px`,
            fontFamily: `monospace`,
            lineHeight: `1.5`,
            overflow: `hidden`,
          },
          children: [
            (0, import_jsx_runtime.jsxs)(`div`, {
              style: { padding: `10px 10px 0 10px` },
              children: [
                (0, import_jsx_runtime.jsx)(`span`, { style: { color: `#d73a49` }, children: `type` }),
                ` `,
                (0, import_jsx_runtime.jsx)(`a`, {
                  href: content$2.typeUrl,
                  style: { color: `#005cc5`, fontWeight: 500, textDecoration: `none` },
                  onMouseEnter: e$26 => {
                    e$26.currentTarget.style.textDecoration = `underline`
                  },
                  onMouseLeave: e$26 => {
                    e$26.currentTarget.style.textDecoration = `none`
                  },
                  children: content$2.typeName,
                }),
                ` `,
                (0, import_jsx_runtime.jsx)(`span`, { style: { color: `#24292e` }, children: `{` }),
              ],
            }),
            (0, import_jsx_runtime.jsx)(`div`, {
              style: { maxHeight: `200px`, overflowY: `auto`, padding: `0 10px`, marginRight: `2px` },
              children: (() => {
                let invalidFieldName = content$2.fieldName || ``,
                  allFields = [...content$2.availableFields],
                  insertIndex = allFields.findIndex(f$14 => f$14.localeCompare(invalidFieldName) > 0),
                  fieldsWithInvalid = insertIndex === -1
                    ? [...allFields, invalidFieldName]
                    : [...allFields.slice(0, insertIndex), invalidFieldName, ...allFields.slice(insertIndex)]
                return fieldsWithInvalid.map(field => {
                  let isInvalidField$1 = field === invalidFieldName
                  return (0, import_jsx_runtime.jsxs)(`div`, {
                    style: {
                      paddingLeft: isInvalidField$1 ? `26px` : `16px`,
                      color: isInvalidField$1 ? `#d73a49` : `#6f42c1`,
                      display: `flex`,
                      alignItems: `center`,
                      backgroundColor: isInvalidField$1 ? `var(--red-a2)` : `transparent`,
                      marginLeft: isInvalidField$1 ? `-10px` : `0`,
                      marginRight: isInvalidField$1 ? `-10px` : `0`,
                      paddingTop: isInvalidField$1 ? `2px` : `0`,
                      paddingBottom: isInvalidField$1 ? `2px` : `0`,
                    },
                    children: [
                      isInvalidField$1
                        ? (0, import_jsx_runtime.jsx)(`span`, {
                          style: { textDecoration: `line-through` },
                          children: field,
                        })
                        : (0, import_jsx_runtime.jsx)(`a`, {
                          href: polenUrlPath(`reference`, `${content$2.typeName}#${field}`),
                          style: { color: `#6f42c1`, textDecoration: `none` },
                          onMouseEnter: e$26 => {
                            e$26.currentTarget.style.textDecoration = `underline`
                          },
                          onMouseLeave: e$26 => {
                            e$26.currentTarget.style.textDecoration = `none`
                          },
                          children: field,
                        }),
                      isInvalidField$1
                      && (0, import_jsx_runtime.jsx)(`span`, {
                        style: {
                          marginLeft: `12px`,
                          color: `#d73a49`,
                          fontSize: `11px`,
                          display: `flex`,
                          alignItems: `center`,
                          gap: `4px`,
                        },
                        children: ` No such field`,
                      }),
                    ],
                  }, field)
                })
              })(),
            }),
            (0, import_jsx_runtime.jsx)(`div`, {
              style: { padding: `0 10px 10px 10px`, color: `#24292e` },
              children: `}`,
            }),
          ],
        }),
      ],
    })
    return (0, import_jsx_runtime.jsxs)(P$3, {
      open,
      children: [
        (0, import_jsx_runtime.jsx)(s$1, {
          children: (0, import_jsx_runtime.jsx)(`span`, {
            style: { cursor: token.polen.isInteractive() ? `pointer` : `default` },
            onMouseEnter: onTriggerHover,
            onMouseLeave: onTriggerLeave,
            onClick: onTriggerClick,
            children: children$3,
          }),
        }),
        (0, import_jsx_runtime.jsx)(i$4, {
          side: `top`,
          align: `start`,
          sideOffset: 4,
          style: {
            padding: `var(--space-2)`,
            background: content$2.invalid ? `var(--red-1)` : `var(--color-background)`,
            border: content$2.invalid ? `2px solid var(--red-7)` : `1px solid var(--gray-6)`,
            borderRadius: `var(--radius-1)`,
            boxShadow: `none`,
            zIndex: 1e3,
            maxWidth: `450px`,
          },
          children: popoverContent,
        }),
      ],
    })
  },
  usePopoverState = (options$2 = {}) => {
    let { showDelay = 300, hideDelay = 200, allowMultiplePins = !0 } = options$2,
      [hoveredId, setHoveredId] = import_react.useState(null),
      [pinnedIds, setPinnedIds] = import_react.useState(new Set()),
      [pendingShowId, setPendingShowId] = import_react.useState(null),
      [pendingHideId, setPendingHideId] = import_react.useState(null),
      showTimerRef = import_react.useRef(null),
      hideTimerRef = import_react.useRef(null),
      clearTimers = import_react.useCallback(() => {
        showTimerRef.current && (clearTimeout(showTimerRef.current), showTimerRef.current = null),
          hideTimerRef.current && (clearTimeout(hideTimerRef.current), hideTimerRef.current = null),
          setPendingShowId(null),
          setPendingHideId(null)
      }, []),
      isOpen = import_react.useCallback(id$2 => hoveredId === id$2 || pinnedIds.has(id$2), [hoveredId, pinnedIds]),
      isPinned = import_react.useCallback(id$2 => pinnedIds.has(id$2), [pinnedIds]),
      onHoverStart = import_react.useCallback(id$2 => {
        if (!pinnedIds.has(id$2)) {
          if (pendingHideId === id$2) {
            clearTimeout(hideTimerRef.current), hideTimerRef.current = null, setPendingHideId(null)
            return
          }
          clearTimers(),
            setPendingShowId(id$2),
            showTimerRef.current = setTimeout(() => {
              setHoveredId(id$2), setPendingShowId(null), showTimerRef.current = null
            }, showDelay)
        }
      }, [pinnedIds, pendingHideId, clearTimers, showDelay]),
      onHoverEnd = import_react.useCallback(id$2 => {
        if (!pinnedIds.has(id$2)) {
          if (pendingShowId === id$2) {
            clearTimeout(showTimerRef.current), showTimerRef.current = null, setPendingShowId(null)
            return
          }
          hoveredId === id$2 && (setPendingHideId(id$2),
            hideTimerRef.current = setTimeout(() => {
              setHoveredId(null), setPendingHideId(null), hideTimerRef.current = null
            }, hideDelay))
        }
      }, [pinnedIds, pendingShowId, hoveredId, hideDelay]),
      onPopoverHover = import_react.useCallback(id$2 => {
        pendingHideId === id$2
          && (clearTimeout(hideTimerRef.current), hideTimerRef.current = null, setPendingHideId(null))
      }, [pendingHideId]),
      onPopoverLeave = import_react.useCallback(id$2 => {
        pinnedIds.has(id$2) || hoveredId === id$2 && (setPendingHideId(id$2),
              hideTimerRef.current = setTimeout(() => {
                setHoveredId(null), setPendingHideId(null), hideTimerRef.current = null
              }, hideDelay))
      }, [pinnedIds, hoveredId, hideDelay]),
      onTogglePin = import_react.useCallback(id$2 => {
        setPinnedIds(prev => {
          let next = new Set(prev)
          return next.has(id$2)
            ? next.delete(id$2)
            : (allowMultiplePins || next.clear(),
              next.add(id$2),
              hoveredId === id$2 && setHoveredId(null),
              pendingShowId === id$2
              && (clearTimeout(showTimerRef.current), showTimerRef.current = null, setPendingShowId(null)),
              pendingHideId === id$2
              && (clearTimeout(hideTimerRef.current), hideTimerRef.current = null, setPendingHideId(null))),
            next
        })
      }, [allowMultiplePins, hoveredId, pendingShowId, pendingHideId]),
      unpin = import_react.useCallback(id$2 => {
        setPinnedIds(prev => {
          let next = new Set(prev)
          return next.delete(id$2), next
        })
      }, []),
      unpinAll = import_react.useCallback(() => {
        setPinnedIds(new Set())
      }, [])
    return import_react.useEffect(() => () => {
      showTimerRef.current && clearTimeout(showTimerRef.current),
        hideTimerRef.current && clearTimeout(hideTimerRef.current)
    }, []),
      import_react.useEffect(() => {
        clearTimers()
      }, [showDelay, hideDelay, clearTimers]),
      { isOpen, isPinned, onHoverStart, onHoverEnd, onTogglePin, onPopoverHover, onPopoverLeave, unpin, unpinAll }
  }
var grammar_default = `/assets/grammar-BB7cJP9w.wasm`,
  __defProp = Object.defineProperty,
  __name = (target, value$2) => __defProp(target, `name`, { value: value$2, configurable: !0 }),
  SIZE_OF_SHORT = 2,
  SIZE_OF_INT = 4,
  SIZE_OF_CURSOR = 4 * SIZE_OF_INT,
  SIZE_OF_NODE = 5 * SIZE_OF_INT,
  SIZE_OF_POINT = 2 * SIZE_OF_INT,
  SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT,
  ZERO_POINT = { row: 0, column: 0 },
  INTERNAL = Symbol(`INTERNAL`)
function assertInternal(x$2) {
  if (x$2 !== INTERNAL) throw Error(`Illegal constructor`)
}
__name(assertInternal, `assertInternal`)
function isPoint(point$3) {
  return !!point$3 && typeof point$3.row == `number` && typeof point$3.column == `number`
}
__name(isPoint, `isPoint`)
function setModule(module2) {
  C = module2
}
__name(setModule, `setModule`)
var C,
  LookaheadIterator = class {
    static {
      __name(this, `LookaheadIterator`)
    }
    0 = 0
    language
    constructor(internal, address, language) {
      assertInternal(internal), this[0] = address, this.language = language
    }
    get currentTypeId() {
      return C._ts_lookahead_iterator_current_symbol(this[0])
    }
    get currentType() {
      return this.language.types[this.currentTypeId] || `ERROR`
    }
    delete() {
      C._ts_lookahead_iterator_delete(this[0]), this[0] = 0
    }
    reset(language, stateId) {
      return C._ts_lookahead_iterator_reset(this[0], language[0], stateId) ? (this.language = language, !0) : !1
    }
    resetState(stateId) {
      return !!C._ts_lookahead_iterator_reset_state(this[0], stateId)
    }
    [Symbol.iterator]() {
      return {
        next: __name(
          () =>
            C._ts_lookahead_iterator_next(this[0]) ? { done: !1, value: this.currentType } : { done: !0, value: `` },
          `next`,
        ),
      }
    }
  }
function getText(tree, startIndex, endIndex, startPosition) {
  let length$1 = endIndex - startIndex, result = tree.textCallback(startIndex, startPosition)
  if (result) {
    for (startIndex += result.length; startIndex < endIndex;) {
      let string$5 = tree.textCallback(startIndex, startPosition)
      if (string$5 && string$5.length > 0) startIndex += string$5.length, result += string$5
      else break
    }
    startIndex > endIndex && (result = result.slice(0, length$1))
  }
  return result ?? ``
}
__name(getText, `getText`)
var Tree = class _Tree {
    static {
      __name(this, `Tree`)
    }
    0 = 0
    textCallback
    language
    constructor(internal, address, language, textCallback) {
      assertInternal(internal), this[0] = address, this.language = language, this.textCallback = textCallback
    }
    copy() {
      let address = C._ts_tree_copy(this[0])
      return new _Tree(INTERNAL, address, this.language, this.textCallback)
    }
    delete() {
      C._ts_tree_delete(this[0]), this[0] = 0
    }
    get rootNode() {
      return C._ts_tree_root_node_wasm(this[0]), unmarshalNode(this)
    }
    rootNodeWithOffset(offsetBytes, offsetExtent) {
      let address = TRANSFER_BUFFER + SIZE_OF_NODE
      return C.setValue(address, offsetBytes, `i32`),
        marshalPoint(address + SIZE_OF_INT, offsetExtent),
        C._ts_tree_root_node_with_offset_wasm(this[0]),
        unmarshalNode(this)
    }
    edit(edit) {
      marshalEdit(edit), C._ts_tree_edit_wasm(this[0])
    }
    walk() {
      return this.rootNode.walk()
    }
    getChangedRanges(other) {
      if (!(other instanceof _Tree)) throw TypeError(`Argument must be a Tree`)
      C._ts_tree_get_changed_ranges_wasm(this[0], other[0])
      let count$2 = C.getValue(TRANSFER_BUFFER, `i32`),
        buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        result = Array(count$2)
      if (count$2 > 0) {
        let address = buffer
        for (let i2 = 0; i2 < count$2; i2++) result[i2] = unmarshalRange(address), address += SIZE_OF_RANGE
        C._free(buffer)
      }
      return result
    }
    getIncludedRanges() {
      C._ts_tree_included_ranges_wasm(this[0])
      let count$2 = C.getValue(TRANSFER_BUFFER, `i32`),
        buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        result = Array(count$2)
      if (count$2 > 0) {
        let address = buffer
        for (let i2 = 0; i2 < count$2; i2++) result[i2] = unmarshalRange(address), address += SIZE_OF_RANGE
        C._free(buffer)
      }
      return result
    }
  },
  TreeCursor = class _TreeCursor {
    static {
      __name(this, `TreeCursor`)
    }
    0 = 0
    1 = 0
    2 = 0
    3 = 0
    tree
    constructor(internal, tree) {
      assertInternal(internal), this.tree = tree, unmarshalTreeCursor(this)
    }
    copy() {
      let copy$2 = new _TreeCursor(INTERNAL, this.tree)
      return C._ts_tree_cursor_copy_wasm(this.tree[0]), unmarshalTreeCursor(copy$2), copy$2
    }
    delete() {
      marshalTreeCursor(this), C._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0
    }
    get currentNode() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_node_wasm(this.tree[0]), unmarshalNode(this.tree)
    }
    get currentFieldId() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_field_id_wasm(this.tree[0])
    }
    get currentFieldName() {
      return this.tree.language.fields[this.currentFieldId]
    }
    get currentDepth() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_depth_wasm(this.tree[0])
    }
    get currentDescendantIndex() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_descendant_index_wasm(this.tree[0])
    }
    get nodeType() {
      return this.tree.language.types[this.nodeTypeId] || `ERROR`
    }
    get nodeTypeId() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0])
    }
    get nodeStateId() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_node_state_id_wasm(this.tree[0])
    }
    get nodeId() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_node_id_wasm(this.tree[0])
    }
    get nodeIsNamed() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1
    }
    get nodeIsMissing() {
      return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1
    }
    get nodeText() {
      marshalTreeCursor(this)
      let startIndex = C._ts_tree_cursor_start_index_wasm(this.tree[0]),
        endIndex = C._ts_tree_cursor_end_index_wasm(this.tree[0])
      C._ts_tree_cursor_start_position_wasm(this.tree[0])
      let startPosition = unmarshalPoint(TRANSFER_BUFFER)
      return getText(this.tree, startIndex, endIndex, startPosition)
    }
    get startPosition() {
      return marshalTreeCursor(this),
        C._ts_tree_cursor_start_position_wasm(this.tree[0]),
        unmarshalPoint(TRANSFER_BUFFER)
    }
    get endPosition() {
      return marshalTreeCursor(this), C._ts_tree_cursor_end_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER)
    }
    get startIndex() {
      return marshalTreeCursor(this), C._ts_tree_cursor_start_index_wasm(this.tree[0])
    }
    get endIndex() {
      return marshalTreeCursor(this), C._ts_tree_cursor_end_index_wasm(this.tree[0])
    }
    gotoFirstChild() {
      marshalTreeCursor(this)
      let result = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0])
      return unmarshalTreeCursor(this), result === 1
    }
    gotoLastChild() {
      marshalTreeCursor(this)
      let result = C._ts_tree_cursor_goto_last_child_wasm(this.tree[0])
      return unmarshalTreeCursor(this), result === 1
    }
    gotoParent() {
      marshalTreeCursor(this)
      let result = C._ts_tree_cursor_goto_parent_wasm(this.tree[0])
      return unmarshalTreeCursor(this), result === 1
    }
    gotoNextSibling() {
      marshalTreeCursor(this)
      let result = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0])
      return unmarshalTreeCursor(this), result === 1
    }
    gotoPreviousSibling() {
      marshalTreeCursor(this)
      let result = C._ts_tree_cursor_goto_previous_sibling_wasm(this.tree[0])
      return unmarshalTreeCursor(this), result === 1
    }
    gotoDescendant(goalDescendantIndex) {
      marshalTreeCursor(this),
        C._ts_tree_cursor_goto_descendant_wasm(this.tree[0], goalDescendantIndex),
        unmarshalTreeCursor(this)
    }
    gotoFirstChildForIndex(goalIndex) {
      marshalTreeCursor(this), C.setValue(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalIndex, `i32`)
      let result = C._ts_tree_cursor_goto_first_child_for_index_wasm(this.tree[0])
      return unmarshalTreeCursor(this), result === 1
    }
    gotoFirstChildForPosition(goalPosition) {
      marshalTreeCursor(this), marshalPoint(TRANSFER_BUFFER + SIZE_OF_CURSOR, goalPosition)
      let result = C._ts_tree_cursor_goto_first_child_for_position_wasm(this.tree[0])
      return unmarshalTreeCursor(this), result === 1
    }
    reset(node$1) {
      marshalNode(node$1),
        marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE),
        C._ts_tree_cursor_reset_wasm(this.tree[0]),
        unmarshalTreeCursor(this)
    }
    resetTo(cursor) {
      marshalTreeCursor(this, TRANSFER_BUFFER),
        marshalTreeCursor(cursor, TRANSFER_BUFFER + SIZE_OF_CURSOR),
        C._ts_tree_cursor_reset_to_wasm(this.tree[0], cursor.tree[0]),
        unmarshalTreeCursor(this)
    }
  },
  Node$1 = class {
    static {
      __name(this, `Node`)
    }
    0 = 0
    _children
    _namedChildren
    constructor(internal, { id: id$2, tree, startIndex, startPosition, other }) {
      assertInternal(internal),
        this[0] = other,
        this.id = id$2,
        this.tree = tree,
        this.startIndex = startIndex,
        this.startPosition = startPosition
    }
    id
    startIndex
    startPosition
    tree
    get typeId() {
      return marshalNode(this), C._ts_node_symbol_wasm(this.tree[0])
    }
    get grammarId() {
      return marshalNode(this), C._ts_node_grammar_symbol_wasm(this.tree[0])
    }
    get type() {
      return this.tree.language.types[this.typeId] || `ERROR`
    }
    get grammarType() {
      return this.tree.language.types[this.grammarId] || `ERROR`
    }
    get isNamed() {
      return marshalNode(this), C._ts_node_is_named_wasm(this.tree[0]) === 1
    }
    get isExtra() {
      return marshalNode(this), C._ts_node_is_extra_wasm(this.tree[0]) === 1
    }
    get isError() {
      return marshalNode(this), C._ts_node_is_error_wasm(this.tree[0]) === 1
    }
    get isMissing() {
      return marshalNode(this), C._ts_node_is_missing_wasm(this.tree[0]) === 1
    }
    get hasChanges() {
      return marshalNode(this), C._ts_node_has_changes_wasm(this.tree[0]) === 1
    }
    get hasError() {
      return marshalNode(this), C._ts_node_has_error_wasm(this.tree[0]) === 1
    }
    get endIndex() {
      return marshalNode(this), C._ts_node_end_index_wasm(this.tree[0])
    }
    get endPosition() {
      return marshalNode(this), C._ts_node_end_point_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER)
    }
    get text() {
      return getText(this.tree, this.startIndex, this.endIndex, this.startPosition)
    }
    get parseState() {
      return marshalNode(this), C._ts_node_parse_state_wasm(this.tree[0])
    }
    get nextParseState() {
      return marshalNode(this), C._ts_node_next_parse_state_wasm(this.tree[0])
    }
    equals(other) {
      return this.tree === other.tree && this.id === other.id
    }
    child(index$4) {
      return marshalNode(this), C._ts_node_child_wasm(this.tree[0], index$4), unmarshalNode(this.tree)
    }
    namedChild(index$4) {
      return marshalNode(this), C._ts_node_named_child_wasm(this.tree[0], index$4), unmarshalNode(this.tree)
    }
    childForFieldId(fieldId) {
      return marshalNode(this), C._ts_node_child_by_field_id_wasm(this.tree[0], fieldId), unmarshalNode(this.tree)
    }
    childForFieldName(fieldName) {
      let fieldId = this.tree.language.fields.indexOf(fieldName)
      return fieldId === -1 ? null : this.childForFieldId(fieldId)
    }
    fieldNameForChild(index$4) {
      marshalNode(this)
      let address = C._ts_node_field_name_for_child_wasm(this.tree[0], index$4)
      return address ? C.AsciiToString(address) : null
    }
    fieldNameForNamedChild(index$4) {
      marshalNode(this)
      let address = C._ts_node_field_name_for_named_child_wasm(this.tree[0], index$4)
      return address ? C.AsciiToString(address) : null
    }
    childrenForFieldName(fieldName) {
      let fieldId = this.tree.language.fields.indexOf(fieldName)
      return fieldId !== -1 && fieldId !== 0 ? this.childrenForFieldId(fieldId) : []
    }
    childrenForFieldId(fieldId) {
      marshalNode(this), C._ts_node_children_by_field_id_wasm(this.tree[0], fieldId)
      let count$2 = C.getValue(TRANSFER_BUFFER, `i32`),
        buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        result = Array(count$2)
      if (count$2 > 0) {
        let address = buffer
        for (let i2 = 0; i2 < count$2; i2++) result[i2] = unmarshalNode(this.tree, address), address += SIZE_OF_NODE
        C._free(buffer)
      }
      return result
    }
    firstChildForIndex(index$4) {
      marshalNode(this)
      let address = TRANSFER_BUFFER + SIZE_OF_NODE
      return C.setValue(address, index$4, `i32`),
        C._ts_node_first_child_for_byte_wasm(this.tree[0]),
        unmarshalNode(this.tree)
    }
    firstNamedChildForIndex(index$4) {
      marshalNode(this)
      let address = TRANSFER_BUFFER + SIZE_OF_NODE
      return C.setValue(address, index$4, `i32`),
        C._ts_node_first_named_child_for_byte_wasm(this.tree[0]),
        unmarshalNode(this.tree)
    }
    get childCount() {
      return marshalNode(this), C._ts_node_child_count_wasm(this.tree[0])
    }
    get namedChildCount() {
      return marshalNode(this), C._ts_node_named_child_count_wasm(this.tree[0])
    }
    get firstChild() {
      return this.child(0)
    }
    get firstNamedChild() {
      return this.namedChild(0)
    }
    get lastChild() {
      return this.child(this.childCount - 1)
    }
    get lastNamedChild() {
      return this.namedChild(this.namedChildCount - 1)
    }
    get children() {
      if (!this._children) {
        marshalNode(this), C._ts_node_children_wasm(this.tree[0])
        let count$2 = C.getValue(TRANSFER_BUFFER, `i32`), buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`)
        if (this._children = Array(count$2), count$2 > 0) {
          let address = buffer
          for (let i2 = 0; i2 < count$2; i2++) {
            this._children[i2] = unmarshalNode(this.tree, address), address += SIZE_OF_NODE
          }
          C._free(buffer)
        }
      }
      return this._children
    }
    get namedChildren() {
      if (!this._namedChildren) {
        marshalNode(this), C._ts_node_named_children_wasm(this.tree[0])
        let count$2 = C.getValue(TRANSFER_BUFFER, `i32`), buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`)
        if (this._namedChildren = Array(count$2), count$2 > 0) {
          let address = buffer
          for (let i2 = 0; i2 < count$2; i2++) {
            this._namedChildren[i2] = unmarshalNode(this.tree, address), address += SIZE_OF_NODE
          }
          C._free(buffer)
        }
      }
      return this._namedChildren
    }
    descendantsOfType(types, startPosition = ZERO_POINT, endPosition = ZERO_POINT) {
      Array.isArray(types) || (types = [types])
      let symbols = [], typesBySymbol = this.tree.language.types
      for (let node_type of types) node_type == `ERROR` && symbols.push(65535)
      for (let i2 = 0, n$19 = typesBySymbol.length; i2 < n$19; i2++) {
        types.includes(typesBySymbol[i2]) && symbols.push(i2)
      }
      let symbolsAddress = C._malloc(SIZE_OF_INT * symbols.length)
      for (let i2 = 0, n$19 = symbols.length; i2 < n$19; i2++) {
        C.setValue(symbolsAddress + i2 * SIZE_OF_INT, symbols[i2], `i32`)
      }
      marshalNode(this),
        C._ts_node_descendants_of_type_wasm(
          this.tree[0],
          symbolsAddress,
          symbols.length,
          startPosition.row,
          startPosition.column,
          endPosition.row,
          endPosition.column,
        )
      let descendantCount = C.getValue(TRANSFER_BUFFER, `i32`),
        descendantAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        result = Array(descendantCount)
      if (descendantCount > 0) {
        let address = descendantAddress
        for (let i2 = 0; i2 < descendantCount; i2++) {
          result[i2] = unmarshalNode(this.tree, address), address += SIZE_OF_NODE
        }
      }
      return C._free(descendantAddress), C._free(symbolsAddress), result
    }
    get nextSibling() {
      return marshalNode(this), C._ts_node_next_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
    }
    get previousSibling() {
      return marshalNode(this), C._ts_node_prev_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
    }
    get nextNamedSibling() {
      return marshalNode(this), C._ts_node_next_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
    }
    get previousNamedSibling() {
      return marshalNode(this), C._ts_node_prev_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree)
    }
    get descendantCount() {
      return marshalNode(this), C._ts_node_descendant_count_wasm(this.tree[0])
    }
    get parent() {
      return marshalNode(this), C._ts_node_parent_wasm(this.tree[0]), unmarshalNode(this.tree)
    }
    childWithDescendant(descendant) {
      return marshalNode(this),
        marshalNode(descendant, 1),
        C._ts_node_child_with_descendant_wasm(this.tree[0]),
        unmarshalNode(this.tree)
    }
    descendantForIndex(start2, end$2 = start2) {
      if (typeof start2 != `number` || typeof end$2 != `number`) throw Error(`Arguments must be numbers`)
      marshalNode(this)
      let address = TRANSFER_BUFFER + SIZE_OF_NODE
      return C.setValue(address, start2, `i32`),
        C.setValue(address + SIZE_OF_INT, end$2, `i32`),
        C._ts_node_descendant_for_index_wasm(this.tree[0]),
        unmarshalNode(this.tree)
    }
    namedDescendantForIndex(start2, end$2 = start2) {
      if (typeof start2 != `number` || typeof end$2 != `number`) throw Error(`Arguments must be numbers`)
      marshalNode(this)
      let address = TRANSFER_BUFFER + SIZE_OF_NODE
      return C.setValue(address, start2, `i32`),
        C.setValue(address + SIZE_OF_INT, end$2, `i32`),
        C._ts_node_named_descendant_for_index_wasm(this.tree[0]),
        unmarshalNode(this.tree)
    }
    descendantForPosition(start2, end$2 = start2) {
      if (!isPoint(start2) || !isPoint(end$2)) throw Error(`Arguments must be {row, column} objects`)
      marshalNode(this)
      let address = TRANSFER_BUFFER + SIZE_OF_NODE
      return marshalPoint(address, start2),
        marshalPoint(address + SIZE_OF_POINT, end$2),
        C._ts_node_descendant_for_position_wasm(this.tree[0]),
        unmarshalNode(this.tree)
    }
    namedDescendantForPosition(start2, end$2 = start2) {
      if (!isPoint(start2) || !isPoint(end$2)) throw Error(`Arguments must be {row, column} objects`)
      marshalNode(this)
      let address = TRANSFER_BUFFER + SIZE_OF_NODE
      return marshalPoint(address, start2),
        marshalPoint(address + SIZE_OF_POINT, end$2),
        C._ts_node_named_descendant_for_position_wasm(this.tree[0]),
        unmarshalNode(this.tree)
    }
    walk() {
      return marshalNode(this), C._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(INTERNAL, this.tree)
    }
    edit(edit) {
      if (this.startIndex >= edit.oldEndIndex) {
        this.startIndex = edit.newEndIndex + (this.startIndex - edit.oldEndIndex)
        let subbedPointRow, subbedPointColumn
        this.startPosition.row > edit.oldEndPosition.row
          ? (subbedPointRow = this.startPosition.row - edit.oldEndPosition.row,
            subbedPointColumn = this.startPosition.column)
          : (subbedPointRow = 0,
            subbedPointColumn = this.startPosition.column,
            this.startPosition.column >= edit.oldEndPosition.column
            && (subbedPointColumn = this.startPosition.column - edit.oldEndPosition.column)),
          subbedPointRow > 0
            ? (this.startPosition.row += subbedPointRow, this.startPosition.column = subbedPointColumn)
            : this.startPosition.column += subbedPointColumn
      } else {this.startIndex > edit.startIndex
          && (this.startIndex = edit.newEndIndex,
            this.startPosition.row = edit.newEndPosition.row,
            this.startPosition.column = edit.newEndPosition.column)}
    }
    toString() {
      marshalNode(this)
      let address = C._ts_node_to_string_wasm(this.tree[0]), result = C.AsciiToString(address)
      return C._free(address), result
    }
  }
function unmarshalCaptures(query, tree, address, patternIndex, result) {
  for (let i2 = 0, n$19 = result.length; i2 < n$19; i2++) {
    let captureIndex = C.getValue(address, `i32`)
    address += SIZE_OF_INT
    let node$1 = unmarshalNode(tree, address)
    address += SIZE_OF_NODE, result[i2] = { patternIndex, name: query.captureNames[captureIndex], node: node$1 }
  }
  return address
}
__name(unmarshalCaptures, `unmarshalCaptures`)
function marshalNode(node$1, index$4 = 0) {
  let address = TRANSFER_BUFFER + index$4 * SIZE_OF_NODE
  C.setValue(address, node$1.id, `i32`),
    address += SIZE_OF_INT,
    C.setValue(address, node$1.startIndex, `i32`),
    address += SIZE_OF_INT,
    C.setValue(address, node$1.startPosition.row, `i32`),
    address += SIZE_OF_INT,
    C.setValue(address, node$1.startPosition.column, `i32`),
    address += SIZE_OF_INT,
    C.setValue(address, node$1[0], `i32`)
}
__name(marshalNode, `marshalNode`)
function unmarshalNode(tree, address = TRANSFER_BUFFER) {
  let id$2 = C.getValue(address, `i32`)
  if (address += SIZE_OF_INT, id$2 === 0) return null
  let index$4 = C.getValue(address, `i32`)
  address += SIZE_OF_INT
  let row = C.getValue(address, `i32`)
  address += SIZE_OF_INT
  let column = C.getValue(address, `i32`)
  address += SIZE_OF_INT
  let other = C.getValue(address, `i32`),
    result = new Node$1(INTERNAL, { id: id$2, tree, startIndex: index$4, startPosition: { row, column }, other })
  return result
}
__name(unmarshalNode, `unmarshalNode`)
function marshalTreeCursor(cursor, address = TRANSFER_BUFFER) {
  C.setValue(address + 0 * SIZE_OF_INT, cursor[0], `i32`),
    C.setValue(address + 1 * SIZE_OF_INT, cursor[1], `i32`),
    C.setValue(address + 2 * SIZE_OF_INT, cursor[2], `i32`),
    C.setValue(address + 3 * SIZE_OF_INT, cursor[3], `i32`)
}
__name(marshalTreeCursor, `marshalTreeCursor`)
function unmarshalTreeCursor(cursor) {
  cursor[0] = C.getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, `i32`),
    cursor[1] = C.getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, `i32`),
    cursor[2] = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, `i32`),
    cursor[3] = C.getValue(TRANSFER_BUFFER + 3 * SIZE_OF_INT, `i32`)
}
__name(unmarshalTreeCursor, `unmarshalTreeCursor`)
function marshalPoint(address, point$3) {
  C.setValue(address, point$3.row, `i32`), C.setValue(address + SIZE_OF_INT, point$3.column, `i32`)
}
__name(marshalPoint, `marshalPoint`)
function unmarshalPoint(address) {
  let result = { row: C.getValue(address, `i32`) >>> 0, column: C.getValue(address + SIZE_OF_INT, `i32`) >>> 0 }
  return result
}
__name(unmarshalPoint, `unmarshalPoint`)
function marshalRange(address, range) {
  marshalPoint(address, range.startPosition),
    address += SIZE_OF_POINT,
    marshalPoint(address, range.endPosition),
    address += SIZE_OF_POINT,
    C.setValue(address, range.startIndex, `i32`),
    address += SIZE_OF_INT,
    C.setValue(address, range.endIndex, `i32`),
    address += SIZE_OF_INT
}
__name(marshalRange, `marshalRange`)
function unmarshalRange(address) {
  let result = {}
  return result.startPosition = unmarshalPoint(address),
    address += SIZE_OF_POINT,
    result.endPosition = unmarshalPoint(address),
    address += SIZE_OF_POINT,
    result.startIndex = C.getValue(address, `i32`) >>> 0,
    address += SIZE_OF_INT,
    result.endIndex = C.getValue(address, `i32`) >>> 0,
    result
}
__name(unmarshalRange, `unmarshalRange`)
function marshalEdit(edit, address = TRANSFER_BUFFER) {
  marshalPoint(address, edit.startPosition),
    address += SIZE_OF_POINT,
    marshalPoint(address, edit.oldEndPosition),
    address += SIZE_OF_POINT,
    marshalPoint(address, edit.newEndPosition),
    address += SIZE_OF_POINT,
    C.setValue(address, edit.startIndex, `i32`),
    address += SIZE_OF_INT,
    C.setValue(address, edit.oldEndIndex, `i32`),
    address += SIZE_OF_INT,
    C.setValue(address, edit.newEndIndex, `i32`),
    address += SIZE_OF_INT
}
__name(marshalEdit, `marshalEdit`)
function unmarshalLanguageMetadata(address) {
  let result = {}
  return result.major_version = C.getValue(address, `i32`),
    address += SIZE_OF_INT,
    result.minor_version = C.getValue(address, `i32`),
    address += SIZE_OF_INT,
    result.field_count = C.getValue(address, `i32`),
    result
}
__name(unmarshalLanguageMetadata, `unmarshalLanguageMetadata`)
var PREDICATE_STEP_TYPE_CAPTURE = 1,
  PREDICATE_STEP_TYPE_STRING = 2,
  QUERY_WORD_REGEX = /[\w-]+/g,
  CaptureQuantifier = { Zero: 0, ZeroOrOne: 1, ZeroOrMore: 2, One: 3, OneOrMore: 4 },
  isCaptureStep = __name(step$3 => step$3.type === `capture`, `isCaptureStep`),
  isStringStep = __name(step$3 => step$3.type === `string`, `isStringStep`),
  QueryErrorKind = { Syntax: 1, NodeName: 2, FieldName: 3, CaptureName: 4, PatternStructure: 5 },
  QueryError = class _QueryError extends Error {
    constructor(kind, info2, index$4, length$1) {
      super(_QueryError.formatMessage(kind, info2)),
        this.kind = kind,
        this.info = info2,
        this.index = index$4,
        this.length = length$1,
        this.name = `QueryError`
    }
    static {
      __name(this, `QueryError`)
    }
    static formatMessage(kind, info2) {
      switch (kind) {
        case QueryErrorKind.NodeName:
          return `Bad node name '${info2.word}'`
        case QueryErrorKind.FieldName:
          return `Bad field name '${info2.word}'`
        case QueryErrorKind.CaptureName:
          return `Bad capture name @${info2.word}`
        case QueryErrorKind.PatternStructure:
          return `Bad pattern structure at offset ${info2.suffix}`
        case QueryErrorKind.Syntax:
          return `Bad syntax at offset ${info2.suffix}`
      }
    }
  }
function parseAnyPredicate(steps, index$4, operator, textPredicates) {
  if (steps.length !== 3) {
    throw Error(`Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}`)
  }
  if (!isCaptureStep(steps[1])) {
    throw Error(`First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}"`)
  }
  let isPositive = operator === `eq?` || operator === `any-eq?`, matchAll = !operator.startsWith(`any-`)
  if (isCaptureStep(steps[2])) {
    let captureName1 = steps[1].name, captureName2 = steps[2].name
    textPredicates[index$4].push(captures => {
      let nodes1 = [], nodes2 = []
      for (let c$3 of captures) {
        c$3.name === captureName1 && nodes1.push(c$3.node), c$3.name === captureName2 && nodes2.push(c$3.node)
      }
      let compare$2 = __name((n1, n2, positive) => positive ? n1.text === n2.text : n1.text !== n2.text, `compare`)
      return matchAll
        ? nodes1.every(n1 => nodes2.some(n2 => compare$2(n1, n2, isPositive)))
        : nodes1.some(n1 => nodes2.some(n2 => compare$2(n1, n2, isPositive)))
    })
  } else {
    let captureName = steps[1].name,
      stringValue = steps[2].value,
      matches = __name(n$19 => n$19.text === stringValue, `matches`),
      doesNotMatch = __name(n$19 => n$19.text !== stringValue, `doesNotMatch`)
    textPredicates[index$4].push(captures => {
      let nodes = []
      for (let c$3 of captures) c$3.name === captureName && nodes.push(c$3.node)
      let test = isPositive ? matches : doesNotMatch
      return matchAll ? nodes.every(test) : nodes.some(test)
    })
  }
}
__name(parseAnyPredicate, `parseAnyPredicate`)
function parseMatchPredicate(steps, index$4, operator, textPredicates) {
  if (steps.length !== 3) {
    throw Error(`Wrong number of arguments to \`#${operator}\` predicate. Expected 2, got ${steps.length - 1}.`)
  }
  if (steps[1].type !== `capture`) {
    throw Error(`First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`)
  }
  if (steps[2].type !== `string`) {
    throw Error(`Second argument of \`#${operator}\` predicate must be a string. Got @${steps[2].name}.`)
  }
  let isPositive = operator === `match?` || operator === `any-match?`,
    matchAll = !operator.startsWith(`any-`),
    captureName = steps[1].name,
    regex = new RegExp(steps[2].value)
  textPredicates[index$4].push(captures => {
    let nodes = []
    for (let c$3 of captures) c$3.name === captureName && nodes.push(c$3.node.text)
    let test = __name((text$6, positive) => positive ? regex.test(text$6) : !regex.test(text$6), `test`)
    return nodes.length === 0
      ? !isPositive
      : matchAll
      ? nodes.every(text$6 => test(text$6, isPositive))
      : nodes.some(text$6 => test(text$6, isPositive))
  })
}
__name(parseMatchPredicate, `parseMatchPredicate`)
function parseAnyOfPredicate(steps, index$4, operator, textPredicates) {
  if (steps.length < 2) {
    throw Error(
      `Wrong number of arguments to \`#${operator}\` predicate. Expected at least 1. Got ${steps.length - 1}.`,
    )
  }
  if (steps[1].type !== `capture`) {
    throw Error(`First argument of \`#${operator}\` predicate must be a capture. Got "${steps[1].value}".`)
  }
  let isPositive = operator === `any-of?`, captureName = steps[1].name, stringSteps = steps.slice(2)
  if (!stringSteps.every(isStringStep)) throw Error(`Arguments to \`#${operator}\` predicate must be strings.".`)
  let values$6 = stringSteps.map(s$14 => s$14.value)
  textPredicates[index$4].push(captures => {
    let nodes = []
    for (let c$3 of captures) c$3.name === captureName && nodes.push(c$3.node.text)
    return nodes.length === 0 ? !isPositive : nodes.every(text$6 => values$6.includes(text$6)) === isPositive
  })
}
__name(parseAnyOfPredicate, `parseAnyOfPredicate`)
function parseIsPredicate(steps, index$4, operator, assertedProperties, refutedProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw Error(`Wrong number of arguments to \`#${operator}\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`)
  }
  if (!steps.every(isStringStep)) throw Error(`Arguments to \`#${operator}\` predicate must be strings.".`)
  let properties = operator === `is?` ? assertedProperties : refutedProperties
  properties[index$4] || (properties[index$4] = {}), properties[index$4][steps[1].value] = steps[2]?.value ?? null
}
__name(parseIsPredicate, `parseIsPredicate`)
function parseSetDirective(steps, index$4, setProperties) {
  if (steps.length < 2 || steps.length > 3) {
    throw Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${steps.length - 1}.`)
  }
  if (!steps.every(isStringStep)) throw Error('Arguments to `#set!` predicate must be strings.".')
  setProperties[index$4] || (setProperties[index$4] = {}),
    setProperties[index$4][steps[1].value] = steps[2]?.value ?? null
}
__name(parseSetDirective, `parseSetDirective`)
function parsePattern(
  index$4,
  stepType,
  stepValueId,
  captureNames,
  stringValues,
  steps,
  textPredicates,
  predicates,
  setProperties,
  assertedProperties,
  refutedProperties,
) {
  if (stepType === PREDICATE_STEP_TYPE_CAPTURE) {
    let name2 = captureNames[stepValueId]
    steps.push({ type: `capture`, name: name2 })
  } else if (stepType === PREDICATE_STEP_TYPE_STRING) steps.push({ type: `string`, value: stringValues[stepValueId] })
  else if (steps.length > 0) {
    if (steps[0].type !== `string`) throw Error(`Predicates must begin with a literal value`)
    let operator = steps[0].value
    switch (operator) {
      case `any-not-eq?`:
      case `not-eq?`:
      case `any-eq?`:
      case `eq?`:
        parseAnyPredicate(steps, index$4, operator, textPredicates)
        break
      case `any-not-match?`:
      case `not-match?`:
      case `any-match?`:
      case `match?`:
        parseMatchPredicate(steps, index$4, operator, textPredicates)
        break
      case `not-any-of?`:
      case `any-of?`:
        parseAnyOfPredicate(steps, index$4, operator, textPredicates)
        break
      case `is?`:
      case `is-not?`:
        parseIsPredicate(steps, index$4, operator, assertedProperties, refutedProperties)
        break
      case `set!`:
        parseSetDirective(steps, index$4, setProperties)
        break
      default:
        predicates[index$4].push({ operator, operands: steps.slice(1) })
    }
    steps.length = 0
  }
}
__name(parsePattern, `parsePattern`)
var Query = class {
    static {
      __name(this, `Query`)
    }
    0 = 0
    exceededMatchLimit
    textPredicates
    captureNames
    captureQuantifiers
    predicates
    setProperties
    assertedProperties
    refutedProperties
    matchLimit
    constructor(language, source) {
      let sourceLength = C.lengthBytesUTF8(source), sourceAddress = C._malloc(sourceLength + 1)
      C.stringToUTF8(source, sourceAddress, sourceLength + 1)
      let address = C._ts_query_new(
        language[0],
        sourceAddress,
        sourceLength,
        TRANSFER_BUFFER,
        TRANSFER_BUFFER + SIZE_OF_INT,
      )
      if (!address) {
        let errorId = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
          errorByte = C.getValue(TRANSFER_BUFFER, `i32`),
          errorIndex = C.UTF8ToString(sourceAddress, errorByte).length,
          suffix$1 = source.slice(errorIndex, errorIndex + 100).split(`
`)[0],
          word = suffix$1.match(QUERY_WORD_REGEX)?.[0] ?? ``
        switch (C._free(sourceAddress), errorId) {
          case QueryErrorKind.Syntax:
            throw new QueryError(QueryErrorKind.Syntax, { suffix: `${errorIndex}: '${suffix$1}'...` }, errorIndex, 0)
          case QueryErrorKind.NodeName:
            throw new QueryError(errorId, { word }, errorIndex, word.length)
          case QueryErrorKind.FieldName:
            throw new QueryError(errorId, { word }, errorIndex, word.length)
          case QueryErrorKind.CaptureName:
            throw new QueryError(errorId, { word }, errorIndex, word.length)
          case QueryErrorKind.PatternStructure:
            throw new QueryError(errorId, { suffix: `${errorIndex}: '${suffix$1}'...` }, errorIndex, 0)
        }
      }
      let stringCount = C._ts_query_string_count(address),
        captureCount = C._ts_query_capture_count(address),
        patternCount = C._ts_query_pattern_count(address),
        captureNames = Array(captureCount),
        captureQuantifiers = Array(patternCount),
        stringValues = Array(stringCount)
      for (let i2 = 0; i2 < captureCount; i2++) {
        let nameAddress = C._ts_query_capture_name_for_id(address, i2, TRANSFER_BUFFER),
          nameLength = C.getValue(TRANSFER_BUFFER, `i32`)
        captureNames[i2] = C.UTF8ToString(nameAddress, nameLength)
      }
      for (let i2 = 0; i2 < patternCount; i2++) {
        let captureQuantifiersArray = Array(captureCount)
        for (let j$1 = 0; j$1 < captureCount; j$1++) {
          let quantifier = C._ts_query_capture_quantifier_for_id(address, i2, j$1)
          captureQuantifiersArray[j$1] = quantifier
        }
        captureQuantifiers[i2] = captureQuantifiersArray
      }
      for (let i2 = 0; i2 < stringCount; i2++) {
        let valueAddress = C._ts_query_string_value_for_id(address, i2, TRANSFER_BUFFER),
          nameLength = C.getValue(TRANSFER_BUFFER, `i32`)
        stringValues[i2] = C.UTF8ToString(valueAddress, nameLength)
      }
      let setProperties = Array(patternCount),
        assertedProperties = Array(patternCount),
        refutedProperties = Array(patternCount),
        predicates = Array(patternCount),
        textPredicates = Array(patternCount)
      for (let i2 = 0; i2 < patternCount; i2++) {
        let predicatesAddress = C._ts_query_predicates_for_pattern(address, i2, TRANSFER_BUFFER),
          stepCount = C.getValue(TRANSFER_BUFFER, `i32`)
        predicates[i2] = [], textPredicates[i2] = []
        let steps = [], stepAddress = predicatesAddress
        for (let j$1 = 0; j$1 < stepCount; j$1++) {
          let stepType = C.getValue(stepAddress, `i32`)
          stepAddress += SIZE_OF_INT
          let stepValueId = C.getValue(stepAddress, `i32`)
          stepAddress += SIZE_OF_INT,
            parsePattern(
              i2,
              stepType,
              stepValueId,
              captureNames,
              stringValues,
              steps,
              textPredicates,
              predicates,
              setProperties,
              assertedProperties,
              refutedProperties,
            )
        }
        Object.freeze(textPredicates[i2]),
          Object.freeze(predicates[i2]),
          Object.freeze(setProperties[i2]),
          Object.freeze(assertedProperties[i2]),
          Object.freeze(refutedProperties[i2])
      }
      C._free(sourceAddress),
        this[0] = address,
        this.captureNames = captureNames,
        this.captureQuantifiers = captureQuantifiers,
        this.textPredicates = textPredicates,
        this.predicates = predicates,
        this.setProperties = setProperties,
        this.assertedProperties = assertedProperties,
        this.refutedProperties = refutedProperties,
        this.exceededMatchLimit = !1
    }
    delete() {
      C._ts_query_delete(this[0]), this[0] = 0
    }
    matches(node$1, options$2 = {}) {
      let startPosition = options$2.startPosition ?? ZERO_POINT,
        endPosition = options$2.endPosition ?? ZERO_POINT,
        startIndex = options$2.startIndex ?? 0,
        endIndex = options$2.endIndex ?? 0,
        matchLimit = options$2.matchLimit ?? 4294967295,
        maxStartDepth = options$2.maxStartDepth ?? 4294967295,
        timeoutMicros = options$2.timeoutMicros ?? 0,
        progressCallback = options$2.progressCallback
      if (typeof matchLimit != `number`) throw Error(`Arguments must be numbers`)
      if (this.matchLimit = matchLimit, endIndex !== 0 && startIndex > endIndex) {
        throw Error('`startIndex` cannot be greater than `endIndex`')
      }
      if (
        endPosition !== ZERO_POINT
        && (startPosition.row > endPosition.row
          || startPosition.row === endPosition.row && startPosition.column > endPosition.column)
      ) throw Error('`startPosition` cannot be greater than `endPosition`')
      progressCallback && (C.currentQueryProgressCallback = progressCallback),
        marshalNode(node$1),
        C._ts_query_matches_wasm(
          this[0],
          node$1.tree[0],
          startPosition.row,
          startPosition.column,
          endPosition.row,
          endPosition.column,
          startIndex,
          endIndex,
          matchLimit,
          maxStartDepth,
          timeoutMicros,
        )
      let rawCount = C.getValue(TRANSFER_BUFFER, `i32`),
        startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, `i32`),
        result = Array(rawCount)
      this.exceededMatchLimit = !!didExceedMatchLimit
      let filteredCount = 0, address = startAddress
      for (let i2 = 0; i2 < rawCount; i2++) {
        let patternIndex = C.getValue(address, `i32`)
        address += SIZE_OF_INT
        let captureCount = C.getValue(address, `i32`)
        address += SIZE_OF_INT
        let captures = Array(captureCount)
        if (
          address = unmarshalCaptures(this, node$1.tree, address, patternIndex, captures),
            this.textPredicates[patternIndex].every(p$25 => p$25(captures))
        ) {
          result[filteredCount] = { pattern: patternIndex, patternIndex, captures }
          let setProperties = this.setProperties[patternIndex]
          result[filteredCount].setProperties = setProperties
          let assertedProperties = this.assertedProperties[patternIndex]
          result[filteredCount].assertedProperties = assertedProperties
          let refutedProperties = this.refutedProperties[patternIndex]
          result[filteredCount].refutedProperties = refutedProperties, filteredCount++
        }
      }
      return result.length = filteredCount, C._free(startAddress), C.currentQueryProgressCallback = null, result
    }
    captures(node$1, options$2 = {}) {
      let startPosition = options$2.startPosition ?? ZERO_POINT,
        endPosition = options$2.endPosition ?? ZERO_POINT,
        startIndex = options$2.startIndex ?? 0,
        endIndex = options$2.endIndex ?? 0,
        matchLimit = options$2.matchLimit ?? 4294967295,
        maxStartDepth = options$2.maxStartDepth ?? 4294967295,
        timeoutMicros = options$2.timeoutMicros ?? 0,
        progressCallback = options$2.progressCallback
      if (typeof matchLimit != `number`) throw Error(`Arguments must be numbers`)
      if (this.matchLimit = matchLimit, endIndex !== 0 && startIndex > endIndex) {
        throw Error('`startIndex` cannot be greater than `endIndex`')
      }
      if (
        endPosition !== ZERO_POINT
        && (startPosition.row > endPosition.row
          || startPosition.row === endPosition.row && startPosition.column > endPosition.column)
      ) throw Error('`startPosition` cannot be greater than `endPosition`')
      progressCallback && (C.currentQueryProgressCallback = progressCallback),
        marshalNode(node$1),
        C._ts_query_captures_wasm(
          this[0],
          node$1.tree[0],
          startPosition.row,
          startPosition.column,
          endPosition.row,
          endPosition.column,
          startIndex,
          endIndex,
          matchLimit,
          maxStartDepth,
          timeoutMicros,
        )
      let count$2 = C.getValue(TRANSFER_BUFFER, `i32`),
        startAddress = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        didExceedMatchLimit = C.getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, `i32`),
        result = []
      this.exceededMatchLimit = !!didExceedMatchLimit
      let captures = [], address = startAddress
      for (let i2 = 0; i2 < count$2; i2++) {
        let patternIndex = C.getValue(address, `i32`)
        address += SIZE_OF_INT
        let captureCount = C.getValue(address, `i32`)
        address += SIZE_OF_INT
        let captureIndex = C.getValue(address, `i32`)
        if (
          address += SIZE_OF_INT,
            captures.length = captureCount,
            address = unmarshalCaptures(this, node$1.tree, address, patternIndex, captures),
            this.textPredicates[patternIndex].every(p$25 => p$25(captures))
        ) {
          let capture$1 = captures[captureIndex], setProperties = this.setProperties[patternIndex]
          capture$1.setProperties = setProperties
          let assertedProperties = this.assertedProperties[patternIndex]
          capture$1.assertedProperties = assertedProperties
          let refutedProperties = this.refutedProperties[patternIndex]
          capture$1.refutedProperties = refutedProperties, result.push(capture$1)
        }
      }
      return C._free(startAddress), C.currentQueryProgressCallback = null, result
    }
    predicatesForPattern(patternIndex) {
      return this.predicates[patternIndex]
    }
    disableCapture(captureName) {
      let captureNameLength = C.lengthBytesUTF8(captureName), captureNameAddress = C._malloc(captureNameLength + 1)
      C.stringToUTF8(captureName, captureNameAddress, captureNameLength + 1),
        C._ts_query_disable_capture(this[0], captureNameAddress, captureNameLength),
        C._free(captureNameAddress)
    }
    disablePattern(patternIndex) {
      if (patternIndex >= this.predicates.length) {
        throw Error(`Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`)
      }
      C._ts_query_disable_pattern(this[0], patternIndex)
    }
    didExceedMatchLimit() {
      return this.exceededMatchLimit
    }
    startIndexForPattern(patternIndex) {
      if (patternIndex >= this.predicates.length) {
        throw Error(`Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`)
      }
      return C._ts_query_start_byte_for_pattern(this[0], patternIndex)
    }
    endIndexForPattern(patternIndex) {
      if (patternIndex >= this.predicates.length) {
        throw Error(`Pattern index is ${patternIndex} but the pattern count is ${this.predicates.length}`)
      }
      return C._ts_query_end_byte_for_pattern(this[0], patternIndex)
    }
    patternCount() {
      return C._ts_query_pattern_count(this[0])
    }
    captureIndexForName(captureName) {
      return this.captureNames.indexOf(captureName)
    }
    isPatternRooted(patternIndex) {
      return C._ts_query_is_pattern_rooted(this[0], patternIndex) === 1
    }
    isPatternNonLocal(patternIndex) {
      return C._ts_query_is_pattern_non_local(this[0], patternIndex) === 1
    }
    isPatternGuaranteedAtStep(byteIndex) {
      return C._ts_query_is_pattern_guaranteed_at_step(this[0], byteIndex) === 1
    }
  },
  LANGUAGE_FUNCTION_REGEX = /^tree_sitter_\w+$/,
  Language = class _Language {
    static {
      __name(this, `Language`)
    }
    0 = 0
    types
    fields
    constructor(internal, address) {
      assertInternal(internal), this[0] = address, this.types = Array(C._ts_language_symbol_count(this[0]))
      for (let i2 = 0, n$19 = this.types.length; i2 < n$19; i2++) {
        C._ts_language_symbol_type(this[0], i2) < 2
          && (this.types[i2] = C.UTF8ToString(C._ts_language_symbol_name(this[0], i2)))
      }
      this.fields = Array(C._ts_language_field_count(this[0]) + 1)
      for (let i2 = 0, n$19 = this.fields.length; i2 < n$19; i2++) {
        let fieldName = C._ts_language_field_name_for_id(this[0], i2)
        fieldName === 0 ? this.fields[i2] = null : this.fields[i2] = C.UTF8ToString(fieldName)
      }
    }
    get name() {
      let ptr = C._ts_language_name(this[0])
      return ptr === 0 ? null : C.UTF8ToString(ptr)
    }
    get version() {
      return C._ts_language_version(this[0])
    }
    get abiVersion() {
      return C._ts_language_abi_version(this[0])
    }
    get metadata() {
      C._ts_language_metadata(this[0])
      let length$1 = C.getValue(TRANSFER_BUFFER, `i32`), address = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`)
      return length$1 === 0 ? null : unmarshalLanguageMetadata(address)
    }
    get fieldCount() {
      return this.fields.length - 1
    }
    get stateCount() {
      return C._ts_language_state_count(this[0])
    }
    fieldIdForName(fieldName) {
      let result = this.fields.indexOf(fieldName)
      return result === -1 ? null : result
    }
    fieldNameForId(fieldId) {
      return this.fields[fieldId] ?? null
    }
    idForNodeType(type$2, named) {
      let typeLength = C.lengthBytesUTF8(type$2), typeAddress = C._malloc(typeLength + 1)
      C.stringToUTF8(type$2, typeAddress, typeLength + 1)
      let result = C._ts_language_symbol_for_name(this[0], typeAddress, typeLength, named ? 1 : 0)
      return C._free(typeAddress), result || null
    }
    get nodeTypeCount() {
      return C._ts_language_symbol_count(this[0])
    }
    nodeTypeForId(typeId) {
      let name2 = C._ts_language_symbol_name(this[0], typeId)
      return name2 ? C.UTF8ToString(name2) : null
    }
    nodeTypeIsNamed(typeId) {
      return !!C._ts_language_type_is_named_wasm(this[0], typeId)
    }
    nodeTypeIsVisible(typeId) {
      return !!C._ts_language_type_is_visible_wasm(this[0], typeId)
    }
    get supertypes() {
      C._ts_language_supertypes_wasm(this[0])
      let count$2 = C.getValue(TRANSFER_BUFFER, `i32`),
        buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        result = Array(count$2)
      if (count$2 > 0) {
        let address = buffer
        for (let i2 = 0; i2 < count$2; i2++) result[i2] = C.getValue(address, `i16`), address += SIZE_OF_SHORT
      }
      return result
    }
    subtypes(supertype) {
      C._ts_language_subtypes_wasm(this[0], supertype)
      let count$2 = C.getValue(TRANSFER_BUFFER, `i32`),
        buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        result = Array(count$2)
      if (count$2 > 0) {
        let address = buffer
        for (let i2 = 0; i2 < count$2; i2++) result[i2] = C.getValue(address, `i16`), address += SIZE_OF_SHORT
      }
      return result
    }
    nextState(stateId, typeId) {
      return C._ts_language_next_state(this[0], stateId, typeId)
    }
    lookaheadIterator(stateId) {
      let address = C._ts_lookahead_iterator_new(this[0], stateId)
      return address ? new LookaheadIterator(INTERNAL, address, this) : null
    }
    query(source) {
      return console.warn(`Language.query is deprecated. Use new Query(language, source) instead.`),
        new Query(this, source)
    }
    static async load(input) {
      let bytes
      if (input instanceof Uint8Array) bytes = Promise.resolve(input)
      else if (globalThis.process?.versions.node) {
        let fs2 = await __vitePreload(
          () => import(`./__vite-browser-external-C2t0qqmN.js`).then(__toDynamicImportESM()),
          [],
        )
        bytes = fs2.readFile(input)
      } else {bytes = fetch(input).then(response =>
          response.arrayBuffer().then(buffer => {
            if (response.ok) return new Uint8Array(buffer)
            {
              let body2 = new TextDecoder(`utf-8`).decode(buffer)
              throw Error(`Language.load failed with status ${response.status}.

${body2}`)
            }
          })
        )}
      let mod = await C.loadWebAssemblyModule(await bytes, { loadAsync: !0 }),
        symbolNames = Object.keys(mod),
        functionName = symbolNames.find(key$1 =>
          LANGUAGE_FUNCTION_REGEX.test(key$1) && !key$1.includes(`external_scanner_`)
        )
      if (!functionName) {
        throw console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(symbolNames, null, 2)}`),
          Error(`Language.load failed: no language function found in WASM file`)
      }
      let languageAddress = mod[functionName]()
      return new _Language(INTERNAL, languageAddress)
    }
  },
  Module2 = (() => {
    var _scriptName = import.meta.url
    return async function(moduleArg = {}) {
      var moduleRtn,
        Module = moduleArg,
        readyPromiseResolve,
        readyPromiseReject,
        readyPromise = new Promise((resolve, reject) => {
          readyPromiseResolve = resolve, readyPromiseReject = reject
        }),
        ENVIRONMENT_IS_WEB = typeof window == `object`,
        ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope < `u`,
        ENVIRONMENT_IS_NODE = typeof process == `object` && typeof process.versions == `object`
          && typeof process.versions.node == `string` && process.type != `renderer`,
        ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER
      if (ENVIRONMENT_IS_NODE) {
        let { createRequire } = await __vitePreload(async () => {
          let { createRequire: createRequire$1 } = await import(`./__vite-browser-external-C2t0qqmN.js`).then(
            __toDynamicImportESM(),
          )
          return { createRequire: createRequire$1 }
        }, [])
        var require$1 = createRequire(import.meta.url)
      }
      Module.currentQueryProgressCallback = null,
        Module.currentProgressCallback = null,
        Module.currentLogCallback = null,
        Module.currentParseCallback = null
      var moduleOverrides = Object.assign({}, Module),
        arguments_ = [],
        thisProgram = `./this.program`,
        quit_ = __name((status$2, toThrow) => {
          throw toThrow
        }, `quit_`),
        scriptDirectory = ``
      function locateFile(path$1) {
        return Module.locateFile ? Module.locateFile(path$1, scriptDirectory) : scriptDirectory + path$1
      }
      __name(locateFile, `locateFile`)
      var readAsync, readBinary
      if (ENVIRONMENT_IS_NODE) {
        var fs = require$1(`fs`), nodePath = require$1(`path`)
        import.meta.url.startsWith(`data:`)
        || (scriptDirectory = nodePath.dirname(require$1(`url`).fileURLToPath(import.meta.url)) + `/`),
          readBinary = __name(filename => {
            filename = isFileURI(filename) ? new URL(filename) : filename
            var ret = fs.readFileSync(filename)
            return ret
          }, `readBinary`),
          readAsync = __name(async (filename, binary2 = !0) => {
            filename = isFileURI(filename) ? new URL(filename) : filename
            var ret = fs.readFileSync(filename, binary2 ? void 0 : `utf8`)
            return ret
          }, `readAsync`),
          !Module.thisProgram && process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, `/`)),
          arguments_ = process.argv.slice(2),
          quit_ = __name((status$2, toThrow) => {
            throw process.exitCode = status$2, toThrow
          }, `quit_`)
      } else {
        ;(ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER
          ? scriptDirectory = self.location.href
          : typeof document < `u` && document.currentScript && (scriptDirectory = document.currentScript.src),
          _scriptName && (scriptDirectory = _scriptName),
          scriptDirectory = scriptDirectory.startsWith(`blob:`)
            ? ``
            : scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, ``).lastIndexOf(`/`) + 1),
          ENVIRONMENT_IS_WORKER && (readBinary = __name(url => {
            var xhr = new XMLHttpRequest()
            return xhr.open(`GET`, url, !1),
              xhr.responseType = `arraybuffer`,
              xhr.send(null),
              new Uint8Array(xhr.response)
          }, `readBinary`)),
          readAsync = __name(async url => {
            if (isFileURI(url)) {
              return new Promise((resolve, reject) => {
                var xhr = new XMLHttpRequest()
                xhr.open(`GET`, url, !0),
                  xhr.responseType = `arraybuffer`,
                  xhr.onload = () => {
                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                      resolve(xhr.response)
                      return
                    }
                    reject(xhr.status)
                  },
                  xhr.onerror = reject,
                  xhr.send(null)
              })
            }
            var response = await fetch(url, { credentials: `same-origin` })
            if (response.ok) {
              return response.arrayBuffer()
            }
            throw Error(response.status + ` : ` + response.url)
          }, `readAsync`))
      }
      var out = Module.print || console.log.bind(console), err = Module.printErr || console.error.bind(console)
      Object.assign(Module, moduleOverrides),
        moduleOverrides = null,
        Module.arguments && (arguments_ = Module.arguments),
        Module.thisProgram && (thisProgram = Module.thisProgram)
      var dynamicLibraries = Module.dynamicLibraries || [],
        wasmBinary = Module.wasmBinary,
        wasmMemory,
        ABORT = !1,
        EXITSTATUS
      function assert(condition, text$6) {
        condition || abort(text$6)
      }
      __name(assert, `assert`)
      var HEAP,
        HEAP8,
        HEAPU8,
        HEAP16,
        HEAPU16,
        HEAP32,
        HEAPU32,
        HEAPF32,
        HEAP64,
        HEAPU64,
        HEAPF64,
        HEAP_DATA_VIEW,
        runtimeInitialized = !1,
        isFileURI = __name(filename => filename.startsWith(`file://`), `isFileURI`)
      function updateMemoryViews() {
        var b$3 = wasmMemory.buffer
        Module.HEAP_DATA_VIEW = HEAP_DATA_VIEW = new DataView(b$3),
          Module.HEAP8 = HEAP8 = new Int8Array(b$3),
          Module.HEAP16 = HEAP16 = new Int16Array(b$3),
          Module.HEAPU8 = HEAPU8 = new Uint8Array(b$3),
          Module.HEAPU16 = HEAPU16 = new Uint16Array(b$3),
          Module.HEAP32 = HEAP32 = new Int32Array(b$3),
          Module.HEAPU32 = HEAPU32 = new Uint32Array(b$3),
          Module.HEAPF32 = HEAPF32 = new Float32Array(b$3),
          Module.HEAPF64 = HEAPF64 = new Float64Array(b$3),
          Module.HEAP64 = HEAP64 = new BigInt64Array(b$3),
          Module.HEAPU64 = HEAPU64 = new BigUint64Array(b$3)
      }
      if (__name(updateMemoryViews, `updateMemoryViews`), Module.wasmMemory) wasmMemory = Module.wasmMemory
      else {
        var INITIAL_MEMORY = Module.INITIAL_MEMORY || 33554432
        wasmMemory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / 65536, maximum: 32768 })
      }
      updateMemoryViews()
      var __RELOC_FUNCS__ = []
      function preRun() {
        if (Module.preRun) {
          for (typeof Module.preRun == `function` && (Module.preRun = [Module.preRun]); Module.preRun.length;) {
            addOnPreRun(Module.preRun.shift())
          }
        }
        callRuntimeCallbacks(onPreRuns)
      }
      __name(preRun, `preRun`)
      function initRuntime() {
        runtimeInitialized = !0,
          callRuntimeCallbacks(__RELOC_FUNCS__),
          wasmExports.__wasm_call_ctors(),
          callRuntimeCallbacks(onPostCtors)
      }
      __name(initRuntime, `initRuntime`)
      function preMain() {}
      __name(preMain, `preMain`)
      function postRun() {
        if (Module.postRun) {
          for (typeof Module.postRun == `function` && (Module.postRun = [Module.postRun]); Module.postRun.length;) {
            addOnPostRun(Module.postRun.shift())
          }
        }
        callRuntimeCallbacks(onPostRuns)
      }
      __name(postRun, `postRun`)
      var runDependencies = 0, dependenciesFulfilled = null
      function getUniqueRunDependency(id$2) {
        return id$2
      }
      __name(getUniqueRunDependency, `getUniqueRunDependency`)
      function addRunDependency(id$2) {
        runDependencies++, Module.monitorRunDependencies?.(runDependencies)
      }
      __name(addRunDependency, `addRunDependency`)
      function removeRunDependency(id$2) {
        if (
          runDependencies--,
            Module.monitorRunDependencies?.(runDependencies),
            runDependencies == 0 && dependenciesFulfilled
        ) {
          var callback = dependenciesFulfilled
          dependenciesFulfilled = null, callback()
        }
      }
      __name(removeRunDependency, `removeRunDependency`)
      function abort(what) {
        Module.onAbort?.(what),
          what = `Aborted(` + what + `)`,
          err(what),
          ABORT = !0,
          what += `. Build with -sASSERTIONS for more info.`
        var e$26 = new WebAssembly.RuntimeError(what)
        throw readyPromiseReject(e$26), e$26
      }
      __name(abort, `abort`)
      var wasmBinaryFile
      function findWasmBinary() {
        return Module.locateFile
          ? locateFile(`tree-sitter.wasm`)
          : new URL(`/assets/tree-sitter-DJBnMkmj.wasm`, `` + import.meta.url).href
      }
      __name(findWasmBinary, `findWasmBinary`)
      function getBinarySync(file) {
        if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary)
        if (readBinary) return readBinary(file)
        throw `both async and sync fetching of the wasm failed`
      }
      __name(getBinarySync, `getBinarySync`)
      async function getWasmBinary(binaryFile) {
        if (!wasmBinary) {
          try {
            var response = await readAsync(binaryFile)
            return new Uint8Array(response)
          } catch {}
        }
        return getBinarySync(binaryFile)
      }
      __name(getWasmBinary, `getWasmBinary`)
      async function instantiateArrayBuffer(binaryFile, imports) {
        try {
          var binary2 = await getWasmBinary(binaryFile), instance2 = await WebAssembly.instantiate(binary2, imports)
          return instance2
        } catch (reason) {
          err(`failed to asynchronously prepare wasm: ${reason}`), abort(reason)
        }
      }
      __name(instantiateArrayBuffer, `instantiateArrayBuffer`)
      async function instantiateAsync(binary2, binaryFile, imports) {
        if (
          !binary2 && typeof WebAssembly.instantiateStreaming == `function` && !isFileURI(binaryFile)
          && !ENVIRONMENT_IS_NODE
        ) {
          try {
            var response = fetch(binaryFile, { credentials: `same-origin` }),
              instantiationResult = await WebAssembly.instantiateStreaming(response, imports)
            return instantiationResult
          } catch (reason) {
            err(`wasm streaming compile failed: ${reason}`), err(`falling back to ArrayBuffer instantiation`)
          }
        }
        return instantiateArrayBuffer(binaryFile, imports)
      }
      __name(instantiateAsync, `instantiateAsync`)
      function getWasmImports() {
        return {
          env: wasmImports,
          wasi_snapshot_preview1: wasmImports,
          'GOT.mem': new Proxy(wasmImports, GOTHandler),
          'GOT.func': new Proxy(wasmImports, GOTHandler),
        }
      }
      __name(getWasmImports, `getWasmImports`)
      async function createWasm() {
        function receiveInstance(instance2, module2) {
          wasmExports = instance2.exports, wasmExports = relocateExports(wasmExports, 1024)
          var metadata2 = getDylinkMetadata(module2)
          return metadata2.neededDynlibs && (dynamicLibraries = metadata2.neededDynlibs.concat(dynamicLibraries)),
            mergeLibSymbols(wasmExports, `main`),
            LDSO.init(),
            loadDylibs(),
            __RELOC_FUNCS__.push(wasmExports.__wasm_apply_data_relocs),
            removeRunDependency(`wasm-instantiate`),
            wasmExports
        }
        __name(receiveInstance, `receiveInstance`), addRunDependency(`wasm-instantiate`)
        function receiveInstantiationResult(result2) {
          return receiveInstance(result2.instance, result2.module)
        }
        __name(receiveInstantiationResult, `receiveInstantiationResult`)
        var info2 = getWasmImports()
        if (Module.instantiateWasm) {
          return new Promise((resolve, reject) => {
            Module.instantiateWasm(info2, (mod, inst) => {
              receiveInstance(mod, inst), resolve(mod.exports)
            })
          })
        }
        wasmBinaryFile ??= findWasmBinary()
        try {
          var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info2),
            exports$1 = receiveInstantiationResult(result)
          return exports$1
        } catch (e$26) {
          return readyPromiseReject(e$26), Promise.reject(e$26)
        }
      }
      __name(createWasm, `createWasm`)
      var ASM_CONSTS = {}
      class ExitStatus {
        static {
          __name(this, `ExitStatus`)
        }
        name = `ExitStatus`
        constructor(status$2) {
          this.message = `Program terminated with exit(${status$2})`, this.status = status$2
        }
      }
      var GOT = {},
        currentModuleWeakSymbols = new Set([]),
        GOTHandler = {
          get(obj, symName) {
            var rtn = GOT[symName]
            return rtn ||= GOT[symName] = new WebAssembly.Global({ value: `i32`, mutable: !0 }),
              currentModuleWeakSymbols.has(symName) || (rtn.required = !0),
              rtn
          },
        },
        LE_HEAP_LOAD_F32 = __name(byteOffset => HEAP_DATA_VIEW.getFloat32(byteOffset, !0), `LE_HEAP_LOAD_F32`),
        LE_HEAP_LOAD_F64 = __name(byteOffset => HEAP_DATA_VIEW.getFloat64(byteOffset, !0), `LE_HEAP_LOAD_F64`),
        LE_HEAP_LOAD_I16 = __name(byteOffset => HEAP_DATA_VIEW.getInt16(byteOffset, !0), `LE_HEAP_LOAD_I16`),
        LE_HEAP_LOAD_I32 = __name(byteOffset => HEAP_DATA_VIEW.getInt32(byteOffset, !0), `LE_HEAP_LOAD_I32`),
        LE_HEAP_LOAD_U16 = __name(byteOffset => HEAP_DATA_VIEW.getUint16(byteOffset, !0), `LE_HEAP_LOAD_U16`),
        LE_HEAP_LOAD_U32 = __name(byteOffset => HEAP_DATA_VIEW.getUint32(byteOffset, !0), `LE_HEAP_LOAD_U32`),
        LE_HEAP_STORE_F32 = __name(
          (byteOffset, value$2) => HEAP_DATA_VIEW.setFloat32(byteOffset, value$2, !0),
          `LE_HEAP_STORE_F32`,
        ),
        LE_HEAP_STORE_F64 = __name(
          (byteOffset, value$2) => HEAP_DATA_VIEW.setFloat64(byteOffset, value$2, !0),
          `LE_HEAP_STORE_F64`,
        ),
        LE_HEAP_STORE_I16 = __name(
          (byteOffset, value$2) => HEAP_DATA_VIEW.setInt16(byteOffset, value$2, !0),
          `LE_HEAP_STORE_I16`,
        ),
        LE_HEAP_STORE_I32 = __name(
          (byteOffset, value$2) => HEAP_DATA_VIEW.setInt32(byteOffset, value$2, !0),
          `LE_HEAP_STORE_I32`,
        ),
        LE_HEAP_STORE_U16 = __name(
          (byteOffset, value$2) => HEAP_DATA_VIEW.setUint16(byteOffset, value$2, !0),
          `LE_HEAP_STORE_U16`,
        ),
        LE_HEAP_STORE_U32 = __name(
          (byteOffset, value$2) => HEAP_DATA_VIEW.setUint32(byteOffset, value$2, !0),
          `LE_HEAP_STORE_U32`,
        ),
        callRuntimeCallbacks = __name(callbacks => {
          for (; callbacks.length > 0;) callbacks.shift()(Module)
        }, `callRuntimeCallbacks`),
        onPostRuns = [],
        addOnPostRun = __name(cb => onPostRuns.unshift(cb), `addOnPostRun`),
        onPreRuns = [],
        addOnPreRun = __name(cb => onPreRuns.unshift(cb), `addOnPreRun`),
        UTF8Decoder = typeof TextDecoder < `u` ? new TextDecoder() : void 0,
        UTF8ArrayToString = __name((heapOrArray, idx = 0, maxBytesToRead = NaN) => {
          for (var endIdx = idx + maxBytesToRead, endPtr = idx; heapOrArray[endPtr] && !(endPtr >= endIdx);) ++endPtr
          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr))
          }
          for (var str = ``; idx < endPtr;) {
            var u0 = heapOrArray[idx++]
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0)
              continue
            }
            var u1 = heapOrArray[idx++] & 63
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1)
              continue
            }
            var u2 = heapOrArray[idx++] & 63
            if (
              u0 = (u0 & 240) == 224
                ? (u0 & 15) << 12 | u1 << 6 | u2
                : (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63, u0 < 65536
            ) str += String.fromCharCode(u0)
            else {
              var ch = u0 - 65536
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
            }
          }
          return str
        }, `UTF8ArrayToString`),
        getDylinkMetadata = __name(binary2 => {
          var offset$3 = 0, end$2 = 0
          function getU8() {
            return binary2[offset$3++]
          }
          __name(getU8, `getU8`)
          function getLEB() {
            for (var ret = 0, mul = 1;;) {
              var byte = binary2[offset$3++]
              if (ret += (byte & 127) * mul, mul *= 128, !(byte & 128)) break
            }
            return ret
          }
          __name(getLEB, `getLEB`)
          function getString() {
            var len = getLEB()
            return offset$3 += len, UTF8ArrayToString(binary2, offset$3 - len, len)
          }
          __name(getString, `getString`)
          function failIf(condition, message) {
            if (condition) throw Error(message)
          }
          __name(failIf, `failIf`)
          var name2 = `dylink.0`
          if (binary2 instanceof WebAssembly.Module) {
            var dylinkSection = WebAssembly.Module.customSections(binary2, name2)
            dylinkSection.length === 0
            && (name2 = `dylink`, dylinkSection = WebAssembly.Module.customSections(binary2, name2)),
              failIf(dylinkSection.length === 0, `need dylink section`),
              binary2 = new Uint8Array(dylinkSection[0]),
              end$2 = binary2.length
          } else {
            var int32View = new Uint32Array(new Uint8Array(binary2.subarray(0, 24)).buffer),
              magicNumberFound = int32View[0] == 1836278016 || int32View[0] == 6386541
            failIf(!magicNumberFound, `need to see wasm magic number`),
              failIf(binary2[8] !== 0, `need the dylink section to be first`),
              offset$3 = 9
            var section_size = getLEB()
            end$2 = offset$3 + section_size, name2 = getString()
          }
          var customSection = { neededDynlibs: [], tlsExports: new Set(), weakImports: new Set() }
          if (name2 == `dylink`) {
            customSection.memorySize = getLEB(),
              customSection.memoryAlign = getLEB(),
              customSection.tableSize = getLEB(),
              customSection.tableAlign = getLEB()
            for (var neededDynlibsCount = getLEB(), i2 = 0; i2 < neededDynlibsCount; ++i2) {
              var libname = getString()
              customSection.neededDynlibs.push(libname)
            }
          } else {
            failIf(name2 !== `dylink.0`)
            for (
              var WASM_DYLINK_MEM_INFO = 1,
                WASM_DYLINK_NEEDED = 2,
                WASM_DYLINK_EXPORT_INFO = 3,
                WASM_DYLINK_IMPORT_INFO = 4,
                WASM_SYMBOL_TLS = 256,
                WASM_SYMBOL_BINDING_MASK = 3,
                WASM_SYMBOL_BINDING_WEAK = 1;
              offset$3 < end$2;
            ) {
              var subsectionType = getU8(), subsectionSize = getLEB()
              if (subsectionType === WASM_DYLINK_MEM_INFO) {
                customSection.memorySize = getLEB(),
                  customSection.memoryAlign = getLEB(),
                  customSection.tableSize = getLEB(),
                  customSection.tableAlign = getLEB()
              } else if (subsectionType === WASM_DYLINK_NEEDED) {
                for (var neededDynlibsCount = getLEB(), i2 = 0; i2 < neededDynlibsCount; ++i2) {
                  libname = getString(), customSection.neededDynlibs.push(libname)
                }
              } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
                for (var count$2 = getLEB(); count$2--;) {
                  var symname = getString(), flags2 = getLEB()
                  flags2 & WASM_SYMBOL_TLS && customSection.tlsExports.add(symname)
                }
              } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
                for (var count$2 = getLEB(); count$2--;) {
                  var modname = getString(), symname = getString(), flags2 = getLEB()
                  ;(flags2 & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK
                    && customSection.weakImports.add(symname)
                }
              } else offset$3 += subsectionSize
            }
          }
          return customSection
        }, `getDylinkMetadata`)
      function getValue(ptr, type$2 = `i8`) {
        switch (type$2.endsWith(`*`) && (type$2 = `*`), type$2) {
          case `i1`:
            return HEAP8[ptr]
          case `i8`:
            return HEAP8[ptr]
          case `i16`:
            return LE_HEAP_LOAD_I16((ptr >> 1) * 2)
          case `i32`:
            return LE_HEAP_LOAD_I32((ptr >> 2) * 4)
          case `i64`:
            return HEAP64[ptr >> 3]
          case `float`:
            return LE_HEAP_LOAD_F32((ptr >> 2) * 4)
          case `double`:
            return LE_HEAP_LOAD_F64((ptr >> 3) * 8)
          case `*`:
            return LE_HEAP_LOAD_U32((ptr >> 2) * 4)
          default:
            abort(`invalid type for getValue: ${type$2}`)
        }
      }
      __name(getValue, `getValue`)
      var newDSO = __name((name2, handle2, syms) => {
          var dso = { refcount: 1 / 0, name: name2, exports: syms, global: !0 }
          return LDSO.loadedLibsByName[name2] = dso, handle2 != null && (LDSO.loadedLibsByHandle[handle2] = dso), dso
        }, `newDSO`),
        LDSO = {
          loadedLibsByName: {},
          loadedLibsByHandle: {},
          init() {
            newDSO(`__main__`, 0, wasmImports)
          },
        },
        ___heap_base = 78224,
        alignMemory = __name((size$14, alignment) => Math.ceil(size$14 / alignment) * alignment, `alignMemory`),
        getMemory = __name(size$14 => {
          if (runtimeInitialized) return _calloc(size$14, 1)
          var ret = ___heap_base, end$2 = ret + alignMemory(size$14, 16)
          return ___heap_base = end$2, GOT.__heap_base.value = end$2, ret
        }, `getMemory`),
        isInternalSym = __name(
          symName =>
            [
              `__cpp_exception`,
              `__c_longjmp`,
              `__wasm_apply_data_relocs`,
              `__dso_handle`,
              `__tls_size`,
              `__tls_align`,
              `__set_stack_limits`,
              `_emscripten_tls_init`,
              `__wasm_init_tls`,
              `__wasm_call_ctors`,
              `__start_em_asm`,
              `__stop_em_asm`,
              `__start_em_js`,
              `__stop_em_js`,
            ].includes(symName) || symName.startsWith(`__em_js__`),
          `isInternalSym`,
        ),
        uleb128Encode = __name((n$19, target) => {
          n$19 < 128 ? target.push(n$19) : target.push(n$19 % 128 | 128, n$19 >> 7)
        }, `uleb128Encode`),
        sigToWasmTypes = __name(sig => {
          for (
            var typeNames = { i: `i32`, j: `i64`, f: `f32`, d: `f64`, e: `externref`, p: `i32` },
              type$2 = { parameters: [], results: sig[0] == `v` ? [] : [typeNames[sig[0]]] },
              i2 = 1;
            i2 < sig.length;
            ++i2
          ) type$2.parameters.push(typeNames[sig[i2]])
          return type$2
        }, `sigToWasmTypes`),
        generateFuncType = __name((sig, target) => {
          var sigRet = sig.slice(0, 1),
            sigParam = sig.slice(1),
            typeCodes = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 }
          target.push(96), uleb128Encode(sigParam.length, target)
          for (var i2 = 0; i2 < sigParam.length; ++i2) target.push(typeCodes[sigParam[i2]])
          sigRet == `v` ? target.push(0) : target.push(1, typeCodes[sigRet])
        }, `generateFuncType`),
        convertJsFunctionToWasm = __name((func2, sig) => {
          if (typeof WebAssembly.Function == `function`) return new WebAssembly.Function(sigToWasmTypes(sig), func2)
          var typeSectionBody = [1]
          generateFuncType(sig, typeSectionBody)
          var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1]
          uleb128Encode(typeSectionBody.length, bytes),
            bytes.push(...typeSectionBody),
            bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0)
          var module2 = new WebAssembly.Module(new Uint8Array(bytes)),
            instance2 = new WebAssembly.Instance(module2, { e: { f: func2 } }),
            wrappedFunc = instance2.exports.f
          return wrappedFunc
        }, `convertJsFunctionToWasm`),
        wasmTableMirror = [],
        wasmTable = new WebAssembly.Table({ initial: 31, element: `anyfunc` }),
        getWasmTableEntry = __name(funcPtr => {
          var func2 = wasmTableMirror[funcPtr]
          return func2
            || (funcPtr >= wasmTableMirror.length && (wasmTableMirror.length = funcPtr + 1),
              wasmTableMirror[funcPtr] = func2 = wasmTable.get(funcPtr)),
            func2
        }, `getWasmTableEntry`),
        updateTableMap = __name((offset$3, count$2) => {
          if (functionsInTableMap) {
            for (var i2 = offset$3; i2 < offset$3 + count$2; i2++) {
              var item = getWasmTableEntry(i2)
              item && functionsInTableMap.set(item, i2)
            }
          }
        }, `updateTableMap`),
        functionsInTableMap,
        getFunctionAddress = __name(
          func2 => (functionsInTableMap || (functionsInTableMap = new WeakMap(), updateTableMap(0, wasmTable.length)),
            functionsInTableMap.get(func2) || 0),
          `getFunctionAddress`,
        ),
        freeTableIndexes = [],
        getEmptyTableSlot = __name(() => {
          if (freeTableIndexes.length) return freeTableIndexes.pop()
          try {
            wasmTable.grow(1)
          } catch (err2) {
            throw err2 instanceof RangeError ? `Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.` : err2
          }
          return wasmTable.length - 1
        }, `getEmptyTableSlot`),
        setWasmTableEntry = __name((idx, func2) => {
          wasmTable.set(idx, func2), wasmTableMirror[idx] = wasmTable.get(idx)
        }, `setWasmTableEntry`),
        addFunction = __name((func2, sig) => {
          var rtn = getFunctionAddress(func2)
          if (rtn) return rtn
          var ret = getEmptyTableSlot()
          try {
            setWasmTableEntry(ret, func2)
          } catch (err2) {
            if (!(err2 instanceof TypeError)) throw err2
            var wrapped = convertJsFunctionToWasm(func2, sig)
            setWasmTableEntry(ret, wrapped)
          }
          return functionsInTableMap.set(func2, ret), ret
        }, `addFunction`),
        updateGOT = __name((exports$1, replace$1) => {
          for (var symName in exports$1) {
            if (isInternalSym(symName)) continue
            var value$2 = exports$1[symName]
            GOT[symName] ||= new WebAssembly.Global({ value: `i32`, mutable: !0 }),
              (replace$1 || GOT[symName].value == 0)
              && (typeof value$2 == `function`
                ? GOT[symName].value = addFunction(value$2)
                : typeof value$2 == `number`
                ? GOT[symName].value = value$2
                : err(`unhandled export type for '${symName}': ${typeof value$2}`))
          }
        }, `updateGOT`),
        relocateExports = __name((exports$1, memoryBase2, replace$1) => {
          var relocated = {}
          for (var e$26 in exports$1) {
            var value$2 = exports$1[e$26]
            typeof value$2 == `object` && (value$2 = value$2.value),
              typeof value$2 == `number` && (value$2 += memoryBase2),
              relocated[e$26] = value$2
          }
          return updateGOT(relocated, replace$1), relocated
        }, `relocateExports`),
        isSymbolDefined = __name(symName => {
          var existing = wasmImports[symName]
          return !(!existing || existing.stub)
        }, `isSymbolDefined`),
        dynCall = __name((sig, ptr, args2 = []) => {
          var rtn = getWasmTableEntry(ptr)(...args2)
          return rtn
        }, `dynCall`),
        stackSave = __name(() => _emscripten_stack_get_current(), `stackSave`),
        stackRestore = __name(val => __emscripten_stack_restore(val), `stackRestore`),
        createInvokeFunction = __name(sig => (ptr, ...args2) => {
          var sp = stackSave()
          try {
            return dynCall(sig, ptr, args2)
          } catch (e$26) {
            if (stackRestore(sp), e$26 !== e$26 + 0) throw e$26
            if (_setThrew(1, 0), sig[0] == `j`) return 0n
          }
        }, `createInvokeFunction`),
        resolveGlobalSymbol = __name((symName, direct = !1) => {
          var sym
          return isSymbolDefined(symName)
            ? sym = wasmImports[symName]
            : symName.startsWith(`invoke_`)
              && (sym = wasmImports[symName] = createInvokeFunction(symName.split(`_`)[1])),
            { sym, name: symName }
        }, `resolveGlobalSymbol`),
        onPostCtors = [],
        addOnPostCtor = __name(cb => onPostCtors.unshift(cb), `addOnPostCtor`),
        UTF8ToString = __name(
          (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : ``,
          `UTF8ToString`,
        ),
        loadWebAssemblyModule = __name((binary, flags, libName, localScope, handle$2) => {
          var metadata = getDylinkMetadata(binary)
          currentModuleWeakSymbols = metadata.weakImports
          function loadModule() {
            var memAlign = 2 ** metadata.memoryAlign,
              memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0,
              tableBase = metadata.tableSize ? wasmTable.length : 0
            handle$2
            && (HEAP8[handle$2 + 8] = 1,
              LE_HEAP_STORE_U32((handle$2 + 12 >> 2) * 4, memoryBase),
              LE_HEAP_STORE_I32((handle$2 + 16 >> 2) * 4, metadata.memorySize),
              LE_HEAP_STORE_U32((handle$2 + 20 >> 2) * 4, tableBase),
              LE_HEAP_STORE_I32((handle$2 + 24 >> 2) * 4, metadata.tableSize)),
              metadata.tableSize && wasmTable.grow(metadata.tableSize)
            var moduleExports
            function resolveSymbol(sym) {
              var resolved = resolveGlobalSymbol(sym).sym
              return !resolved && localScope && (resolved = localScope[sym]), resolved ||= moduleExports[sym], resolved
            }
            __name(resolveSymbol, `resolveSymbol`)
            var proxyHandler = {
                get(stubs, prop) {
                  switch (prop) {
                    case `__memory_base`:
                      return memoryBase
                    case `__table_base`:
                      return tableBase
                  }
                  if (prop in wasmImports && !wasmImports[prop].stub) {
                    var res = wasmImports[prop]
                    return res
                  }
                  if (!(prop in stubs)) {
                    var resolved
                    stubs[prop] = (...args2) => (resolved ||= resolveSymbol(prop), resolved(...args2))
                  }
                  return stubs[prop]
                },
              },
              proxy$1 = new Proxy({}, proxyHandler),
              info = {
                'GOT.mem': new Proxy({}, GOTHandler),
                'GOT.func': new Proxy({}, GOTHandler),
                env: proxy$1,
                wasi_snapshot_preview1: proxy$1,
              }
            function postInstantiation(module$2, instance$1) {
              updateTableMap(tableBase, metadata.tableSize),
                moduleExports = relocateExports(instance$1.exports, memoryBase),
                flags.allowUndefined || reportUndefinedSymbols()
              function addEmAsm(addr, body$2) {
                for (var args$1 = [], arity = 0; arity < 16 && body$2.indexOf(`$` + arity) != -1; arity++) {
                  args$1.push(`$` + arity)
                }
                args$1 = args$1.join(`,`)
                var func = `(${args$1}) => { ${body$2} };`
                ASM_CONSTS[start$2] = eval(func)
              }
              if (__name(addEmAsm, `addEmAsm`), `__start_em_asm` in moduleExports) {
                for (var start$2 = moduleExports.__start_em_asm, stop = moduleExports.__stop_em_asm; start$2 < stop;) {
                  var jsString = UTF8ToString(start$2)
                  addEmAsm(start$2, jsString), start$2 = HEAPU8.indexOf(0, start$2) + 1
                }
              }
              function addEmJs(name$1, cSig, body$2) {
                var jsArgs = []
                if (cSig = cSig.slice(1, -1), cSig != `void`) {
                  for (var i$14 in cSig = cSig.split(`,`), cSig) {
                    var jsArg = cSig[i$14].split(` `).pop()
                    jsArgs.push(jsArg.replace(`*`, ``))
                  }
                }
                var func = `(${jsArgs}) => ${body$2};`
                moduleExports[name$1] = eval(func)
              }
              for (var name in __name(addEmJs, `addEmJs`), moduleExports) {
                if (name.startsWith(`__em_js__`)) {
                  var start$2 = moduleExports[name], jsString = UTF8ToString(start$2), parts$1 = jsString.split(`<::>`)
                  addEmJs(name.replace(`__em_js__`, ``), parts$1[0], parts$1[1]), delete moduleExports[name]
                }
              }
              var applyRelocs = moduleExports.__wasm_apply_data_relocs
              applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs))
              var init = moduleExports.__wasm_call_ctors
              return init && (runtimeInitialized ? init() : addOnPostCtor(init)), moduleExports
            }
            if (__name(postInstantiation, `postInstantiation`), flags.loadAsync) {
              if (binary instanceof WebAssembly.Module) {
                var instance = new WebAssembly.Instance(binary, info)
                return Promise.resolve(postInstantiation(binary, instance))
              }
              return WebAssembly.instantiate(binary, info).then(result =>
                postInstantiation(result.module, result.instance)
              )
            }
            var module$1 = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary),
              instance = new WebAssembly.Instance(module$1, info)
            return postInstantiation(module$1, instance)
          }
          return __name(loadModule, `loadModule`),
            flags.loadAsync
              ? metadata.neededDynlibs.reduce(
                (chain, dynNeeded) => chain.then(() => loadDynamicLibrary(dynNeeded, flags, localScope)),
                Promise.resolve(),
              ).then(loadModule)
              : (metadata.neededDynlibs.forEach(needed => loadDynamicLibrary(needed, flags, localScope)), loadModule())
        }, `loadWebAssemblyModule`),
        mergeLibSymbols = __name((exports$1, libName2) => {
          for (var [sym, exp] of Object.entries(exports$1)) {
            let setImport = __name(target => {
              isSymbolDefined(target) || (wasmImports[target] = exp)
            }, `setImport`)
            setImport(sym)
            let main_alias = `__main_argc_argv`
            sym == `main` && setImport(main_alias), sym == main_alias && setImport(`main`)
          }
        }, `mergeLibSymbols`),
        asyncLoad = __name(async url => {
          var arrayBuffer = await readAsync(url)
          return new Uint8Array(arrayBuffer)
        }, `asyncLoad`)
      function loadDynamicLibrary(libName2, flags2 = { global: !0, nodelete: !0 }, localScope2, handle2) {
        var dso = LDSO.loadedLibsByName[libName2]
        if (dso) {
          return flags2.global
            ? dso.global || (dso.global = !0, mergeLibSymbols(dso.exports, libName2))
            : localScope2 && Object.assign(localScope2, dso.exports),
            flags2.nodelete && dso.refcount !== 1 / 0 && (dso.refcount = 1 / 0),
            dso.refcount++,
            handle2 && (LDSO.loadedLibsByHandle[handle2] = dso),
            flags2.loadAsync ? Promise.resolve(!0) : !0
        }
        dso = newDSO(libName2, handle2, `loading`),
          dso.refcount = flags2.nodelete ? 1 / 0 : 1,
          dso.global = flags2.global
        function loadLibData() {
          if (handle2) {
            var data = LE_HEAP_LOAD_U32((handle2 + 28 >> 2) * 4), dataSize = LE_HEAP_LOAD_U32((handle2 + 32 >> 2) * 4)
            if (data && dataSize) {
              var libData = HEAP8.slice(data, data + dataSize)
              return flags2.loadAsync ? Promise.resolve(libData) : libData
            }
          }
          var libFile = locateFile(libName2)
          if (flags2.loadAsync) return asyncLoad(libFile)
          if (!readBinary) {
            throw Error(`${libFile}: file not found, and synchronous loading of external files is not available`)
          }
          return readBinary(libFile)
        }
        __name(loadLibData, `loadLibData`)
        function getExports() {
          return flags2.loadAsync
            ? loadLibData().then(libData => loadWebAssemblyModule(libData, flags2, libName2, localScope2, handle2))
            : loadWebAssemblyModule(loadLibData(), flags2, libName2, localScope2, handle2)
        }
        __name(getExports, `getExports`)
        function moduleLoaded(exports$1) {
          dso.global ? mergeLibSymbols(exports$1, libName2) : localScope2 && Object.assign(localScope2, exports$1),
            dso.exports = exports$1
        }
        return __name(moduleLoaded, `moduleLoaded`),
          flags2.loadAsync
            ? getExports().then(exports$1 => (moduleLoaded(exports$1), !0))
            : (moduleLoaded(getExports()), !0)
      }
      __name(loadDynamicLibrary, `loadDynamicLibrary`)
      var reportUndefinedSymbols = __name(() => {
          for (var [symName, entry] of Object.entries(GOT)) {
            if (entry.value == 0) {
              var value$2 = resolveGlobalSymbol(symName, !0).sym
              if (!value$2 && !entry.required) continue
              if (typeof value$2 == `function`) entry.value = addFunction(value$2, value$2.sig)
              else if (typeof value$2 == `number`) entry.value = value$2
              else throw Error(`bad export type for '${symName}': ${typeof value$2}`)
            }
          }
        }, `reportUndefinedSymbols`),
        loadDylibs = __name(() => {
          if (!dynamicLibraries.length) {
            reportUndefinedSymbols()
            return
          }
          addRunDependency(`loadDylibs`),
            dynamicLibraries.reduce(
              (chain, lib) =>
                chain.then(() =>
                  loadDynamicLibrary(lib, { loadAsync: !0, global: !0, nodelete: !0, allowUndefined: !0 })
                ),
              Promise.resolve(),
            ).then(() => {
              reportUndefinedSymbols(), removeRunDependency(`loadDylibs`)
            })
        }, `loadDylibs`),
        noExitRuntime = Module.noExitRuntime || !0
      function setValue(ptr, value$2, type$2 = `i8`) {
        switch (type$2.endsWith(`*`) && (type$2 = `*`), type$2) {
          case `i1`:
            HEAP8[ptr] = value$2
            break
          case `i8`:
            HEAP8[ptr] = value$2
            break
          case `i16`:
            LE_HEAP_STORE_I16((ptr >> 1) * 2, value$2)
            break
          case `i32`:
            LE_HEAP_STORE_I32((ptr >> 2) * 4, value$2)
            break
          case `i64`:
            HEAP64[ptr >> 3] = BigInt(value$2)
            break
          case `float`:
            LE_HEAP_STORE_F32((ptr >> 2) * 4, value$2)
            break
          case `double`:
            LE_HEAP_STORE_F64((ptr >> 3) * 8, value$2)
            break
          case `*`:
            LE_HEAP_STORE_U32((ptr >> 2) * 4, value$2)
            break
          default:
            abort(`invalid type for setValue: ${type$2}`)
        }
      }
      __name(setValue, `setValue`)
      var ___memory_base = new WebAssembly.Global({ value: `i32`, mutable: !1 }, 1024),
        ___stack_pointer = new WebAssembly.Global({ value: `i32`, mutable: !0 }, 78224),
        ___table_base = new WebAssembly.Global({ value: `i32`, mutable: !1 }, 1),
        __abort_js = __name(() => abort(``), `__abort_js`)
      __abort_js.sig = `v`
      var _emscripten_get_now = __name(() => performance.now(), `_emscripten_get_now`)
      _emscripten_get_now.sig = `d`
      var _emscripten_date_now = __name(() => Date.now(), `_emscripten_date_now`)
      _emscripten_date_now.sig = `d`
      var nowIsMonotonic = 1,
        checkWasiClock = __name(clock_id => clock_id >= 0 && clock_id <= 3, `checkWasiClock`),
        INT53_MAX = 9007199254740992,
        INT53_MIN = -9007199254740992,
        bigintToI53Checked = __name(num => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num), `bigintToI53Checked`)
      function _clock_time_get(clk_id, ignored_precision, ptime) {
        if (ignored_precision = bigintToI53Checked(ignored_precision), !checkWasiClock(clk_id)) return 28
        var now$1
        if (clk_id === 0) now$1 = _emscripten_date_now()
        else if (nowIsMonotonic) now$1 = _emscripten_get_now()
        else return 52
        var nsec = Math.round(now$1 * 1e3 * 1e3)
        return HEAP64[ptime >> 3] = BigInt(nsec), 0
      }
      __name(_clock_time_get, `_clock_time_get`), _clock_time_get.sig = `iijp`
      var getHeapMax = __name(() => 2147483648, `getHeapMax`),
        growMemory = __name(size$14 => {
          var b$3 = wasmMemory.buffer, pages$1 = (size$14 - b$3.byteLength + 65535) / 65536 | 0
          try {
            return wasmMemory.grow(pages$1), updateMemoryViews(), 1
          } catch {}
        }, `growMemory`),
        _emscripten_resize_heap = __name(requestedSize => {
          var oldSize = HEAPU8.length
          requestedSize >>>= 0
          var maxHeapSize = getHeapMax()
          if (requestedSize > maxHeapSize) return !1
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + .2 / cutDown)
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296)
            var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)),
              replacement = growMemory(newSize)
            if (replacement) return !0
          }
          return !1
        }, `_emscripten_resize_heap`)
      _emscripten_resize_heap.sig = `ip`
      var _fd_close = __name(fd => 52, `_fd_close`)
      _fd_close.sig = `ii`
      function _fd_seek(fd, offset$3, whence, newOffset) {
        return offset$3 = bigintToI53Checked(offset$3), 70
      }
      __name(_fd_seek, `_fd_seek`), _fd_seek.sig = `iijip`
      var printCharBuffers = [null, [], []],
        printChar = __name((stream, curr) => {
          var buffer = printCharBuffers[stream]
          curr === 0 || curr === 10
            ? ((stream === 1 ? out : err)(UTF8ArrayToString(buffer)), buffer.length = 0)
            : buffer.push(curr)
        }, `printChar`),
        flush_NO_FILESYSTEM = __name(() => {
          printCharBuffers[1].length && printChar(1, 10), printCharBuffers[2].length && printChar(2, 10)
        }, `flush_NO_FILESYSTEM`),
        SYSCALLS = {
          varargs: void 0,
          getStr(ptr) {
            var ret = UTF8ToString(ptr)
            return ret
          },
        },
        _fd_write = __name((fd, iov, iovcnt, pnum) => {
          for (var num = 0, i2 = 0; i2 < iovcnt; i2++) {
            var ptr = LE_HEAP_LOAD_U32((iov >> 2) * 4), len = LE_HEAP_LOAD_U32((iov + 4 >> 2) * 4)
            iov += 8
            for (var j$1 = 0; j$1 < len; j$1++) printChar(fd, HEAPU8[ptr + j$1])
            num += len
          }
          return LE_HEAP_STORE_U32((pnum >> 2) * 4, num), 0
        }, `_fd_write`)
      _fd_write.sig = `iippp`
      function _tree_sitter_log_callback(isLexMessage, messageAddress) {
        if (Module.currentLogCallback) {
          let message = UTF8ToString(messageAddress)
          Module.currentLogCallback(message, isLexMessage !== 0)
        }
      }
      __name(_tree_sitter_log_callback, `_tree_sitter_log_callback`)
      function _tree_sitter_parse_callback(inputBufferAddress, index$4, row, column, lengthAddress) {
        let INPUT_BUFFER_SIZE = 10 * 1024, string$5 = Module.currentParseCallback(index$4, { row, column })
        typeof string$5 == `string`
          ? (setValue(lengthAddress, string$5.length, `i32`),
            stringToUTF16(string$5, inputBufferAddress, INPUT_BUFFER_SIZE))
          : setValue(lengthAddress, 0, `i32`)
      }
      __name(_tree_sitter_parse_callback, `_tree_sitter_parse_callback`)
      function _tree_sitter_progress_callback(currentOffset, hasError) {
        return Module.currentProgressCallback ? Module.currentProgressCallback({ currentOffset, hasError }) : !1
      }
      __name(_tree_sitter_progress_callback, `_tree_sitter_progress_callback`)
      function _tree_sitter_query_progress_callback(currentOffset) {
        return Module.currentQueryProgressCallback ? Module.currentQueryProgressCallback({ currentOffset }) : !1
      }
      __name(_tree_sitter_query_progress_callback, `_tree_sitter_query_progress_callback`)
      var runtimeKeepaliveCounter = 0,
        keepRuntimeAlive = __name(() => noExitRuntime || runtimeKeepaliveCounter > 0, `keepRuntimeAlive`),
        _proc_exit = __name(code$3 => {
          EXITSTATUS = code$3,
            keepRuntimeAlive() || (Module.onExit?.(code$3), ABORT = !0),
            quit_(code$3, new ExitStatus(code$3))
        }, `_proc_exit`)
      _proc_exit.sig = `vi`
      var exitJS = __name((status$2, implicit) => {
          EXITSTATUS = status$2, _proc_exit(status$2)
        }, `exitJS`),
        handleException = __name(e$26 => {
          if (e$26 instanceof ExitStatus || e$26 == `unwind`) return EXITSTATUS
          quit_(1, e$26)
        }, `handleException`),
        lengthBytesUTF8 = __name(str => {
          for (var len = 0, i2 = 0; i2 < str.length; ++i2) {
            var c$3 = str.charCodeAt(i2)
            c$3 <= 127 ? len++ : c$3 <= 2047 ? len += 2 : c$3 >= 55296 && c$3 <= 57343 ? (len += 4, ++i2) : len += 3
          }
          return len
        }, `lengthBytesUTF8`),
        stringToUTF8Array = __name((str, heap, outIdx, maxBytesToWrite) => {
          if (!(maxBytesToWrite > 0)) return 0
          for (var startIdx = outIdx, endIdx = outIdx + maxBytesToWrite - 1, i2 = 0; i2 < str.length; ++i2) {
            var u$7 = str.charCodeAt(i2)
            if (u$7 >= 55296 && u$7 <= 57343) {
              var u1 = str.charCodeAt(++i2)
              u$7 = 65536 + ((u$7 & 1023) << 10) | u1 & 1023
            }
            if (u$7 <= 127) {
              if (outIdx >= endIdx) break
              heap[outIdx++] = u$7
            } else if (u$7 <= 2047) {
              if (outIdx + 1 >= endIdx) break
              heap[outIdx++] = 192 | u$7 >> 6, heap[outIdx++] = 128 | u$7 & 63
            } else if (u$7 <= 65535) {
              if (outIdx + 2 >= endIdx) break
              heap[outIdx++] = 224 | u$7 >> 12, heap[outIdx++] = 128 | u$7 >> 6 & 63, heap[outIdx++] = 128 | u$7 & 63
            } else {
              if (outIdx + 3 >= endIdx) break
              heap[outIdx++] = 240 | u$7 >> 18,
                heap[outIdx++] = 128 | u$7 >> 12 & 63,
                heap[outIdx++] = 128 | u$7 >> 6 & 63,
                heap[outIdx++] = 128 | u$7 & 63
            }
          }
          return heap[outIdx] = 0, outIdx - startIdx
        }, `stringToUTF8Array`),
        stringToUTF8 = __name(
          (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite),
          `stringToUTF8`,
        ),
        stackAlloc = __name(sz => __emscripten_stack_alloc(sz), `stackAlloc`),
        stringToUTF8OnStack = __name(str => {
          var size$14 = lengthBytesUTF8(str) + 1, ret = stackAlloc(size$14)
          return stringToUTF8(str, ret, size$14), ret
        }, `stringToUTF8OnStack`),
        AsciiToString = __name(ptr => {
          for (var str = ``;;) {
            var ch = HEAPU8[ptr++]
            if (!ch) return str
            str += String.fromCharCode(ch)
          }
        }, `AsciiToString`),
        stringToUTF16 = __name((str, outPtr, maxBytesToWrite) => {
          if (maxBytesToWrite ??= 2147483647, maxBytesToWrite < 2) return 0
          maxBytesToWrite -= 2
          for (
            var startPtr = outPtr,
              numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length,
              i2 = 0;
            i2 < numCharsToWrite;
            ++i2
          ) {
            var codeUnit = str.charCodeAt(i2)
            LE_HEAP_STORE_I16((outPtr >> 1) * 2, codeUnit), outPtr += 2
          }
          return LE_HEAP_STORE_I16((outPtr >> 1) * 2, 0), outPtr - startPtr
        }, `stringToUTF16`),
        wasmImports = {
          __heap_base: ___heap_base,
          __indirect_function_table: wasmTable,
          __memory_base: ___memory_base,
          __stack_pointer: ___stack_pointer,
          __table_base: ___table_base,
          _abort_js: __abort_js,
          clock_time_get: _clock_time_get,
          emscripten_resize_heap: _emscripten_resize_heap,
          fd_close: _fd_close,
          fd_seek: _fd_seek,
          fd_write: _fd_write,
          memory: wasmMemory,
          tree_sitter_log_callback: _tree_sitter_log_callback,
          tree_sitter_parse_callback: _tree_sitter_parse_callback,
          tree_sitter_progress_callback: _tree_sitter_progress_callback,
          tree_sitter_query_progress_callback: _tree_sitter_query_progress_callback,
        },
        wasmExports = await createWasm(),
        ___wasm_call_ctors = wasmExports.__wasm_call_ctors,
        _malloc = Module._malloc = wasmExports.malloc,
        _calloc = Module._calloc = wasmExports.calloc,
        _realloc = Module._realloc = wasmExports.realloc,
        _free = Module._free = wasmExports.free,
        _memcmp = Module._memcmp = wasmExports.memcmp,
        _ts_language_symbol_count = Module._ts_language_symbol_count = wasmExports.ts_language_symbol_count,
        _ts_language_state_count = Module._ts_language_state_count = wasmExports.ts_language_state_count,
        _ts_language_version = Module._ts_language_version = wasmExports.ts_language_version,
        _ts_language_abi_version = Module._ts_language_abi_version = wasmExports.ts_language_abi_version,
        _ts_language_metadata = Module._ts_language_metadata = wasmExports.ts_language_metadata,
        _ts_language_name = Module._ts_language_name = wasmExports.ts_language_name,
        _ts_language_field_count = Module._ts_language_field_count = wasmExports.ts_language_field_count,
        _ts_language_next_state = Module._ts_language_next_state = wasmExports.ts_language_next_state,
        _ts_language_symbol_name = Module._ts_language_symbol_name = wasmExports.ts_language_symbol_name,
        _ts_language_symbol_for_name = Module._ts_language_symbol_for_name = wasmExports.ts_language_symbol_for_name,
        _strncmp = Module._strncmp = wasmExports.strncmp,
        _ts_language_symbol_type = Module._ts_language_symbol_type = wasmExports.ts_language_symbol_type,
        _ts_language_field_name_for_id = Module._ts_language_field_name_for_id =
          wasmExports.ts_language_field_name_for_id,
        _ts_lookahead_iterator_new = Module._ts_lookahead_iterator_new = wasmExports.ts_lookahead_iterator_new,
        _ts_lookahead_iterator_delete = Module._ts_lookahead_iterator_delete = wasmExports.ts_lookahead_iterator_delete,
        _ts_lookahead_iterator_reset_state = Module._ts_lookahead_iterator_reset_state =
          wasmExports.ts_lookahead_iterator_reset_state,
        _ts_lookahead_iterator_reset = Module._ts_lookahead_iterator_reset = wasmExports.ts_lookahead_iterator_reset,
        _ts_lookahead_iterator_next = Module._ts_lookahead_iterator_next = wasmExports.ts_lookahead_iterator_next,
        _ts_lookahead_iterator_current_symbol = Module._ts_lookahead_iterator_current_symbol =
          wasmExports.ts_lookahead_iterator_current_symbol,
        _ts_parser_delete = Module._ts_parser_delete = wasmExports.ts_parser_delete,
        _ts_parser_reset = Module._ts_parser_reset = wasmExports.ts_parser_reset,
        _ts_parser_set_language = Module._ts_parser_set_language = wasmExports.ts_parser_set_language,
        _ts_parser_timeout_micros = Module._ts_parser_timeout_micros = wasmExports.ts_parser_timeout_micros,
        _ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = wasmExports.ts_parser_set_timeout_micros,
        _ts_parser_set_included_ranges = Module._ts_parser_set_included_ranges =
          wasmExports.ts_parser_set_included_ranges,
        _ts_query_new = Module._ts_query_new = wasmExports.ts_query_new,
        _ts_query_delete = Module._ts_query_delete = wasmExports.ts_query_delete,
        _iswspace = Module._iswspace = wasmExports.iswspace,
        _iswalnum = Module._iswalnum = wasmExports.iswalnum,
        _ts_query_pattern_count = Module._ts_query_pattern_count = wasmExports.ts_query_pattern_count,
        _ts_query_capture_count = Module._ts_query_capture_count = wasmExports.ts_query_capture_count,
        _ts_query_string_count = Module._ts_query_string_count = wasmExports.ts_query_string_count,
        _ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = wasmExports.ts_query_capture_name_for_id,
        _ts_query_capture_quantifier_for_id = Module._ts_query_capture_quantifier_for_id =
          wasmExports.ts_query_capture_quantifier_for_id,
        _ts_query_string_value_for_id = Module._ts_query_string_value_for_id = wasmExports.ts_query_string_value_for_id,
        _ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern =
          wasmExports.ts_query_predicates_for_pattern,
        _ts_query_start_byte_for_pattern = Module._ts_query_start_byte_for_pattern =
          wasmExports.ts_query_start_byte_for_pattern,
        _ts_query_end_byte_for_pattern = Module._ts_query_end_byte_for_pattern =
          wasmExports.ts_query_end_byte_for_pattern,
        _ts_query_is_pattern_rooted = Module._ts_query_is_pattern_rooted = wasmExports.ts_query_is_pattern_rooted,
        _ts_query_is_pattern_non_local = Module._ts_query_is_pattern_non_local =
          wasmExports.ts_query_is_pattern_non_local,
        _ts_query_is_pattern_guaranteed_at_step = Module._ts_query_is_pattern_guaranteed_at_step =
          wasmExports.ts_query_is_pattern_guaranteed_at_step,
        _ts_query_disable_capture = Module._ts_query_disable_capture = wasmExports.ts_query_disable_capture,
        _ts_query_disable_pattern = Module._ts_query_disable_pattern = wasmExports.ts_query_disable_pattern,
        _ts_tree_copy = Module._ts_tree_copy = wasmExports.ts_tree_copy,
        _ts_tree_delete = Module._ts_tree_delete = wasmExports.ts_tree_delete,
        _ts_init = Module._ts_init = wasmExports.ts_init,
        _ts_parser_new_wasm = Module._ts_parser_new_wasm = wasmExports.ts_parser_new_wasm,
        _ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = wasmExports.ts_parser_enable_logger_wasm,
        _ts_parser_parse_wasm = Module._ts_parser_parse_wasm = wasmExports.ts_parser_parse_wasm,
        _ts_parser_included_ranges_wasm = Module._ts_parser_included_ranges_wasm =
          wasmExports.ts_parser_included_ranges_wasm,
        _ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm =
          wasmExports.ts_language_type_is_named_wasm,
        _ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm =
          wasmExports.ts_language_type_is_visible_wasm,
        _ts_language_supertypes_wasm = Module._ts_language_supertypes_wasm = wasmExports.ts_language_supertypes_wasm,
        _ts_language_subtypes_wasm = Module._ts_language_subtypes_wasm = wasmExports.ts_language_subtypes_wasm,
        _ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = wasmExports.ts_tree_root_node_wasm,
        _ts_tree_root_node_with_offset_wasm = Module._ts_tree_root_node_with_offset_wasm =
          wasmExports.ts_tree_root_node_with_offset_wasm,
        _ts_tree_edit_wasm = Module._ts_tree_edit_wasm = wasmExports.ts_tree_edit_wasm,
        _ts_tree_included_ranges_wasm = Module._ts_tree_included_ranges_wasm = wasmExports.ts_tree_included_ranges_wasm,
        _ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm =
          wasmExports.ts_tree_get_changed_ranges_wasm,
        _ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = wasmExports.ts_tree_cursor_new_wasm,
        _ts_tree_cursor_copy_wasm = Module._ts_tree_cursor_copy_wasm = wasmExports.ts_tree_cursor_copy_wasm,
        _ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = wasmExports.ts_tree_cursor_delete_wasm,
        _ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = wasmExports.ts_tree_cursor_reset_wasm,
        _ts_tree_cursor_reset_to_wasm = Module._ts_tree_cursor_reset_to_wasm = wasmExports.ts_tree_cursor_reset_to_wasm,
        _ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm =
          wasmExports.ts_tree_cursor_goto_first_child_wasm,
        _ts_tree_cursor_goto_last_child_wasm = Module._ts_tree_cursor_goto_last_child_wasm =
          wasmExports.ts_tree_cursor_goto_last_child_wasm,
        _ts_tree_cursor_goto_first_child_for_index_wasm = Module._ts_tree_cursor_goto_first_child_for_index_wasm =
          wasmExports.ts_tree_cursor_goto_first_child_for_index_wasm,
        _ts_tree_cursor_goto_first_child_for_position_wasm = Module._ts_tree_cursor_goto_first_child_for_position_wasm =
          wasmExports.ts_tree_cursor_goto_first_child_for_position_wasm,
        _ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm =
          wasmExports.ts_tree_cursor_goto_next_sibling_wasm,
        _ts_tree_cursor_goto_previous_sibling_wasm = Module._ts_tree_cursor_goto_previous_sibling_wasm =
          wasmExports.ts_tree_cursor_goto_previous_sibling_wasm,
        _ts_tree_cursor_goto_descendant_wasm = Module._ts_tree_cursor_goto_descendant_wasm =
          wasmExports.ts_tree_cursor_goto_descendant_wasm,
        _ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm =
          wasmExports.ts_tree_cursor_goto_parent_wasm,
        _ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm =
          wasmExports.ts_tree_cursor_current_node_type_id_wasm,
        _ts_tree_cursor_current_node_state_id_wasm = Module._ts_tree_cursor_current_node_state_id_wasm =
          wasmExports.ts_tree_cursor_current_node_state_id_wasm,
        _ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm =
          wasmExports.ts_tree_cursor_current_node_is_named_wasm,
        _ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm =
          wasmExports.ts_tree_cursor_current_node_is_missing_wasm,
        _ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm =
          wasmExports.ts_tree_cursor_current_node_id_wasm,
        _ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm =
          wasmExports.ts_tree_cursor_start_position_wasm,
        _ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm =
          wasmExports.ts_tree_cursor_end_position_wasm,
        _ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm =
          wasmExports.ts_tree_cursor_start_index_wasm,
        _ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm =
          wasmExports.ts_tree_cursor_end_index_wasm,
        _ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm =
          wasmExports.ts_tree_cursor_current_field_id_wasm,
        _ts_tree_cursor_current_depth_wasm = Module._ts_tree_cursor_current_depth_wasm =
          wasmExports.ts_tree_cursor_current_depth_wasm,
        _ts_tree_cursor_current_descendant_index_wasm = Module._ts_tree_cursor_current_descendant_index_wasm =
          wasmExports.ts_tree_cursor_current_descendant_index_wasm,
        _ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm =
          wasmExports.ts_tree_cursor_current_node_wasm,
        _ts_node_symbol_wasm = Module._ts_node_symbol_wasm = wasmExports.ts_node_symbol_wasm,
        _ts_node_field_name_for_child_wasm = Module._ts_node_field_name_for_child_wasm =
          wasmExports.ts_node_field_name_for_child_wasm,
        _ts_node_field_name_for_named_child_wasm = Module._ts_node_field_name_for_named_child_wasm =
          wasmExports.ts_node_field_name_for_named_child_wasm,
        _ts_node_children_by_field_id_wasm = Module._ts_node_children_by_field_id_wasm =
          wasmExports.ts_node_children_by_field_id_wasm,
        _ts_node_first_child_for_byte_wasm = Module._ts_node_first_child_for_byte_wasm =
          wasmExports.ts_node_first_child_for_byte_wasm,
        _ts_node_first_named_child_for_byte_wasm = Module._ts_node_first_named_child_for_byte_wasm =
          wasmExports.ts_node_first_named_child_for_byte_wasm,
        _ts_node_grammar_symbol_wasm = Module._ts_node_grammar_symbol_wasm = wasmExports.ts_node_grammar_symbol_wasm,
        _ts_node_child_count_wasm = Module._ts_node_child_count_wasm = wasmExports.ts_node_child_count_wasm,
        _ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm =
          wasmExports.ts_node_named_child_count_wasm,
        _ts_node_child_wasm = Module._ts_node_child_wasm = wasmExports.ts_node_child_wasm,
        _ts_node_named_child_wasm = Module._ts_node_named_child_wasm = wasmExports.ts_node_named_child_wasm,
        _ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm =
          wasmExports.ts_node_child_by_field_id_wasm,
        _ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = wasmExports.ts_node_next_sibling_wasm,
        _ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = wasmExports.ts_node_prev_sibling_wasm,
        _ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm =
          wasmExports.ts_node_next_named_sibling_wasm,
        _ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm =
          wasmExports.ts_node_prev_named_sibling_wasm,
        _ts_node_descendant_count_wasm = Module._ts_node_descendant_count_wasm =
          wasmExports.ts_node_descendant_count_wasm,
        _ts_node_parent_wasm = Module._ts_node_parent_wasm = wasmExports.ts_node_parent_wasm,
        _ts_node_child_with_descendant_wasm = Module._ts_node_child_with_descendant_wasm =
          wasmExports.ts_node_child_with_descendant_wasm,
        _ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm =
          wasmExports.ts_node_descendant_for_index_wasm,
        _ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm =
          wasmExports.ts_node_named_descendant_for_index_wasm,
        _ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm =
          wasmExports.ts_node_descendant_for_position_wasm,
        _ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm =
          wasmExports.ts_node_named_descendant_for_position_wasm,
        _ts_node_start_point_wasm = Module._ts_node_start_point_wasm = wasmExports.ts_node_start_point_wasm,
        _ts_node_end_point_wasm = Module._ts_node_end_point_wasm = wasmExports.ts_node_end_point_wasm,
        _ts_node_start_index_wasm = Module._ts_node_start_index_wasm = wasmExports.ts_node_start_index_wasm,
        _ts_node_end_index_wasm = Module._ts_node_end_index_wasm = wasmExports.ts_node_end_index_wasm,
        _ts_node_to_string_wasm = Module._ts_node_to_string_wasm = wasmExports.ts_node_to_string_wasm,
        _ts_node_children_wasm = Module._ts_node_children_wasm = wasmExports.ts_node_children_wasm,
        _ts_node_named_children_wasm = Module._ts_node_named_children_wasm = wasmExports.ts_node_named_children_wasm,
        _ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm =
          wasmExports.ts_node_descendants_of_type_wasm,
        _ts_node_is_named_wasm = Module._ts_node_is_named_wasm = wasmExports.ts_node_is_named_wasm,
        _ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = wasmExports.ts_node_has_changes_wasm,
        _ts_node_has_error_wasm = Module._ts_node_has_error_wasm = wasmExports.ts_node_has_error_wasm,
        _ts_node_is_error_wasm = Module._ts_node_is_error_wasm = wasmExports.ts_node_is_error_wasm,
        _ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = wasmExports.ts_node_is_missing_wasm,
        _ts_node_is_extra_wasm = Module._ts_node_is_extra_wasm = wasmExports.ts_node_is_extra_wasm,
        _ts_node_parse_state_wasm = Module._ts_node_parse_state_wasm = wasmExports.ts_node_parse_state_wasm,
        _ts_node_next_parse_state_wasm = Module._ts_node_next_parse_state_wasm =
          wasmExports.ts_node_next_parse_state_wasm,
        _ts_query_matches_wasm = Module._ts_query_matches_wasm = wasmExports.ts_query_matches_wasm,
        _ts_query_captures_wasm = Module._ts_query_captures_wasm = wasmExports.ts_query_captures_wasm,
        _memset = Module._memset = wasmExports.memset,
        _memcpy = Module._memcpy = wasmExports.memcpy,
        _memmove = Module._memmove = wasmExports.memmove,
        _iswalpha = Module._iswalpha = wasmExports.iswalpha,
        _iswblank = Module._iswblank = wasmExports.iswblank,
        _iswdigit = Module._iswdigit = wasmExports.iswdigit,
        _iswlower = Module._iswlower = wasmExports.iswlower,
        _iswupper = Module._iswupper = wasmExports.iswupper,
        _iswxdigit = Module._iswxdigit = wasmExports.iswxdigit,
        _memchr = Module._memchr = wasmExports.memchr,
        _strlen = Module._strlen = wasmExports.strlen,
        _strcmp = Module._strcmp = wasmExports.strcmp,
        _strncat = Module._strncat = wasmExports.strncat,
        _strncpy = Module._strncpy = wasmExports.strncpy,
        _towlower = Module._towlower = wasmExports.towlower,
        _towupper = Module._towupper = wasmExports.towupper,
        _setThrew = wasmExports.setThrew,
        __emscripten_stack_restore = wasmExports._emscripten_stack_restore,
        __emscripten_stack_alloc = wasmExports._emscripten_stack_alloc,
        _emscripten_stack_get_current = wasmExports.emscripten_stack_get_current,
        ___wasm_apply_data_relocs = wasmExports.__wasm_apply_data_relocs
      Module.setValue = setValue,
        Module.getValue = getValue,
        Module.UTF8ToString = UTF8ToString,
        Module.stringToUTF8 = stringToUTF8,
        Module.lengthBytesUTF8 = lengthBytesUTF8,
        Module.AsciiToString = AsciiToString,
        Module.stringToUTF16 = stringToUTF16,
        Module.loadWebAssemblyModule = loadWebAssemblyModule
      function callMain(args2 = []) {
        var entryFunction = resolveGlobalSymbol(`main`).sym
        if (entryFunction) {
          args2.unshift(thisProgram)
          var argc = args2.length, argv = stackAlloc((argc + 1) * 4), argv_ptr = argv
          args2.forEach(arg => {
            LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, stringToUTF8OnStack(arg)), argv_ptr += 4
          }), LE_HEAP_STORE_U32((argv_ptr >> 2) * 4, 0)
          try {
            var ret = entryFunction(argc, argv)
            return exitJS(ret, !0), ret
          } catch (e$26) {
            return handleException(e$26)
          }
        }
      }
      __name(callMain, `callMain`)
      function run(args2 = arguments_) {
        if (runDependencies > 0) {
          dependenciesFulfilled = run
          return
        }
        if (preRun(), runDependencies > 0) {
          dependenciesFulfilled = run
          return
        }
        function doRun() {
          if (Module.calledRun = !0, !ABORT) {
            initRuntime(), readyPromiseResolve(Module), Module.onRuntimeInitialized?.()
            var noInitialRun = Module.noInitialRun
            noInitialRun || callMain(args2), postRun()
          }
        }
        __name(doRun, `doRun`),
          Module.setStatus
            ? (Module.setStatus(`Running...`),
              setTimeout(() => {
                setTimeout(() => Module.setStatus(``), 1), doRun()
              }, 1))
            : doRun()
      }
      if (__name(run, `run`), Module.preInit) {
        for (typeof Module.preInit == `function` && (Module.preInit = [Module.preInit]); Module.preInit.length > 0;) {
          Module.preInit.pop()()
        }
      }
      return run(), moduleRtn = readyPromise, moduleRtn
    }
  })(),
  tree_sitter_default$1 = Module2,
  Module3 = null
async function initializeBinding(moduleOptions) {
  return Module3 ||= await tree_sitter_default$1(moduleOptions), Module3
}
__name(initializeBinding, `initializeBinding`)
function checkModule() {
  return !!Module3
}
__name(checkModule, `checkModule`)
var TRANSFER_BUFFER,
  LANGUAGE_VERSION,
  MIN_COMPATIBLE_VERSION,
  Parser = class {
    static {
      __name(this, `Parser`)
    }
    0 = 0
    1 = 0
    logCallback = null
    language = null
    static async init(moduleOptions) {
      setModule(await initializeBinding(moduleOptions)),
        TRANSFER_BUFFER = C._ts_init(),
        LANGUAGE_VERSION = C.getValue(TRANSFER_BUFFER, `i32`),
        MIN_COMPATIBLE_VERSION = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`)
    }
    constructor() {
      this.initialize()
    }
    initialize() {
      if (!checkModule()) throw Error('cannot construct a Parser before calling `init()`')
      C._ts_parser_new_wasm(),
        this[0] = C.getValue(TRANSFER_BUFFER, `i32`),
        this[1] = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`)
    }
    delete() {
      C._ts_parser_delete(this[0]), C._free(this[1]), this[0] = 0, this[1] = 0
    }
    setLanguage(language) {
      let address
      if (!language) address = 0, this.language = null
      else if (language.constructor === Language) {
        address = language[0]
        let version = C._ts_language_version(address)
        if (version < MIN_COMPATIBLE_VERSION || LANGUAGE_VERSION < version) {
          throw Error(
            `Incompatible language version ${version}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${LANGUAGE_VERSION}.`,
          )
        }
        this.language = language
      } else throw Error(`Argument must be a Language`)
      return C._ts_parser_set_language(this[0], address), this
    }
    parse(callback, oldTree, options$2) {
      if (typeof callback == `string`) C.currentParseCallback = index$4 => callback.slice(index$4)
      else if (typeof callback == `function`) C.currentParseCallback = callback
      else throw Error(`Argument must be a string or a function`)
      options$2?.progressCallback
        ? C.currentProgressCallback = options$2.progressCallback
        : C.currentProgressCallback = null,
        this.logCallback
          ? (C.currentLogCallback = this.logCallback, C._ts_parser_enable_logger_wasm(this[0], 1))
          : (C.currentLogCallback = null, C._ts_parser_enable_logger_wasm(this[0], 0))
      let rangeCount = 0, rangeAddress = 0
      if (options$2?.includedRanges) {
        rangeCount = options$2.includedRanges.length, rangeAddress = C._calloc(rangeCount, SIZE_OF_RANGE)
        let address = rangeAddress
        for (let i2 = 0; i2 < rangeCount; i2++) {
          marshalRange(address, options$2.includedRanges[i2]), address += SIZE_OF_RANGE
        }
      }
      let treeAddress = C._ts_parser_parse_wasm(this[0], this[1], oldTree ? oldTree[0] : 0, rangeAddress, rangeCount)
      if (!treeAddress) {
        return C.currentParseCallback = null, C.currentLogCallback = null, C.currentProgressCallback = null, null
      }
      if (!this.language) throw Error(`Parser must have a language to parse`)
      let result = new Tree(INTERNAL, treeAddress, this.language, C.currentParseCallback)
      return C.currentParseCallback = null, C.currentLogCallback = null, C.currentProgressCallback = null, result
    }
    reset() {
      C._ts_parser_reset(this[0])
    }
    getIncludedRanges() {
      C._ts_parser_included_ranges_wasm(this[0])
      let count$2 = C.getValue(TRANSFER_BUFFER, `i32`),
        buffer = C.getValue(TRANSFER_BUFFER + SIZE_OF_INT, `i32`),
        result = Array(count$2)
      if (count$2 > 0) {
        let address = buffer
        for (let i2 = 0; i2 < count$2; i2++) result[i2] = unmarshalRange(address), address += SIZE_OF_RANGE
        C._free(buffer)
      }
      return result
    }
    getTimeoutMicros() {
      return C._ts_parser_timeout_micros(this[0])
    }
    setTimeoutMicros(timeout$2) {
      C._ts_parser_set_timeout_micros(this[0], 0, timeout$2)
    }
    setLogger(callback) {
      if (!callback) this.logCallback = null
      else if (typeof callback != `function`) throw Error(`Logger callback must be a function`)
      else this.logCallback = callback
      return this
    }
    getLogger() {
      return this.logCallback
    }
  },
  tree_sitter_default = `/assets/tree-sitter-DJBnMkmj.wasm`
function isKeywordNodeType(type$2) {
  return type$2 === `query` || type$2 === `mutation` || type$2 === `subscription` || type$2 === `fragment`
    || type$2 === `on`
}
function isPunctuationNodeType(type$2) {
  return [`{`, `}`, `(`, `)`, `[`, `]`, `:`, `=`, `,`, `!`, `|`, `&`, `@`, `...`, `$`].includes(type$2)
}
var UnifiedToken = class {
  treeSitterNode
  semantic
  polen
  highlighter
  codeHike
  _text
  _start
  _end
  _nodeType
  constructor(treeSitterNode, semantic, annotations$2) {
    this.treeSitterNode = treeSitterNode,
      this.semantic = semantic,
      this._text = treeSitterNode.text,
      this._start = treeSitterNode.startIndex,
      this._end = treeSitterNode.endIndex,
      this._nodeType = treeSitterNode.type,
      this.codeHike = { annotations: annotations$2 },
      this.polen = { isInteractive: () => this._isInteractive(), getReferenceUrl: () => this._getReferenceUrl() },
      this.highlighter = { getCssClass: () => this._getCssClass() }
  }
  get text() {
    return this._text
  }
  get start() {
    return this._start
  }
  get end() {
    return this._end
  }
  _getCssClass() {
    let nodeType = this._nodeType
    if (nodeType === `error_hint`) return `graphql-error-hint`
    if (nodeType === `comment` || nodeType === `description`) return `graphql-comment`
    if (isKeywordNodeType(nodeType)) return `graphql-keyword`
    if (nodeType === `string_value`) return `graphql-string`
    if (nodeType === `int_value` || nodeType === `float_value`) return `graphql-number`
    if (isPunctuationNodeType(nodeType)) return `graphql-punctuation`
    if (nodeType === `name`) {
      if (this.semantic && `kind` in this.semantic && this.semantic.kind === `InvalidField`) {
        return `graphql-field-error`
      }
      if (isOutputField$1(this.semantic) || isInputField(this.semantic)) return `graphql-field-interactive`
      if (
        this.semantic instanceof GraphQLObjectType || this.semantic instanceof GraphQLScalarType
        || this.semantic instanceof GraphQLInterfaceType
      ) return `graphql-type-interactive`
      if (isVariable(this.semantic)) return `graphql-variable`
      if (isOperation(this.semantic)) return `graphql-operation`
      if (isFragment(this.semantic)) return `graphql-fragment`
      if (isArgument(this.semantic)) return `graphql-argument`
    }
    return nodeType === `variable` ? `graphql-variable` : `graphql-text`
  }
  _isInteractive() {
    return this.semantic
      ? isOutputField$1(this.semantic) || isInputField(this.semantic) || isArgument(this.semantic)
        || isInvalidField(this.semantic) || this.semantic instanceof GraphQLObjectType
        || this.semantic instanceof GraphQLScalarType || this.semantic instanceof GraphQLInterfaceType
        || this.semantic instanceof GraphQLUnionType || this.semantic instanceof GraphQLEnumType
        || this.semantic instanceof GraphQLInputObjectType
      : !1
  }
  _getReferenceUrl() {
    if (!this.semantic) return null
    if (isArgument(this.semantic)) {
      let basePath = createReferencePath({ type: this.semantic.parentType.name })
      return `${basePath}#${this.semantic.parentField.name}__${this.semantic.argumentDef.name}`
    }
    if (isOutputField$1(this.semantic)) {
      let basePath = createReferencePath({ type: this.semantic.parentType.name })
      return `${basePath}#${this.semantic.fieldDef.name}`
    }
    if (isInputField(this.semantic)) {
      let basePath = createReferencePath({ type: this.semantic.parentType.name })
      return `${basePath}#${this.semantic.fieldDef.name}`
    }
    return this.semantic instanceof GraphQLObjectType || this.semantic instanceof GraphQLScalarType
        || this.semantic instanceof GraphQLInterfaceType || this.semantic instanceof GraphQLUnionType
        || this.semantic instanceof GraphQLEnumType || this.semantic instanceof GraphQLInputObjectType
      ? createReferencePath({ type: this.semantic.name })
      : null
  }
}
let parserPromise = null
var SyntheticNode = class {
    type
    _text
    _startIndex
    _endIndex
    constructor(type$2, _text, _startIndex, _endIndex) {
      this.type = type$2, this._text = _text, this._startIndex = _startIndex, this._endIndex = _endIndex
    }
    get text() {
      return this._text
    }
    get startIndex() {
      return this._startIndex
    }
    get endIndex() {
      return this._endIndex
    }
    get childCount() {
      return 0
    }
    get parent() {
      return null
    }
  },
  SemanticContext = class {
    typeStack = []
    operationType = null
    schema
    constructor(schema) {
      this.schema = schema
    }
    enterOperation(type$2) {
      this.operationType = type$2
      let rootType = type$2 === `query`
        ? this.schema.getQueryType()
        : type$2 === `mutation`
        ? this.schema.getMutationType()
        : type$2 === `subscription`
        ? this.schema.getSubscriptionType()
        : null
      rootType && (this.typeStack = [{ type: rootType }])
    }
    enterFragment(typeName) {
      let type$2 = this.schema.getType(typeName)
      type$2 && (isObjectType(type$2) || isInterfaceType(type$2)) && (this.typeStack = [{ type: type$2 }])
    }
    getFieldInfo(fieldName) {
      let current = this.typeStack[this.typeStack.length - 1]
      if (!current) return null
      let fields = current.type.getFields(), fieldDef = fields[fieldName]
      return fieldDef ? { parentType: current.type, fieldDef } : null
    }
    enterField(fieldName) {
      let fieldInfo = this.getFieldInfo(fieldName)
      if (fieldInfo) {
        let fieldType = getNamedType(fieldInfo.fieldDef.type)
        ;(isObjectType(fieldType) || isInterfaceType(fieldType))
          && this.typeStack.push({ type: fieldType, field: fieldInfo.fieldDef })
      }
    }
    exitField() {
      if (this.typeStack.length > 1) {
        let last$3 = this.typeStack[this.typeStack.length - 1]
        last$3 && last$3.field && this.typeStack.pop()
      }
    }
    getArgumentInfo(argName) {
      let current = this.typeStack[this.typeStack.length - 1]
      if (!current?.field) return null
      let arg = current.field.args.find(a$22 => a$22.name === argName)
      return arg ? { field: current.field, arg, parentType: current.type } : null
    }
    getCurrentType() {
      let current = this.typeStack[this.typeStack.length - 1]
      return current?.type || null
    }
    lookupType(typeName) {
      return this.schema.getType(typeName)
    }
    reset() {
      this.typeStack = [], this.operationType = null
    }
  }
const makeParseError = {
  invalidInput: message => ({ _tag: `InvalidInput`, message }),
  documentTooLarge: (maxSize, actualSize) => ({ _tag: `DocumentTooLarge`, maxSize, actualSize }),
  treeSitterError: message => ({ _tag: `TreeSitterError`, message }),
  parserInitError: message => ({ _tag: `ParserInitError`, message }),
}
async function parseGraphQLWithTreeSitterEither(code$3, annotations$2 = [], schema) {
  if (!code$3 || typeof code$3 != `string`) {
    return left(makeParseError.invalidInput(`Invalid GraphQL code: code must be a non-empty string`))
  }
  let maxSize = 1e5
  if (code$3.length > maxSize) return left(makeParseError.documentTooLarge(maxSize, code$3.length))
  let parser
  try {
    parser = await getParser()
  } catch (error) {
    return left(makeParseError.parserInitError(error instanceof Error ? error.message : `Failed to initialize parser`))
  }
  let tree = parser.parse(code$3)
  if (!tree) return left(makeParseError.treeSitterError(`Tree-sitter failed to parse GraphQL code`))
  try {
    let tokens = collectTokensWithSemantics(tree, code$3, schema, annotations$2),
      tokensWithHints = addErrorHintTokens(tokens, code$3, annotations$2)
    return right(tokensWithHints)
  } catch (error) {
    return left(makeParseError.treeSitterError(error instanceof Error ? error.message : `Failed to process tokens`))
  } finally {
    tree.delete()
  }
}
async function parseGraphQLWithTreeSitter(code$3, annotations$2 = [], schema) {
  let result = await parseGraphQLWithTreeSitterEither(code$3, annotations$2, schema)
  if (isLeft(result)) {
    let error = result.left
    switch (error._tag) {
      case `InvalidInput`:
        throw Error(error.message)
      case `DocumentTooLarge`:
        throw Error(`GraphQL document too large: maximum ${error.maxSize} characters allowed`)
      case `TreeSitterError`:
      case `ParserInitError`:
        throw Error(error.message)
      default: {
        let exhaustiveCheck = error
        throw Error(`Unhandled parse error: ${JSON.stringify(exhaustiveCheck)}`)
      }
    }
  }
  return result.right
}
async function getParser() {
  return parserPromise ||= initializeTreeSitter(), parserPromise
}
async function initializeTreeSitter() {
  try {
    let isNode$2 = typeof process < `u` && process.versions && process.versions.node
    if (isNode$2) {
      let fs = await __vitePreload(() => import(`node:fs/promises`), []),
        path$1 = await __vitePreload(() => import(`node:path`), []),
        treeSitterWasmPath = path$1.join(process.cwd(), `node_modules/web-tree-sitter/tree-sitter.wasm`),
        graphqlWasmPath = path$1.join(process.cwd(), `node_modules/tree-sitter-graphql-grammar-wasm/grammar.wasm`)
      await Parser.init({ locateFile: filename => filename === `tree-sitter.wasm` ? treeSitterWasmPath : filename })
      let parser = new Parser(),
        wasmBuffer = await fs.readFile(graphqlWasmPath),
        GraphQL = await Language.load(new Uint8Array(wasmBuffer))
      return parser.setLanguage(GraphQL), parser
    } else {
      await Parser.init({ locateFile: filename => filename === `tree-sitter.wasm` ? tree_sitter_default : filename })
      let parser = new Parser(), response = await fetch(grammar_default)
      if (!response.ok) {
        throw Error(
          `Failed to load GraphQL grammar file: ${response.status} ${response.statusText}. This may indicate a network issue or missing grammar file.`,
        )
      }
      let wasmBuffer = await response.arrayBuffer()
      if (wasmBuffer.byteLength === 0) throw Error(`GraphQL grammar file is empty or corrupted`)
      let GraphQL = await Language.load(new Uint8Array(wasmBuffer))
      return parser.setLanguage(GraphQL), parser
    }
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes(`fetch`)) {
        throw Error(`Tree-sitter initialization failed: ${error.message}. Check your network connection.`)
      }
      if (error.message.includes(`Language.load`)) {
        throw Error(`Failed to load GraphQL grammar: ${error.message}. The grammar file may be corrupted.`)
      }
    }
    throw error
  }
}
function addErrorHintTokens(tokens, code$3, annotations$2) {
  let tokensWithHints = [], processedIndices = new Set(), invalidFieldCount = 0
  if (
    tokens.forEach(t$18 => {
      t$18.semantic && `kind` in t$18.semantic && t$18.semantic.kind === `InvalidField` && invalidFieldCount++
    }), invalidFieldCount > 10
  ) return console.warn(`Polen: ${invalidFieldCount} invalid fields detected. Schema may not match queries.`), tokens
  for (let i$14 = 0; i$14 < tokens.length; i$14++) {
    let token = tokens[i$14]
    if (
      !processedIndices.has(i$14)
      && (tokensWithHints.push(token),
        processedIndices.add(i$14),
        token.semantic && `kind` in token.semantic && token.semantic.kind === `InvalidField`)
    ) {
      let fieldEndIndex = i$14, j$1 = i$14 + 1
      for (; j$1 < tokens.length && tokens[j$1].treeSitterNode.type === `whitespace`;) j$1++
      if (j$1 < tokens.length && tokens[j$1].text === `(`) {
        let parenDepth = 1
        for (j$1++; j$1 < tokens.length && parenDepth > 0;) {
          let t$18 = tokens[j$1]
          t$18.text === `(` ? parenDepth++ : t$18.text === `)` && parenDepth--, j$1++
        }
        fieldEndIndex = j$1 - 1
        for (let k$1 = i$14 + 1; k$1 <= fieldEndIndex; k$1++) {
          k$1 < tokens.length && !processedIndices.has(k$1)
            && (tokensWithHints.push(tokens[k$1]), processedIndices.add(k$1))
        }
      }
      let lastFieldToken = tokens[fieldEndIndex] || token,
        hintText = `  No such field`,
        hintToken = new UnifiedToken(
          createSyntheticNode(`error_hint`, hintText, lastFieldToken.end, lastFieldToken.end + 16),
          void 0,
          annotations$2,
        )
      tokensWithHints.push(hintToken)
    }
  }
  return tokensWithHints
}
function collectTokensWithSemantics(tree, code$3, schema, annotations$2) {
  let tokens = [], cursor = tree.walk(), context$2 = schema ? new SemanticContext(schema) : null, lastEnd = 0
  function processNode() {
    let node$1 = cursor.currentNode
    if (!node$1) return
    if (context$2) {
      if (node$1.type === `operation_definition`) {
        let operationType = findChildByType(cursor, `operation_type`)
        operationType && context$2.enterOperation(operationType.text)
      }
      if (node$1.type === `fragment_definition`) {
        let typeCondition = findChildByType(cursor, `type_condition`)
        if (typeCondition) {
          let typeName = findChildByType(cursor, `named_type`, typeCondition)
          if (typeName) {
            let nameNode = findChildByType(cursor, `name`, typeName)
            nameNode && context$2.enterFragment(nameNode.text)
          }
        }
      }
    }
    let isValueNode = node$1.type === `string_value` || node$1.type === `int_value` || node$1.type === `float_value`,
      shouldCollectToken = (node$1.childCount === 0 || isValueNode) && node$1.text.trim() !== ``
    if (shouldCollectToken) {
      if (node$1.startIndex > lastEnd) {
        let whitespace$1 = code$3.slice(lastEnd, node$1.startIndex)
        tokens.push(
          new UnifiedToken(createWhitespaceNode(whitespace$1, lastEnd, node$1.startIndex), void 0, annotations$2),
        )
      }
      let semantic
      if (context$2 && node$1.type === `name`) {
        let parent = cursor.currentNode.parent
        if (parent?.type === `field`) {
          let fieldInfo = context$2.getFieldInfo(node$1.text), currentType = context$2.getCurrentType()
          fieldInfo
            ? (semantic = { kind: `OutputField`, parentType: fieldInfo.parentType, fieldDef: fieldInfo.fieldDef },
              context$2.enterField(node$1.text))
            : currentType && (semantic = { kind: `InvalidField`, fieldName: node$1.text, parentType: currentType })
        } else if (parent?.type === `named_type`) {
          let type$2 = context$2.lookupType(node$1.text)
          type$2
            && (type$2 instanceof GraphQLObjectType || type$2 instanceof GraphQLScalarType
              || type$2 instanceof GraphQLInterfaceType || type$2 instanceof GraphQLUnionType
              || type$2 instanceof GraphQLEnumType || type$2 instanceof GraphQLInputObjectType)
            && (semantic = type$2)
        } else if (parent?.type === `operation_definition`) {
          semantic = { kind: `Operation`, type: context$2.operationType || `query`, name: node$1.text }
        } else if (parent?.type === `fragment_definition`) {
          semantic = { kind: `Fragment`, name: node$1.text, onType: context$2.getCurrentType() }
        } else if (parent?.type === `argument`) {
          let argumentsNode = parent.parent
          if (argumentsNode && argumentsNode.type === `arguments`) {
            let fieldNode = argumentsNode.parent
            if (fieldNode && fieldNode.type === `field`) {
              for (let i$14 = 0; i$14 < fieldNode.childCount; i$14++) {
                let child = fieldNode.child(i$14)
                if (child && child.type === `name`) {
                  let rootType = context$2.schema.getQueryType() || context$2.schema.getMutationType()
                    || context$2.schema.getSubscriptionType()
                  if (rootType) {
                    let field = rootType.getFields()[child.text], parentType = rootType
                    if (!field) {
                      let currentType = context$2.getCurrentType()
                      currentType && (field = currentType.getFields()[child.text], parentType = currentType)
                    }
                    if (field && parentType) {
                      let arg = field.args.find(a$22 => a$22.name === node$1.text)
                      arg && (semantic = { kind: `Argument`, parentType, parentField: field, argumentDef: arg })
                    }
                  }
                  break
                }
              }
            }
          }
        } else {
          ;(parent?.type === `variable` || parent?.type === `variable_definition`)
            && (semantic = { kind: `Variable`, name: node$1.text })
        }
      } else {context$2 && node$1.type === `variable` && node$1.text.startsWith(`$`)
          && (semantic = { kind: `Variable`, name: node$1.text.slice(1) })}
      let token = new UnifiedToken(node$1, semantic, annotations$2)
      tokens.push(token), lastEnd = node$1.endIndex
    }
    if (!isValueNode && cursor.gotoFirstChild()) {
      do processNode()
      while (cursor.gotoNextSibling())
      if (cursor.gotoParent(), context$2 && node$1.type === `field`) {
        let hasSelectionSet = node$1.childCount > 0 && node$1.children.some(child => child?.type === `selection_set`)
        hasSelectionSet && context$2.exitField()
      } else {context$2 && (node$1.type === `operation_definition` || node$1.type === `fragment_definition`)
          && context$2.reset()}
    }
  }
  if (processNode(), lastEnd < code$3.length) {
    let remaining = code$3.slice(lastEnd)
    tokens.push(new UnifiedToken(createWhitespaceNode(remaining, lastEnd, code$3.length), void 0, annotations$2))
  }
  return tokens
}
function findChildByType(cursor, type$2, node$1) {
  let targetNode = node$1 || cursor.currentNode
  if (!targetNode) return null
  for (let i$14 = 0; i$14 < targetNode.childCount; i$14++) {
    let child = targetNode.child(i$14)
    if (child && child.type === type$2) return child
  }
  return null
}
function createWhitespaceNode(text$6, start$2, end$2) {
  let node$1 = new SyntheticNode(`whitespace`, text$6, start$2, end$2)
  return node$1
}
function createSyntheticNode(type$2, text$6, start$2, end$2) {
  let node$1 = new SyntheticNode(type$2, text$6, start$2, end$2)
  return node$1
}
const GraphQLInteractiveImpl = ({ codeblock, schema, showWarningIfNoSchema = !0, toolbar, style: style$1 }) => {
    let [tokens, setTokens] = import_react.useState(null),
      [isLoading, setIsLoading] = import_react.useState(!0),
      [error, setError] = import_react.useState(null),
      [retryCount, setRetryCount] = import_react.useState(0),
      popoverState = usePopoverState({ showDelay: 300, hideDelay: 100, allowMultiplePins: !0 }),
      parseTokens = import_react.useCallback(async () => {
        try {
          setIsLoading(!0), setError(null)
          let parsedTokens = await parseGraphQLWithTreeSitter(codeblock.code, codeblock.annotations, schema)
          setTokens(parsedTokens), setRetryCount(0)
        } catch (err) {
          let errorMessage = err instanceof Error ? err.message : `Unknown parsing error`
          setError(errorMessage), setTokens([])
        } finally {
          setIsLoading(!1)
        }
      }, [codeblock.code, codeblock.annotations, schema]),
      handleRetry = import_react.useCallback(() => {
        setRetryCount(prev => prev + 1), parseTokens()
      }, [parseTokens])
    return import_react.useEffect(() => {
      parseTokens()
    }, [parseTokens]),
      isLoading
        ? (0, import_jsx_runtime.jsxs)(`div`, {
          className: `graphql-loading`,
          children: [
            (0, import_jsx_runtime.jsx)(`pre`, {
              style: { opacity: .5 },
              children: (0, import_jsx_runtime.jsx)(`code`, { children: codeblock.code }),
            }),
            (0, import_jsx_runtime.jsx)(`div`, {
              style: {
                position: `absolute`,
                top: `8px`,
                right: `8px`,
                fontSize: `12px`,
                color: `#666`,
                backgroundColor: `#f0f0f0`,
                padding: `2px 6px`,
                borderRadius: `3px`,
              },
              children: `Loading tree-sitter...`,
            }),
          ],
        })
        : error
        ? (0, import_jsx_runtime.jsxs)(p, {
          className: `graphql-error`,
          p: `4`,
          style: {
            borderRadius: `var(--radius-2)`,
            backgroundColor: `var(--gray-2)`,
            position: `relative`,
            borderLeft: `3px solid var(--red-9)`,
          },
          children: [
            (0, import_jsx_runtime.jsx)(`pre`, {
              style: { margin: 0, whiteSpace: `pre` },
              children: (0, import_jsx_runtime.jsx)(`code`, { children: codeblock.code }),
            }),
            (0, import_jsx_runtime.jsxs)(`div`, {
              style: {
                color: `var(--red-11)`,
                fontSize: `12px`,
                marginTop: `8px`,
                padding: `8px`,
                backgroundColor: `var(--red-a3)`,
                borderRadius: `3px`,
                display: `flex`,
                justifyContent: `space-between`,
                alignItems: `center`,
              },
              children: [
                (0, import_jsx_runtime.jsxs)(`span`, { children: [`Interactive parsing failed: `, error] }),
                retryCount < 3
                && (0, import_jsx_runtime.jsxs)(`button`, {
                  onClick: handleRetry,
                  style: {
                    backgroundColor: `var(--red-9)`,
                    color: `white`,
                    border: `none`,
                    padding: `4px 8px`,
                    borderRadius: `3px`,
                    fontSize: `11px`,
                    cursor: `pointer`,
                  },
                  children: [`Retry (`, retryCount + 1, `/3)`],
                }),
              ],
            }),
          ],
        })
        : !tokens || tokens.length === 0
        ? (0, import_jsx_runtime.jsxs)(p, {
          className: `graphql-fallback`,
          p: `4`,
          style: { borderRadius: `var(--radius-2)`, backgroundColor: `var(--gray-2)`, position: `relative` },
          children: [
            (0, import_jsx_runtime.jsx)(`pre`, {
              style: { margin: 0, whiteSpace: `pre` },
              children: (0, import_jsx_runtime.jsx)(`code`, { children: codeblock.code }),
            }),
            error
            && (0, import_jsx_runtime.jsx)(`div`, {
              style: {
                position: `absolute`,
                top: `8px`,
                right: `8px`,
                fontSize: `12px`,
                color: `var(--red-11)`,
                backgroundColor: `var(--red-a3)`,
                padding: `2px 6px`,
                borderRadius: `3px`,
                maxWidth: `200px`,
              },
              title: error,
              children: `Interactive features unavailable`,
            }),
          ],
        })
        : (0, import_jsx_runtime.jsxs)(p, {
          className: `graphql-interactive`,
          p: `4`,
          position: `relative`,
          style: {
            borderRadius: `var(--radius-2)`,
            backgroundColor: `var(--gray-2)`,
            overflowX: `auto`,
            maxWidth: `100%`,
            ...style$1,
          },
          children: [
            (0, import_jsx_runtime.jsx)(`pre`, {
              style: { margin: 0, whiteSpace: `pre` },
              children: (0, import_jsx_runtime.jsx)(`code`, {
                children: tokens.map((token, index$4) => {
                  let tokenId = `${token.start}-${token.end}-${index$4}`
                  return (0, import_jsx_runtime.jsx)(TokenComponent, {
                    token,
                    tokenId,
                    popoverState,
                    ...schema !== void 0 && { schema },
                  }, tokenId)
                }),
              }),
            }),
            toolbar
            && (0, import_jsx_runtime.jsx)(`div`, {
              style: { position: `absolute`, top: `8px`, right: `8px`, zIndex: 10 },
              children: toolbar(),
            }),
            !schema && showWarningIfNoSchema && !toolbar && (0, import_jsx_runtime.jsxs)(`div`, {
              style: {
                position: `absolute`,
                top: `8px`,
                right: `8px`,
                fontSize: `12px`,
                color: `var(--amber-11)`,
                backgroundColor: `var(--amber-a3)`,
                padding: `2px 6px`,
                borderRadius: `3px`,
                display: `flex`,
                alignItems: `center`,
                gap: `4px`,
              },
              title: `Interactive features are not available because no GraphQL schema is configured`,
              children: [
                (0, import_jsx_runtime.jsxs)(`svg`, {
                  width: `12`,
                  height: `12`,
                  viewBox: `0 0 24 24`,
                  fill: `none`,
                  stroke: `currentColor`,
                  strokeWidth: `2`,
                  children: [
                    (0, import_jsx_runtime.jsx)(`path`, {
                      d: `M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z`,
                    }),
                    (0, import_jsx_runtime.jsx)(`line`, { x1: `12`, y1: `9`, x2: `12`, y2: `13` }),
                    (0, import_jsx_runtime.jsx)(`line`, { x1: `12`, y1: `17`, x2: `12.01`, y2: `17` }),
                  ],
                }),
                `No schema configured`,
              ],
            }),
          ],
        })
  },
  TokenComponent = ({ token, tokenId, popoverState, schema }) => {
    let [isHovered, setIsHovered] = import_react.useState(!1),
      handleClick = import_react.useCallback(e$26 => {
        if (token.polen.isInteractive()) {
          if (
            e$26.preventDefault(),
              e$26.stopPropagation(),
              token.semantic && `kind` in token.semantic && token.semantic.kind === `InvalidField`
          ) return
          popoverState.onTogglePin(tokenId)
        }
      }, [token, tokenId, popoverState]),
      handleMouseEnter = import_react.useCallback(() => {
        token.polen.isInteractive() && (setIsHovered(!0), popoverState.onHoverStart(tokenId))
      }, [token, tokenId, popoverState]),
      handleMouseLeave = import_react.useCallback(() => {
        setIsHovered(!1), popoverState.onHoverEnd(tokenId)
      }, [tokenId, popoverState]),
      baseClass = token.highlighter.getCssClass(),
      getBaseStyle = () => {
        switch (baseClass) {
          case `graphql-keyword`:
            return { color: `var(--red-11)`, fontWeight: `bold` }
          case `graphql-type-interactive`:
            return { color: `var(--blue-11)`, fontWeight: 500 }
          case `graphql-field-interactive`:
            return { color: `var(--violet-11)` }
          case `graphql-field-error`:
            return { color: `var(--red-11)` }
          case `graphql-error-hint`:
            return { color: `var(--red-11)`, fontSize: `0.9em`, fontStyle: `italic`, opacity: .5 }
          case `graphql-comment`:
            return { color: `var(--gray-11)`, fontStyle: `italic`, opacity: .6 }
          case `graphql-operation`:
            return { color: `var(--violet-11)`, fontStyle: `italic` }
          case `graphql-fragment`:
            return { color: `var(--violet-11)`, fontStyle: `italic` }
          case `graphql-variable`:
            return { color: `var(--orange-11)` }
          case `graphql-argument`:
            return { color: `var(--gray-12)` }
          case `graphql-string`:
            return { color: `var(--blue-11)` }
          case `graphql-number`:
            return { color: `var(--blue-11)` }
          case `graphql-punctuation`:
            return { color: `var(--gray-11)`, opacity: .5 }
          default:
            return { color: `var(--gray-12)` }
        }
      },
      isInvalidField$1 = token.semantic && `kind` in token.semantic && token.semantic.kind === `InvalidField`,
      style$1 = {
        ...getBaseStyle(),
        ...token.polen.isInteractive() && !isInvalidField$1
          && {
            cursor: `pointer`,
            textDecoration: isHovered ? `underline` : `none`,
            backgroundColor: isHovered ? `var(--accent-a3)` : `transparent`,
          },
        ...isInvalidField$1
          && {
            cursor: `default`,
            textDecoration: `underline wavy var(--red-a5)`,
            textUnderlineOffset: `2px`,
            backgroundColor: isHovered ? `var(--red-a2)` : `transparent`,
          },
        ...token.codeHike.annotations.length > 0 && { position: `relative`, backgroundColor: `var(--yellow-a3)` },
      },
      tokenSpan = (0, import_jsx_runtime.jsx)(`span`, {
        className: baseClass,
        style: style$1,
        'data-token-class': baseClass,
        'data-interactive': token.polen.isInteractive(),
        children: token.text,
      })
    return (0, import_jsx_runtime.jsx)(GraphQLTokenPopover, {
      token,
      open: popoverState.isOpen(tokenId),
      pinned: popoverState.isPinned(tokenId),
      onTriggerHover: handleMouseEnter,
      onTriggerLeave: handleMouseLeave,
      onTriggerClick: handleClick,
      onContentHover: () => popoverState.onPopoverHover(tokenId),
      onContentLeave: () => popoverState.onPopoverLeave(tokenId),
      onClose: () => popoverState.unpin(tokenId),
      children: tokenSpan,
    })
  },
  GraphQLInteractive = props =>
    (0, import_jsx_runtime.jsx)(GraphQLErrorBoundary, {
      fallbackCode: props.codeblock.code,
      onError: (error, errorInfo) => {},
      children: (0, import_jsx_runtime.jsx)(GraphQLInteractiveImpl, { ...props }),
    }),
  CodeBlock = ({ codeblock, schema }) =>
    codeblock.lang === `graphql` && codeblock.meta?.includes(`interactive`) && schema
      ? (0, import_jsx_runtime.jsx)(GraphQLInteractive, {
        codeblock,
        schema,
        showWarningIfNoSchema: templateConfig.warnings.interactiveWithoutSchema.enabled,
      })
      : (0, import_jsx_runtime.jsx)(Pre, { code: codeblock }),
  MdxProvider = ({ children: children$3, schema }) =>
    (0, import_jsx_runtime.jsx)(MDXProvider, {
      components: {
        p: props => (0, import_jsx_runtime.jsx)(p$2, { as: `p`, mb: `4`, ...props }),
        h1: props => (0, import_jsx_runtime.jsx)(r, { size: `8`, mt: `6`, mb: `4`, ...props }),
        h2: props => (0, import_jsx_runtime.jsx)(r, { size: `7`, mt: `6`, mb: `3`, ...props }),
        h3: props => (0, import_jsx_runtime.jsx)(r, { size: `6`, mt: `5`, mb: `3`, ...props }),
        h4: props => (0, import_jsx_runtime.jsx)(r, { size: `5`, mt: `5`, mb: `2`, ...props }),
        h5: props => (0, import_jsx_runtime.jsx)(r, { size: `4`, mt: `4`, mb: `2`, ...props }),
        h6: props => (0, import_jsx_runtime.jsx)(r, { size: `3`, mt: `4`, mb: `2`, ...props }),
        strong: r$2,
        em: e$2,
        code: p$3,
        blockquote: props => (0, import_jsx_runtime.jsx)(e$3, { my: `4`, ...props }),
        a: e$1,
        hr: props => (0, import_jsx_runtime.jsx)(o$1, { my: `6`, ...props }),
        table: m$2,
        thead: d$1,
        tbody: b$2,
        tr: P$2,
        th: f$3,
        td: T$1,
        ul: props => (0, import_jsx_runtime.jsx)(p, { as: `ul`, mb: `4`, style: { paddingLeft: `1.5rem` }, ...props }),
        ol: props => (0, import_jsx_runtime.jsx)(p, { as: `ol`, mb: `4`, style: { paddingLeft: `1.5rem` }, ...props }),
        li: props => (0, import_jsx_runtime.jsx)(p, { as: `li`, mb: `2`, ...props }),
        Badge: e,
        Button: o$3,
        Callout: callout_exports,
        Card: o,
        DataList: data_list_exports,
        Tabs: tabs_exports,
        Tooltip: e$4,
        CodeBlock: props => (0, import_jsx_runtime.jsx)(CodeBlock, { ...props, schema: schema || void 0 }),
      },
      children: children$3,
    }),
  IndexSchema = Catalog,
  isHasExamplesIndexPage = !1,
  loader$1 = async () => {
    let firstExample = examplesCatalog.examples[0]
    if (firstExample) throw redirect(`/examples/${firstExample.name}`)
    return examplesCatalog
  },
  Component$4 = () => {
    let examplesCatalog$1 = useLoaderData(IndexSchema),
      schema = schemasCatalog,
      hasExamples = examplesCatalog$1 && examplesCatalog$1.examples.length > 0,
      insituDiagnostic = !hasExamples && (0, import_jsx_runtime.jsxs)(DevelopmentTip, {
        title: `Examples Setup`,
        variant: `warning`,
        children: [
          (0, import_jsx_runtime.jsx)(p$2, {
            children: `The examples section is enabled but no example files were found. To get started:`,
          }),
          (0, import_jsx_runtime.jsx)(p, {
            mt: `2`,
            children: (0, import_jsx_runtime.jsxs)(p$2, {
              children: [
                (0, import_jsx_runtime.jsx)(`strong`, { children: `Option 1:` }),
                ` Add `,
                (0, import_jsx_runtime.jsx)(p$3, { children: `.graphql` }),
                ` or `,
                (0, import_jsx_runtime.jsx)(p$3, { children: `.gql` }),
                ` files to your `,
                (0, import_jsx_runtime.jsx)(p$3, { children: `examples/` }),
                ` `,
                `directory`,
              ],
            }),
          }),
          (0, import_jsx_runtime.jsx)(p, {
            mt: `1`,
            children: (0, import_jsx_runtime.jsxs)(p$2, {
              children: [
                (0, import_jsx_runtime.jsx)(`strong`, { children: `Option 2:` }),
                ` If you don't need examples, disable this section in your config by setting`,
                ` `,
                (0, import_jsx_runtime.jsx)(p$3, { children: `examples.enabled: false` }),
              ],
            }),
          }),
        ],
      })
    return null
  },
  examplesIndexRoute = routeIndex({ schema: IndexSchema, loader: loader$1, Component: Component$4 }),
  useHighlighted = (content$2, options$2) => {
    let config = { interactive: options$2?.interactive ?? !1, lang: options$2?.lang ?? `graphql` }, meta = []
    config.interactive && meta.push(`interactive`)
    let metaString = meta.join(` `), [highlightedCode, setHighlightedCode] = import_react.useState(null)
    return import_react.useEffect(() => {
      let HIGHLIGHT_TIMEOUT = seconds(5),
        highlightContent = async () => {
          try {
            let highlighted = await runPromise(
              tryPromise({
                try: () =>
                  highlight({ value: content$2, lang: config.lang, meta: metaString }, { theme: `github-light` }),
                catch: error => Error(`Highlight failed: ${error}`),
              }).pipe(
                timeout(HIGHLIGHT_TIMEOUT),
                catchTag(
                  `TimeoutException`,
                  () => fail$1(Error(`Highlight timeout after ${toSeconds(HIGHLIGHT_TIMEOUT)} seconds`)),
                ),
              ),
            )
            setHighlightedCode(highlighted)
          } catch (error) {
            console.error(`Failed to highlight code:`, error), setHighlightedCode(null)
          }
        }
      highlightContent()
    }, [content$2, config.lang, config.interactive]),
      highlightedCode
  },
  VersionCoveragePicker = ({ document: document$3, current, onChange }) => {
    if (is$4(document$3)) return null
    let options$2 = Array.from(keys$3(document$3.versionDocuments))
    if (options$2.length === 0) return null
    let formatLabel$1 = versionCoverage => {
      let prefix$1 = isSingle(versionCoverage) ? `Version` : `Versions`
      return `${prefix$1} ${toLabel(versionCoverage)}`
    }
    return (0, import_jsx_runtime.jsxs)(C$2, {
      value: toLabel(current),
      onValueChange: label => {
        let selection = options$2.find(s$14 => toLabel(s$14) === label)
        selection && onChange(selection)
      },
      children: [
        (0, import_jsx_runtime.jsx)(u$2, { children: formatLabel$1(current) }),
        (0, import_jsx_runtime.jsx)(g$2, {
          position: `popper`,
          sideOffset: 5,
          children: options$2.map(selection =>
            (0, import_jsx_runtime.jsx)(
              v$2,
              { value: toLabel(selection), children: formatLabel$1(selection) },
              toLabel(selection),
            )
          ),
        }),
      ],
    })
  },
  GraphQLDocument = (
    {
      document: document$3,
      schemaCatalog,
      showVersionCoveragePicker = !0,
      onVersionCoverageChange,
      selectedVersionCoverage: controlledVersionCoverage,
      style: style$1,
    },
  ) => {
    let isControlled = controlledVersionCoverage !== void 0,
      [internalVersionCoverage, setInternalVersionCoverage] = import_react.useState(
        getOrNull(getLatestVersion(schemaCatalog)),
      ),
      selectedVersionCoverage = isControlled ? controlledVersionCoverage : internalVersionCoverage,
      internalOnVersionChange = version => {
        isControlled || setInternalVersionCoverage(version), onVersionCoverageChange?.(version)
      },
      result = resolveDocumentAndSchema(document$3, schemaCatalog, selectedVersionCoverage)
    if (isLeft(result)) return console.error(`Failed to resolve document and schema:`, result.left.message), null
    let { schema, content: content$2 } = result.right, highlightedCode = useHighlighted(content$2, { interactive: !0 })
    return highlightedCode
      ? (0, import_jsx_runtime.jsx)(GraphQLInteractive, {
        codeblock: highlightedCode,
        schema: schema?.definition,
        style: style$1,
        toolbar: () =>
          showVersionCoveragePicker && selectedVersionCoverage
          && (0, import_jsx_runtime.jsx)(VersionCoveragePicker, {
            document: document$3,
            schemaCatalog,
            current: selectedVersionCoverage,
            onChange: internalOnVersionChange,
          }),
      })
      : null
  },
  NameSchema = Example,
  nameLoader = async ({ params }) => {
    let { name } = params
    if (!name) throw new Response(`Not Found`, { status: 404 })
    let exampleOption = findFirst$7(examplesCatalog.examples, e$26 => e$26.name === name)
    if (isNone$2(exampleOption)) throw new Response(`Not Found`, { status: 404 })
    let example = exampleOption.value
    return example
  },
  Component$3 = () => {
    let example = useLoaderData(NameSchema),
      [searchParams] = useSearchParams(),
      versionParam = searchParams.get(`version`),
      selectedVersion = versionParam ? decodeSync$7(versionParam) : void 0
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsx)(r, { size: `6`, mb: `4`, children: title(example.name) }),
        (0, import_jsx_runtime.jsx)(GraphQLDocument, {
          document: example.document,
          schemaCatalog: schemasCatalog ?? void 0,
          selectedVersionCoverage: selectedVersion,
        }),
      ],
    })
  },
  nameRoute = route({ path: `:name`, schema: NameSchema, loader: nameLoader, Component: Component$3 }),
  LayoutSchema = Catalog,
  layoutLoader = async () => examplesCatalog,
  LayoutComponent = () => {
    let examplesCatalog$1 = useLoaderData(Catalog),
      sidebarData = examplesCatalog$1.examples.map(example => ({
        type: `ItemLink`,
        title: title(example.name),
        pathExp: example.name,
      })) ?? []
    return (0, import_jsx_runtime.jsxs)(Body, {
      subgrid: !0,
      children: [
        (0, import_jsx_runtime.jsxs)(Item$4, {
          cols: 4,
          style: { overflowY: `auto`, position: `sticky`, top: 0 },
          children: [
            (0, import_jsx_runtime.jsx)(r, {
              size: `4`,
              mb: `4`,
              style: { paddingLeft: `1rem` },
              children: `Examples`,
            }),
            (0, import_jsx_runtime.jsx)(Sidebar, { data: sidebarData, basePath: `/examples` }),
          ],
        }),
        (0, import_jsx_runtime.jsx)(Item$4, { cols: 8, children: (0, import_jsx_runtime.jsx)(Outlet, {}) }),
      ],
    })
  },
  examplesRoute = route({
    path: `examples`,
    schema: LayoutSchema,
    loader: layoutLoader,
    Component: LayoutComponent,
    children: [examplesIndexRoute, nameRoute],
  }),
  filterBy = filter$9 => getValue => collection =>
    value(filter$9).pipe(tagsExhaustive({
      DirectedFilterAllowAll: () => [...collection],
      DirectedFilterDenyAll: () => [],
      DirectedFilterAllow: f$14 => {
        let allowSet = new Set(f$14.items)
        return collection.filter(item => allowSet.has(getValue(item)))
      },
      DirectedFilterDeny: f$14 => {
        let denySet = new Set(f$14.items)
        return collection.filter(item => !denySet.has(getValue(item)))
      },
    }))
function filterByProperty(filter$9) {
  return propertyName => collection => filterBy(filter$9)(item => item[propertyName])(collection)
}
function isObject$1(subject) {
  return Object.prototype.toString.call(subject) === `[object Object]`
}
function isRecord(subject) {
  return isObject$1(subject) || Array.isArray(subject)
}
function canUseDOM() {
  return !!(typeof window < `u` && window.document && window.document.createElement)
}
function areOptionsEqual(optionsA, optionsB) {
  let optionsAKeys = Object.keys(optionsA), optionsBKeys = Object.keys(optionsB)
  if (optionsAKeys.length !== optionsBKeys.length) return !1
  let breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {})),
    breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}))
  return breakpointsA === breakpointsB
    ? optionsAKeys.every(key$1 => {
      let valueA = optionsA[key$1], valueB = optionsB[key$1]
      return typeof valueA == `function`
        ? `${valueA}` == `${valueB}`
        : !isRecord(valueA) || !isRecord(valueB)
        ? valueA === valueB
        : areOptionsEqual(valueA, valueB)
    })
    : !1
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort((a$22, b$3) => a$22.name > b$3.name ? 1 : -1).map(plugin => plugin.options)
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length) return !1
  let optionsA = sortAndMapPluginToOptions(pluginsA), optionsB = sortAndMapPluginToOptions(pluginsB)
  return optionsA.every((optionA, index$4) => {
    let optionB = optionsB[index$4]
    return areOptionsEqual(optionA, optionB)
  })
}
function isNumber(subject) {
  return typeof subject == `number`
}
function isString(subject) {
  return typeof subject == `string`
}
function isBoolean(subject) {
  return typeof subject == `boolean`
}
function isObject(subject) {
  return Object.prototype.toString.call(subject) === `[object Object]`
}
function mathAbs(n$19) {
  return Math.abs(n$19)
}
function mathSign(n$19) {
  return Math.sign(n$19)
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA)
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0 || mathAbs(valueB) <= mathAbs(valueA)) return 0
  let diff$10 = deltaAbs(mathAbs(valueB), mathAbs(valueA))
  return mathAbs(diff$10 / valueB)
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100
}
function arrayKeys(array$3) {
  return objectKeys(array$3).map(Number)
}
function arrayLast(array$3) {
  return array$3[arrayLastIndex(array$3)]
}
function arrayLastIndex(array$3) {
  return Math.max(0, array$3.length - 1)
}
function arrayIsLastIndex(array$3, index$4) {
  return index$4 === arrayLastIndex(array$3)
}
function arrayFromNumber(n$19, startAt = 0) {
  return Array.from(Array(n$19), (_$1, i$14) => startAt + i$14)
}
function objectKeys(object) {
  return Object.keys(object)
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => (objectKeys(currentObject).forEach(key$1 => {
    let valueA = mergedObjects[key$1], valueB = currentObject[key$1], areObjects = isObject(valueA) && isObject(valueB)
    mergedObjects[key$1] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB
  }),
    mergedObjects), {})
}
function isMouseEvent(evt, ownerWindow) {
  return ownerWindow.MouseEvent !== void 0 && evt instanceof ownerWindow.MouseEvent
}
function Alignment(align, viewSize) {
  let predefined = { start: start$2, center, end: end$2 }
  function start$2() {
    return 0
  }
  function center(n$19) {
    return end$2(n$19) / 2
  }
  function end$2(n$19) {
    return viewSize - n$19
  }
  function measure(n$19, index$4) {
    return isString(align) ? predefined[align](n$19) : align(viewSize, n$19, index$4)
  }
  let self$1 = { measure }
  return self$1
}
function EventStore() {
  let listeners = []
  function add$5(node$1, type$2, handler, options$2 = { passive: !0 }) {
    let removeListener
    if (`addEventListener` in node$1) {
      node$1.addEventListener(type$2, handler, options$2),
        removeListener = () => node$1.removeEventListener(type$2, handler, options$2)
    } else {
      let legacyMediaQueryList = node$1
      legacyMediaQueryList.addListener(handler), removeListener = () => legacyMediaQueryList.removeListener(handler)
    }
    return listeners.push(removeListener), self$1
  }
  function clear() {
    listeners = listeners.filter(remove$7 => remove$7())
  }
  let self$1 = { add: add$5, clear }
  return self$1
}
function Animations(ownerDocument, ownerWindow, update$5, render$3) {
  let documentVisibleHandler = EventStore(),
    fixedTimeStep = 1e3 / 60,
    lastTimeStamp = null,
    accumulatedTime = 0,
    animationId = 0
  function init() {
    documentVisibleHandler.add(ownerDocument, `visibilitychange`, () => {
      ownerDocument.hidden && reset()
    })
  }
  function destroy() {
    stop(), documentVisibleHandler.clear()
  }
  function animate(timeStamp) {
    if (!animationId) return
    lastTimeStamp || (lastTimeStamp = timeStamp, update$5(), update$5())
    let timeElapsed = timeStamp - lastTimeStamp
    for (lastTimeStamp = timeStamp, accumulatedTime += timeElapsed; accumulatedTime >= fixedTimeStep;) {
      update$5(), accumulatedTime -= fixedTimeStep
    }
    let alpha = accumulatedTime / fixedTimeStep
    render$3(alpha), animationId &&= ownerWindow.requestAnimationFrame(animate)
  }
  function start$2() {
    animationId ||= ownerWindow.requestAnimationFrame(animate)
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId), lastTimeStamp = null, accumulatedTime = 0, animationId = 0
  }
  function reset() {
    lastTimeStamp = null, accumulatedTime = 0
  }
  let self$1 = { init, destroy, start: start$2, stop, update: update$5, render: render$3 }
  return self$1
}
function Axis(axis, contentDirection) {
  let isRightToLeft = contentDirection === `rtl`,
    isVertical = axis === `y`,
    scroll = isVertical ? `y` : `x`,
    cross = isVertical ? `x` : `y`,
    sign = !isVertical && isRightToLeft ? -1 : 1,
    startEdge = getStartEdge(),
    endEdge = getEndEdge()
  function measureSize(nodeRect) {
    let { height, width } = nodeRect
    return isVertical ? height : width
  }
  function getStartEdge() {
    return isVertical ? `top` : isRightToLeft ? `right` : `left`
  }
  function getEndEdge() {
    return isVertical ? `bottom` : isRightToLeft ? `left` : `right`
  }
  function direction(n$19) {
    return n$19 * sign
  }
  let self$1 = { scroll, cross, startEdge, endEdge, measureSize, direction }
  return self$1
}
function Limit(min$10 = 0, max$12 = 0) {
  let length$1 = mathAbs(min$10 - max$12)
  function reachedMin(n$19) {
    return n$19 < min$10
  }
  function reachedMax(n$19) {
    return n$19 > max$12
  }
  function reachedAny(n$19) {
    return reachedMin(n$19) || reachedMax(n$19)
  }
  function constrain(n$19) {
    return reachedAny(n$19) ? reachedMin(n$19) ? min$10 : max$12 : n$19
  }
  function removeOffset(n$19) {
    return length$1 ? n$19 - length$1 * Math.ceil((n$19 - max$12) / length$1) : n$19
  }
  let self$1 = {
    length: length$1,
    max: max$12,
    min: min$10,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset,
  }
  return self$1
}
function Counter(max$12, start$2, loop$2) {
  let { constrain } = Limit(0, max$12), loopEnd = max$12 + 1, counter$5 = withinLimit(start$2)
  function withinLimit(n$19) {
    return loop$2 ? mathAbs((loopEnd + n$19) % loopEnd) : constrain(n$19)
  }
  function get$12() {
    return counter$5
  }
  function set$6(n$19) {
    return counter$5 = withinLimit(n$19), self$1
  }
  function add$5(n$19) {
    return clone$1().set(get$12() + n$19)
  }
  function clone$1() {
    return Counter(max$12, get$12(), loop$2)
  }
  let self$1 = { get: get$12, set: set$6, add: add$5, clone: clone$1 }
  return self$1
}
function DragHandler(
  axis,
  rootNode,
  ownerDocument,
  ownerWindow,
  target,
  dragTracker,
  location,
  animation,
  scrollTo,
  scrollBody,
  scrollTarget,
  index$4,
  eventHandler,
  percentOfView,
  dragFree,
  dragThreshold,
  skipSnaps,
  baseFriction,
  watchDrag,
) {
  let { cross: crossAxis, direction } = axis,
    focusNodes = [`INPUT`, `SELECT`, `TEXTAREA`],
    nonPassiveEvent = { passive: !1 },
    initEvents = EventStore(),
    dragEvents = EventStore(),
    goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20)),
    snapForceBoost = { mouse: 300, touch: 400 },
    freeForceBoost = { mouse: 500, touch: 600 },
    baseSpeed = dragFree ? 43 : 25,
    isMoving = !1,
    startScroll = 0,
    startCross = 0,
    pointerIsDown = !1,
    preventScroll = !1,
    preventClick = !1,
    isMouse = !1
  function init(emblaApi) {
    if (!watchDrag) return
    function downIfAllowed(evt) {
      ;(isBoolean(watchDrag) || watchDrag(emblaApi, evt)) && down(evt)
    }
    let node$1 = rootNode
    initEvents.add(node$1, `dragstart`, evt => evt.preventDefault(), nonPassiveEvent).add(
      node$1,
      `touchmove`,
      () => void 0,
      nonPassiveEvent,
    ).add(node$1, `touchend`, () => void 0).add(node$1, `touchstart`, downIfAllowed).add(
      node$1,
      `mousedown`,
      downIfAllowed,
    ).add(node$1, `touchcancel`, up).add(node$1, `contextmenu`, up).add(node$1, `click`, click, !0)
  }
  function destroy() {
    initEvents.clear(), dragEvents.clear()
  }
  function addDragEvents() {
    let node$1 = isMouse ? ownerDocument : rootNode
    dragEvents.add(node$1, `touchmove`, move, nonPassiveEvent).add(node$1, `touchend`, up).add(
      node$1,
      `mousemove`,
      move,
      nonPassiveEvent,
    ).add(node$1, `mouseup`, up)
  }
  function isFocusNode(node$1) {
    let nodeName = node$1.nodeName || ``
    return focusNodes.includes(nodeName)
  }
  function forceBoost() {
    let boost = dragFree ? freeForceBoost : snapForceBoost, type$2 = isMouse ? `mouse` : `touch`
    return boost[type$2]
  }
  function allowedForce(force, targetChanged) {
    let next = index$4.add(mathSign(force) * -1), baseForce = scrollTarget.byDistance(force, !dragFree).distance
    return dragFree || mathAbs(force) < goToNextThreshold
      ? baseForce
      : skipSnaps && targetChanged
      ? baseForce * .5
      : scrollTarget.byIndex(next.get(), 0).distance
  }
  function down(evt) {
    let isMouseEvt = isMouseEvent(evt, ownerWindow)
    isMouse = isMouseEvt,
      preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving,
      isMoving = deltaAbs(target.get(), location.get()) >= 2,
      !(isMouseEvt && evt.button !== 0)
      && (isFocusNode(evt.target)
        || (pointerIsDown = !0,
          dragTracker.pointerDown(evt),
          scrollBody.useFriction(0).useDuration(0),
          target.set(location),
          addDragEvents(),
          startScroll = dragTracker.readPoint(evt),
          startCross = dragTracker.readPoint(evt, crossAxis),
          eventHandler.emit(`pointerDown`)))
  }
  function move(evt) {
    let isTouchEvt = !isMouseEvent(evt, ownerWindow)
    if (isTouchEvt && evt.touches.length >= 2) return up(evt)
    let lastScroll = dragTracker.readPoint(evt),
      lastCross = dragTracker.readPoint(evt, crossAxis),
      diffScroll = deltaAbs(lastScroll, startScroll),
      diffCross = deltaAbs(lastCross, startCross)
    if (!preventScroll && !isMouse && (!evt.cancelable || (preventScroll = diffScroll > diffCross, !preventScroll))) {
      return up(evt)
    }
    let diff$10 = dragTracker.pointerMove(evt)
    diffScroll > dragThreshold && (preventClick = !0),
      scrollBody.useFriction(.3).useDuration(.75),
      animation.start(),
      target.add(direction(diff$10)),
      evt.preventDefault()
  }
  function up(evt) {
    let currentLocation = scrollTarget.byDistance(0, !1),
      targetChanged = currentLocation.index !== index$4.get(),
      rawForce = dragTracker.pointerUp(evt) * forceBoost(),
      force = allowedForce(direction(rawForce), targetChanged),
      forceFactor = factorAbs(rawForce, force),
      speed = baseSpeed - 10 * forceFactor,
      friction = baseFriction + forceFactor / 50
    preventScroll = !1,
      pointerIsDown = !1,
      dragEvents.clear(),
      scrollBody.useDuration(speed).useFriction(friction),
      scrollTo.distance(force, !dragFree),
      isMouse = !1,
      eventHandler.emit(`pointerUp`)
  }
  function click(evt) {
    preventClick && (evt.stopPropagation(), evt.preventDefault(), preventClick = !1)
  }
  function pointerDown() {
    return pointerIsDown
  }
  let self$1 = { init, destroy, pointerDown }
  return self$1
}
function DragTracker(axis, ownerWindow) {
  let logInterval = 170, startEvent, lastEvent
  function readTime(evt) {
    return evt.timeStamp
  }
  function readPoint(evt, evtAxis) {
    let property = evtAxis || axis.scroll, coord = `client${property === `x` ? `X` : `Y`}`
    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord]
  }
  function pointerDown(evt) {
    return startEvent = evt, lastEvent = evt, readPoint(evt)
  }
  function pointerMove(evt) {
    let diff$10 = readPoint(evt) - readPoint(lastEvent), expired = readTime(evt) - readTime(startEvent) > logInterval
    return lastEvent = evt, expired && (startEvent = evt), diff$10
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent) return 0
    let diffDrag = readPoint(lastEvent) - readPoint(startEvent),
      diffTime = readTime(evt) - readTime(startEvent),
      expired = readTime(evt) - readTime(lastEvent) > logInterval,
      force = diffDrag / diffTime,
      isFlick = diffTime && !expired && mathAbs(force) > .1
    return isFlick ? force : 0
  }
  let self$1 = { pointerDown, pointerMove, pointerUp, readPoint }
  return self$1
}
function NodeRects() {
  function measure(node$1) {
    let { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node$1,
      offset$3 = {
        top: offsetTop,
        right: offsetLeft + offsetWidth,
        bottom: offsetTop + offsetHeight,
        left: offsetLeft,
        width: offsetWidth,
        height: offsetHeight,
      }
    return offset$3
  }
  let self$1 = { measure }
  return self$1
}
function PercentOfView(viewSize) {
  function measure(n$19) {
    return viewSize * (n$19 / 100)
  }
  let self$1 = { measure }
  return self$1
}
function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  let observeNodes = [container].concat(slides), resizeObserver, containerSize, slideSizes = [], destroyed = !1
  function readSize(node$1) {
    return axis.measureSize(nodeRects.measure(node$1))
  }
  function init(emblaApi) {
    if (!watchResize) return
    containerSize = readSize(container), slideSizes = slides.map(readSize)
    function defaultCallback(entries$2) {
      for (let entry of entries$2) {
        if (destroyed) return
        let isContainer = entry.target === container,
          slideIndex = slides.indexOf(entry.target),
          lastSize = isContainer ? containerSize : slideSizes[slideIndex],
          newSize = readSize(isContainer ? container : slides[slideIndex]),
          diffSize = mathAbs(newSize - lastSize)
        if (diffSize >= .5) {
          emblaApi.reInit(), eventHandler.emit(`resize`)
          break
        }
      }
    }
    resizeObserver = new ResizeObserver(entries$2 => {
      ;(isBoolean(watchResize) || watchResize(emblaApi, entries$2)) && defaultCallback(entries$2)
    }),
      ownerWindow.requestAnimationFrame(() => {
        observeNodes.forEach(node$1 => resizeObserver.observe(node$1))
      })
  }
  function destroy() {
    destroyed = !0, resizeObserver && resizeObserver.disconnect()
  }
  let self$1 = { init, destroy }
  return self$1
}
function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
  let scrollVelocity = 0,
    scrollDirection = 0,
    scrollDuration = baseDuration,
    scrollFriction = baseFriction,
    rawLocation = location.get(),
    rawLocationPrevious = 0
  function seek() {
    let displacement = target.get() - location.get(), isInstant = !scrollDuration, scrollDistance = 0
    return isInstant
      ? (scrollVelocity = 0, previousLocation.set(target), location.set(target), scrollDistance = displacement)
      : (previousLocation.set(location),
        scrollVelocity += displacement / scrollDuration,
        scrollVelocity *= scrollFriction,
        rawLocation += scrollVelocity,
        location.add(scrollVelocity),
        scrollDistance = rawLocation - rawLocationPrevious),
      scrollDirection = mathSign(scrollDistance),
      rawLocationPrevious = rawLocation,
      self$1
  }
  function settled() {
    let diff$10 = target.get() - offsetLocation.get()
    return mathAbs(diff$10) < .001
  }
  function duration() {
    return scrollDuration
  }
  function direction() {
    return scrollDirection
  }
  function velocity() {
    return scrollVelocity
  }
  function useBaseDuration() {
    return useDuration(baseDuration)
  }
  function useBaseFriction() {
    return useFriction(baseFriction)
  }
  function useDuration(n$19) {
    return scrollDuration = n$19, self$1
  }
  function useFriction(n$19) {
    return scrollFriction = n$19, self$1
  }
  let self$1 = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration,
  }
  return self$1
}
function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
  let pullBackThreshold = percentOfView.measure(10),
    edgeOffsetTolerance = percentOfView.measure(50),
    frictionLimit = Limit(.1, .99),
    disabled = !1
  function shouldConstrain() {
    return !(disabled || !limit.reachedAny(target.get()) || !limit.reachedAny(location.get()))
  }
  function constrain(pointerDown) {
    if (!shouldConstrain()) return
    let edge = limit.reachedMin(location.get()) ? `min` : `max`,
      diffToEdge = mathAbs(limit[edge] - location.get()),
      diffToTarget = target.get() - location.get(),
      friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance)
    target.subtract(diffToTarget * friction),
      !pointerDown && mathAbs(diffToTarget) < pullBackThreshold
      && (target.set(limit.constrain(target.get())), scrollBody.useDuration(25).useBaseFriction())
  }
  function toggleActive(active$1) {
    disabled = !active$1
  }
  let self$1 = { shouldConstrain, constrain, toggleActive }
  return self$1
}
function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  let scrollBounds = Limit(-contentSize + viewSize, 0),
    snapsBounded = measureBounded(),
    scrollContainLimit = findScrollContainLimit(),
    snapsContained = measureContained()
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) <= 1
  }
  function findScrollContainLimit() {
    let startSnap = snapsBounded[0],
      endSnap = arrayLast(snapsBounded),
      min$10 = snapsBounded.lastIndexOf(startSnap),
      max$12 = snapsBounded.indexOf(endSnap) + 1
    return Limit(min$10, max$12)
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index$4) => {
      let { min: min$10, max: max$12 } = scrollBounds,
        snap = scrollBounds.constrain(snapAligned),
        isFirst = !index$4,
        isLast = arrayIsLastIndex(snapsAligned, index$4)
      return isFirst
        ? max$12
        : isLast || usePixelTolerance(min$10, snap)
        ? min$10
        : usePixelTolerance(max$12, snap)
        ? max$12
        : snap
    }).map(scrollBound => parseFloat(scrollBound.toFixed(3)))
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max]
    if (containScroll === `keepSnaps`) return snapsBounded
    let { min: min$10, max: max$12 } = scrollContainLimit
    return snapsBounded.slice(min$10, max$12)
  }
  let self$1 = { snapsContained, scrollContainLimit }
  return self$1
}
function ScrollLimit(contentSize, scrollSnaps, loop$2) {
  let max$12 = scrollSnaps[0],
    min$10 = loop$2 ? max$12 - contentSize : arrayLast(scrollSnaps),
    limit = Limit(min$10, max$12),
    self$1 = { limit }
  return self$1
}
function ScrollLooper(contentSize, limit, location, vectors) {
  let jointSafety = .1,
    min$10 = limit.min + jointSafety,
    max$12 = limit.max + jointSafety,
    { reachedMin, reachedMax } = Limit(min$10, max$12)
  function shouldLoop(direction) {
    return direction === 1 ? reachedMax(location.get()) : direction === -1 ? reachedMin(location.get()) : !1
  }
  function loop$2(direction) {
    if (!shouldLoop(direction)) return
    let loopDistance = contentSize * (direction * -1)
    vectors.forEach(v$4 => v$4.add(loopDistance))
  }
  let self$1 = { loop: loop$2 }
  return self$1
}
function ScrollProgress(limit) {
  let { max: max$12, length: length$1 } = limit
  function get$12(n$19) {
    let currentLocation = n$19 - max$12
    return length$1 ? currentLocation / -length$1 : 0
  }
  let self$1 = { get: get$12 }
  return self$1
}
function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  let { startEdge, endEdge } = axis,
    { groupSlides } = slidesToScroll,
    alignments = measureSizes().map(alignment.measure),
    snaps = measureUnaligned(),
    snapsAligned = measureAligned()
  function measureSizes() {
    return groupSlides(slideRects).map(rects => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs)
  }
  function measureUnaligned() {
    return slideRects.map(rect => containerRect[startEdge] - rect[startEdge]).map(snap => -mathAbs(snap))
  }
  function measureAligned() {
    return groupSlides(snaps).map(g$3 => g$3[0]).map((snap, index$4) => snap + alignments[index$4])
  }
  let self$1 = { snaps, snapsAligned }
  return self$1
}
function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  let { groupSlides } = slidesToScroll,
    { min: min$10, max: max$12 } = scrollContainLimit,
    slideRegistry = createSlideRegistry()
  function createSlideRegistry() {
    let groupedSlideIndexes = groupSlides(slideIndexes), doNotContain = !containSnaps || containScroll === `keepSnaps`
    return scrollSnaps.length === 1
      ? [slideIndexes]
      : doNotContain
      ? groupedSlideIndexes
      : groupedSlideIndexes.slice(min$10, max$12).map((group, index$4, groups) => {
        let isFirst = !index$4, isLast = arrayIsLastIndex(groups, index$4)
        if (isFirst) {
          let range = arrayLast(groups[0]) + 1
          return arrayFromNumber(range)
        }
        if (isLast) {
          let range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1
          return arrayFromNumber(range, arrayLast(groups)[0])
        }
        return group
      })
  }
  let self$1 = { slideRegistry }
  return self$1
}
function ScrollTarget(loop$2, scrollSnaps, contentSize, limit, targetVector) {
  let { reachedAny, removeOffset, constrain } = limit
  function minDistance(distances) {
    return distances.concat().sort((a$22, b$3) => mathAbs(a$22) - mathAbs(b$3))[0]
  }
  function findTargetSnap(target) {
    let distance = loop$2 ? removeOffset(target) : constrain(target),
      ascDiffsToSnaps = scrollSnaps.map((snap, index$5) => ({ diff: shortcut(snap - distance, 0), index: index$5 }))
        .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff)),
      { index: index$4 } = ascDiffsToSnaps[0]
    return { index: index$4, distance }
  }
  function shortcut(target, direction) {
    let targets = [target, target + contentSize, target - contentSize]
    if (!loop$2) return target
    if (!direction) return minDistance(targets)
    let matchingTargets = targets.filter(t$18 => mathSign(t$18) === direction)
    return matchingTargets.length ? minDistance(matchingTargets) : arrayLast(targets) - contentSize
  }
  function byIndex(index$4, direction) {
    let diffToSnap = scrollSnaps[index$4] - targetVector.get(), distance = shortcut(diffToSnap, direction)
    return { index: index$4, distance }
  }
  function byDistance(distance, snap) {
    let target = targetVector.get() + distance,
      { index: index$4, distance: targetSnapDistance } = findTargetSnap(target),
      reachedBound = !loop$2 && reachedAny(target)
    if (!snap || reachedBound) return { index: index$4, distance }
    let diffToSnap = scrollSnaps[index$4] - targetSnapDistance, snapDistance = distance + shortcut(diffToSnap, 0)
    return { index: index$4, distance: snapDistance }
  }
  let self$1 = { byDistance, byIndex, shortcut }
  return self$1
}
function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target) {
    let distanceDiff = target.distance, indexDiff = target.index !== indexCurrent.get()
    targetVector.add(distanceDiff),
      distanceDiff
      && (scrollBody.duration() ? animation.start() : (animation.update(), animation.render(1), animation.update())),
      indexDiff && (indexPrevious.set(indexCurrent.get()), indexCurrent.set(target.index), eventHandler.emit(`select`))
  }
  function distance(n$19, snap) {
    let target = scrollTarget.byDistance(n$19, snap)
    scrollTo(target)
  }
  function index$4(n$19, direction) {
    let targetIndex = indexCurrent.clone().set(n$19), target = scrollTarget.byIndex(targetIndex.get(), direction)
    scrollTo(target)
  }
  let self$1 = { distance, index: index$4 }
  return self$1
}
function SlideFocus(root$5, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  let focusListenerOptions = { passive: !0, capture: !0 }, lastTabPressTime = 0
  function init(emblaApi) {
    if (!watchFocus) return
    function defaultCallback(index$4) {
      let nowTime = new Date().getTime(), diffTime = nowTime - lastTabPressTime
      if (diffTime > 10) return
      eventHandler.emit(`slideFocusStart`), root$5.scrollLeft = 0
      let group = slideRegistry.findIndex(group$1 => group$1.includes(index$4))
      isNumber(group) && (scrollBody.useDuration(0), scrollTo.index(group, 0), eventHandler.emit(`slideFocus`))
    }
    eventStore.add(document, `keydown`, registerTabPress, !1),
      slides.forEach((slide, slideIndex) => {
        eventStore.add(slide, `focus`, evt => {
          ;(isBoolean(watchFocus) || watchFocus(emblaApi, evt)) && defaultCallback(slideIndex)
        }, focusListenerOptions)
      })
  }
  function registerTabPress(event) {
    event.code === `Tab` && (lastTabPressTime = new Date().getTime())
  }
  let self$1 = { init }
  return self$1
}
function Vector1D(initialValue) {
  let value$2 = initialValue
  function get$12() {
    return value$2
  }
  function set$6(n$19) {
    value$2 = normalizeInput(n$19)
  }
  function add$5(n$19) {
    value$2 += normalizeInput(n$19)
  }
  function subtract(n$19) {
    value$2 -= normalizeInput(n$19)
  }
  function normalizeInput(n$19) {
    return isNumber(n$19) ? n$19 : n$19.get()
  }
  let self$1 = { get: get$12, set: set$6, add: add$5, subtract }
  return self$1
}
function Translate(axis, container) {
  let translate = axis.scroll === `x` ? x$2 : y$3,
    containerStyle = container.style,
    previousTarget = null,
    disabled = !1
  function x$2(n$19) {
    return `translate3d(${n$19}px,0px,0px)`
  }
  function y$3(n$19) {
    return `translate3d(0px,${n$19}px,0px)`
  }
  function to(target) {
    if (disabled) return
    let newTarget = roundToTwoDecimals(axis.direction(target))
    newTarget !== previousTarget && (containerStyle.transform = translate(newTarget), previousTarget = newTarget)
  }
  function toggleActive(active$1) {
    disabled = !active$1
  }
  function clear() {
    disabled || (containerStyle.transform = ``, container.getAttribute(`style`) || container.removeAttribute(`style`))
  }
  let self$1 = { clear, to, toggleActive }
  return self$1
}
function SlideLooper(
  axis,
  viewSize,
  contentSize,
  slideSizes,
  slideSizesWithGaps,
  snaps,
  scrollSnaps,
  location,
  slides,
) {
  let roundingSafety = .5,
    ascItems = arrayKeys(slideSizesWithGaps),
    descItems = arrayKeys(slideSizesWithGaps).reverse(),
    loopPoints = startPoints().concat(endPoints())
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a$22, i$14) => a$22 - slideSizesWithGaps[i$14], from)
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a$22, i$14) => {
      let remainingGap = removeSlideSizes(a$22, gap)
      return remainingGap > 0 ? a$22.concat([i$14]) : a$22
    }, [])
  }
  function findSlideBounds(offset$3) {
    return snaps.map((snap, index$4) => ({
      start: snap - slideSizes[index$4] + roundingSafety + offset$3,
      end: snap + viewSize - roundingSafety + offset$3,
    }))
  }
  function findLoopPoints(indexes, offset$3, isEndEdge) {
    let slideBounds = findSlideBounds(offset$3)
    return indexes.map(index$4 => {
      let initial = isEndEdge ? 0 : -contentSize,
        altered = isEndEdge ? contentSize : 0,
        boundEdge = isEndEdge ? `end` : `start`,
        loopPoint = slideBounds[index$4][boundEdge]
      return {
        index: index$4,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index$4]),
        target: () => location.get() > loopPoint ? initial : altered,
      }
    })
  }
  function startPoints() {
    let gap = scrollSnaps[0], indexes = slidesInGap(descItems, gap)
    return findLoopPoints(indexes, contentSize, !1)
  }
  function endPoints() {
    let gap = viewSize - scrollSnaps[0] - 1, indexes = slidesInGap(ascItems, gap)
    return findLoopPoints(indexes, -contentSize, !0)
  }
  function canLoop() {
    return loopPoints.every(({ index: index$4 }) => {
      let otherIndexes = ascItems.filter(i$14 => i$14 !== index$4)
      return removeSlideSizes(otherIndexes, viewSize) <= .1
    })
  }
  function loop$2() {
    loopPoints.forEach(loopPoint => {
      let { target, translate, slideLocation } = loopPoint, shiftLocation = target()
      shiftLocation !== slideLocation.get() && (translate.to(shiftLocation), slideLocation.set(shiftLocation))
    })
  }
  function clear() {
    loopPoints.forEach(loopPoint => loopPoint.translate.clear())
  }
  let self$1 = { canLoop, clear, loop: loop$2, loopPoints }
  return self$1
}
function SlidesHandler(container, eventHandler, watchSlides) {
  let mutationObserver, destroyed = !1
  function init(emblaApi) {
    if (!watchSlides) return
    function defaultCallback(mutations) {
      for (let mutation of mutations) {
        if (mutation.type === `childList`) {
          emblaApi.reInit(), eventHandler.emit(`slidesChanged`)
          break
        }
      }
    }
    mutationObserver = new MutationObserver(mutations => {
      destroyed || (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) && defaultCallback(mutations)
    }), mutationObserver.observe(container, { childList: !0 })
  }
  function destroy() {
    mutationObserver && mutationObserver.disconnect(), destroyed = !0
  }
  let self$1 = { init, destroy }
  return self$1
}
function SlidesInView(container, slides, eventHandler, threshold) {
  let intersectionEntryMap = {}, inViewCache = null, notInViewCache = null, intersectionObserver, destroyed = !1
  function init() {
    intersectionObserver = new IntersectionObserver(entries$2 => {
      destroyed || (entries$2.forEach(entry => {
        let index$4 = slides.indexOf(entry.target)
        intersectionEntryMap[index$4] = entry
      }),
        inViewCache = null,
        notInViewCache = null,
        eventHandler.emit(`slidesInView`))
    }, { root: container.parentElement, threshold }), slides.forEach(slide => intersectionObserver.observe(slide))
  }
  function destroy() {
    intersectionObserver && intersectionObserver.disconnect(), destroyed = !0
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list$3, slideIndex) => {
      let index$4 = parseInt(slideIndex),
        { isIntersecting } = intersectionEntryMap[index$4],
        inViewMatch = inView && isIntersecting,
        notInViewMatch = !inView && !isIntersecting
      return (inViewMatch || notInViewMatch) && list$3.push(index$4), list$3
    }, [])
  }
  function get$12(inView = !0) {
    if (inView && inViewCache) return inViewCache
    if (!inView && notInViewCache) return notInViewCache
    let slideIndexes = createInViewList(inView)
    return inView && (inViewCache = slideIndexes), inView || (notInViewCache = slideIndexes), slideIndexes
  }
  let self$1 = { init, destroy, get: get$12 }
  return self$1
}
function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  let { measureSize, startEdge, endEdge } = axis,
    withEdgeGap = slideRects[0] && readEdgeGap,
    startGap = measureStartGap(),
    endGap = measureEndGap(),
    slideSizes = slideRects.map(measureSize),
    slideSizesWithGaps = measureWithGaps()
  function measureStartGap() {
    if (!withEdgeGap) return 0
    let slideRect = slideRects[0]
    return mathAbs(containerRect[startEdge] - slideRect[startEdge])
  }
  function measureEndGap() {
    if (!withEdgeGap) return 0
    let style$1 = ownerWindow.getComputedStyle(arrayLast(slides))
    return parseFloat(style$1.getPropertyValue(`margin-${endEdge}`))
  }
  function measureWithGaps() {
    return slideRects.map((rect, index$4, rects) => {
      let isFirst = !index$4, isLast = arrayIsLastIndex(rects, index$4)
      return isFirst
        ? slideSizes[index$4] + startGap
        : isLast
        ? slideSizes[index$4] + endGap
        : rects[index$4 + 1][startEdge] - rect[startEdge]
    }).map(mathAbs)
  }
  let self$1 = { slideSizes, slideSizesWithGaps, startGap, endGap }
  return self$1
}
function SlidesToScroll(
  axis,
  viewSize,
  slidesToScroll,
  loop$2,
  containerRect,
  slideRects,
  startGap,
  endGap,
  pixelTolerance,
) {
  let { startEdge, endEdge, direction } = axis, groupByNumber = isNumber(slidesToScroll)
  function byNumber(array$3, groupSize) {
    return arrayKeys(array$3).filter(i$14 => i$14 % groupSize === 0).map(i$14 => array$3.slice(i$14, i$14 + groupSize))
  }
  function bySize(array$3) {
    return array$3.length
      ? arrayKeys(array$3).reduce((groups, rectB, index$4) => {
        let rectA = arrayLast(groups) || 0,
          isFirst = rectA === 0,
          isLast = rectB === arrayLastIndex(array$3),
          edgeA = containerRect[startEdge] - slideRects[rectA][startEdge],
          edgeB = containerRect[startEdge] - slideRects[rectB][endEdge],
          gapA = !loop$2 && isFirst ? direction(startGap) : 0,
          gapB = !loop$2 && isLast ? direction(endGap) : 0,
          chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA))
        return index$4 && chunkSize > viewSize + pixelTolerance && groups.push(rectB),
          isLast && groups.push(array$3.length),
          groups
      }, []).map((currentSize, index$4, groups) => {
        let previousSize = Math.max(groups[index$4 - 1] || 0)
        return array$3.slice(previousSize, currentSize)
      })
      : []
  }
  function groupSlides(array$3) {
    return groupByNumber ? byNumber(array$3, slidesToScroll) : bySize(array$3)
  }
  let self$1 = { groupSlides }
  return self$1
}
function Engine(root$5, container, slides, ownerDocument, ownerWindow, options$2, eventHandler) {
  let {
      align,
      axis: scrollAxis,
      direction,
      startIndex,
      loop: loop$2,
      duration,
      dragFree,
      dragThreshold,
      inViewThreshold,
      slidesToScroll: groupSlides,
      skipSnaps,
      containScroll,
      watchResize,
      watchSlides,
      watchDrag,
      watchFocus,
    } = options$2,
    pixelTolerance = 2,
    nodeRects = NodeRects(),
    containerRect = nodeRects.measure(container),
    slideRects = slides.map(nodeRects.measure),
    axis = Axis(scrollAxis, direction),
    viewSize = axis.measureSize(containerRect),
    percentOfView = PercentOfView(viewSize),
    alignment = Alignment(align, viewSize),
    containSnaps = !loop$2 && !!containScroll,
    readEdgeGap = loop$2 || !!containScroll,
    { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(
      axis,
      containerRect,
      slideRects,
      slides,
      readEdgeGap,
      ownerWindow,
    ),
    slidesToScroll = SlidesToScroll(
      axis,
      viewSize,
      groupSlides,
      loop$2,
      containerRect,
      slideRects,
      startGap,
      endGap,
      pixelTolerance,
    ),
    { snaps, snapsAligned } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll),
    contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps),
    { snapsContained, scrollContainLimit } = ScrollContain(
      viewSize,
      contentSize,
      snapsAligned,
      containScroll,
      pixelTolerance,
    ),
    scrollSnaps = containSnaps ? snapsContained : snapsAligned,
    { limit } = ScrollLimit(contentSize, scrollSnaps, loop$2),
    index$4 = Counter(arrayLastIndex(scrollSnaps), startIndex, loop$2),
    indexPrevious = index$4.clone(),
    slideIndexes = arrayKeys(slides),
    update$5 = ({ dragHandler, scrollBody: scrollBody$1, scrollBounds, options: { loop: loop$3 } }) => {
      loop$3 || scrollBounds.constrain(dragHandler.pointerDown()), scrollBody$1.seek()
    },
    render$3 = ({
      scrollBody: scrollBody$1,
      translate,
      location: location$1,
      offsetLocation: offsetLocation$1,
      previousLocation: previousLocation$1,
      scrollLooper,
      slideLooper,
      dragHandler,
      animation: animation$1,
      eventHandler: eventHandler$1,
      scrollBounds,
      options: { loop: loop$3 },
    }, alpha) => {
      let shouldSettle = scrollBody$1.settled(),
        withinBounds = !scrollBounds.shouldConstrain(),
        hasSettled = loop$3 ? shouldSettle : shouldSettle && withinBounds,
        hasSettledAndIdle = hasSettled && !dragHandler.pointerDown()
      hasSettledAndIdle && animation$1.stop()
      let interpolatedLocation = location$1.get() * alpha + previousLocation$1.get() * (1 - alpha)
      offsetLocation$1.set(interpolatedLocation),
        loop$3 && (scrollLooper.loop(scrollBody$1.direction()), slideLooper.loop()),
        translate.to(offsetLocation$1.get()),
        hasSettledAndIdle && eventHandler$1.emit(`settle`),
        hasSettled || eventHandler$1.emit(`scroll`)
    },
    animation = Animations(ownerDocument, ownerWindow, () => update$5(engine), alpha => render$3(engine, alpha)),
    friction = .68,
    startLocation = scrollSnaps[index$4.get()],
    location = Vector1D(startLocation),
    previousLocation = Vector1D(startLocation),
    offsetLocation = Vector1D(startLocation),
    target = Vector1D(startLocation),
    scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction),
    scrollTarget = ScrollTarget(loop$2, scrollSnaps, contentSize, limit, target),
    scrollTo = ScrollTo(animation, index$4, indexPrevious, scrollBody, scrollTarget, target, eventHandler),
    scrollProgress = ScrollProgress(limit),
    eventStore = EventStore(),
    slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold),
    { slideRegistry } = SlideRegistry(
      containSnaps,
      containScroll,
      scrollSnaps,
      scrollContainLimit,
      slidesToScroll,
      slideIndexes,
    ),
    slideFocus = SlideFocus(root$5, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus),
    engine = {
      ownerDocument,
      ownerWindow,
      eventHandler,
      containerRect,
      slideRects,
      animation,
      axis,
      dragHandler: DragHandler(
        axis,
        root$5,
        ownerDocument,
        ownerWindow,
        target,
        DragTracker(axis, ownerWindow),
        location,
        animation,
        scrollTo,
        scrollBody,
        scrollTarget,
        index$4,
        eventHandler,
        percentOfView,
        dragFree,
        dragThreshold,
        skipSnaps,
        friction,
        watchDrag,
      ),
      eventStore,
      percentOfView,
      index: index$4,
      indexPrevious,
      limit,
      location,
      offsetLocation,
      previousLocation,
      options: options$2,
      resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
      scrollBody,
      scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
      scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [
        location,
        offsetLocation,
        previousLocation,
        target,
      ]),
      scrollProgress,
      scrollSnapList: scrollSnaps.map(scrollProgress.get),
      scrollSnaps,
      scrollTarget,
      scrollTo,
      slideLooper: SlideLooper(
        axis,
        viewSize,
        contentSize,
        slideSizes,
        slideSizesWithGaps,
        snaps,
        scrollSnaps,
        offsetLocation,
        slides,
      ),
      slideFocus,
      slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
      slidesInView,
      slideIndexes,
      slideRegistry,
      slidesToScroll,
      target,
      translate: Translate(axis, container),
    }
  return engine
}
function EventHandler() {
  let listeners = {}, api
  function init(emblaApi) {
    api = emblaApi
  }
  function getListeners(evt) {
    return listeners[evt] || []
  }
  function emit(evt) {
    return getListeners(evt).forEach(e$26 => e$26(api, evt)), self$1
  }
  function on(evt, cb) {
    return listeners[evt] = getListeners(evt).concat([cb]), self$1
  }
  function off(evt, cb) {
    return listeners[evt] = getListeners(evt).filter(e$26 => e$26 !== cb), self$1
  }
  function clear() {
    listeners = {}
  }
  let self$1 = { init, emit, off, on, clear }
  return self$1
}
const defaultOptions = {
  align: `center`,
  axis: `x`,
  container: null,
  slides: null,
  containScroll: `trimSnaps`,
  direction: `ltr`,
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0,
}
function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {})
  }
  function optionsAtMedia(options$2) {
    let optionsAtMedia$1 = options$2.breakpoints || {},
      matchedMediaOptions = objectKeys(optionsAtMedia$1).filter(media => ownerWindow.matchMedia(media).matches).map(
        media => optionsAtMedia$1[media],
      ).reduce((a$22, mediaOption) => mergeOptions(a$22, mediaOption), {})
    return mergeOptions(options$2, matchedMediaOptions)
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map(options$2 => objectKeys(options$2.breakpoints || {})).reduce(
      (acc, mediaQueries) => acc.concat(mediaQueries),
      [],
    ).map(ownerWindow.matchMedia)
  }
  let self$1 = { mergeOptions, optionsAtMedia, optionsMediaQueries }
  return self$1
}
function PluginsHandler(optionsHandler) {
  let activePlugins = []
  function init(emblaApi, plugins) {
    return activePlugins = plugins.filter(({ options: options$2 }) =>
      optionsHandler.optionsAtMedia(options$2).active !== !1
    ),
      activePlugins.forEach(plugin => plugin.init(emblaApi, optionsHandler)),
      plugins.reduce((map$20, plugin) => Object.assign(map$20, { [plugin.name]: plugin }), {})
  }
  function destroy() {
    activePlugins = activePlugins.filter(plugin => plugin.destroy())
  }
  let self$1 = { init, destroy }
  return self$1
}
function EmblaCarousel(root$5, userOptions, userPlugins) {
  let ownerDocument = root$5.ownerDocument,
    ownerWindow = ownerDocument.defaultView,
    optionsHandler = OptionsHandler(ownerWindow),
    pluginsHandler = PluginsHandler(optionsHandler),
    mediaHandlers = EventStore(),
    eventHandler = EventHandler(),
    { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler,
    { on, off, emit } = eventHandler,
    reInit = reActivate,
    destroyed = !1,
    engine,
    optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions),
    options$2 = mergeOptions(optionsBase),
    pluginList = [],
    pluginApis,
    container,
    slides
  function storeElements() {
    let { container: userContainer, slides: userSlides } = options$2,
      customContainer = isString(userContainer) ? root$5.querySelector(userContainer) : userContainer
    container = customContainer || root$5.children[0]
    let customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides
    slides = [].slice.call(customSlides || container.children)
  }
  function createEngine(options$3) {
    let engine$1 = Engine(root$5, container, slides, ownerDocument, ownerWindow, options$3, eventHandler)
    if (options$3.loop && !engine$1.slideLooper.canLoop()) {
      let optionsWithoutLoop = Object.assign({}, options$3, { loop: !1 })
      return createEngine(optionsWithoutLoop)
    }
    return engine$1
  }
  function activate(withOptions, withPlugins) {
    destroyed
      || (optionsBase = mergeOptions(optionsBase, withOptions),
        options$2 = optionsAtMedia(optionsBase),
        pluginList = withPlugins || pluginList,
        storeElements(),
        engine = createEngine(options$2),
        optionsMediaQueries([optionsBase, ...pluginList.map(({ options: options$3 }) => options$3)]).forEach(query =>
          mediaHandlers.add(query, `change`, reActivate)
        ),
        options$2.active
        && (engine.translate.to(engine.location.get()),
          engine.animation.init(),
          engine.slidesInView.init(),
          engine.slideFocus.init(self$1),
          engine.eventHandler.init(self$1),
          engine.resizeHandler.init(self$1),
          engine.slidesHandler.init(self$1),
          engine.options.loop && engine.slideLooper.loop(),
          container.offsetParent && slides.length && engine.dragHandler.init(self$1),
          pluginApis = pluginsHandler.init(self$1, pluginList)))
  }
  function reActivate(withOptions, withPlugins) {
    let startIndex = selectedScrollSnap()
    deActivate(), activate(mergeOptions({ startIndex }, withOptions), withPlugins), eventHandler.emit(`reInit`)
  }
  function deActivate() {
    engine.dragHandler.destroy(),
      engine.eventStore.clear(),
      engine.translate.clear(),
      engine.slideLooper.clear(),
      engine.resizeHandler.destroy(),
      engine.slidesHandler.destroy(),
      engine.slidesInView.destroy(),
      engine.animation.destroy(),
      pluginsHandler.destroy(),
      mediaHandlers.clear()
  }
  function destroy() {
    destroyed
      || (destroyed = !0, mediaHandlers.clear(), deActivate(), eventHandler.emit(`destroy`), eventHandler.clear())
  }
  function scrollTo(index$4, jump, direction) {
    !options$2.active || destroyed
      || (engine.scrollBody.useBaseFriction().useDuration(jump === !0 ? 0 : options$2.duration),
        engine.scrollTo.index(index$4, direction || 0))
  }
  function scrollNext(jump) {
    let next = engine.index.add(1).get()
    scrollTo(next, jump, -1)
  }
  function scrollPrev(jump) {
    let prev = engine.index.add(-1).get()
    scrollTo(prev, jump, 1)
  }
  function canScrollNext() {
    let next = engine.index.add(1).get()
    return next !== selectedScrollSnap()
  }
  function canScrollPrev() {
    let prev = engine.index.add(-1).get()
    return prev !== selectedScrollSnap()
  }
  function scrollSnapList() {
    return engine.scrollSnapList
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.offsetLocation.get())
  }
  function selectedScrollSnap() {
    return engine.index.get()
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get()
  }
  function slidesInView() {
    return engine.slidesInView.get()
  }
  function slidesNotInView() {
    return engine.slidesInView.get(!1)
  }
  function plugins() {
    return pluginApis
  }
  function internalEngine() {
    return engine
  }
  function rootNode() {
    return root$5
  }
  function containerNode() {
    return container
  }
  function slideNodes() {
    return slides
  }
  let self$1 = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off,
    on,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView,
  }
  return activate(userOptions, userPlugins), setTimeout(() => eventHandler.emit(`init`), 0), self$1
}
EmblaCarousel.globalOptions = void 0
function useEmblaCarousel(options$2 = {}, plugins = []) {
  let storedOptions = (0, import_react.useRef)(options$2),
    storedPlugins = (0, import_react.useRef)(plugins),
    [emblaApi, setEmblaApi] = (0, import_react.useState)(),
    [viewport, setViewport] = (0, import_react.useState)(),
    reInit = (0, import_react.useCallback)(() => {
      emblaApi && emblaApi.reInit(storedOptions.current, storedPlugins.current)
    }, [emblaApi])
  return (0, import_react.useEffect)(() => {
    areOptionsEqual(storedOptions.current, options$2) || (storedOptions.current = options$2, reInit())
  }, [options$2, reInit]),
    (0, import_react.useEffect)(() => {
      arePluginsEqual(storedPlugins.current, plugins) || (storedPlugins.current = plugins, reInit())
    }, [plugins, reInit]),
    (0, import_react.useEffect)(() => {
      if (canUseDOM() && viewport) {
        EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions
        let newEmblaApi = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current)
        return setEmblaApi(newEmblaApi), () => newEmblaApi.destroy()
      } else setEmblaApi(void 0)
    }, [viewport, setEmblaApi]),
    [setViewport, emblaApi]
}
useEmblaCarousel.globalOptions = void 0
const CarouselPill = ({ isActive: isActive$2, progress, autoPlay, isPaused, isHovering, onClick, index: index$4 }) => {
    let pillWidth = 24,
      pillHeight = 4,
      borderRadius = 2,
      gap = 2,
      strokeWidth = 1.5,
      svgWidth = pillWidth + gap * 2 + strokeWidth * 2,
      svgHeight = pillHeight + gap * 2 + strokeWidth * 2,
      progressWidth = pillWidth + gap * 2 + 1,
      progressHeight = pillHeight + gap * 2 + 1,
      progressRadius = borderRadius + gap,
      perimeter = 2 * (progressWidth + progressHeight - 2 * progressRadius) + 2 * Math.PI * progressRadius
    return (0, import_jsx_runtime.jsx)(p, {
      onClick,
      style: { cursor: `pointer`, opacity: isActive$2 ? 1 : .6, transition: `opacity 0.3s ease` },
      'aria-label': `Go to slide ${index$4 + 1}`,
      children: (0, import_jsx_runtime.jsxs)(`svg`, {
        width: svgWidth,
        height: svgHeight,
        viewBox: `0 0 ${svgWidth} ${svgHeight}`,
        children: [
          (0, import_jsx_runtime.jsx)(`rect`, {
            x: gap + strokeWidth,
            y: gap + strokeWidth,
            width: pillWidth,
            height: pillHeight,
            rx: borderRadius,
            ry: borderRadius,
            fill: isActive$2 ? `var(--accent-9)` : `var(--gray-5)`,
            style: { transition: `fill 0.3s ease` },
          }),
          isActive$2 && autoPlay && (0, import_jsx_runtime.jsx)(`rect`, {
            x: strokeWidth / 2,
            y: strokeWidth / 2,
            width: progressWidth,
            height: progressHeight,
            rx: progressRadius,
            ry: progressRadius,
            fill: `none`,
            stroke: `var(--accent-11)`,
            strokeWidth,
            strokeDasharray: perimeter,
            strokeDashoffset: perimeter * (1 - progress / 100),
            style: {
              transition: isPaused || isHovering ? `none` : `stroke-dashoffset 0.05s linear`,
              opacity: `0.5`,
              transformOrigin: `center`,
            },
          }),
        ],
      }),
    })
  },
  Carousel = (
    {
      children: children$3,
      autoPlay = !1,
      slideDuration = 1e4,
      loop: loop$2 = !0,
      align = `center`,
      slidesToScroll = 1,
      showDots = !0,
      onSlideChange,
      className,
      slideWidth = children$3.length > 1 ? `80%` : `100%`,
    },
  ) => {
    let [emblaRef, emblaApi] = useEmblaCarousel({ loop: loop$2, align, slidesToScroll, containScroll: !1 }),
      [selectedIndex, setSelectedIndex] = (0, import_react.useState)(0),
      [isHovering, setIsHovering] = (0, import_react.useState)(!1),
      [progress, setProgress] = (0, import_react.useState)(0),
      progressIntervalRef = (0, import_react.useRef)(null),
      elapsedRef = (0, import_react.useRef)(0),
      PROGRESS_UPDATE_INTERVAL = 50
    ;(0, import_react.useEffect)(() => {
      if (!emblaApi) return
      let onSelect = () => {
        let index$4 = emblaApi.selectedScrollSnap()
        setSelectedIndex(index$4), onSlideChange?.(index$4), elapsedRef.current = 0, setProgress(0)
      }
      return emblaApi.on(`select`, onSelect), onSelect(), () => {
        emblaApi.off(`select`, onSelect)
      }
    }, [emblaApi, onSlideChange])
    let startAutoPlay = (0, import_react.useCallback)((resumeFromProgress = !1) => {
        progressIntervalRef.current && clearInterval(progressIntervalRef.current),
          resumeFromProgress || (elapsedRef.current = 0, setProgress(0)),
          progressIntervalRef.current = setInterval(() => {
            if (!isHovering) {
              elapsedRef.current += PROGRESS_UPDATE_INTERVAL
              let newProgress = elapsedRef.current / slideDuration * 100
              newProgress >= 100
              && (elapsedRef.current = 0, emblaApi && children$3.length > 1 && emblaApi.scrollNext()),
                setProgress(Math.min(newProgress, 100))
            }
          }, PROGRESS_UPDATE_INTERVAL)
      }, [emblaApi, autoPlay, isHovering, children$3.length, slideDuration]),
      stopAutoPlay = (0, import_react.useCallback)((preserveProgress = !1) => {
        progressIntervalRef.current && (clearInterval(progressIntervalRef.current), progressIntervalRef.current = null),
          preserveProgress || (elapsedRef.current = 0, setProgress(0))
      }, [])
    return (0, import_react.useEffect)(
      () => (autoPlay && !isHovering && children$3.length > 1 ? startAutoPlay(!0) : stopAutoPlay(!0), () => {
        stopAutoPlay(!1)
      }),
      [autoPlay, isHovering, startAutoPlay, stopAutoPlay, children$3.length],
    ),
      (0, import_react.useEffect)(() => {
        if (!emblaApi) return
        let handleKeyDown = event => {
          event.key === `ArrowLeft`
            ? (event.preventDefault(), emblaApi.scrollPrev())
            : event.key === `ArrowRight` && (event.preventDefault(), emblaApi.scrollNext())
        }
        return window.addEventListener(`keydown`, handleKeyDown), () => {
          window.removeEventListener(`keydown`, handleKeyDown)
        }
      }, [emblaApi]),
      children$3.length === 0 ? null : (0, import_jsx_runtime.jsxs)(p, {
        position: `relative`,
        className,
        onMouseEnter: () => setIsHovering(!0),
        onMouseLeave: () => setIsHovering(!1),
        children: [
          (0, import_jsx_runtime.jsx)(p, {
            ref: emblaRef,
            style: {
              overflow: `hidden`,
              marginLeft: `calc(-50vw + 50%)`,
              marginRight: `calc(-50vw + 50%)`,
              paddingLeft: `calc(50vw - 50%)`,
              paddingRight: `calc(50vw - 50%)`,
            },
            children: (0, import_jsx_runtime.jsx)(p$1, {
              style: { display: `flex`, gap: children$3.length > 1 ? `2rem` : 0 },
              children: import_react.Children.map(children$3, (child, index$4) =>
                (0, import_jsx_runtime.jsx)(p, {
                  style: {
                    flex: `0 0 ${slideWidth}`,
                    minWidth: 0,
                    opacity: index$4 === selectedIndex ? 1 : .5,
                    transition: `opacity 0.3s ease-in-out`,
                    overflow: `auto`,
                    display: `flex`,
                    flexDirection: `column`,
                  },
                  children: child,
                })),
            }),
          }),
          children$3.length > 1 && showDots && (0, import_jsx_runtime.jsx)(p$1, {
            justify: `center`,
            align: `center`,
            gap: `2`,
            mt: `3`,
            children: import_react.Children.map(children$3, (_$1, index$4) =>
              (0, import_jsx_runtime.jsx)(CarouselPill, {
                isActive: index$4 === selectedIndex,
                progress,
                autoPlay,
                isPaused: !1,
                isHovering,
                onClick: () => emblaApi?.scrollTo(index$4),
                index: index$4,
              }, index$4)),
          }),
        ],
      })
  },
  ExamplesSection = ({ examples, schemaCatalog, title: title$1 = `API Examples`, maxExamples = 3 }) => {
    if (examples.length === 0) return null
    let displayExamples = examples.slice(0, maxExamples)
    return (0, import_jsx_runtime.jsxs)(r$1, {
      size: `3`,
      id: `examples`,
      style: { overflow: `visible` },
      children: [
        (0, import_jsx_runtime.jsx)(p, {
          mb: `4`,
          style: { textAlign: `center` },
          children: (0, import_jsx_runtime.jsx)(r, { size: `6`, mb: `2`, children: title$1 }),
        }),
        (0, import_jsx_runtime.jsx)(Carousel, {
          autoPlay: !0,
          children: displayExamples.map(example =>
            (0, import_jsx_runtime.jsx)(GraphQLDocument, {
              style: { height: `100%` },
              document: example.document,
              schemaCatalog,
            }, example.name)
          ),
        }),
      ],
    })
  },
  BUILT_IN_SCALARS = new Set([`String`, `Int`, `Float`, `Boolean`, `ID`]),
  analyzeSchema = (schema, version, date$1, options$2 = {}) => {
    let ignoreDeprecated = options$2.ignoreDeprecated ?? !1,
      typeMap = schema.getTypeMap(),
      totalTypes = 0,
      objectTypes = 0,
      interfaceTypes = 0,
      unionTypes = 0,
      enumTypes = 0,
      scalarTypes = 0,
      inputTypes = 0,
      totalFields = 0,
      totalArguments = 0,
      deprecatedFields = 0,
      deprecatedEnumValues = 0,
      deprecatedArguments = 0,
      typesWithDescriptions = 0,
      fieldsWithDescriptions = 0,
      argumentsWithDescriptions = 0
    for (let [typeName, type$2] of Object.entries(typeMap)) {
      if (typeName.startsWith(`__`)) continue
      if (totalTypes++, type$2.description && typesWithDescriptions++, isObjectType(type$2)) {
        objectTypes++
        let fields = type$2.getFields()
        for (let field of Object.values(fields)) {
          if (ignoreDeprecated && field.deprecationReason) continue
          if (
            totalFields++,
              field.description && fieldsWithDescriptions++,
              field.deprecationReason && deprecatedFields++,
              field.args
          ) {
            for (let arg of field.args) {
              if (ignoreDeprecated && arg.deprecationReason) continue
              totalArguments++,
                arg.description && argumentsWithDescriptions++,
                arg.deprecationReason && deprecatedArguments++
            }
          }
        }
      } else if (isInterfaceType(type$2)) {
        interfaceTypes++
        let fields = type$2.getFields()
        for (let field of Object.values(fields)) {
          if (ignoreDeprecated && field.deprecationReason) continue
          if (
            totalFields++,
              field.description && fieldsWithDescriptions++,
              field.deprecationReason && deprecatedFields++,
              field.args
          ) {
            for (let arg of field.args) {
              if (ignoreDeprecated && arg.deprecationReason) continue
              totalArguments++,
                arg.description && argumentsWithDescriptions++,
                arg.deprecationReason && deprecatedArguments++
            }
          }
        }
      } else if (isUnionType(type$2)) unionTypes++
      else if (isEnumType(type$2)) {
        enumTypes++
        let values$6 = type$2.getValues()
        for (let value$2 of values$6) {
          if (ignoreDeprecated && value$2.deprecationReason) continue
          value$2.deprecationReason && deprecatedEnumValues++
        }
      } else if (isScalarType(type$2)) BUILT_IN_SCALARS.has(typeName) ? totalTypes-- : scalarTypes++
      else if (isInputObjectType(type$2)) {
        inputTypes++
        let fields = type$2.getFields()
        for (let field of Object.values(fields)) {
          if (ignoreDeprecated && field.deprecationReason) continue
          totalFields++, field.description && fieldsWithDescriptions++
        }
      }
    }
    let typeBreakdown = {
        objectTypes,
        objectTypesPercentage: totalTypes > 0 ? objectTypes / totalTypes * 100 : 0,
        interfaceTypes,
        interfaceTypesPercentage: totalTypes > 0 ? interfaceTypes / totalTypes * 100 : 0,
        unionTypes,
        unionTypesPercentage: totalTypes > 0 ? unionTypes / totalTypes * 100 : 0,
        enumTypes,
        enumTypesPercentage: totalTypes > 0 ? enumTypes / totalTypes * 100 : 0,
        scalarTypes,
        scalarTypesPercentage: totalTypes > 0 ? scalarTypes / totalTypes * 100 : 0,
        inputTypes,
        inputTypesPercentage: totalTypes > 0 ? inputTypes / totalTypes * 100 : 0,
      },
      totalElements = totalTypes + totalFields + totalArguments,
      elementsWithDescriptions = typesWithDescriptions + fieldsWithDescriptions + argumentsWithDescriptions,
      descriptionCoverage = {
        types: totalTypes > 0 ? typesWithDescriptions / totalTypes * 100 : 0,
        fields: totalFields > 0 ? fieldsWithDescriptions / totalFields * 100 : 0,
        arguments: totalArguments > 0 ? argumentsWithDescriptions / totalArguments * 100 : 0,
        overall: totalElements > 0 ? elementsWithDescriptions / totalElements * 100 : 0,
      },
      totalDeprecatable = totalFields + totalArguments + deprecatedEnumValues,
      totalDeprecated = deprecatedFields + deprecatedArguments + deprecatedEnumValues,
      deprecation = {
        fields: deprecatedFields,
        enumValues: deprecatedEnumValues,
        arguments: deprecatedArguments,
        surfaceAreaPercentage: totalDeprecatable > 0 ? totalDeprecated / totalDeprecatable * 100 : 0,
      },
      queryType = schema.getQueryType(),
      mutationType = schema.getMutationType(),
      subscriptionType = schema.getSubscriptionType(),
      queries = queryType ? Object.keys(queryType.getFields()).length : 0,
      mutations = mutationType ? Object.keys(mutationType.getFields()).length : 0,
      subscriptions = subscriptionType ? Object.keys(subscriptionType.getFields()).length : 0
    return {
      version,
      ...date$1 ? { date: date$1 } : {},
      totalTypes,
      typeBreakdown,
      queries,
      mutations,
      subscriptions,
      descriptionCoverage,
      deprecation,
      totalFields,
      totalArguments,
    }
  }
var hero_default = null
const Hero = (
    {
      title: title$1 = templateConfig.templateVariables.title || `GraphQL Developer Portal`,
      tagline = `Explore and integrate with our GraphQL API`,
      callToActions,
      heroImage,
      layout = `asymmetric`,
    },
  ) =>
  {
    let getDefaultCTAs = () => {
        let defaults = []
        return examplesCatalog && examplesCatalog.examples && examplesCatalog.examples.length > 0
          && defaults.push({ label: `View Examples`, href: `/examples`, variant: `primary` }),
          defaults
      },
      ctaButtons
    if (callToActions) {
      if (Array.isArray(callToActions)) ctaButtons = [...callToActions]
      else {
        let ctaConfig = callToActions
        if (ctaConfig.over) ctaButtons = [...ctaConfig.over]
        else {
          let defaults = getDefaultCTAs()
          ctaButtons = [...ctaConfig.before || [], ...defaults, ...ctaConfig.after || []]
        }
      }
    } else ctaButtons = getDefaultCTAs()
    let schemaStats = null,
      imageSrc = heroImage || hero_default,
      effectiveLayout = layout === `auto` ? `asymmetric` : layout
    return effectiveLayout === `asymmetric`
      ? (0, import_jsx_runtime.jsx)(Body, {
        children: (0, import_jsx_runtime.jsx)(r$1, {
          size: `4`,
          py: `9`,
          children: (0, import_jsx_runtime.jsx)(p$5, {
            size: `4`,
            children: (0, import_jsx_runtime.jsxs)(o$4, {
              columns: `12`,
              gap: `5`,
              align: `center`,
              children: [
                (0, import_jsx_runtime.jsxs)(p, {
                  style: { gridColumn: `1 / 8` },
                  children: [
                    (0, import_jsx_runtime.jsx)(r, {
                      size: `9`,
                      mb: `5`,
                      style: {
                        fontSize: `clamp(2.5rem, 5vw, 4rem)`,
                        lineHeight: 1.15,
                        letterSpacing: `-0.03em`,
                        fontWeight: 900,
                      },
                      children: title$1,
                    }),
                    (0, import_jsx_runtime.jsx)(p$2, {
                      size: `4`,
                      color: `gray`,
                      mb: `7`,
                      style: { maxWidth: `420px`, display: `block`, lineHeight: 1.6 },
                      children: tagline,
                    }),
                    (0, import_jsx_runtime.jsx)(p$1, {
                      gap: `3`,
                      wrap: `wrap`,
                      mb: `8`,
                      children: ctaButtons.map((cta, index$4) => {
                        let isExternal = cta.href.startsWith(`http`) || cta.href.startsWith(`#`),
                          isPrimary = cta.variant === `primary` || index$4 === 0 && !cta.variant
                        return isExternal
                          ? (0, import_jsx_runtime.jsx)(o$3, {
                            size: `3`,
                            variant: isPrimary ? `solid` : `outline`,
                            asChild: !0,
                            children: (0, import_jsx_runtime.jsx)(`a`, { href: cta.href, children: cta.label }),
                          }, index$4)
                          : (0, import_jsx_runtime.jsx)(o$3, {
                            size: `3`,
                            variant: isPrimary ? `solid` : `outline`,
                            asChild: !0,
                            children: (0, import_jsx_runtime.jsx)(Link, { to: cta.href, children: cta.label }),
                          }, index$4)
                      }),
                    }),
                    schemaStats && (0, import_jsx_runtime.jsxs)(p$1, {
                      gap: `4`,
                      style: { opacity: .8 },
                      children: [
                        (0, import_jsx_runtime.jsxs)(p$2, {
                          size: `2`,
                          color: `gray`,
                          children: [(0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.types }), ` Types`],
                        }),
                        (0, import_jsx_runtime.jsxs)(p$2, {
                          size: `2`,
                          color: `gray`,
                          children: [
                            (0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.queries }),
                            ` Queries`,
                          ],
                        }),
                        schemaStats.mutations > 0
                        && (0, import_jsx_runtime.jsxs)(p$2, {
                          size: `2`,
                          color: `gray`,
                          children: [
                            (0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.mutations }),
                            ` Mutations`,
                          ],
                        }),
                        schemaStats.subscriptions > 0
                        && (0, import_jsx_runtime.jsxs)(p$2, {
                          size: `2`,
                          color: `gray`,
                          children: [
                            (0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.subscriptions }),
                            ` Subscriptions`,
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                imageSrc && (0, import_jsx_runtime.jsx)(p, {
                  style: { gridColumn: `9 / 13`, display: `flex`, alignItems: `center`, justifyContent: `flex-end` },
                  children: (0, import_jsx_runtime.jsx)(`img`, {
                    src: imageSrc,
                    alt: `Hero`,
                    style: {
                      width: `100%`,
                      height: `auto`,
                      maxWidth: `480px`,
                      maxHeight: `420px`,
                      objectFit: `contain`,
                    },
                  }),
                }),
              ],
            }),
          }),
        }),
      })
      : (0, import_jsx_runtime.jsx)(Viewport$2, {
        children: (0, import_jsx_runtime.jsx)(p, {
          style: {
            display: `grid`,
            placeItems: `center`,
            height: `85vh`,
            minHeight: `600px`,
            position: `relative`,
            ...imageSrc
              ? {
                background: `
              radial-gradient(ellipse at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.7) 100%),
              linear-gradient(to bottom, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.6) 100%),
              url(${imageSrc})
            `,
                backgroundSize: `cover`,
                backgroundPosition: `center`,
                backgroundRepeat: `no-repeat`,
              }
              : { background: `var(--gray-2)` },
          },
          children: (0, import_jsx_runtime.jsx)(p$5, {
            size: `4`,
            style: { position: `relative`, zIndex: 3 },
            children: (0, import_jsx_runtime.jsxs)(p, {
              style: { textAlign: `center`, padding: `2rem` },
              children: [
                (0, import_jsx_runtime.jsx)(r, {
                  size: `9`,
                  mb: `5`,
                  style: {
                    fontSize: `clamp(3.5rem, 8vw, 5.5rem)`,
                    lineHeight: 1.1,
                    letterSpacing: `-0.04em`,
                    fontWeight: 900,
                    color: imageSrc ? `white` : `inherit`,
                    textShadow: imageSrc ? `0 2px 20px rgba(0,0,0,0.5), 0 1px 3px rgba(0,0,0,0.8)` : `none`,
                  },
                  children: title$1,
                }),
                (0, import_jsx_runtime.jsx)(p$2, {
                  as: `p`,
                  size: `6`,
                  mb: `7`,
                  style: {
                    maxWidth: `600px`,
                    margin: `0 auto`,
                    display: `block`,
                    lineHeight: 1.5,
                    color: imageSrc ? `white` : `var(--gray-11)`,
                    textShadow: imageSrc ? `0 1px 10px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.8)` : `none`,
                    opacity: imageSrc ? .95 : 1,
                  },
                  children: tagline,
                }),
                (0, import_jsx_runtime.jsx)(p$1, {
                  gap: `3`,
                  justify: `center`,
                  wrap: `wrap`,
                  mb: `8`,
                  mt: `9`,
                  children: ctaButtons.map((cta, index$4) => {
                    let isExternal = cta.href.startsWith(`http`) || cta.href.startsWith(`#`),
                      isPrimary = cta.variant === `primary` || index$4 === 0 && !cta.variant
                    return isExternal
                      ? (0, import_jsx_runtime.jsx)(o$3, {
                        size: `4`,
                        variant: isPrimary ? `solid` : `outline`,
                        asChild: !0,
                        children: (0, import_jsx_runtime.jsx)(`a`, { href: cta.href, children: cta.label }),
                      }, index$4)
                      : (0, import_jsx_runtime.jsx)(o$3, {
                        size: `4`,
                        variant: isPrimary ? `solid` : `outline`,
                        asChild: !0,
                        children: (0, import_jsx_runtime.jsx)(Link, { to: cta.href, children: cta.label }),
                      }, index$4)
                  }),
                }),
                schemaStats && (0, import_jsx_runtime.jsxs)(p$1, {
                  gap: `6`,
                  justify: `center`,
                  children: [
                    (0, import_jsx_runtime.jsxs)(p$2, {
                      size: `3`,
                      style: {
                        color: imageSrc ? `white` : `var(--gray-11)`,
                        textShadow: imageSrc ? `0 1px 3px rgba(0,0,0,0.5)` : `none`,
                        opacity: imageSrc ? .9 : .8,
                      },
                      children: [(0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.types }), ` Types`],
                    }),
                    (0, import_jsx_runtime.jsxs)(p$2, {
                      size: `3`,
                      style: {
                        color: imageSrc ? `white` : `var(--gray-11)`,
                        textShadow: imageSrc ? `0 1px 3px rgba(0,0,0,0.5)` : `none`,
                        opacity: imageSrc ? .9 : .8,
                      },
                      children: [(0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.queries }), ` Queries`],
                    }),
                    schemaStats.mutations > 0
                    && (0, import_jsx_runtime.jsxs)(p$2, {
                      size: `3`,
                      style: {
                        color: imageSrc ? `white` : `var(--gray-11)`,
                        textShadow: imageSrc ? `0 1px 3px rgba(0,0,0,0.5)` : `none`,
                        opacity: imageSrc ? .9 : .8,
                      },
                      children: [
                        (0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.mutations }),
                        ` Mutations`,
                      ],
                    }),
                    schemaStats.subscriptions > 0
                    && (0, import_jsx_runtime.jsxs)(p$2, {
                      size: `3`,
                      style: {
                        color: imageSrc ? `white` : `var(--gray-11)`,
                        textShadow: imageSrc ? `0 1px 3px rgba(0,0,0,0.5)` : `none`,
                        opacity: imageSrc ? .9 : .8,
                      },
                      children: [
                        (0, import_jsx_runtime.jsx)(`strong`, { children: schemaStats.subscriptions }),
                        ` Subscriptions`,
                      ],
                    }),
                  ],
                }),
              ],
            }),
          }),
        }),
      })
  },
  loader = () => templateConfig.home.enabled ? null : redirect(`/reference`),
  Component$2 = () => {
    let filteredExamples = filterByProperty(templateConfig.home.examples.filter)(`name`)(examplesCatalog.examples)
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        templateConfig.home.hero.enabled
        && (0, import_jsx_runtime.jsx)(Hero, {
          ...Object.fromEntries(
            Object.entries(templateConfig.home.hero).filter(([k$1, v$4]) => k$1 !== `enabled` && v$4 !== void 0),
          ),
        }),
        (0, import_jsx_runtime.jsx)(Body, {
          style: { marginTop: `800px` },
          children: templateConfig.home.examples.enabled && filteredExamples.length > 0
            && (0, import_jsx_runtime.jsx)(ExamplesSection, {
              examples: filteredExamples,
              schemaCatalog: schemasCatalog ?? void 0,
              ...Object.fromEntries(
                Object.entries({
                  title: templateConfig.home.examples.title,
                  description: templateConfig.home.examples.description,
                  maxExamples: templateConfig.home.examples.maxExamples,
                }).filter(([_$1, v$4]) => v$4 !== void 0),
              ),
            }),
        }),
      ],
    })
  },
  index = routeIndex({ loader, Component: Component$2 }),
  HamburgerMenu = (
    { isOpen, onToggle, onClose, sidebarData, basePath, topContent },
  ) => ((0, import_react.useEffect)(
    () => (isOpen ? document.body.style.overflow = `hidden` : document.body.style.overflow = ``, () => {
      document.body.style.overflow = ``
    }),
    [isOpen],
  ),
    (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsx)(p, {
          display: { initial: `block`, xs: `block`, sm: `block`, md: `none`, lg: `none`, xl: `none` },
          children: (0, import_jsx_runtime.jsx)(o$2, {
            size: `2`,
            variant: `ghost`,
            onClick: onToggle,
            'aria-label': `Toggle navigation menu`,
            children: isOpen
              ? (0, import_jsx_runtime.jsx)(Cross2Icon, { width: `18`, height: `18` })
              : (0, import_jsx_runtime.jsx)(HamburgerMenuIcon, { width: `18`, height: `18` }),
          }),
        }),
        isOpen && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [
            (0, import_jsx_runtime.jsx)(p, {
              position: `fixed`,
              inset: `0`,
              style: { backgroundColor: `var(--black-a9)`, zIndex: 50 },
              onClick: onClose,
              display: { initial: `block`, xs: `block`, sm: `block`, md: `none`, lg: `none`, xl: `none` },
            }),
            (0, import_jsx_runtime.jsxs)(p, {
              position: `fixed`,
              top: `0`,
              left: `0`,
              bottom: `0`,
              width: `280px`,
              style: {
                backgroundColor: `var(--color-background)`,
                boxShadow: `var(--shadow-6)`,
                zIndex: 100,
                overflowY: `auto`,
              },
              p: `4`,
              display: { initial: `block`, xs: `block`, sm: `block`, md: `none`, lg: `none`, xl: `none` },
              children: [
                (0, import_jsx_runtime.jsxs)(p$1, {
                  justify: `between`,
                  align: `center`,
                  mb: `4`,
                  children: [
                    (0, import_jsx_runtime.jsx)(p$2, { size: `5`, weight: `bold`, children: `Navigation` }),
                    (0, import_jsx_runtime.jsx)(o$2, {
                      size: `2`,
                      variant: `ghost`,
                      onClick: onClose,
                      'aria-label': `Close navigation menu`,
                      children: (0, import_jsx_runtime.jsx)(Cross2Icon, { width: `18`, height: `18` }),
                    }),
                  ],
                }),
                (0, import_jsx_runtime.jsx)(Sidebar, {
                  data: sidebarData,
                  ...basePath !== void 0 && { basePath },
                  ...topContent !== void 0 && { topContent },
                }),
              ],
            }),
          ],
        }),
      ],
    })),
  SidebarLayout = ({ children: children$3, sidebar, basePath, topContent }) => {
    let location = useLocation(), [mobileMenuOpen, setMobileMenuOpen] = (0, import_react.useState)(!1)
    ;(0, import_react.useEffect)(() => {
      setMobileMenuOpen(!1)
    }, [location.pathname])
    let isShowSidebar = sidebar && sidebar.length > 0
    return (0, import_jsx_runtime.jsxs)(Body, {
      subgrid: !0,
      children: [
        isShowSidebar && (0, import_jsx_runtime.jsx)(p, {
          display: { initial: `block`, md: `none` },
          mb: `4`,
          children: (0, import_jsx_runtime.jsx)(HamburgerMenu, {
            isOpen: mobileMenuOpen,
            onToggle: () => {
              setMobileMenuOpen(!mobileMenuOpen)
            },
            onClose: () => {
              setMobileMenuOpen(!1)
            },
            sidebarData: sidebar,
            ...basePath !== void 0 && { basePath },
            ...topContent !== void 0 && { topContent },
          }),
        }),
        isShowSidebar && (0, import_jsx_runtime.jsx)(Item$4, {
          cols: { initial: 3, md: 3 },
          children: (0, import_jsx_runtime.jsx)(p, {
            display: { initial: `none`, md: `block` },
            position: `sticky`,
            top: `4`,
            children: (0, import_jsx_runtime.jsx)(Sidebar, {
              data: sidebar,
              ...basePath !== void 0 && { basePath },
              ...topContent !== void 0 && { topContent },
            }),
          }),
        }),
        (0, import_jsx_runtime.jsx)(Item$4, { cols: 6, start: 5, children: children$3 }),
      ],
    })
  },
  pagesCatalog = { sidebarIndex: {}, pages: [] },
  routes$1 = [],
  Component$1 = () => {
    let location = useLocation(),
      pathSegments = location.pathname.split(`/`).filter(Boolean),
      topLevelPath = pathSegments[0] ? `/${pathSegments[0]}` : `/`,
      sidebar = pagesCatalog.sidebarIndex[topLevelPath]?.items || [],
      schema = schemasCatalog
    return (0, import_jsx_runtime.jsx)(MdxProvider, {
      schema,
      children: (0, import_jsx_runtime.jsx)(SidebarLayout, {
        sidebar,
        children: (0, import_jsx_runtime.jsx)(Outlet, {}),
      }),
    })
  },
  pages = route({ Component: Component$1, children: [...routes$1] }),
  isOutputField = field => `args` in field,
  isUsingInputArgumentPattern = field => {
    if (field.args.length !== 1) return !1
    let arg = field.args[0]
    return arg.name === `input`
      ? !!(isInputObjectType(arg) || isNonNullType(arg.type) && isInputObjectType(arg.type.ofType))
      : !1
  },
  getIAP = field => isUsingInputArgumentPattern(field) ? getNamedType(field.args[0].type) : null,
  getKindMap = schema => {
    let queryType = schema.getQueryType() ?? null,
      mutationType = schema.getMutationType() ?? null,
      subscriptionType = schema.getSubscriptionType() ?? null,
      rootTypeNames = [queryType?.name, mutationType?.name, subscriptionType?.name].filter(_$1 => _$1 !== void 0),
      typeMap = schema.getTypeMap(),
      typeMapValues = Object.values(typeMap),
      kindMap = {
        index: {
          Root: { query: queryType, mutation: mutationType, subscription: subscriptionType },
          OutputObject: {},
          InputObject: {},
          Interface: {},
          Union: {},
          Enum: {},
          ScalarCustom: {},
          ScalarStandard: {},
        },
        list: {
          Root: [queryType, mutationType, subscriptionType].filter(_$1 => _$1 !== null),
          OutputObject: [],
          InputObject: [],
          Interface: [],
          Union: [],
          Enum: [],
          ScalarCustom: [],
          ScalarStandard: [],
        },
      }
    for (let type$2 of typeMapValues) {
      if (type$2.name.startsWith(`__`)) continue
      switch (!0) {
        case isScalarType(type$2):
          isScalarTypeCustom(type$2)
            ? (kindMap.list.ScalarCustom.push(type$2), kindMap.index.ScalarCustom[type$2.name] = type$2)
            : (kindMap.list.ScalarStandard.push(type$2), kindMap.index.ScalarStandard[type$2.name] = type$2)
          break
        case isEnumType(type$2):
          kindMap.list.Enum.push(type$2), kindMap.index.Enum[type$2.name] = type$2
          break
        case isInputObjectType(type$2):
          kindMap.list.InputObject.push(type$2), kindMap.index.InputObject[type$2.name] = type$2
          break
        case isInterfaceType(type$2):
          kindMap.list.Interface.push(type$2), kindMap.index.Interface[type$2.name] = type$2
          break
        case isObjectType(type$2):
          includesUnknown(rootTypeNames, type$2.name)
            || (kindMap.list.OutputObject.push(type$2), kindMap.index.OutputObject[type$2.name] = type$2)
          break
        case isUnionType(type$2):
          kindMap.list.Union.push(type$2), kindMap.index.Union[type$2.name] = type$2
          break
        default:
          break
      }
    }
    return kindMap
  },
  standardScalarTypeNames = { String: `String`, ID: `ID`, Int: `Int`, Float: `Float`, Boolean: `Boolean` },
  isScalarTypeCustom = node$1 => !(node$1.name in standardScalarTypeNames),
  extractTypeNameFromChange = change =>
    value(change).pipe(
      tag$1(`TYPE_ADDED`, c$3 => some$4(c$3.name)),
      tag$1(`TYPE_REMOVED`, c$3 => some$4(c$3.name)),
      tag$1(`FIELD_ADDED`, c$3 => some$4(c$3.typeName)),
      tag$1(`FIELD_REMOVED`, c$3 => some$4(c$3.typeName)),
      tag$1(`INPUT_FIELD_ADDED`, c$3 => some$4(c$3.inputName)),
      tag$1(`INPUT_FIELD_REMOVED`, c$3 => some$4(c$3.inputName)),
      tag$1(`ENUM_VALUE_ADDED`, c$3 => some$4(c$3.enumName)),
      tag$1(`ENUM_VALUE_REMOVED`, c$3 => some$4(c$3.enumName)),
      tag$1(`UNION_MEMBER_ADDED`, c$3 => some$4(c$3.unionName)),
      tag$1(`UNION_MEMBER_REMOVED`, c$3 => some$4(c$3.unionName)),
      tag$1(`OBJECT_TYPE_INTERFACE_ADDED`, c$3 => some$4(c$3.objectName)),
      tag$1(`OBJECT_TYPE_INTERFACE_REMOVED`, c$3 => some$4(c$3.objectName)),
      orElse(() => none$7()),
    ),
  createFromSchema = schema => {
    let lifecycles = {}
    for (let revision of schema.revisions) {
      for (let change of revision.changes) {
        let typeNameOption = extractTypeNameFromChange(change)
        if (isSome(typeNameOption)) {
          let typeName = typeNameOption.value
          lifecycles[typeName] || (lifecycles[typeName] = []), lifecycles[typeName].push({ change, revision, schema })
        }
      }
    }
    return lifecycles
  },
  getTypeSince = (lifecycles, typeName, currentSchema) => {
    let entries$2 = lifecycles[typeName]
    if (!(!entries$2 || entries$2.length === 0)) {
      for (let entry of entries$2) {
        if (entry.change._tag === `TYPE_ADDED` && entry.change.name === typeName) {
          if (currentSchema && entry.schema._tag === `SchemaVersioned`) {
            if (currentSchema._tag !== `SchemaVersioned`) throw Error(`todo -- version/unversioned mismatch!`)
            let entryVer = entry.schema.version
            if (greaterThan$1(entryVer, currentSchema.version)) continue
          }
          return { _tag: `added`, revision: entry.revision, change: entry.change, schema: entry.schema }
        }
      }
      return { _tag: `initial` }
    }
  },
  getTypeRemovedDate = (lifecycles, typeName, currentSchema) => {
    let entries$2 = lifecycles[typeName]
    if (!entries$2) return
    if (!currentSchema) {
      let latestDate
      for (let entry of entries$2) {
        if (entry.change._tag === `TYPE_REMOVED` && entry.change.name === typeName) {
          let date$1 = new Date(entry.revision.date)
          ;(!latestDate || date$1 > latestDate) && (latestDate = date$1)
        }
      }
      return latestDate
    }
    let currentVer = getVersion(currentSchema)
    if (currentVer) {
      for (let entry of entries$2) {
        if (
          entry.change._tag === `TYPE_REMOVED` && entry.change.name === typeName
          && entry.schema._tag === `SchemaVersioned`
        ) {
          if (currentSchema._tag !== `SchemaVersioned`) throw Error(`todo -- version/unversioned mismatch!`)
          let entryVer = entry.schema.version
          if (greaterThan$1(entryVer, currentVer)) return
        }
      }
    }
  },
  getFieldSince = (lifecycles, typeName, fieldName, currentSchema) => {
    let entries$2 = lifecycles[typeName]
    if (!entries$2 || entries$2.length === 0) return
    let currentVer = currentSchema ? getVersion(currentSchema) : void 0
    for (let entry of entries$2) {
      let isFieldAdded$1 = entry.change._tag === `FIELD_ADDED` && entry.change.typeName === typeName
          && entry.change.fieldName === fieldName
        || entry.change._tag === `INPUT_FIELD_ADDED` && entry.change.inputName === typeName
          && entry.change.fieldName === fieldName
      if (isFieldAdded$1) {
        if (currentVer && entry.schema._tag === `SchemaVersioned`) {
          if (currentSchema && currentSchema._tag !== `SchemaVersioned`) {
            throw Error(`todo -- version/unversioned mismatch!`)
          }
          let entryVer = entry.schema.version
          if (greaterThan$1(entryVer, currentVer)) continue
        }
        return { _tag: `added`, revision: entry.revision, change: entry.change, schema: entry.schema }
      }
    }
    return { _tag: `initial` }
  },
  getFieldRemovedDate = (lifecycles, typeName, fieldName, currentSchema) => {
    let entries$2 = lifecycles[typeName]
    if (entries$2 && !currentSchema) {
      let latestDate
      for (let entry of entries$2) {
        let isFieldRemoved$1 = entry.change._tag === `FIELD_REMOVED` && entry.change.typeName === typeName
            && entry.change.fieldName === fieldName
          || entry.change._tag === `INPUT_FIELD_REMOVED` && entry.change.inputName === typeName
            && entry.change.fieldName === fieldName
        if (isFieldRemoved$1) {
          let date$1 = new Date(entry.revision.date)
          ;(!latestDate || date$1 > latestDate) && (latestDate = date$1)
        }
      }
      return latestDate
    }
  },
  SchemaContext = (0, import_react.createContext)(void 0),
  GraphqlLifecycleProvider = ({ children: children$3, lifecycle, schema }) =>
    (0, import_jsx_runtime.jsx)(SchemaContext.Provider, {
      value: { schema, lifecycles: lifecycle },
      children: children$3,
    }),
  useSchema = () => {
    let context$2 = (0, import_react.useContext)(SchemaContext)
    if (!context$2) throw Error(`useSchema must be used within a GraphqlLifecycleProvider`)
    return context$2
  },
  TypeAnnotation = ({ type: type$2 }) => {
    if (isNonNullType(type$2)) {
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: [
          (0, import_jsx_runtime.jsx)(TypeAnnotation, { type: type$2.ofType }),
          (0, import_jsx_runtime.jsx)(p$2, { color: `gray`, children: `!` }),
        ],
      })
    }
    if (isListType(type$2)) {
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: [
          (0, import_jsx_runtime.jsx)(p$2, { color: `gray`, children: `[` }),
          (0, import_jsx_runtime.jsx)(TypeAnnotation, { type: type$2.ofType }),
          (0, import_jsx_runtime.jsx)(p$2, { color: `gray`, children: `]` }),
        ],
      })
    }
    if (isNamedType(type$2)) return (0, import_jsx_runtime.jsx)(TypeLink, { type: type$2 })
    let _exhaustive = type$2
    throw Error(`Unexpected GraphQL type encountered: ${String(_exhaustive)}`)
  },
  ArgumentAnnotation = ({ data }) =>
    (0, import_jsx_runtime.jsxs)(p$1, {
      align: `baseline`,
      gap: `1`,
      children: [
        (0, import_jsx_runtime.jsx)(p$3, { size: `2`, variant: `ghost`, color: `gray`, children: data.name }),
        (0, import_jsx_runtime.jsx)(p$2, { size: `2`, color: `gray`, children: `:` }),
        (0, import_jsx_runtime.jsx)(TypeAnnotation, { type: data.type }),
      ],
    }),
  FieldList = ({ data, parentTypeName }) => {
    if (!isFielded(data)) return null
    let fields = getFields(data)
    if (fields.length === 0) return null
    let maxFieldNameLength = (0, import_react.useMemo)(() => Math.max(...fields.map(field => field.name.length)), [
      fields,
    ])
    return (0, import_jsx_runtime.jsx)(p$1, {
      direction: `column`,
      gap: `3`,
      children: fields.map(field =>
        (0, import_jsx_runtime.jsx)(Field, {
          data: field,
          parentTypeName: parentTypeName ?? data.name,
          fieldNameWidth: maxFieldNameLength,
        }, field.name)
      ),
    })
  },
  ArgumentListAnnotation = ({ field }) => {
    if (field.args.length === 0) return null
    let inputObject = getIAP(field),
      inputObjectFields = inputObject
        ? (0, import_jsx_runtime.jsxs)(p, {
          mt: `3`,
          children: [
            (0, import_jsx_runtime.jsx)(o$1, { size: `1`, my: `2` }),
            (0, import_jsx_runtime.jsx)(p$2, {
              size: `1`,
              color: `gray`,
              weight: `medium`,
              children: `Input Object Fields:`,
            }),
            (0, import_jsx_runtime.jsx)(p, {
              mt: `2`,
              ml: `3`,
              style: { borderLeft: `1px solid var(--gray-4)` },
              children: (0, import_jsx_runtime.jsx)(FieldList, { data: inputObject }),
            }),
          ],
        })
        : null
    return (0, import_jsx_runtime.jsx)(p, {
      children: (0, import_jsx_runtime.jsxs)(p$1, {
        direction: `column`,
        gap: `2`,
        children: [
          field.args.map(arg =>
            (0, import_jsx_runtime.jsx)(p, {
              ml: `3`,
              children: (0, import_jsx_runtime.jsx)(ArgumentAnnotation, { data: arg }),
            }, arg.name)
          ),
          inputObjectFields,
        ],
      }),
    })
  },
  htmlVoidElements = [
    `area`,
    `base`,
    `basefont`,
    `bgsound`,
    `br`,
    `col`,
    `command`,
    `embed`,
    `frame`,
    `hr`,
    `image`,
    `img`,
    `input`,
    `keygen`,
    `link`,
    `meta`,
    `param`,
    `source`,
    `track`,
    `wbr`,
  ]
var Schema = class {
  constructor(property, normal, space$1) {
    this.normal = normal, this.property = property, space$1 && (this.space = space$1)
  }
}
Schema.prototype.normal = {}, Schema.prototype.property = {}, Schema.prototype.space = void 0
function merge(definitions, space$1) {
  let property = {}, normal = {}
  for (let definition$2 of definitions) {
    Object.assign(property, definition$2.property), Object.assign(normal, definition$2.normal)
  }
  return new Schema(property, normal, space$1)
}
function normalize$1(value$2) {
  return value$2.toLowerCase()
}
var Info = class {
  constructor(property, attribute) {
    this.attribute = attribute, this.property = property
  }
}
Info.prototype.attribute = ``,
  Info.prototype.booleanish = !1,
  Info.prototype.boolean = !1,
  Info.prototype.commaOrSpaceSeparated = !1,
  Info.prototype.commaSeparated = !1,
  Info.prototype.defined = !1,
  Info.prototype.mustUseProperty = !1,
  Info.prototype.number = !1,
  Info.prototype.overloadedBoolean = !1,
  Info.prototype.property = ``,
  Info.prototype.spaceSeparated = !1,
  Info.prototype.space = void 0
var types_exports = {}
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated,
})
let powers = 0
const boolean = increment(),
  booleanish = increment(),
  overloadedBoolean = increment(),
  number = increment(),
  spaceSeparated = increment(),
  commaSeparated = increment(),
  commaOrSpaceSeparated = increment()
function increment() {
  return 2 ** ++powers
}
const checks = Object.keys(types_exports)
var DefinedInfo = class extends Info {
  constructor(property, attribute, mask, space$1) {
    let index$4 = -1
    if (super(property, attribute), mark(this, `space`, space$1), typeof mask == `number`) {
      for (; ++index$4 < checks.length;) {
        let check$1 = checks[index$4]
        mark(this, checks[index$4], (mask & types_exports[check$1]) === types_exports[check$1])
      }
    }
  }
}
DefinedInfo.prototype.defined = !0
function mark(values$6, key$1, value$2) {
  value$2 && (values$6[key$1] = value$2)
}
function create(definition$2) {
  let properties = {}, normals = {}
  for (let [property, value$2] of Object.entries(definition$2.properties)) {
    let info = new DefinedInfo(
      property,
      definition$2.transform(definition$2.attributes || {}, property),
      value$2,
      definition$2.space,
    )
    definition$2.mustUseProperty && definition$2.mustUseProperty.includes(property) && (info.mustUseProperty = !0),
      properties[property] = info,
      normals[normalize$1(property)] = property,
      normals[normalize$1(info.attribute)] = property
  }
  return new Schema(properties, normals, definition$2.space)
}
const aria = create({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null,
  },
  transform(_$1, property) {
    return property === `role` ? property : `aria-` + property.slice(4).toLowerCase()
  },
})
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase())
}
const html$5 = create({
    attributes: { acceptcharset: `accept-charset`, classname: `class`, htmlfor: `for`, httpequiv: `http-equiv` },
    mustUseProperty: [`checked`, `multiple`, `muted`, `selected`],
    properties: {
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      blocking: spaceSeparated,
      capture: null,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number,
      hidden: overloadedBoolean,
      high: number,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: boolean,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number,
      manifest: null,
      max: null,
      maxLength: number,
      media: null,
      method: null,
      min: null,
      minLength: number,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number,
      rowSpan: number,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shadowRootClonable: boolean,
      shadowRootDelegatesFocus: boolean,
      shadowRootMode: null,
      shape: null,
      size: number,
      sizes: null,
      slot: null,
      span: number,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: number,
      step: null,
      style: null,
      tabIndex: number,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number,
      wrap: null,
      writingSuggestions: null,
      align: null,
      aLink: null,
      archive: spaceSeparated,
      axis: null,
      background: null,
      bgColor: null,
      border: number,
      borderColor: null,
      bottomMargin: number,
      cellPadding: null,
      cellSpacing: null,
      char: null,
      charOff: null,
      classId: null,
      clear: null,
      code: null,
      codeBase: null,
      codeType: null,
      color: null,
      compact: boolean,
      declare: boolean,
      event: null,
      face: null,
      frame: null,
      frameBorder: null,
      hSpace: number,
      leftMargin: number,
      link: null,
      longDesc: null,
      lowSrc: null,
      marginHeight: number,
      marginWidth: number,
      noResize: boolean,
      noHref: boolean,
      noShade: boolean,
      noWrap: boolean,
      object: null,
      profile: null,
      prompt: null,
      rev: null,
      rightMargin: number,
      rules: null,
      scheme: null,
      scrolling: booleanish,
      standby: null,
      summary: null,
      text: null,
      topMargin: number,
      valueType: null,
      version: null,
      vAlign: null,
      vLink: null,
      vSpace: number,
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number,
      security: null,
      unselectable: null,
    },
    space: `html`,
    transform: caseInsensitiveTransform,
  }),
  svg$1 = create({
    attributes: {
      accentHeight: `accent-height`,
      alignmentBaseline: `alignment-baseline`,
      arabicForm: `arabic-form`,
      baselineShift: `baseline-shift`,
      capHeight: `cap-height`,
      className: `class`,
      clipPath: `clip-path`,
      clipRule: `clip-rule`,
      colorInterpolation: `color-interpolation`,
      colorInterpolationFilters: `color-interpolation-filters`,
      colorProfile: `color-profile`,
      colorRendering: `color-rendering`,
      crossOrigin: `crossorigin`,
      dataType: `datatype`,
      dominantBaseline: `dominant-baseline`,
      enableBackground: `enable-background`,
      fillOpacity: `fill-opacity`,
      fillRule: `fill-rule`,
      floodColor: `flood-color`,
      floodOpacity: `flood-opacity`,
      fontFamily: `font-family`,
      fontSize: `font-size`,
      fontSizeAdjust: `font-size-adjust`,
      fontStretch: `font-stretch`,
      fontStyle: `font-style`,
      fontVariant: `font-variant`,
      fontWeight: `font-weight`,
      glyphName: `glyph-name`,
      glyphOrientationHorizontal: `glyph-orientation-horizontal`,
      glyphOrientationVertical: `glyph-orientation-vertical`,
      hrefLang: `hreflang`,
      horizAdvX: `horiz-adv-x`,
      horizOriginX: `horiz-origin-x`,
      horizOriginY: `horiz-origin-y`,
      imageRendering: `image-rendering`,
      letterSpacing: `letter-spacing`,
      lightingColor: `lighting-color`,
      markerEnd: `marker-end`,
      markerMid: `marker-mid`,
      markerStart: `marker-start`,
      navDown: `nav-down`,
      navDownLeft: `nav-down-left`,
      navDownRight: `nav-down-right`,
      navLeft: `nav-left`,
      navNext: `nav-next`,
      navPrev: `nav-prev`,
      navRight: `nav-right`,
      navUp: `nav-up`,
      navUpLeft: `nav-up-left`,
      navUpRight: `nav-up-right`,
      onAbort: `onabort`,
      onActivate: `onactivate`,
      onAfterPrint: `onafterprint`,
      onBeforePrint: `onbeforeprint`,
      onBegin: `onbegin`,
      onCancel: `oncancel`,
      onCanPlay: `oncanplay`,
      onCanPlayThrough: `oncanplaythrough`,
      onChange: `onchange`,
      onClick: `onclick`,
      onClose: `onclose`,
      onCopy: `oncopy`,
      onCueChange: `oncuechange`,
      onCut: `oncut`,
      onDblClick: `ondblclick`,
      onDrag: `ondrag`,
      onDragEnd: `ondragend`,
      onDragEnter: `ondragenter`,
      onDragExit: `ondragexit`,
      onDragLeave: `ondragleave`,
      onDragOver: `ondragover`,
      onDragStart: `ondragstart`,
      onDrop: `ondrop`,
      onDurationChange: `ondurationchange`,
      onEmptied: `onemptied`,
      onEnd: `onend`,
      onEnded: `onended`,
      onError: `onerror`,
      onFocus: `onfocus`,
      onFocusIn: `onfocusin`,
      onFocusOut: `onfocusout`,
      onHashChange: `onhashchange`,
      onInput: `oninput`,
      onInvalid: `oninvalid`,
      onKeyDown: `onkeydown`,
      onKeyPress: `onkeypress`,
      onKeyUp: `onkeyup`,
      onLoad: `onload`,
      onLoadedData: `onloadeddata`,
      onLoadedMetadata: `onloadedmetadata`,
      onLoadStart: `onloadstart`,
      onMessage: `onmessage`,
      onMouseDown: `onmousedown`,
      onMouseEnter: `onmouseenter`,
      onMouseLeave: `onmouseleave`,
      onMouseMove: `onmousemove`,
      onMouseOut: `onmouseout`,
      onMouseOver: `onmouseover`,
      onMouseUp: `onmouseup`,
      onMouseWheel: `onmousewheel`,
      onOffline: `onoffline`,
      onOnline: `ononline`,
      onPageHide: `onpagehide`,
      onPageShow: `onpageshow`,
      onPaste: `onpaste`,
      onPause: `onpause`,
      onPlay: `onplay`,
      onPlaying: `onplaying`,
      onPopState: `onpopstate`,
      onProgress: `onprogress`,
      onRateChange: `onratechange`,
      onRepeat: `onrepeat`,
      onReset: `onreset`,
      onResize: `onresize`,
      onScroll: `onscroll`,
      onSeeked: `onseeked`,
      onSeeking: `onseeking`,
      onSelect: `onselect`,
      onShow: `onshow`,
      onStalled: `onstalled`,
      onStorage: `onstorage`,
      onSubmit: `onsubmit`,
      onSuspend: `onsuspend`,
      onTimeUpdate: `ontimeupdate`,
      onToggle: `ontoggle`,
      onUnload: `onunload`,
      onVolumeChange: `onvolumechange`,
      onWaiting: `onwaiting`,
      onZoom: `onzoom`,
      overlinePosition: `overline-position`,
      overlineThickness: `overline-thickness`,
      paintOrder: `paint-order`,
      panose1: `panose-1`,
      pointerEvents: `pointer-events`,
      referrerPolicy: `referrerpolicy`,
      renderingIntent: `rendering-intent`,
      shapeRendering: `shape-rendering`,
      stopColor: `stop-color`,
      stopOpacity: `stop-opacity`,
      strikethroughPosition: `strikethrough-position`,
      strikethroughThickness: `strikethrough-thickness`,
      strokeDashArray: `stroke-dasharray`,
      strokeDashOffset: `stroke-dashoffset`,
      strokeLineCap: `stroke-linecap`,
      strokeLineJoin: `stroke-linejoin`,
      strokeMiterLimit: `stroke-miterlimit`,
      strokeOpacity: `stroke-opacity`,
      strokeWidth: `stroke-width`,
      tabIndex: `tabindex`,
      textAnchor: `text-anchor`,
      textDecoration: `text-decoration`,
      textRendering: `text-rendering`,
      transformOrigin: `transform-origin`,
      typeOf: `typeof`,
      underlinePosition: `underline-position`,
      underlineThickness: `underline-thickness`,
      unicodeBidi: `unicode-bidi`,
      unicodeRange: `unicode-range`,
      unitsPerEm: `units-per-em`,
      vAlphabetic: `v-alphabetic`,
      vHanging: `v-hanging`,
      vIdeographic: `v-ideographic`,
      vMathematical: `v-mathematical`,
      vectorEffect: `vector-effect`,
      vertAdvY: `vert-adv-y`,
      vertOriginX: `vert-origin-x`,
      vertOriginY: `vert-origin-y`,
      wordSpacing: `word-spacing`,
      writingMode: `writing-mode`,
      xHeight: `x-height`,
      playbackOrder: `playbackorder`,
      timelineBegin: `timelinebegin`,
    },
    properties: {
      about: commaOrSpaceSeparated,
      accentHeight: number,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: number,
      amplitude: number,
      arabicForm: null,
      ascent: number,
      attributeName: null,
      attributeType: null,
      azimuth: number,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: number,
      by: null,
      calcMode: null,
      capHeight: number,
      className: spaceSeparated,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: number,
      diffuseConstant: number,
      direction: null,
      display: null,
      dur: null,
      divisor: number,
      dominantBaseline: null,
      download: boolean,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: number,
      enableBackground: null,
      end: null,
      event: null,
      exponent: number,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: number,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: commaSeparated,
      g2: commaSeparated,
      glyphName: commaSeparated,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: number,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: number,
      horizOriginX: number,
      horizOriginY: number,
      id: null,
      ideographic: number,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: number,
      k: number,
      k1: number,
      k2: number,
      k3: number,
      k4: number,
      kernelMatrix: commaOrSpaceSeparated,
      kernelUnitLength: null,
      keyPoints: null,
      keySplines: null,
      keyTimes: null,
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: number,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: number,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: number,
      overlineThickness: number,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: number,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: spaceSeparated,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: number,
      pointsAtY: number,
      pointsAtZ: number,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: commaOrSpaceSeparated,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: commaOrSpaceSeparated,
      rev: commaOrSpaceSeparated,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: commaOrSpaceSeparated,
      requiredFeatures: commaOrSpaceSeparated,
      requiredFonts: commaOrSpaceSeparated,
      requiredFormats: commaOrSpaceSeparated,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: number,
      specularExponent: number,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: number,
      strikethroughThickness: number,
      string: null,
      stroke: null,
      strokeDashArray: commaOrSpaceSeparated,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: number,
      strokeOpacity: number,
      strokeWidth: null,
      style: null,
      surfaceScale: number,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: commaOrSpaceSeparated,
      tabIndex: number,
      tableValues: null,
      target: null,
      targetX: number,
      targetY: number,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: commaOrSpaceSeparated,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: number,
      underlineThickness: number,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: number,
      values: null,
      vAlphabetic: number,
      vMathematical: number,
      vectorEffect: null,
      vHanging: number,
      vIdeographic: number,
      version: null,
      vertAdvY: number,
      vertOriginX: number,
      vertOriginY: number,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: number,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null,
    },
    space: `svg`,
    transform: caseSensitiveTransform,
  }),
  xlink = create({
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null,
    },
    space: `xlink`,
    transform(_$1, property) {
      return `xlink:` + property.slice(5).toLowerCase()
    },
  }),
  xmlns = create({
    attributes: { xmlnsxlink: `xmlns:xlink` },
    properties: { xmlnsXLink: null, xmlns: null },
    space: `xmlns`,
    transform: caseInsensitiveTransform,
  }),
  xml = create({
    properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
    space: `xml`,
    transform(_$1, property) {
      return `xml:` + property.slice(3).toLowerCase()
    },
  }),
  cap = /[A-Z]/g,
  dash = /-[a-z]/g,
  valid = /^data[-\w.:]+$/i
function find(schema, value$2) {
  let normal = normalize$1(value$2), property = value$2, Type$3 = Info
  if (normal in schema.normal) return schema.property[schema.normal[normal]]
  if (normal.length > 4 && normal.slice(0, 4) === `data` && valid.test(value$2)) {
    if (value$2.charAt(4) === `-`) {
      let rest = value$2.slice(5).replace(dash, camelcase)
      property = `data` + rest.charAt(0).toUpperCase() + rest.slice(1)
    } else {
      let rest = value$2.slice(4)
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab)
        dashes.charAt(0) !== `-` && (dashes = `-` + dashes), value$2 = `data` + dashes
      }
    }
    Type$3 = DefinedInfo
  }
  return new Type$3(property, value$2)
}
function kebab($0) {
  return `-` + $0.toLowerCase()
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase()
}
const html$2 = merge([aria, html$5, xlink, xmlns, xml], `html`),
  svg = merge([aria, svg$1, xlink, xmlns, xml], `svg`),
  own$5 = {}.hasOwnProperty
function zwitch(key$1, options$2) {
  let settings = options$2 || {}
  function one$2(value$2, ...parameters) {
    let fn = one$2.invalid, handlers$1 = one$2.handlers
    if (value$2 && own$5.call(value$2, key$1)) {
      let id$2 = String(value$2[key$1])
      fn = own$5.call(handlers$1, id$2) ? handlers$1[id$2] : one$2.unknown
    }
    if (fn) return fn.call(this, value$2, ...parameters)
  }
  return one$2.handlers = settings.handlers || {},
    one$2.invalid = settings.invalid,
    one$2.unknown = settings.unknown,
    one$2
}
const defaultSubsetRegex = /["&'<>`]/g,
  surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  controlCharactersRegex = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
  regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g,
  subsetToRegexCache = new WeakMap()
function core(value$2, options$2) {
  if (
    value$2 = value$2.replace(
      options$2.subset ? charactersToExpressionCached(options$2.subset) : defaultSubsetRegex,
      basic,
    ), options$2.subset || options$2.escapeOnly
  ) return value$2
  return value$2.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic)
  function surrogate(pair, index$4, all$8) {
    return options$2.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all$8.charCodeAt(index$4 + 2),
      options$2,
    )
  }
  function basic(character, index$4, all$8) {
    return options$2.format(character.charCodeAt(0), all$8.charCodeAt(index$4 + 1), options$2)
  }
}
function charactersToExpressionCached(subset) {
  let cached$3 = subsetToRegexCache.get(subset)
  return cached$3 || (cached$3 = charactersToExpression(subset), subsetToRegexCache.set(subset, cached$3)), cached$3
}
function charactersToExpression(subset) {
  let groups = [], index$4 = -1
  for (; ++index$4 < subset.length;) groups.push(subset[index$4].replace(regexEscapeRegex, `\\$&`))
  return RegExp(`(?:` + groups.join(`|`) + `)`, `g`)
}
const hexadecimalRegex = /[\dA-Fa-f]/
function toHexadecimal(code$3, next, omit$3) {
  let value$2 = `&#x` + code$3.toString(16).toUpperCase()
  return omit$3 && next && !hexadecimalRegex.test(String.fromCharCode(next)) ? value$2 : value$2 + `;`
}
const decimalRegex = /\d/
function toDecimal(code$3, next, omit$3) {
  let value$2 = `&#` + String(code$3)
  return omit$3 && next && !decimalRegex.test(String.fromCharCode(next)) ? value$2 : value$2 + `;`
}
const characterEntitiesLegacy =
    `AElig.AMP.Aacute.Acirc.Agrave.Aring.Atilde.Auml.COPY.Ccedil.ETH.Eacute.Ecirc.Egrave.Euml.GT.Iacute.Icirc.Igrave.Iuml.LT.Ntilde.Oacute.Ocirc.Ograve.Oslash.Otilde.Ouml.QUOT.REG.THORN.Uacute.Ucirc.Ugrave.Uuml.Yacute.aacute.acirc.acute.aelig.agrave.amp.aring.atilde.auml.brvbar.ccedil.cedil.cent.copy.curren.deg.divide.eacute.ecirc.egrave.eth.euml.frac12.frac14.frac34.gt.iacute.icirc.iexcl.igrave.iquest.iuml.laquo.lt.macr.micro.middot.nbsp.not.ntilde.oacute.ocirc.ograve.ordf.ordm.oslash.otilde.ouml.para.plusmn.pound.quot.raquo.reg.sect.shy.sup1.sup2.sup3.szlig.thorn.times.uacute.ucirc.ugrave.uml.uuml.yacute.yen.yuml`
      .split(`.`),
  characterEntitiesHtml4 = {
    nbsp: `\xA0`,
    iexcl: ``,
    cent: ``,
    pound: ``,
    curren: ``,
    yen: ``,
    brvbar: ``,
    sect: ``,
    uml: ``,
    copy: ``,
    ordf: ``,
    laquo: ``,
    not: ``,
    shy: ``,
    reg: ``,
    macr: ``,
    deg: ``,
    plusmn: ``,
    sup2: ``,
    sup3: ``,
    acute: ``,
    micro: ``,
    para: ``,
    middot: ``,
    cedil: ``,
    sup1: ``,
    ordm: ``,
    raquo: ``,
    frac14: ``,
    frac12: ``,
    frac34: ``,
    iquest: ``,
    Agrave: ``,
    Aacute: ``,
    Acirc: ``,
    Atilde: ``,
    Auml: ``,
    Aring: ``,
    AElig: ``,
    Ccedil: ``,
    Egrave: ``,
    Eacute: ``,
    Ecirc: ``,
    Euml: ``,
    Igrave: ``,
    Iacute: ``,
    Icirc: ``,
    Iuml: ``,
    ETH: ``,
    Ntilde: ``,
    Ograve: ``,
    Oacute: ``,
    Ocirc: ``,
    Otilde: ``,
    Ouml: ``,
    times: ``,
    Oslash: ``,
    Ugrave: ``,
    Uacute: ``,
    Ucirc: ``,
    Uuml: ``,
    Yacute: ``,
    THORN: ``,
    szlig: ``,
    agrave: ``,
    aacute: ``,
    acirc: ``,
    atilde: ``,
    auml: ``,
    aring: ``,
    aelig: ``,
    ccedil: ``,
    egrave: ``,
    eacute: ``,
    ecirc: ``,
    euml: ``,
    igrave: ``,
    iacute: ``,
    icirc: ``,
    iuml: ``,
    eth: ``,
    ntilde: ``,
    ograve: ``,
    oacute: ``,
    ocirc: ``,
    otilde: ``,
    ouml: ``,
    divide: ``,
    oslash: ``,
    ugrave: ``,
    uacute: ``,
    ucirc: ``,
    uuml: ``,
    yacute: ``,
    thorn: ``,
    yuml: ``,
    fnof: ``,
    Alpha: ``,
    Beta: ``,
    Gamma: ``,
    Delta: ``,
    Epsilon: ``,
    Zeta: ``,
    Eta: ``,
    Theta: ``,
    Iota: ``,
    Kappa: ``,
    Lambda: ``,
    Mu: ``,
    Nu: ``,
    Xi: ``,
    Omicron: ``,
    Pi: ``,
    Rho: ``,
    Sigma: ``,
    Tau: ``,
    Upsilon: ``,
    Phi: ``,
    Chi: ``,
    Psi: ``,
    Omega: ``,
    alpha: ``,
    beta: ``,
    gamma: ``,
    delta: ``,
    epsilon: ``,
    zeta: ``,
    eta: ``,
    theta: ``,
    iota: ``,
    kappa: ``,
    lambda: ``,
    mu: ``,
    nu: ``,
    xi: ``,
    omicron: ``,
    pi: ``,
    rho: ``,
    sigmaf: ``,
    sigma: ``,
    tau: ``,
    upsilon: ``,
    phi: ``,
    chi: ``,
    psi: ``,
    omega: ``,
    thetasym: ``,
    upsih: ``,
    piv: ``,
    bull: ``,
    hellip: ``,
    prime: ``,
    Prime: ``,
    oline: ``,
    frasl: ``,
    weierp: ``,
    image: ``,
    real: ``,
    trade: ``,
    alefsym: ``,
    larr: ``,
    uarr: ``,
    rarr: ``,
    darr: ``,
    harr: ``,
    crarr: ``,
    lArr: ``,
    uArr: ``,
    rArr: ``,
    dArr: ``,
    hArr: ``,
    forall: ``,
    part: ``,
    exist: ``,
    empty: ``,
    nabla: ``,
    isin: ``,
    notin: ``,
    ni: ``,
    prod: ``,
    sum: ``,
    minus: ``,
    lowast: ``,
    radic: ``,
    prop: ``,
    infin: ``,
    ang: ``,
    and: ``,
    or: ``,
    cap: ``,
    cup: ``,
    int: ``,
    there4: ``,
    sim: ``,
    cong: ``,
    asymp: ``,
    ne: ``,
    equiv: ``,
    le: ``,
    ge: ``,
    sub: ``,
    sup: ``,
    nsub: ``,
    sube: ``,
    supe: ``,
    oplus: ``,
    otimes: ``,
    perp: ``,
    sdot: ``,
    lceil: ``,
    rceil: ``,
    lfloor: ``,
    rfloor: ``,
    lang: ``,
    rang: ``,
    loz: ``,
    spades: ``,
    clubs: ``,
    hearts: ``,
    diams: ``,
    quot: `"`,
    amp: `&`,
    lt: `<`,
    gt: `>`,
    OElig: ``,
    oelig: ``,
    Scaron: ``,
    scaron: ``,
    Yuml: ``,
    circ: ``,
    tilde: ``,
    ensp: ``,
    emsp: ``,
    thinsp: ``,
    zwnj: ``,
    zwj: ``,
    lrm: ``,
    rlm: ``,
    ndash: ``,
    mdash: ``,
    lsquo: ``,
    rsquo: ``,
    sbquo: ``,
    ldquo: ``,
    rdquo: ``,
    bdquo: ``,
    dagger: ``,
    Dagger: ``,
    permil: ``,
    lsaquo: ``,
    rsaquo: ``,
    euro: ``,
  },
  dangerous = [`cent`, `copy`, `divide`, `gt`, `lt`, `not`, `para`, `times`],
  own$4 = {}.hasOwnProperty,
  characters = {}
let key
for (key in characterEntitiesHtml4) {
  own$4.call(characterEntitiesHtml4, key) && (characters[characterEntitiesHtml4[key]] = key)
}
const notAlphanumericRegex = /[^\dA-Za-z]/
function toNamed(code$3, next, omit$3, attribute) {
  let character = String.fromCharCode(code$3)
  if (own$4.call(characters, character)) {
    let name = characters[character], value$2 = `&` + name
    return omit$3 && characterEntitiesLegacy.includes(name) && !dangerous.includes(name)
        && (!attribute || next && next !== 61 && notAlphanumericRegex.test(String.fromCharCode(next)))
      ? value$2
      : value$2 + `;`
  }
  return ``
}
function formatSmart(code$3, next, options$2) {
  let numeric = toHexadecimal(code$3, next, options$2.omitOptionalSemicolons), named
  if (
    (options$2.useNamedReferences || options$2.useShortestReferences)
    && (named = toNamed(code$3, next, options$2.omitOptionalSemicolons, options$2.attribute)),
      (options$2.useShortestReferences || !named) && options$2.useShortestReferences
  ) {
    let decimal = toDecimal(code$3, next, options$2.omitOptionalSemicolons)
    decimal.length < numeric.length && (numeric = decimal)
  }
  return named && (!options$2.useShortestReferences || named.length < numeric.length) ? named : numeric
}
function stringifyEntities(value$2, options$2) {
  return core(value$2, Object.assign({ format: formatSmart }, options$2))
}
const htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g,
  bogusCommentEntitySubset = [`>`],
  commentEntitySubset = [`<`, `>`]
function comment(node$1, _1, _2, state) {
  return state.settings.bogusComments
    ? `<?`
      + stringifyEntities(
        node$1.value,
        Object.assign({}, state.settings.characterReferences, { subset: bogusCommentEntitySubset }),
      ) + `>`
    : `<!--` + node$1.value.replace(htmlCommentRegex, encode$29) + `-->`
  function encode$29($0) {
    return stringifyEntities($0, Object.assign({}, state.settings.characterReferences, { subset: commentEntitySubset }))
  }
}
function doctype(_1, _2, _3, state) {
  return `<!` + (state.settings.upperDoctype ? `DOCTYPE` : `doctype`) + (state.settings.tightDoctype ? `` : ` `)
    + `html>`
}
function ccount(value$2, character) {
  let source = String(value$2)
  if (typeof character != `string`) throw TypeError(`Expected character`)
  let count$2 = 0, index$4 = source.indexOf(character)
  for (; index$4 !== -1;) count$2++, index$4 = source.indexOf(character, index$4 + character.length)
  return count$2
}
function stringify(values$6, options$2) {
  let settings = options$2 || {}, input = values$6[values$6.length - 1] === `` ? [...values$6, ``] : values$6
  return input.join((settings.padRight ? ` ` : ``) + `,` + (settings.padLeft === !1 ? `` : ` `)).trim()
}
function stringify$1(values$6) {
  return values$6.join(` `).trim()
}
const re = /[ \t\n\f\r]/g
function whitespace(thing) {
  return typeof thing == `object` ? thing.type === `text` ? empty$1(thing.value) : !1 : empty$1(thing)
}
function empty$1(value$2) {
  return value$2.replace(re, ``) === ``
}
const siblingAfter = siblings(1), siblingBefore = siblings(-1), emptyChildren$1 = []
function siblings(increment$1) {
  return sibling
  function sibling(parent, index$4, includeWhitespace) {
    let siblings$1 = parent ? parent.children : emptyChildren$1,
      offset$3 = (index$4 || 0) + increment$1,
      next = siblings$1[offset$3]
    if (!includeWhitespace) for (; next && whitespace(next);) offset$3 += increment$1, next = siblings$1[offset$3]
    return next
  }
}
const own$3 = {}.hasOwnProperty
function omission(handlers$1) {
  return omit$3
  function omit$3(node$1, index$4, parent) {
    return own$3.call(handlers$1, node$1.tagName) && handlers$1[node$1.tagName](node$1, index$4, parent)
  }
}
const closing = omission({
  body: body$1,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt,
  head: headOrColgroupOrCaption,
  html: html$4,
  li,
  optgroup,
  option,
  p: p$4,
  rp: rubyElement,
  rt: rubyElement,
  tbody: tbody$1,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr,
})
function headOrColgroupOrCaption(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4, !0)
  return !next || next.type !== `comment` && !(next.type === `text` && whitespace(next.value.charAt(0)))
}
function html$4(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type !== `comment`
}
function body$1(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type !== `comment`
}
function p$4(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return next
    ? next.type === `element`
      && (next.tagName === `address` || next.tagName === `article` || next.tagName === `aside`
        || next.tagName === `blockquote` || next.tagName === `details` || next.tagName === `div`
        || next.tagName === `dl` || next.tagName === `fieldset` || next.tagName === `figcaption`
        || next.tagName === `figure` || next.tagName === `footer` || next.tagName === `form` || next.tagName === `h1`
        || next.tagName === `h2` || next.tagName === `h3` || next.tagName === `h4` || next.tagName === `h5`
        || next.tagName === `h6` || next.tagName === `header` || next.tagName === `hgroup` || next.tagName === `hr`
        || next.tagName === `main` || next.tagName === `menu` || next.tagName === `nav` || next.tagName === `ol`
        || next.tagName === `p` || next.tagName === `pre` || next.tagName === `section` || next.tagName === `table`
        || next.tagName === `ul`)
    : !parent
      || !(parent.type === `element`
        && (parent.tagName === `a` || parent.tagName === `audio` || parent.tagName === `del` || parent.tagName === `ins`
          || parent.tagName === `map` || parent.tagName === `noscript` || parent.tagName === `video`))
}
function li(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && next.tagName === `li`
}
function dt(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !!(next && next.type === `element` && (next.tagName === `dt` || next.tagName === `dd`))
}
function dd(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && (next.tagName === `dt` || next.tagName === `dd`)
}
function rubyElement(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && (next.tagName === `rp` || next.tagName === `rt`)
}
function optgroup(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && next.tagName === `optgroup`
}
function option(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && (next.tagName === `option` || next.tagName === `optgroup`)
}
function thead(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !!(next && next.type === `element` && (next.tagName === `tbody` || next.tagName === `tfoot`))
}
function tbody$1(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && (next.tagName === `tbody` || next.tagName === `tfoot`)
}
function tfoot(_$1, index$4, parent) {
  return !siblingAfter(parent, index$4)
}
function tr(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && next.tagName === `tr`
}
function cells(_$1, index$4, parent) {
  let next = siblingAfter(parent, index$4)
  return !next || next.type === `element` && (next.tagName === `td` || next.tagName === `th`)
}
const opening = omission({ body, colgroup, head, html: html$3, tbody })
function html$3(node$1) {
  let head$5 = siblingAfter(node$1, -1)
  return !head$5 || head$5.type !== `comment`
}
function head(node$1) {
  let seen$1 = new Set()
  for (let child$1 of node$1.children) {
    if (child$1.type === `element` && (child$1.tagName === `base` || child$1.tagName === `title`)) {
      if (seen$1.has(child$1.tagName)) return !1
      seen$1.add(child$1.tagName)
    }
  }
  let child = node$1.children[0]
  return !child || child.type === `element`
}
function body(node$1) {
  let head$5 = siblingAfter(node$1, -1, !0)
  return !head$5
    || head$5.type !== `comment` && !(head$5.type === `text` && whitespace(head$5.value.charAt(0)))
      && !(head$5.type === `element`
        && (head$5.tagName === `meta` || head$5.tagName === `link` || head$5.tagName === `script`
          || head$5.tagName === `style` || head$5.tagName === `template`))
}
function colgroup(node$1, index$4, parent) {
  let previous$2 = siblingBefore(parent, index$4), head$5 = siblingAfter(node$1, -1, !0)
  return parent && previous$2 && previous$2.type === `element` && previous$2.tagName === `colgroup`
      && closing(previous$2, parent.children.indexOf(previous$2), parent)
    ? !1
    : !!(head$5 && head$5.type === `element` && head$5.tagName === `col`)
}
function tbody(node$1, index$4, parent) {
  let previous$2 = siblingBefore(parent, index$4), head$5 = siblingAfter(node$1, -1)
  return parent && previous$2 && previous$2.type === `element`
      && (previous$2.tagName === `thead` || previous$2.tagName === `tbody`)
      && closing(previous$2, parent.children.indexOf(previous$2), parent)
    ? !1
    : !!(head$5 && head$5.type === `element` && head$5.tagName === `tr`)
}
const constants = {
  name: [[
    `	
\f\r &/=>`.split(``),
    `	
\f\r "&'/=>\``.split(``),
  ], [
    `\0	
\f\r "&'/<=>`.split(``),
    `\0	
\f\r "&'/<=>\``.split(``),
  ]],
  unquoted: [[
    `	
\f\r &>`.split(``),
    `\0	
\f\r "&'<=>\``.split(``),
  ], [
    `\0	
\f\r "&'<=>\``.split(``),
    `\0	
\f\r "&'<=>\``.split(``),
  ]],
  single: [[`&'`.split(``), `"&'\``.split(``)], [`\0&'`.split(``), `\0"&'\``.split(``)]],
  double: [[`"&`.split(``), `"&'\``.split(``)], [`\0"&`.split(``), `\0"&'\``.split(``)]],
}
function element$1(node$1, index$4, parent, state) {
  let schema = state.schema,
    omit$3 = schema.space === `svg` ? !1 : state.settings.omitOptionalTags,
    selfClosing = schema.space === `svg`
      ? state.settings.closeEmptyElements
      : state.settings.voids.includes(node$1.tagName.toLowerCase()),
    parts$1 = [],
    last$3
  schema.space === `html` && node$1.tagName === `svg` && (state.schema = svg)
  let attributes = serializeAttributes(state, node$1.properties),
    content$2 = state.all(schema.space === `html` && node$1.tagName === `template` ? node$1.content : node$1)
  return state.schema = schema,
    content$2 && (selfClosing = !1),
    (attributes || !omit$3 || !opening(node$1, index$4, parent))
    && (parts$1.push(`<`, node$1.tagName, attributes ? ` ` + attributes : ``),
      selfClosing && (schema.space === `svg` || state.settings.closeSelfClosing)
      && (last$3 = attributes.charAt(attributes.length - 1),
        (!state.settings.tightSelfClosing || last$3 === `/` || last$3 && last$3 !== `"` && last$3 !== `'`)
        && parts$1.push(` `),
        parts$1.push(`/`)),
      parts$1.push(`>`)),
    parts$1.push(content$2),
    !selfClosing && (!omit$3 || !closing(node$1, index$4, parent)) && parts$1.push(`</` + node$1.tagName + `>`),
    parts$1.join(``)
}
function serializeAttributes(state, properties) {
  let values$6 = [], index$4 = -1, key$1
  if (properties) {
    for (key$1 in properties) {
      if (properties[key$1] !== null && properties[key$1] !== void 0) {
        let value$2 = serializeAttribute(state, key$1, properties[key$1])
        value$2 && values$6.push(value$2)
      }
    }
  }
  for (; ++index$4 < values$6.length;) {
    let last$3 = state.settings.tightAttributes ? values$6[index$4].charAt(values$6[index$4].length - 1) : void 0
    index$4 !== values$6.length - 1 && last$3 !== `"` && last$3 !== `'` && (values$6[index$4] += ` `)
  }
  return values$6.join(``)
}
function serializeAttribute(state, key$1, value$2) {
  let info = find(state.schema, key$1),
    x$2 = state.settings.allowParseErrors && state.schema.space === `html` ? 0 : 1,
    y$3 = state.settings.allowDangerousCharacters ? 0 : 1,
    quote = state.quote,
    result
  if (
    info.overloadedBoolean && (value$2 === info.attribute || value$2 === ``)
      ? value$2 = !0
      : (info.boolean || info.overloadedBoolean)
        && (typeof value$2 != `string` || value$2 === info.attribute || value$2 === ``) && (value$2 = !!value$2),
      value$2 == null || value$2 === !1 || typeof value$2 == `number` && Number.isNaN(value$2)
  ) return ``
  let name = stringifyEntities(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, { subset: constants.name[x$2][y$3] }),
  )
  return value$2 === !0
      || (value$2 = Array.isArray(value$2)
        ? (info.commaSeparated ? stringify : stringify$1)(value$2, {
          padLeft: !state.settings.tightCommaSeparatedLists,
        })
        : String(value$2),
        state.settings.collapseEmptyAttributes && !value$2)
    ? name
    : (state.settings.preferUnquoted
      && (result = stringifyEntities(
        value$2,
        Object.assign({}, state.settings.characterReferences, { attribute: !0, subset: constants.unquoted[x$2][y$3] }),
      )),
      result !== value$2
      && (state.settings.quoteSmart && ccount(value$2, quote) > ccount(value$2, state.alternative)
        && (quote = state.alternative),
        result = quote
          + stringifyEntities(
            value$2,
            Object.assign({}, state.settings.characterReferences, {
              subset: (quote === `'` ? constants.single : constants.double)[x$2][y$3],
              attribute: !0,
            }),
          ) + quote),
      name + (result && `=` + result))
}
const textEntitySubset = [`<`, `&`]
function text$5(node$1, _$1, parent, state) {
  return parent && parent.type === `element` && (parent.tagName === `script` || parent.tagName === `style`)
    ? node$1.value
    : stringifyEntities(
      node$1.value,
      Object.assign({}, state.settings.characterReferences, { subset: textEntitySubset }),
    )
}
function raw(node$1, index$4, parent, state) {
  return state.settings.allowDangerousHtml ? node$1.value : text$5(node$1, index$4, parent, state)
}
function root$3(node$1, _1, _2, state) {
  return state.all(node$1)
}
const handle$1 = zwitch(`type`, {
  invalid,
  unknown,
  handlers: { comment, doctype, element: element$1, raw, root: root$3, text: text$5 },
})
function invalid(node$1) {
  throw Error('Expected node, not `' + node$1 + '`')
}
function unknown(node_) {
  let node$1 = node_
  throw Error('Cannot compile unknown node `' + node$1.type + '`')
}
const emptyOptions$3 = {}, emptyCharacterReferences = {}, emptyChildren = []
function toHtml(tree, options$2) {
  let options_ = options$2 || emptyOptions$3, quote = options_.quote || `"`, alternative = quote === `"` ? `'` : `"`
  if (quote !== `"` && quote !== `'`) throw Error('Invalid quote `' + quote + '`, expected `\'` or `"`')
  let state = {
    one: one$1,
    all: all$1,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || !1,
      allowParseErrors: options_.allowParseErrors || !1,
      allowDangerousCharacters: options_.allowDangerousCharacters || !1,
      quoteSmart: options_.quoteSmart || !1,
      preferUnquoted: options_.preferUnquoted || !1,
      tightAttributes: options_.tightAttributes || !1,
      upperDoctype: options_.upperDoctype || !1,
      tightDoctype: options_.tightDoctype || !1,
      bogusComments: options_.bogusComments || !1,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || !1,
      tightSelfClosing: options_.tightSelfClosing || !1,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || !1,
      allowDangerousHtml: options_.allowDangerousHtml || !1,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || !1,
      closeEmptyElements: options_.closeEmptyElements || !1,
    },
    schema: options_.space === `svg` ? svg : html$2,
    quote,
    alternative,
  }
  return state.one(Array.isArray(tree) ? { type: `root`, children: tree } : tree, void 0, void 0)
}
function one$1(node$1, index$4, parent) {
  return handle$1(node$1, index$4, parent, this)
}
function all$1(parent) {
  let results = [], children$3 = parent && parent.children || emptyChildren, index$4 = -1
  for (; ++index$4 < children$3.length;) results[index$4] = this.one(children$3[index$4], index$4, parent)
  return results.join(``)
}
function rehypeStringify(options$2) {
  let self$1 = this, settings = { ...self$1.data(`settings`), ...options$2 }
  self$1.compiler = compiler$1
  function compiler$1(tree) {
    return toHtml(tree, settings)
  }
}
const asciiAlpha = regexCheck(/[A-Za-z]/),
  asciiAlphanumeric = regexCheck(/[\dA-Za-z]/),
  asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/)
function asciiControl(code$3) {
  return code$3 !== null && (code$3 < 32 || code$3 === 127)
}
const asciiDigit = regexCheck(/\d/),
  asciiHexDigit = regexCheck(/[\dA-Fa-f]/),
  asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)
function markdownLineEnding(code$3) {
  return code$3 !== null && code$3 < -2
}
function markdownLineEndingOrSpace(code$3) {
  return code$3 !== null && (code$3 < 0 || code$3 === 32)
}
function markdownSpace(code$3) {
  return code$3 === -2 || code$3 === -1 || code$3 === 32
}
const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u), unicodeWhitespace = regexCheck(/\s/)
function regexCheck(regex) {
  return check$1
  function check$1(code$3) {
    return code$3 !== null && code$3 > -1 && regex.test(String.fromCharCode(code$3))
  }
}
function escapeStringRegexp(string$5) {
  if (typeof string$5 != `string`) throw TypeError(`Expected a string`)
  return string$5.replace(/[|\\{}()[\]^$+*?.]/g, `\\$&`).replace(/-/g, `\\x2d`)
}
const convert = function(test) {
  if (test == null) return ok$1
  if (typeof test == `function`) return castFactory(test)
  if (typeof test == `object`) return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
  if (typeof test == `string`) return typeFactory(test)
  throw Error(`Expected function, string, or object as test`)
}
function anyFactory(tests) {
  let checks$1 = [], index$4 = -1
  for (; ++index$4 < tests.length;) checks$1[index$4] = convert(tests[index$4])
  return castFactory(any$2)
  function any$2(...parameters) {
    let index$5 = -1
    for (; ++index$5 < checks$1.length;) if (checks$1[index$5].apply(this, parameters)) return !0
    return !1
  }
}
function propsFactory(check$1) {
  let checkAsRecord = check$1
  return castFactory(all$8)
  function all$8(node$1) {
    let nodeAsRecord = node$1, key$1
    for (key$1 in check$1) if (nodeAsRecord[key$1] !== checkAsRecord[key$1]) return !1
    return !0
  }
}
function typeFactory(check$1) {
  return castFactory(type$2)
  function type$2(node$1) {
    return node$1 && node$1.type === check$1
  }
}
function castFactory(testFunction) {
  return check$1
  function check$1(value$2, index$4, parent) {
    return !!(looksLikeANode(value$2)
      && testFunction.call(this, value$2, typeof index$4 == `number` ? index$4 : void 0, parent || void 0))
  }
}
function ok$1() {
  return !0
}
function looksLikeANode(value$2) {
  return typeof value$2 == `object` && !!value$2 && `type` in value$2
}
function color(d$7) {
  return d$7
}
const empty = [], CONTINUE = !0, EXIT = !1, SKIP = `skip`
function visitParents(tree, test, visitor, reverse$4) {
  let check$1
  typeof test == `function` && typeof visitor != `function` ? (reverse$4 = visitor, visitor = test) : check$1 = test
  let is$29 = convert(check$1), step$3 = reverse$4 ? -1 : 1
  factory(tree, void 0, [])()
  function factory(node$1, index$4, parents) {
    let value$2 = node$1 && typeof node$1 == `object` ? node$1 : {}
    if (typeof value$2.type == `string`) {
      let name = typeof value$2.tagName == `string`
        ? value$2.tagName
        : typeof value$2.name == `string`
        ? value$2.name
        : void 0
      Object.defineProperty(visit$2, `name`, {
        value: `node (` + color(node$1.type + (name ? `<` + name + `>` : ``)) + `)`,
      })
    }
    return visit$2
    function visit$2() {
      let result = empty, subresult, offset$3, grandparents
      if (
        (!test || is$29(node$1, index$4, parents[parents.length - 1] || void 0))
        && (result = toResult(visitor(node$1, parents)), result[0] === EXIT)
      ) return result
      if (`children` in node$1 && node$1.children) {
        let nodeAsParent = node$1
        if (nodeAsParent.children && result[0] !== SKIP) {
          for (
            offset$3 = (reverse$4 ? nodeAsParent.children.length : -1) + step$3,
              grandparents = parents.concat(nodeAsParent);
            offset$3 > -1 && offset$3 < nodeAsParent.children.length;
          ) {
            let child = nodeAsParent.children[offset$3]
            if (subresult = factory(child, offset$3, grandparents)(), subresult[0] === EXIT) return subresult
            offset$3 = typeof subresult[1] == `number` ? subresult[1] : offset$3 + step$3
          }
        }
      }
      return result
    }
  }
}
function toResult(value$2) {
  return Array.isArray(value$2)
    ? value$2
    : typeof value$2 == `number`
    ? [CONTINUE, value$2]
    : value$2 == null
    ? empty
    : [value$2]
}
function findAndReplace(tree, list$3, options$2) {
  let settings = options$2 || {}, ignored = convert(settings.ignore || []), pairs = toPairs(list$3), pairIndex = -1
  for (; ++pairIndex < pairs.length;) visitParents(tree, `text`, visitor)
  function visitor(node$1, parents) {
    let index$4 = -1, grandparent
    for (; ++index$4 < parents.length;) {
      let parent = parents[index$4], siblings$1 = grandparent ? grandparent.children : void 0
      if (ignored(parent, siblings$1 ? siblings$1.indexOf(parent) : void 0, grandparent)) return
      grandparent = parent
    }
    if (grandparent) return handler(node$1, parents)
  }
  function handler(node$1, parents) {
    let parent = parents[parents.length - 1],
      find$3 = pairs[pairIndex][0],
      replace$1 = pairs[pairIndex][1],
      start$2 = 0,
      siblings$1 = parent.children,
      index$4 = siblings$1.indexOf(node$1),
      change = !1,
      nodes = []
    find$3.lastIndex = 0
    let match$13 = find$3.exec(node$1.value)
    for (; match$13;) {
      let position$2 = match$13.index,
        matchObject = { index: match$13.index, input: match$13.input, stack: [...parents, node$1] },
        value$2 = replace$1(...match$13, matchObject)
      if (
        typeof value$2 == `string` && (value$2 = value$2.length > 0 ? { type: `text`, value: value$2 } : void 0),
          value$2 === !1
            ? find$3.lastIndex = position$2 + 1
            : (start$2 !== position$2 && nodes.push({ type: `text`, value: node$1.value.slice(start$2, position$2) }),
              Array.isArray(value$2) ? nodes.push(...value$2) : value$2 && nodes.push(value$2),
              start$2 = position$2 + match$13[0].length,
              change = !0),
          !find$3.global
      ) break
      match$13 = find$3.exec(node$1.value)
    }
    return change
      ? (start$2 < node$1.value.length && nodes.push({ type: `text`, value: node$1.value.slice(start$2) }),
        parent.children.splice(index$4, 1, ...nodes))
      : nodes = [node$1],
      index$4 + nodes.length
  }
}
function toPairs(tupleOrList) {
  let result = []
  if (!Array.isArray(tupleOrList)) throw TypeError(`Expected find and replace tuple or list of tuples`)
  let list$3 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList], index$4 = -1
  for (; ++index$4 < list$3.length;) {
    let tuple$2 = list$3[index$4]
    result.push([toExpression(tuple$2[0]), toFunction(tuple$2[1])])
  }
  return result
}
function toExpression(find$3) {
  return typeof find$3 == `string` ? new RegExp(escapeStringRegexp(find$3), `g`) : find$3
}
function toFunction(replace$1) {
  return typeof replace$1 == `function` ? replace$1 : function() {
    return replace$1
  }
}
const inConstruct = `phrasing`, notInConstruct = [`autolink`, `link`, `image`, `label`]
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue,
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww,
    },
  }
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [{ character: `@`, before: `[+\\-.\\w]`, after: `[\\-.\\w]`, inConstruct, notInConstruct }, {
      character: `.`,
      before: `[Ww]`,
      after: `[\\-.\\w]`,
      inConstruct,
      notInConstruct,
    }, { character: `:`, before: `[ps]`, after: `\\/`, inConstruct, notInConstruct }],
  }
}
function enterLiteralAutolink(token) {
  this.enter({ type: `link`, title: null, url: ``, children: [] }, token)
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token)
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token)
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token)
  let node$1 = this.stack[this.stack.length - 1]
  node$1.type, node$1.url = `http://` + this.sliceSerialize(token)
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token)
}
function exitLiteralAutolink(token) {
  this.exit(token)
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(tree, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl], [
    /(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu,
    findEmail,
  ]], { ignore: [`link`, `linkReference`] })
}
function findUrl(_$1, protocol, domain$1, path$1, match$13) {
  let prefix$1 = ``
  if (
    !previous$1(match$13)
    || (/^w/i.test(protocol) && (domain$1 = protocol + domain$1, protocol = ``, prefix$1 = `http://`),
      !isCorrectDomain(domain$1))
  ) return !1
  let parts$1 = splitUrl(domain$1 + path$1)
  if (!parts$1[0]) return !1
  let result = {
    type: `link`,
    title: null,
    url: prefix$1 + protocol + parts$1[0],
    children: [{ type: `text`, value: protocol + parts$1[0] }],
  }
  return parts$1[1] ? [result, { type: `text`, value: parts$1[1] }] : result
}
function findEmail(_$1, atext, label, match$13) {
  return !previous$1(match$13, !0) || /[-\d_]$/.test(label)
    ? !1
    : {
      type: `link`,
      title: null,
      url: `mailto:` + atext + `@` + label,
      children: [{ type: `text`, value: atext + `@` + label }],
    }
}
function isCorrectDomain(domain$1) {
  let parts$1 = domain$1.split(`.`)
  return !(parts$1.length < 2
    || parts$1[parts$1.length - 1]
      && (/_/.test(parts$1[parts$1.length - 1]) || !/[a-zA-Z\d]/.test(parts$1[parts$1.length - 1]))
    || parts$1[parts$1.length - 2]
      && (/_/.test(parts$1[parts$1.length - 2]) || !/[a-zA-Z\d]/.test(parts$1[parts$1.length - 2])))
}
function splitUrl(url) {
  let trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url)
  if (!trailExec) return [url, void 0]
  url = url.slice(0, trailExec.index)
  let trail$1 = trailExec[0],
    closingParenIndex = trail$1.indexOf(`)`),
    openingParens = ccount(url, `(`),
    closingParens = ccount(url, `)`)
  for (; closingParenIndex !== -1 && openingParens > closingParens;) {
    url += trail$1.slice(0, closingParenIndex + 1),
      trail$1 = trail$1.slice(closingParenIndex + 1),
      closingParenIndex = trail$1.indexOf(`)`),
      closingParens++
  }
  return [url, trail$1]
}
function previous$1(match$13, email) {
  let code$3 = match$13.input.charCodeAt(match$13.index - 1)
  return (match$13.index === 0 || unicodeWhitespace(code$3) || unicodePunctuation(code$3)) && (!email || code$3 !== 47)
}
function normalizeIdentifier(value$2) {
  return value$2.replace(/[\t\n\r ]+/g, ` `).replace(/^ | $/g, ``).toLowerCase().toUpperCase()
}
footnoteReference$1.peek = footnoteReferencePeek
function enterFootnoteCallString() {
  this.buffer()
}
function enterFootnoteCall(token) {
  this.enter({ type: `footnoteReference`, identifier: ``, label: `` }, token)
}
function enterFootnoteDefinitionLabelString() {
  this.buffer()
}
function enterFootnoteDefinition(token) {
  this.enter({ type: `footnoteDefinition`, identifier: ``, label: ``, children: [] }, token)
}
function exitFootnoteCallString(token) {
  let label = this.resume(), node$1 = this.stack[this.stack.length - 1]
  node$1.type, node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase(), node$1.label = label
}
function exitFootnoteCall(token) {
  this.exit(token)
}
function exitFootnoteDefinitionLabelString(token) {
  let label = this.resume(), node$1 = this.stack[this.stack.length - 1]
  node$1.type, node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase(), node$1.label = label
}
function exitFootnoteDefinition(token) {
  this.exit(token)
}
function footnoteReferencePeek() {
  return `[`
}
function footnoteReference$1(node$1, _$1, state, info) {
  let tracker = state.createTracker(info),
    value$2 = tracker.move(`[^`),
    exit$5 = state.enter(`footnoteReference`),
    subexit = state.enter(`reference`)
  return value$2 += tracker.move(state.safe(state.associationId(node$1), { after: `]`, before: value$2 })),
    subexit(),
    exit$5(),
    value$2 += tracker.move(`]`),
    value$2
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition,
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition,
    },
  }
}
function gfmFootnoteToMarkdown(options$2) {
  let firstLineBlank = !1
  return options$2 && options$2.firstLineBlank && (firstLineBlank = !0), {
    handlers: { footnoteDefinition, footnoteReference: footnoteReference$1 },
    unsafe: [{ character: `[`, inConstruct: [`label`, `phrasing`, `reference`] }],
  }
  function footnoteDefinition(node$1, _$1, state, info) {
    let tracker = state.createTracker(info),
      value$2 = tracker.move(`[^`),
      exit$5 = state.enter(`footnoteDefinition`),
      subexit = state.enter(`label`)
    return value$2 += tracker.move(state.safe(state.associationId(node$1), { before: value$2, after: `]` })),
      subexit(),
      value$2 += tracker.move(`]:`),
      node$1.children && node$1.children.length > 0 && (tracker.shift(4),
        value$2 += tracker.move(
          (firstLineBlank
            ? `
`
            : ` `)
            + state.indentLines(
              state.containerFlow(node$1, tracker.current()),
              firstLineBlank ? mapAll : mapExceptFirst,
            ),
        )),
      exit$5(),
      value$2
  }
}
function mapExceptFirst(line, index$4, blank) {
  return index$4 === 0 ? line : mapAll(line, index$4, blank)
}
function mapAll(line, index$4, blank) {
  return (blank ? `` : `    `) + line
}
const constructsWithoutStrikethrough = [
  `autolink`,
  `destinationLiteral`,
  `destinationRaw`,
  `reference`,
  `titleQuote`,
  `titleApostrophe`,
]
handleDelete.peek = peekDelete
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: [`delete`],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough },
  }
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [{ character: `~`, inConstruct: `phrasing`, notInConstruct: constructsWithoutStrikethrough }],
    handlers: { delete: handleDelete },
  }
}
function enterStrikethrough(token) {
  this.enter({ type: `delete`, children: [] }, token)
}
function exitStrikethrough(token) {
  this.exit(token)
}
function handleDelete(node$1, _$1, state, info) {
  let tracker = state.createTracker(info), exit$5 = state.enter(`strikethrough`), value$2 = tracker.move(`~~`)
  return value$2 += state.containerPhrasing(node$1, { ...tracker.current(), before: value$2, after: `~` }),
    value$2 += tracker.move(`~~`),
    exit$5(),
    value$2
}
function peekDelete() {
  return `~`
}
function defaultStringLength(value$2) {
  return value$2.length
}
function markdownTable(table$1, options$2) {
  let settings = options$2 || {},
    align = (settings.align || []).concat(),
    stringLength = settings.stringLength || defaultStringLength,
    alignments = [],
    cellMatrix = [],
    sizeMatrix = [],
    longestCellByColumn = [],
    mostCellsPerRow = 0,
    rowIndex = -1
  for (; ++rowIndex < table$1.length;) {
    let row$1 = [], sizes$1 = [], columnIndex$1 = -1
    for (
      table$1[rowIndex].length > mostCellsPerRow && (mostCellsPerRow = table$1[rowIndex].length);
      ++columnIndex$1 < table$1[rowIndex].length;
    ) {
      let cell = serialize$1(table$1[rowIndex][columnIndex$1])
      if (settings.alignDelimiters !== !1) {
        let size$14 = stringLength(cell)
        sizes$1[columnIndex$1] = size$14,
          (longestCellByColumn[columnIndex$1] === void 0 || size$14 > longestCellByColumn[columnIndex$1])
          && (longestCellByColumn[columnIndex$1] = size$14)
      }
      row$1.push(cell)
    }
    cellMatrix[rowIndex] = row$1, sizeMatrix[rowIndex] = sizes$1
  }
  let columnIndex = -1
  if (typeof align == `object` && `length` in align) {
    for (; ++columnIndex < mostCellsPerRow;) alignments[columnIndex] = toAlignment(align[columnIndex])
  } else {
    let code$3 = toAlignment(align)
    for (; ++columnIndex < mostCellsPerRow;) alignments[columnIndex] = code$3
  }
  columnIndex = -1
  let row = [], sizes = []
  for (; ++columnIndex < mostCellsPerRow;) {
    let code$3 = alignments[columnIndex], before$2 = ``, after$2 = ``
    code$3 === 99
      ? (before$2 = `:`, after$2 = `:`)
      : code$3 === 108
      ? before$2 = `:`
      : code$3 === 114 && (after$2 = `:`)
    let size$14 = settings.alignDelimiters === !1
        ? 1
        : Math.max(1, longestCellByColumn[columnIndex] - before$2.length - after$2.length),
      cell = before$2 + `-`.repeat(size$14) + after$2
    settings.alignDelimiters !== !1
    && (size$14 = before$2.length + size$14 + after$2.length,
      size$14 > longestCellByColumn[columnIndex] && (longestCellByColumn[columnIndex] = size$14),
      sizes[columnIndex] = size$14), row[columnIndex] = cell
  }
  cellMatrix.splice(1, 0, row), sizeMatrix.splice(1, 0, sizes), rowIndex = -1
  let lines = []
  for (; ++rowIndex < cellMatrix.length;) {
    let row$1 = cellMatrix[rowIndex], sizes$1 = sizeMatrix[rowIndex]
    columnIndex = -1
    let line = []
    for (; ++columnIndex < mostCellsPerRow;) {
      let cell = row$1[columnIndex] || ``, before$2 = ``, after$2 = ``
      if (settings.alignDelimiters !== !1) {
        let size$14 = longestCellByColumn[columnIndex] - (sizes$1[columnIndex] || 0), code$3 = alignments[columnIndex]
        code$3 === 114
          ? before$2 = ` `.repeat(size$14)
          : code$3 === 99
          ? size$14 % 2
            ? (before$2 = ` `.repeat(size$14 / 2 + .5), after$2 = ` `.repeat(size$14 / 2 - .5))
            : (before$2 = ` `.repeat(size$14 / 2), after$2 = before$2)
          : after$2 = ` `.repeat(size$14)
      }
      settings.delimiterStart !== !1 && !columnIndex && line.push(`|`),
        settings.padding !== !1 && !(settings.alignDelimiters === !1 && cell === ``)
        && (settings.delimiterStart !== !1 || columnIndex) && line.push(` `),
        settings.alignDelimiters !== !1 && line.push(before$2),
        line.push(cell),
        settings.alignDelimiters !== !1 && line.push(after$2),
        settings.padding !== !1 && line.push(` `),
        (settings.delimiterEnd !== !1 || columnIndex !== mostCellsPerRow - 1) && line.push(`|`)
    }
    lines.push(settings.delimiterEnd === !1 ? line.join(``).replace(/ +$/, ``) : line.join(``))
  }
  return lines.join(`
`)
}
function serialize$1(value$2) {
  return value$2 == null ? `` : String(value$2)
}
function toAlignment(value$2) {
  let code$3 = typeof value$2 == `string` ? value$2.codePointAt(0) : 0
  return code$3 === 67 || code$3 === 99
    ? 99
    : code$3 === 76 || code$3 === 108
    ? 108
    : code$3 === 82 || code$3 === 114
    ? 114
    : 0
}
function blockquote$1(node$1, _$1, state, info) {
  let exit$5 = state.enter(`blockquote`), tracker = state.createTracker(info)
  tracker.move(`> `), tracker.shift(2)
  let value$2 = state.indentLines(state.containerFlow(node$1, tracker.current()), map$1)
  return exit$5(), value$2
}
function map$1(line, _$1, blank) {
  return `>` + (blank ? `` : ` `) + line
}
function patternInScope(stack, pattern$1) {
  return listInScope(stack, pattern$1.inConstruct, !0) && !listInScope(stack, pattern$1.notInConstruct, !1)
}
function listInScope(stack, list$3, none$9) {
  if (typeof list$3 == `string` && (list$3 = [list$3]), !list$3 || list$3.length === 0) return none$9
  let index$4 = -1
  for (; ++index$4 < list$3.length;) if (stack.includes(list$3[index$4])) return !0
  return !1
}
function hardBreak$1(_$1, _1, state, info) {
  let index$4 = -1
  for (; ++index$4 < state.unsafe.length;) {
    if (
      state.unsafe[index$4].character === `
` && patternInScope(state.stack, state.unsafe[index$4])
    ) return /[ \t]/.test(info.before) ? `` : ` `
  }
  return `\\
`
}
function longestStreak(value$2, substring) {
  let source = String(value$2), index$4 = source.indexOf(substring), expected = index$4, count$2 = 0, max$12 = 0
  if (typeof substring != `string`) throw TypeError(`Expected substring`)
  for (; index$4 !== -1;) {
    index$4 === expected ? ++count$2 > max$12 && (max$12 = count$2) : count$2 = 1,
      expected = index$4 + substring.length,
      index$4 = source.indexOf(substring, expected)
  }
  return max$12
}
function formatCodeAsIndented(node$1, state) {
  return !!(state.options.fences === !1 && node$1.value && !node$1.lang && /[^ \r\n]/.test(node$1.value)
    && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node$1.value))
}
function checkFence(state) {
  let marker = state.options.fence || '`'
  if (marker !== '`' && marker !== `~`) {
    throw Error('Cannot serialize code with `' + marker + '` for `options.fence`, expected `` ` `` or `~`')
  }
  return marker
}
function code$2(node$1, _$1, state, info) {
  let marker = checkFence(state), raw$1 = node$1.value || ``, suffix$1 = marker === '`' ? `GraveAccent` : `Tilde`
  if (formatCodeAsIndented(node$1, state)) {
    let exit$6 = state.enter(`codeIndented`), value$3 = state.indentLines(raw$1, map)
    return exit$6(), value$3
  }
  let tracker = state.createTracker(info),
    sequence = marker.repeat(Math.max(longestStreak(raw$1, marker) + 1, 3)),
    exit$5 = state.enter(`codeFenced`),
    value$2 = tracker.move(sequence)
  if (node$1.lang) {
    let subexit = state.enter(`codeFencedLang${suffix$1}`)
    value$2 += tracker.move(
      state.safe(node$1.lang, { before: value$2, after: ` `, encode: ['`'], ...tracker.current() }),
    ), subexit()
  }
  if (node$1.lang && node$1.meta) {
    let subexit = state.enter(`codeFencedMeta${suffix$1}`)
    value$2 += tracker.move(` `),
      value$2 += tracker.move(state.safe(node$1.meta, {
        before: value$2,
        after: `
`,
        encode: ['`'],
        ...tracker.current(),
      })),
      subexit()
  }
  return value$2 += tracker.move(`
`),
    raw$1 && (value$2 += tracker.move(
      raw$1 + `
`,
    )),
    value$2 += tracker.move(sequence),
    exit$5(),
    value$2
}
function map(line, _$1, blank) {
  return (blank ? `` : `    `) + line
}
function checkQuote(state) {
  let marker = state.options.quote || `"`
  if (marker !== `"` && marker !== `'`) {
    throw Error('Cannot serialize title with `' + marker + '` for `options.quote`, expected `"`, or `\'`')
  }
  return marker
}
function definition$1(node$1, _$1, state, info) {
  let quote = checkQuote(state),
    suffix$1 = quote === `"` ? `Quote` : `Apostrophe`,
    exit$5 = state.enter(`definition`),
    subexit = state.enter(`label`),
    tracker = state.createTracker(info),
    value$2 = tracker.move(`[`)
  return value$2 += tracker.move(
    state.safe(state.associationId(node$1), { before: value$2, after: `]`, ...tracker.current() }),
  ),
    value$2 += tracker.move(`]: `),
    subexit(),
    !node$1.url || /[\0- \u007F]/.test(node$1.url)
      ? (subexit = state.enter(`destinationLiteral`),
        value$2 += tracker.move(`<`),
        value$2 += tracker.move(state.safe(node$1.url, { before: value$2, after: `>`, ...tracker.current() })),
        value$2 += tracker.move(`>`))
      : (subexit = state.enter(`destinationRaw`),
        value$2 += tracker.move(state.safe(node$1.url, {
          before: value$2,
          after: node$1.title ? ` ` : `
`,
          ...tracker.current(),
        }))),
    subexit(),
    node$1.title
    && (subexit = state.enter(`title${suffix$1}`),
      value$2 += tracker.move(` ` + quote),
      value$2 += tracker.move(state.safe(node$1.title, { before: value$2, after: quote, ...tracker.current() })),
      value$2 += tracker.move(quote),
      subexit()),
    exit$5(),
    value$2
}
function checkEmphasis(state) {
  let marker = state.options.emphasis || `*`
  if (marker !== `*` && marker !== `_`) {
    throw Error('Cannot serialize emphasis with `' + marker + '` for `options.emphasis`, expected `*`, or `_`')
  }
  return marker
}
function encodeCharacterReference(code$3) {
  return `&#x` + code$3.toString(16).toUpperCase() + `;`
}
function classifyCharacter(code$3) {
  if (code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)) return 1
  if (unicodePunctuation(code$3)) return 2
}
function encodeInfo(outside, inside, marker) {
  let outsideKind = classifyCharacter(outside), insideKind = classifyCharacter(inside)
  return outsideKind === void 0
    ? insideKind === void 0
      ? marker === `_` ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
      : insideKind === 1
      ? { inside: !0, outside: !0 }
      : { inside: !1, outside: !0 }
    : outsideKind === 1
    ? insideKind === void 0
      ? { inside: !1, outside: !1 }
      : insideKind === 1
      ? { inside: !0, outside: !0 }
      : { inside: !1, outside: !1 }
    : insideKind === void 0
    ? { inside: !1, outside: !1 }
    : insideKind === 1
    ? { inside: !0, outside: !1 }
    : { inside: !1, outside: !1 }
}
emphasis$1.peek = emphasisPeek
function emphasis$1(node$1, _$1, state, info) {
  let marker = checkEmphasis(state),
    exit$5 = state.enter(`emphasis`),
    tracker = state.createTracker(info),
    before$2 = tracker.move(marker),
    between = tracker.move(state.containerPhrasing(node$1, { after: marker, before: before$2, ...tracker.current() })),
    betweenHead = between.charCodeAt(0),
    open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker)
  open.inside && (between = encodeCharacterReference(betweenHead) + between.slice(1))
  let betweenTail = between.charCodeAt(between.length - 1),
    close$1 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)
  close$1.inside && (between = between.slice(0, -1) + encodeCharacterReference(betweenTail))
  let after$2 = tracker.move(marker)
  return exit$5(),
    state.attentionEncodeSurroundingInfo = { after: close$1.outside, before: open.outside },
    before$2 + between + after$2
}
function emphasisPeek(_$1, _1, state) {
  return state.options.emphasis || `*`
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse$4, test, visitor
  typeof testOrVisitor == `function` && typeof visitorOrReverse != `function`
    ? (test = void 0, visitor = testOrVisitor, reverse$4 = visitorOrReverse)
    : (test = testOrVisitor, visitor = visitorOrReverse, reverse$4 = maybeReverse),
    visitParents(tree, test, overload, reverse$4)
  function overload(node$1, parents) {
    let parent = parents[parents.length - 1], index$4 = parent ? parent.children.indexOf(node$1) : void 0
    return visitor(node$1, index$4, parent)
  }
}
const emptyOptions$2 = {}
function toString$1(value$2, options$2) {
  let settings = options$2 || emptyOptions$2,
    includeImageAlt = typeof settings.includeImageAlt == `boolean` ? settings.includeImageAlt : !0,
    includeHtml = typeof settings.includeHtml == `boolean` ? settings.includeHtml : !0
  return one(value$2, includeImageAlt, includeHtml)
}
function one(value$2, includeImageAlt, includeHtml) {
  if (node(value$2)) {
    if (`value` in value$2) return value$2.type === `html` && !includeHtml ? `` : value$2.value
    if (includeImageAlt && `alt` in value$2 && value$2.alt) return value$2.alt
    if (`children` in value$2) return all(value$2.children, includeImageAlt, includeHtml)
  }
  return Array.isArray(value$2) ? all(value$2, includeImageAlt, includeHtml) : ``
}
function all(values$6, includeImageAlt, includeHtml) {
  let result = [], index$4 = -1
  for (; ++index$4 < values$6.length;) result[index$4] = one(values$6[index$4], includeImageAlt, includeHtml)
  return result.join(``)
}
function node(value$2) {
  return !!(value$2 && typeof value$2 == `object`)
}
function formatHeadingAsSetext(node$1, state) {
  let literalWithBreak = !1
  return visit(node$1, function(node$2) {
    if (`value` in node$2 && /\r?\n|\r/.test(node$2.value) || node$2.type === `break`) {
      return literalWithBreak = !0, EXIT
    }
  }),
    !!((!node$1.depth || node$1.depth < 3) && toString$1(node$1) && (state.options.setext || literalWithBreak))
}
function heading$1(node$1, _$1, state, info) {
  let rank = Math.max(Math.min(6, node$1.depth || 1), 1), tracker = state.createTracker(info)
  if (formatHeadingAsSetext(node$1, state)) {
    let exit$6 = state.enter(`headingSetext`),
      subexit$1 = state.enter(`phrasing`),
      value$3 = state.containerPhrasing(node$1, {
        ...tracker.current(),
        before: `
`,
        after: `
`,
      })
    return subexit$1(),
      exit$6(),
      value$3 + `
` + (rank === 1 ? `=` : `-`).repeat(
        value$3.length - (Math.max(
          value$3.lastIndexOf(`\r`),
          value$3.lastIndexOf(`
`),
        ) + 1),
      )
  }
  let sequence = `#`.repeat(rank), exit$5 = state.enter(`headingAtx`), subexit = state.enter(`phrasing`)
  tracker.move(sequence + ` `)
  let value$2 = state.containerPhrasing(node$1, {
    before: `# `,
    after: `
`,
    ...tracker.current(),
  })
  return /^[\t ]/.test(value$2) && (value$2 = encodeCharacterReference(value$2.charCodeAt(0)) + value$2.slice(1)),
    value$2 = value$2 ? sequence + ` ` + value$2 : sequence,
    state.options.closeAtx && (value$2 += ` ` + sequence),
    subexit(),
    exit$5(),
    value$2
}
html$1.peek = htmlPeek
function html$1(node$1) {
  return node$1.value || ``
}
function htmlPeek() {
  return `<`
}
image$1.peek = imagePeek
function image$1(node$1, _$1, state, info) {
  let quote = checkQuote(state),
    suffix$1 = quote === `"` ? `Quote` : `Apostrophe`,
    exit$5 = state.enter(`image`),
    subexit = state.enter(`label`),
    tracker = state.createTracker(info),
    value$2 = tracker.move(`![`)
  return value$2 += tracker.move(state.safe(node$1.alt, { before: value$2, after: `]`, ...tracker.current() })),
    value$2 += tracker.move(`](`),
    subexit(),
    !node$1.url && node$1.title || /[\0- \u007F]/.test(node$1.url)
      ? (subexit = state.enter(`destinationLiteral`),
        value$2 += tracker.move(`<`),
        value$2 += tracker.move(state.safe(node$1.url, { before: value$2, after: `>`, ...tracker.current() })),
        value$2 += tracker.move(`>`))
      : (subexit = state.enter(`destinationRaw`),
        value$2 += tracker.move(
          state.safe(node$1.url, { before: value$2, after: node$1.title ? ` ` : `)`, ...tracker.current() }),
        )),
    subexit(),
    node$1.title
    && (subexit = state.enter(`title${suffix$1}`),
      value$2 += tracker.move(` ` + quote),
      value$2 += tracker.move(state.safe(node$1.title, { before: value$2, after: quote, ...tracker.current() })),
      value$2 += tracker.move(quote),
      subexit()),
    value$2 += tracker.move(`)`),
    exit$5(),
    value$2
}
function imagePeek() {
  return `!`
}
imageReference$1.peek = imageReferencePeek
function imageReference$1(node$1, _$1, state, info) {
  let type$2 = node$1.referenceType,
    exit$5 = state.enter(`imageReference`),
    subexit = state.enter(`label`),
    tracker = state.createTracker(info),
    value$2 = tracker.move(`![`),
    alt = state.safe(node$1.alt, { before: value$2, after: `]`, ...tracker.current() })
  value$2 += tracker.move(alt + `][`), subexit()
  let stack = state.stack
  state.stack = [], subexit = state.enter(`reference`)
  let reference$1 = state.safe(state.associationId(node$1), { before: value$2, after: `]`, ...tracker.current() })
  return subexit(),
    state.stack = stack,
    exit$5(),
    type$2 === `full` || !alt || alt !== reference$1
      ? value$2 += tracker.move(reference$1 + `]`)
      : type$2 === `shortcut`
      ? value$2 = value$2.slice(0, -1)
      : value$2 += tracker.move(`]`),
    value$2
}
function imageReferencePeek() {
  return `!`
}
inlineCode$1.peek = inlineCodePeek
function inlineCode$1(node$1, _$1, state) {
  let value$2 = node$1.value || ``, sequence = '`', index$4 = -1
  for (; RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value$2);) sequence += '`'
  for (
    /[^ \r\n]/.test(value$2) && (/^[ \r\n]/.test(value$2) && /[ \r\n]$/.test(value$2) || /^`|`$/.test(value$2))
    && (value$2 = ` ` + value$2 + ` `);
    ++index$4 < state.unsafe.length;
  ) {
    let pattern$1 = state.unsafe[index$4], expression = state.compilePattern(pattern$1), match$13
    if (pattern$1.atBreak) {
      for (; match$13 = expression.exec(value$2);) {
        let position$2 = match$13.index
        value$2.charCodeAt(position$2) === 10 && value$2.charCodeAt(position$2 - 1) === 13 && position$2--,
          value$2 = value$2.slice(0, position$2) + ` ` + value$2.slice(match$13.index + 1)
      }
    }
  }
  return sequence + value$2 + sequence
}
function inlineCodePeek() {
  return '`'
}
function formatLinkAsAutolink(node$1, state) {
  let raw$1 = toString$1(node$1)
  return !!(!state.options.resourceLink && node$1.url && !node$1.title && node$1.children
    && node$1.children.length === 1 && node$1.children[0].type === `text`
    && (raw$1 === node$1.url || `mailto:` + raw$1 === node$1.url) && /^[a-z][a-z+.-]+:/i.test(node$1.url)
    && !/[\0- <>\u007F]/.test(node$1.url))
}
link$1.peek = linkPeek
function link$1(node$1, _$1, state, info) {
  let quote = checkQuote(state),
    suffix$1 = quote === `"` ? `Quote` : `Apostrophe`,
    tracker = state.createTracker(info),
    exit$5,
    subexit
  if (formatLinkAsAutolink(node$1, state)) {
    let stack = state.stack
    state.stack = [], exit$5 = state.enter(`autolink`)
    let value$3 = tracker.move(`<`)
    return value$3 += tracker.move(
      state.containerPhrasing(node$1, { before: value$3, after: `>`, ...tracker.current() }),
    ),
      value$3 += tracker.move(`>`),
      exit$5(),
      state.stack = stack,
      value$3
  }
  exit$5 = state.enter(`link`), subexit = state.enter(`label`)
  let value$2 = tracker.move(`[`)
  return value$2 += tracker.move(
    state.containerPhrasing(node$1, { before: value$2, after: `](`, ...tracker.current() }),
  ),
    value$2 += tracker.move(`](`),
    subexit(),
    !node$1.url && node$1.title || /[\0- \u007F]/.test(node$1.url)
      ? (subexit = state.enter(`destinationLiteral`),
        value$2 += tracker.move(`<`),
        value$2 += tracker.move(state.safe(node$1.url, { before: value$2, after: `>`, ...tracker.current() })),
        value$2 += tracker.move(`>`))
      : (subexit = state.enter(`destinationRaw`),
        value$2 += tracker.move(
          state.safe(node$1.url, { before: value$2, after: node$1.title ? ` ` : `)`, ...tracker.current() }),
        )),
    subexit(),
    node$1.title
    && (subexit = state.enter(`title${suffix$1}`),
      value$2 += tracker.move(` ` + quote),
      value$2 += tracker.move(state.safe(node$1.title, { before: value$2, after: quote, ...tracker.current() })),
      value$2 += tracker.move(quote),
      subexit()),
    value$2 += tracker.move(`)`),
    exit$5(),
    value$2
}
function linkPeek(node$1, _$1, state) {
  return formatLinkAsAutolink(node$1, state) ? `<` : `[`
}
linkReference$1.peek = linkReferencePeek
function linkReference$1(node$1, _$1, state, info) {
  let type$2 = node$1.referenceType,
    exit$5 = state.enter(`linkReference`),
    subexit = state.enter(`label`),
    tracker = state.createTracker(info),
    value$2 = tracker.move(`[`),
    text$6 = state.containerPhrasing(node$1, { before: value$2, after: `]`, ...tracker.current() })
  value$2 += tracker.move(text$6 + `][`), subexit()
  let stack = state.stack
  state.stack = [], subexit = state.enter(`reference`)
  let reference$1 = state.safe(state.associationId(node$1), { before: value$2, after: `]`, ...tracker.current() })
  return subexit(),
    state.stack = stack,
    exit$5(),
    type$2 === `full` || !text$6 || text$6 !== reference$1
      ? value$2 += tracker.move(reference$1 + `]`)
      : type$2 === `shortcut`
      ? value$2 = value$2.slice(0, -1)
      : value$2 += tracker.move(`]`),
    value$2
}
function linkReferencePeek() {
  return `[`
}
function checkBullet(state) {
  let marker = state.options.bullet || `*`
  if (marker !== `*` && marker !== `+` && marker !== `-`) {
    throw Error('Cannot serialize items with `' + marker + '` for `options.bullet`, expected `*`, `+`, or `-`')
  }
  return marker
}
function checkBulletOther(state) {
  let bullet = checkBullet(state), bulletOther = state.options.bulletOther
  if (!bulletOther) return bullet === `*` ? `-` : `*`
  if (bulletOther !== `*` && bulletOther !== `+` && bulletOther !== `-`) {
    throw Error(
      'Cannot serialize items with `' + bulletOther + '` for `options.bulletOther`, expected `*`, `+`, or `-`',
    )
  }
  if (bulletOther === bullet) {
    throw Error('Expected `bullet` (`' + bullet + '`) and `bulletOther` (`' + bulletOther + '`) to be different')
  }
  return bulletOther
}
function checkBulletOrdered(state) {
  let marker = state.options.bulletOrdered || `.`
  if (marker !== `.` && marker !== `)`) {
    throw Error('Cannot serialize items with `' + marker + '` for `options.bulletOrdered`, expected `.` or `)`')
  }
  return marker
}
function checkRule(state) {
  let marker = state.options.rule || `*`
  if (marker !== `*` && marker !== `-` && marker !== `_`) {
    throw Error('Cannot serialize rules with `' + marker + '` for `options.rule`, expected `*`, `-`, or `_`')
  }
  return marker
}
function list$2(node$1, parent, state, info) {
  let exit$5 = state.enter(`list`),
    bulletCurrent = state.bulletCurrent,
    bullet = node$1.ordered ? checkBulletOrdered(state) : checkBullet(state),
    bulletOther = node$1.ordered ? bullet === `.` ? `)` : `.` : checkBulletOther(state),
    useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : !1
  if (!node$1.ordered) {
    let firstListItem = node$1.children ? node$1.children[0] : void 0
    if (
      (bullet === `*` || bullet === `-`) && firstListItem && (!firstListItem.children || !firstListItem.children[0])
      && state.stack[state.stack.length - 1] === `list` && state.stack[state.stack.length - 2] === `listItem`
      && state.stack[state.stack.length - 3] === `list` && state.stack[state.stack.length - 4] === `listItem`
      && state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0
      && state.indexStack[state.indexStack.length - 3] === 0 && (useDifferentMarker = !0),
        checkRule(state) === bullet && firstListItem
    ) {
      let index$4 = -1
      for (; ++index$4 < node$1.children.length;) {
        let item = node$1.children[index$4]
        if (
          item && item.type === `listItem` && item.children && item.children[0]
          && item.children[0].type === `thematicBreak`
        ) {
          useDifferentMarker = !0
          break
        }
      }
    }
  }
  useDifferentMarker && (bullet = bulletOther), state.bulletCurrent = bullet
  let value$2 = state.containerFlow(node$1, info)
  return state.bulletLastUsed = bullet, state.bulletCurrent = bulletCurrent, exit$5(), value$2
}
function checkListItemIndent(state) {
  let style$1 = state.options.listItemIndent || `one`
  if (style$1 !== `tab` && style$1 !== `one` && style$1 !== `mixed`) {
    throw Error(
      'Cannot serialize items with `' + style$1 + '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`',
    )
  }
  return style$1
}
function listItem$1(node$1, parent, state, info) {
  let listItemIndent = checkListItemIndent(state), bullet = state.bulletCurrent || checkBullet(state)
  parent && parent.type === `list` && parent.ordered
    && (bullet = (typeof parent.start == `number` && parent.start > -1 ? parent.start : 1)
      + (state.options.incrementListMarker === !1 ? 0 : parent.children.indexOf(node$1)) + bullet)
  let size$14 = bullet.length + 1
  ;(listItemIndent === `tab`
    || listItemIndent === `mixed` && (parent && parent.type === `list` && parent.spread || node$1.spread))
    && (size$14 = Math.ceil(size$14 / 4) * 4)
  let tracker = state.createTracker(info)
  tracker.move(bullet + ` `.repeat(size$14 - bullet.length)), tracker.shift(size$14)
  let exit$5 = state.enter(`listItem`),
    value$2 = state.indentLines(state.containerFlow(node$1, tracker.current()), map$20)
  return exit$5(), value$2
  function map$20(line, index$4, blank) {
    return index$4
      ? (blank ? `` : ` `.repeat(size$14)) + line
      : (blank ? bullet : bullet + ` `.repeat(size$14 - bullet.length)) + line
  }
}
function paragraph$1(node$1, _$1, state, info) {
  let exit$5 = state.enter(`paragraph`),
    subexit = state.enter(`phrasing`),
    value$2 = state.containerPhrasing(node$1, info)
  return subexit(), exit$5(), value$2
}
const phrasing = convert([
  `break`,
  `delete`,
  `emphasis`,
  `footnote`,
  `footnoteReference`,
  `image`,
  `imageReference`,
  `inlineCode`,
  `inlineMath`,
  `link`,
  `linkReference`,
  `mdxJsxTextElement`,
  `mdxTextExpression`,
  `strong`,
  `text`,
  `textDirective`,
])
function root$2(node$1, _$1, state, info) {
  let hasPhrasing = node$1.children.some(function(d$7) {
      return phrasing(d$7)
    }),
    container = hasPhrasing ? state.containerPhrasing : state.containerFlow
  return container.call(state, node$1, info)
}
function checkStrong(state) {
  let marker = state.options.strong || `*`
  if (marker !== `*` && marker !== `_`) {
    throw Error('Cannot serialize strong with `' + marker + '` for `options.strong`, expected `*`, or `_`')
  }
  return marker
}
strong$1.peek = strongPeek
function strong$1(node$1, _$1, state, info) {
  let marker = checkStrong(state),
    exit$5 = state.enter(`strong`),
    tracker = state.createTracker(info),
    before$2 = tracker.move(marker + marker),
    between = tracker.move(state.containerPhrasing(node$1, { after: marker, before: before$2, ...tracker.current() })),
    betweenHead = between.charCodeAt(0),
    open = encodeInfo(info.before.charCodeAt(info.before.length - 1), betweenHead, marker)
  open.inside && (between = encodeCharacterReference(betweenHead) + between.slice(1))
  let betweenTail = between.charCodeAt(between.length - 1),
    close$1 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)
  close$1.inside && (between = between.slice(0, -1) + encodeCharacterReference(betweenTail))
  let after$2 = tracker.move(marker + marker)
  return exit$5(),
    state.attentionEncodeSurroundingInfo = { after: close$1.outside, before: open.outside },
    before$2 + between + after$2
}
function strongPeek(_$1, _1, state) {
  return state.options.strong || `*`
}
function text$4(node$1, _$1, state, info) {
  return state.safe(node$1.value, info)
}
function checkRuleRepetition(state) {
  let repetition = state.options.ruleRepetition || 3
  if (repetition < 3) {
    throw Error(
      'Cannot serialize rules with repetition `' + repetition + '` for `options.ruleRepetition`, expected `3` or more',
    )
  }
  return repetition
}
function thematicBreak$2(_$1, _1, state) {
  let value$2 = (checkRule(state) + (state.options.ruleSpaces ? ` ` : ``)).repeat(checkRuleRepetition(state))
  return state.options.ruleSpaces ? value$2.slice(0, -1) : value$2
}
const handle = {
    blockquote: blockquote$1,
    break: hardBreak$1,
    code: code$2,
    definition: definition$1,
    emphasis: emphasis$1,
    hardBreak: hardBreak$1,
    heading: heading$1,
    html: html$1,
    image: image$1,
    imageReference: imageReference$1,
    inlineCode: inlineCode$1,
    link: link$1,
    linkReference: linkReference$1,
    list: list$2,
    listItem: listItem$1,
    paragraph: paragraph$1,
    root: root$2,
    strong: strong$1,
    text: text$4,
    thematicBreak: thematicBreak$2,
  },
  element = document.createElement(`i`)
function decodeNamedCharacterReference(value$2) {
  let characterReference$1 = `&` + value$2 + `;`
  element.innerHTML = characterReference$1
  let character = element.textContent
  return character.charCodeAt(character.length - 1) === 59 && value$2 !== `semi` || character === characterReference$1
    ? !1
    : character
}
function decodeNumericCharacterReference(value$2, base) {
  let code$3 = Number.parseInt(value$2, base)
  return code$3 < 9 || code$3 === 11 || code$3 > 13 && code$3 < 32 || code$3 > 126 && code$3 < 160
      || code$3 > 55295 && code$3 < 57344 || code$3 > 64975 && code$3 < 65008 || (code$3 & 65535) == 65535
      || (code$3 & 65535) == 65534 || code$3 > 1114111
    ? ``
    : String.fromCodePoint(code$3)
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi
function decodeString(value$2) {
  return value$2.replace(characterEscapeOrReference, decode)
}
function decode($0, $1, $2) {
  if ($1) return $1
  let head$5 = $2.charCodeAt(0)
  if (head$5 === 35) {
    let head$6 = $2.charCodeAt(1), hex = head$6 === 120 || head$6 === 88
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)
  }
  return decodeNamedCharacterReference($2) || $0
}
function gfmTableFromMarkdown() {
  return {
    enter: { table: enterTable, tableData: enterCell, tableHeader: enterCell, tableRow: enterRow },
    exit: { codeText: exitCodeText, table: exitTable, tableData: exit$1, tableHeader: exit$1, tableRow: exit$1 },
  }
}
function enterTable(token) {
  let align = token._align
  this.enter({
    type: `table`,
    align: align.map(function(d$7) {
      return d$7 === `none` ? null : d$7
    }),
    children: [],
  }, token), this.data.inTable = !0
}
function exitTable(token) {
  this.exit(token), this.data.inTable = void 0
}
function enterRow(token) {
  this.enter({ type: `tableRow`, children: [] }, token)
}
function exit$1(token) {
  this.exit(token)
}
function enterCell(token) {
  this.enter({ type: `tableCell`, children: [] }, token)
}
function exitCodeText(token) {
  let value$2 = this.resume()
  this.data.inTable && (value$2 = value$2.replace(/\\([\\|])/g, replace))
  let node$1 = this.stack[this.stack.length - 1]
  node$1.type, node$1.value = value$2, this.exit(token)
}
function replace($0, $1) {
  return $1 === `|` ? $1 : $0
}
function gfmTableToMarkdown(options$2) {
  let settings = options$2 || {},
    padding = settings.tableCellPadding,
    alignDelimiters = settings.tablePipeAlign,
    stringLength = settings.stringLength,
    around = padding ? ` ` : `|`
  return {
    unsafe: [
      { character: `\r`, inConstruct: `tableCell` },
      {
        character: `
`,
        inConstruct: `tableCell`,
      },
      { atBreak: !0, character: `|`, after: `[	 :-]` },
      { character: `|`, inConstruct: `tableCell` },
      { atBreak: !0, character: `:`, after: `-` },
      { atBreak: !0, character: `-`, after: `[:|-]` },
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow,
    },
  }
  function handleTable(node$1, _$1, state, info) {
    return serializeData(handleTableAsData(node$1, state, info), node$1.align)
  }
  function handleTableRow(node$1, _$1, state, info) {
    let row = handleTableRowAsData(node$1, state, info), value$2 = serializeData([row])
    return value$2.slice(
      0,
      value$2.indexOf(`
`),
    )
  }
  function handleTableCell(node$1, _$1, state, info) {
    let exit$5 = state.enter(`tableCell`),
      subexit = state.enter(`phrasing`),
      value$2 = state.containerPhrasing(node$1, { ...info, before: around, after: around })
    return subexit(), exit$5(), value$2
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, { align, alignDelimiters, padding, stringLength })
  }
  function handleTableAsData(node$1, state, info) {
    let children$3 = node$1.children, index$4 = -1, result = [], subexit = state.enter(`table`)
    for (; ++index$4 < children$3.length;) result[index$4] = handleTableRowAsData(children$3[index$4], state, info)
    return subexit(), result
  }
  function handleTableRowAsData(node$1, state, info) {
    let children$3 = node$1.children, index$4 = -1, result = [], subexit = state.enter(`tableRow`)
    for (; ++index$4 < children$3.length;) result[index$4] = handleTableCell(children$3[index$4], node$1, state, info)
    return subexit(), result
  }
  function inlineCodeWithTable(node$1, parent, state) {
    let value$2 = handle.inlineCode(node$1, parent, state)
    return state.stack.includes(`tableCell`) && (value$2 = value$2.replace(/\|/g, `\\$&`)), value$2
  }
}
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem,
    },
  }
}
function gfmTaskListItemToMarkdown() {
  return { unsafe: [{ atBreak: !0, character: `-`, after: `[:|-]` }], handlers: { listItem: listItemWithTaskListItem } }
}
function exitCheck(token) {
  let node$1 = this.stack[this.stack.length - 2]
  node$1.type, node$1.checked = token.type === `taskListCheckValueChecked`
}
function exitParagraphWithTaskListItem(token) {
  let parent = this.stack[this.stack.length - 2]
  if (parent && parent.type === `listItem` && typeof parent.checked == `boolean`) {
    let node$1 = this.stack[this.stack.length - 1]
    node$1.type
    let head$5 = node$1.children[0]
    if (head$5 && head$5.type === `text`) {
      let siblings$1 = parent.children, index$4 = -1, firstParaghraph
      for (; ++index$4 < siblings$1.length;) {
        let sibling = siblings$1[index$4]
        if (sibling.type === `paragraph`) {
          firstParaghraph = sibling
          break
        }
      }
      firstParaghraph === node$1 && (head$5.value = head$5.value.slice(1),
        head$5.value.length === 0
          ? node$1.children.shift()
          : node$1.position && head$5.position && typeof head$5.position.start.offset == `number`
            && (head$5.position.start.column++,
              head$5.position.start.offset++,
              node$1.position.start = Object.assign({}, head$5.position.start)))
    }
  }
  this.exit(token)
}
function listItemWithTaskListItem(node$1, parent, state, info) {
  let head$5 = node$1.children[0],
    checkable = typeof node$1.checked == `boolean` && head$5 && head$5.type === `paragraph`,
    checkbox = `[` + (node$1.checked ? `x` : ` `) + `] `,
    tracker = state.createTracker(info)
  checkable && tracker.move(checkbox)
  let value$2 = handle.listItem(node$1, parent, state, { ...info, ...tracker.current() })
  return checkable && (value$2 = value$2.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check$1)), value$2
  function check$1($0) {
    return $0 + checkbox
  }
}
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown(),
  ]
}
function gfmToMarkdown(options$2) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(options$2),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options$2),
      gfmTaskListItemToMarkdown(),
    ],
  }
}
function splice(list$3, start$2, remove$7, items) {
  let end$2 = list$3.length, chunkStart = 0, parameters
  if (
    start$2 = start$2 < 0 ? -start$2 > end$2 ? 0 : end$2 + start$2 : start$2 > end$2 ? end$2 : start$2,
      remove$7 = remove$7 > 0 ? remove$7 : 0,
      items.length < 1e4
  ) parameters = Array.from(items), parameters.unshift(start$2, remove$7), list$3.splice(...parameters)
  else {for (remove$7 && list$3.splice(start$2, remove$7); chunkStart < items.length;) {
      parameters = items.slice(chunkStart, chunkStart + 1e4),
        parameters.unshift(start$2, 0),
        list$3.splice(...parameters),
        chunkStart += 1e4,
        start$2 += 1e4
    }}
}
function push(list$3, items) {
  return list$3.length > 0 ? (splice(list$3, list$3.length, 0, items), list$3) : items
}
const hasOwnProperty = {}.hasOwnProperty
function combineExtensions(extensions) {
  let all$8 = {}, index$4 = -1
  for (; ++index$4 < extensions.length;) syntaxExtension(all$8, extensions[index$4])
  return all$8
}
function syntaxExtension(all$8, extension$1) {
  let hook
  for (hook in extension$1) {
    let maybe = hasOwnProperty.call(all$8, hook) ? all$8[hook] : void 0,
      left$2 = maybe || (all$8[hook] = {}),
      right$2 = extension$1[hook],
      code$3
    if (right$2) {
      for (code$3 in right$2) {
        hasOwnProperty.call(left$2, code$3) || (left$2[code$3] = [])
        let value$2 = right$2[code$3]
        constructs(left$2[code$3], Array.isArray(value$2) ? value$2 : value$2 ? [value$2] : [])
      }
    }
  }
}
function constructs(existing, list$3) {
  let index$4 = -1, before$2 = []
  for (; ++index$4 < list$3.length;) (list$3[index$4].add === `after` ? existing : before$2).push(list$3[index$4])
  splice(existing, 0, 0, before$2)
}
const wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: !0 },
  domain = { tokenize: tokenizeDomain, partial: !0 },
  path = { tokenize: tokenizePath, partial: !0 },
  trail = { tokenize: tokenizeTrail, partial: !0 },
  emailDomainDotTrail = { tokenize: tokenizeEmailDomainDotTrail, partial: !0 },
  wwwAutolink = { name: `wwwAutolink`, tokenize: tokenizeWwwAutolink, previous: previousWww },
  protocolAutolink = { name: `protocolAutolink`, tokenize: tokenizeProtocolAutolink, previous: previousProtocol },
  emailAutolink = { name: `emailAutolink`, tokenize: tokenizeEmailAutolink, previous: previousEmail },
  text$3 = {}
function gfmAutolinkLiteral() {
  return { text: text$3 }
}
let code$1 = 48
for (; code$1 < 123;) {
  text$3[code$1] = emailAutolink, code$1++, code$1 === 58 ? code$1 = 65 : code$1 === 91 && (code$1 = 97)
}
text$3[43] = emailAutolink,
  text$3[45] = emailAutolink,
  text$3[46] = emailAutolink,
  text$3[95] = emailAutolink,
  text$3[72] = [emailAutolink, protocolAutolink],
  text$3[104] = [emailAutolink, protocolAutolink],
  text$3[87] = [emailAutolink, wwwAutolink],
  text$3[119] = [emailAutolink, wwwAutolink]
function tokenizeEmailAutolink(effects, ok$2, nok) {
  let self$1 = this, dot, data
  return start$2
  function start$2(code$3) {
    return !gfmAtext(code$3) || !previousEmail.call(self$1, self$1.previous) || previousUnbalanced(self$1.events)
      ? nok(code$3)
      : (effects.enter(`literalAutolink`), effects.enter(`literalAutolinkEmail`), atext(code$3))
  }
  function atext(code$3) {
    return gfmAtext(code$3)
      ? (effects.consume(code$3), atext)
      : code$3 === 64
      ? (effects.consume(code$3), emailDomain)
      : nok(code$3)
  }
  function emailDomain(code$3) {
    return code$3 === 46
      ? effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code$3)
      : code$3 === 45 || code$3 === 95 || asciiAlphanumeric(code$3)
      ? (data = !0, effects.consume(code$3), emailDomain)
      : emailDomainAfter(code$3)
  }
  function emailDomainDot(code$3) {
    return effects.consume(code$3), dot = !0, emailDomain
  }
  function emailDomainAfter(code$3) {
    return data && dot && asciiAlpha(self$1.previous)
      ? (effects.exit(`literalAutolinkEmail`), effects.exit(`literalAutolink`), ok$2(code$3))
      : nok(code$3)
  }
}
function tokenizeWwwAutolink(effects, ok$2, nok) {
  let self$1 = this
  return wwwStart
  function wwwStart(code$3) {
    return code$3 !== 87 && code$3 !== 119 || !previousWww.call(self$1, self$1.previous)
        || previousUnbalanced(self$1.events)
      ? nok(code$3)
      : (effects.enter(`literalAutolink`),
        effects.enter(`literalAutolinkWww`),
        effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code$3))
  }
  function wwwAfter(code$3) {
    return effects.exit(`literalAutolinkWww`), effects.exit(`literalAutolink`), ok$2(code$3)
  }
}
function tokenizeProtocolAutolink(effects, ok$2, nok) {
  let self$1 = this, buffer = ``, seen$1 = !1
  return protocolStart
  function protocolStart(code$3) {
    return (code$3 === 72 || code$3 === 104) && previousProtocol.call(self$1, self$1.previous)
        && !previousUnbalanced(self$1.events)
      ? (effects.enter(`literalAutolink`),
        effects.enter(`literalAutolinkHttp`),
        buffer += String.fromCodePoint(code$3),
        effects.consume(code$3),
        protocolPrefixInside)
      : nok(code$3)
  }
  function protocolPrefixInside(code$3) {
    if (asciiAlpha(code$3) && buffer.length < 5) {
      return buffer += String.fromCodePoint(code$3), effects.consume(code$3), protocolPrefixInside
    }
    if (code$3 === 58) {
      let protocol = buffer.toLowerCase()
      if (protocol === `http` || protocol === `https`) return effects.consume(code$3), protocolSlashesInside
    }
    return nok(code$3)
  }
  function protocolSlashesInside(code$3) {
    return code$3 === 47
      ? (effects.consume(code$3), seen$1 ? afterProtocol : (seen$1 = !0, protocolSlashesInside))
      : nok(code$3)
  }
  function afterProtocol(code$3) {
    return code$3 === null || asciiControl(code$3) || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)
        || unicodePunctuation(code$3)
      ? nok(code$3)
      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code$3)
  }
  function protocolAfter(code$3) {
    return effects.exit(`literalAutolinkHttp`), effects.exit(`literalAutolink`), ok$2(code$3)
  }
}
function tokenizeWwwPrefix(effects, ok$2, nok) {
  let size$14 = 0
  return wwwPrefixInside
  function wwwPrefixInside(code$3) {
    return (code$3 === 87 || code$3 === 119) && size$14 < 3
      ? (size$14++, effects.consume(code$3), wwwPrefixInside)
      : code$3 === 46 && size$14 === 3
      ? (effects.consume(code$3), wwwPrefixAfter)
      : nok(code$3)
  }
  function wwwPrefixAfter(code$3) {
    return code$3 === null ? nok(code$3) : ok$2(code$3)
  }
}
function tokenizeDomain(effects, ok$2, nok) {
  let underscoreInLastSegment, underscoreInLastLastSegment, seen$1
  return domainInside
  function domainInside(code$3) {
    return code$3 === 46 || code$3 === 95
      ? effects.check(trail, domainAfter, domainAtPunctuation)(code$3)
      : code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)
          || code$3 !== 45 && unicodePunctuation(code$3)
      ? domainAfter(code$3)
      : (seen$1 = !0, effects.consume(code$3), domainInside)
  }
  function domainAtPunctuation(code$3) {
    return code$3 === 95
      ? underscoreInLastSegment = !0
      : (underscoreInLastLastSegment = underscoreInLastSegment, underscoreInLastSegment = void 0),
      effects.consume(code$3),
      domainInside
  }
  function domainAfter(code$3) {
    return underscoreInLastLastSegment || underscoreInLastSegment || !seen$1 ? nok(code$3) : ok$2(code$3)
  }
}
function tokenizePath(effects, ok$2) {
  let sizeOpen = 0, sizeClose = 0
  return pathInside
  function pathInside(code$3) {
    return code$3 === 40
      ? (sizeOpen++, effects.consume(code$3), pathInside)
      : code$3 === 41 && sizeClose < sizeOpen
      ? pathAtPunctuation(code$3)
      : code$3 === 33 || code$3 === 34 || code$3 === 38 || code$3 === 39 || code$3 === 41 || code$3 === 42
          || code$3 === 44 || code$3 === 46 || code$3 === 58 || code$3 === 59 || code$3 === 60 || code$3 === 63
          || code$3 === 93 || code$3 === 95 || code$3 === 126
      ? effects.check(trail, ok$2, pathAtPunctuation)(code$3)
      : code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)
      ? ok$2(code$3)
      : (effects.consume(code$3), pathInside)
  }
  function pathAtPunctuation(code$3) {
    return code$3 === 41 && sizeClose++, effects.consume(code$3), pathInside
  }
}
function tokenizeTrail(effects, ok$2, nok) {
  return trail$1
  function trail$1(code$3) {
    return code$3 === 33 || code$3 === 34 || code$3 === 39 || code$3 === 41 || code$3 === 42 || code$3 === 44
        || code$3 === 46 || code$3 === 58 || code$3 === 59 || code$3 === 63 || code$3 === 95 || code$3 === 126
      ? (effects.consume(code$3), trail$1)
      : code$3 === 38
      ? (effects.consume(code$3), trailCharacterReferenceStart)
      : code$3 === 93
      ? (effects.consume(code$3), trailBracketAfter)
      : code$3 === 60 || code$3 === null || markdownLineEndingOrSpace(code$3) || unicodeWhitespace(code$3)
      ? ok$2(code$3)
      : nok(code$3)
  }
  function trailBracketAfter(code$3) {
    return code$3 === null || code$3 === 40 || code$3 === 91 || markdownLineEndingOrSpace(code$3)
        || unicodeWhitespace(code$3)
      ? ok$2(code$3)
      : trail$1(code$3)
  }
  function trailCharacterReferenceStart(code$3) {
    return asciiAlpha(code$3) ? trailCharacterReferenceInside(code$3) : nok(code$3)
  }
  function trailCharacterReferenceInside(code$3) {
    return code$3 === 59
      ? (effects.consume(code$3), trail$1)
      : asciiAlpha(code$3)
      ? (effects.consume(code$3), trailCharacterReferenceInside)
      : nok(code$3)
  }
}
function tokenizeEmailDomainDotTrail(effects, ok$2, nok) {
  return start$2
  function start$2(code$3) {
    return effects.consume(code$3), after$2
  }
  function after$2(code$3) {
    return asciiAlphanumeric(code$3) ? nok(code$3) : ok$2(code$3)
  }
}
function previousWww(code$3) {
  return code$3 === null || code$3 === 40 || code$3 === 42 || code$3 === 95 || code$3 === 91 || code$3 === 93
    || code$3 === 126 || markdownLineEndingOrSpace(code$3)
}
function previousProtocol(code$3) {
  return !asciiAlpha(code$3)
}
function previousEmail(code$3) {
  return !(code$3 === 47 || gfmAtext(code$3))
}
function gfmAtext(code$3) {
  return code$3 === 43 || code$3 === 45 || code$3 === 46 || code$3 === 95 || asciiAlphanumeric(code$3)
}
function previousUnbalanced(events) {
  let index$4 = events.length, result = !1
  for (; index$4--;) {
    let token = events[index$4][1]
    if ((token.type === `labelLink` || token.type === `labelImage`) && !token._balanced) {
      result = !0
      break
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = !1
      break
    }
  }
  return events.length > 0 && !result && (events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), result
}
function normalizeUri(value$2) {
  let result = [], index$4 = -1, start$2 = 0, skip = 0
  for (; ++index$4 < value$2.length;) {
    let code$3 = value$2.charCodeAt(index$4), replace$1 = ``
    if (
      code$3 === 37 && asciiAlphanumeric(value$2.charCodeAt(index$4 + 1))
      && asciiAlphanumeric(value$2.charCodeAt(index$4 + 2))
    ) skip = 2
    else if (code$3 < 128) {
      ;/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code$3)) || (replace$1 = String.fromCharCode(code$3))
    } else if (code$3 > 55295 && code$3 < 57344) {
      let next = value$2.charCodeAt(index$4 + 1)
      code$3 < 56320 && next > 56319 && next < 57344
        ? (replace$1 = String.fromCharCode(code$3, next), skip = 1)
        : replace$1 = ``
    } else replace$1 = String.fromCharCode(code$3)
    replace$1
    && (result.push(value$2.slice(start$2, index$4), encodeURIComponent(replace$1)),
      start$2 = index$4 + skip + 1,
      replace$1 = ``), skip && (index$4 += skip, skip = 0)
  }
  return result.join(``) + value$2.slice(start$2)
}
function resolveAll(constructs$1, events, context$2) {
  let called = [], index$4 = -1
  for (; ++index$4 < constructs$1.length;) {
    let resolve = constructs$1[index$4].resolveAll
    resolve && !called.includes(resolve) && (events = resolve(events, context$2), called.push(resolve))
  }
  return events
}
const attention = { name: `attention`, resolveAll: resolveAllAttention, tokenize: tokenizeAttention }
function resolveAllAttention(events, context$2) {
  let index$4 = -1, open, group, text$6, openingSequence, closingSequence, use$2, nextEvents, offset$3
  for (; ++index$4 < events.length;) {
    if (
      events[index$4][0] === `enter` && events[index$4][1].type === `attentionSequence` && events[index$4][1]._close
    ) {
      for (open = index$4; open--;) {
        if (
          events[open][0] === `exit` && events[open][1].type === `attentionSequence` && events[open][1]._open
          && context$2.sliceSerialize(events[open][1]).charCodeAt(0)
            === context$2.sliceSerialize(events[index$4][1]).charCodeAt(0)
        ) {
          if (
            (events[open][1]._close || events[index$4][1]._open)
            && (events[index$4][1].end.offset - events[index$4][1].start.offset) % 3
            && !((events[open][1].end.offset - events[open][1].start.offset + events[index$4][1].end.offset
              - events[index$4][1].start.offset) % 3)
          ) continue
          use$2 = events[open][1].end.offset - events[open][1].start.offset > 1
              && events[index$4][1].end.offset - events[index$4][1].start.offset > 1
            ? 2
            : 1
          let start$2 = { ...events[open][1].end }, end$2 = { ...events[index$4][1].start }
          movePoint(start$2, -use$2),
            movePoint(end$2, use$2),
            openingSequence = {
              type: use$2 > 1 ? `strongSequence` : `emphasisSequence`,
              start: start$2,
              end: { ...events[open][1].end },
            },
            closingSequence = {
              type: use$2 > 1 ? `strongSequence` : `emphasisSequence`,
              start: { ...events[index$4][1].start },
              end: end$2,
            },
            text$6 = {
              type: use$2 > 1 ? `strongText` : `emphasisText`,
              start: { ...events[open][1].end },
              end: { ...events[index$4][1].start },
            },
            group = {
              type: use$2 > 1 ? `strong` : `emphasis`,
              start: { ...openingSequence.start },
              end: { ...closingSequence.end },
            },
            events[open][1].end = { ...openingSequence.start },
            events[index$4][1].start = { ...closingSequence.end },
            nextEvents = [],
            events[open][1].end.offset - events[open][1].start.offset
            && (nextEvents = push(nextEvents, [[`enter`, events[open][1], context$2], [
              `exit`,
              events[open][1],
              context$2,
            ]])),
            nextEvents = push(nextEvents, [[`enter`, group, context$2], [`enter`, openingSequence, context$2], [
              `exit`,
              openingSequence,
              context$2,
            ], [`enter`, text$6, context$2]]),
            nextEvents = push(
              nextEvents,
              resolveAll(context$2.parser.constructs.insideSpan.null, events.slice(open + 1, index$4), context$2),
            ),
            nextEvents = push(nextEvents, [[`exit`, text$6, context$2], [`enter`, closingSequence, context$2], [
              `exit`,
              closingSequence,
              context$2,
            ], [`exit`, group, context$2]]),
            events[index$4][1].end.offset - events[index$4][1].start.offset
              ? (offset$3 = 2,
                nextEvents = push(nextEvents, [[`enter`, events[index$4][1], context$2], [
                  `exit`,
                  events[index$4][1],
                  context$2,
                ]]))
              : offset$3 = 0,
            splice(events, open - 1, index$4 - open + 3, nextEvents),
            index$4 = open + nextEvents.length - offset$3 - 2
          break
        }
      }
    }
  }
  for (index$4 = -1; ++index$4 < events.length;) {
    events[index$4][1].type === `attentionSequence` && (events[index$4][1].type = `data`)
  }
  return events
}
function tokenizeAttention(effects, ok$2) {
  let attentionMarkers$1 = this.parser.constructs.attentionMarkers.null,
    previous$2 = this.previous,
    before$2 = classifyCharacter(previous$2),
    marker
  return start$2
  function start$2(code$3) {
    return marker = code$3, effects.enter(`attentionSequence`), inside(code$3)
  }
  function inside(code$3) {
    if (code$3 === marker) return effects.consume(code$3), inside
    let token = effects.exit(`attentionSequence`),
      after$2 = classifyCharacter(code$3),
      open = !after$2 || after$2 === 2 && before$2 || attentionMarkers$1.includes(code$3),
      close$1 = !before$2 || before$2 === 2 && after$2 || attentionMarkers$1.includes(previous$2)
    return token._open = !!(marker === 42 ? open : open && (before$2 || !close$1)),
      token._close = !!(marker === 42 ? close$1 : close$1 && (after$2 || !open)),
      ok$2(code$3)
  }
}
function movePoint(point$3, offset$3) {
  point$3.column += offset$3, point$3.offset += offset$3, point$3._bufferIndex += offset$3
}
const autolink = { name: `autolink`, tokenize: tokenizeAutolink }
function tokenizeAutolink(effects, ok$2, nok) {
  let size$14 = 0
  return start$2
  function start$2(code$3) {
    return effects.enter(`autolink`),
      effects.enter(`autolinkMarker`),
      effects.consume(code$3),
      effects.exit(`autolinkMarker`),
      effects.enter(`autolinkProtocol`),
      open
  }
  function open(code$3) {
    return asciiAlpha(code$3)
      ? (effects.consume(code$3), schemeOrEmailAtext)
      : code$3 === 64
      ? nok(code$3)
      : emailAtext(code$3)
  }
  function schemeOrEmailAtext(code$3) {
    return code$3 === 43 || code$3 === 45 || code$3 === 46 || asciiAlphanumeric(code$3)
      ? (size$14 = 1, schemeInsideOrEmailAtext(code$3))
      : emailAtext(code$3)
  }
  function schemeInsideOrEmailAtext(code$3) {
    return code$3 === 58
      ? (effects.consume(code$3), size$14 = 0, urlInside)
      : (code$3 === 43 || code$3 === 45 || code$3 === 46 || asciiAlphanumeric(code$3)) && size$14++ < 32
      ? (effects.consume(code$3), schemeInsideOrEmailAtext)
      : (size$14 = 0, emailAtext(code$3))
  }
  function urlInside(code$3) {
    return code$3 === 62
      ? (effects.exit(`autolinkProtocol`),
        effects.enter(`autolinkMarker`),
        effects.consume(code$3),
        effects.exit(`autolinkMarker`),
        effects.exit(`autolink`),
        ok$2)
      : code$3 === null || code$3 === 32 || code$3 === 60 || asciiControl(code$3)
      ? nok(code$3)
      : (effects.consume(code$3), urlInside)
  }
  function emailAtext(code$3) {
    return code$3 === 64
      ? (effects.consume(code$3), emailAtSignOrDot)
      : asciiAtext(code$3)
      ? (effects.consume(code$3), emailAtext)
      : nok(code$3)
  }
  function emailAtSignOrDot(code$3) {
    return asciiAlphanumeric(code$3) ? emailLabel(code$3) : nok(code$3)
  }
  function emailLabel(code$3) {
    return code$3 === 46
      ? (effects.consume(code$3), size$14 = 0, emailAtSignOrDot)
      : code$3 === 62
      ? (effects.exit(`autolinkProtocol`).type = `autolinkEmail`,
        effects.enter(`autolinkMarker`),
        effects.consume(code$3),
        effects.exit(`autolinkMarker`),
        effects.exit(`autolink`),
        ok$2)
      : emailValue(code$3)
  }
  function emailValue(code$3) {
    if ((code$3 === 45 || asciiAlphanumeric(code$3)) && size$14++ < 63) {
      let next = code$3 === 45 ? emailValue : emailLabel
      return effects.consume(code$3), next
    }
    return nok(code$3)
  }
}
function factorySpace(effects, ok$2, type$2, max$12) {
  let limit = max$12 ? max$12 - 1 : 1 / 0, size$14 = 0
  return start$2
  function start$2(code$3) {
    return markdownSpace(code$3) ? (effects.enter(type$2), prefix$1(code$3)) : ok$2(code$3)
  }
  function prefix$1(code$3) {
    return markdownSpace(code$3) && size$14++ < limit
      ? (effects.consume(code$3), prefix$1)
      : (effects.exit(type$2), ok$2(code$3))
  }
}
const blankLine = { partial: !0, tokenize: tokenizeBlankLine }
function tokenizeBlankLine(effects, ok$2, nok) {
  return start$2
  function start$2(code$3) {
    return markdownSpace(code$3) ? factorySpace(effects, after$2, `linePrefix`)(code$3) : after$2(code$3)
  }
  function after$2(code$3) {
    return code$3 === null || markdownLineEnding(code$3) ? ok$2(code$3) : nok(code$3)
  }
}
const blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit,
  name: `blockQuote`,
  tokenize: tokenizeBlockQuoteStart,
}
function tokenizeBlockQuoteStart(effects, ok$2, nok) {
  let self$1 = this
  return start$2
  function start$2(code$3) {
    if (code$3 === 62) {
      let state = self$1.containerState
      return state.open || (effects.enter(`blockQuote`, { _container: !0 }), state.open = !0),
        effects.enter(`blockQuotePrefix`),
        effects.enter(`blockQuoteMarker`),
        effects.consume(code$3),
        effects.exit(`blockQuoteMarker`),
        after$2
    }
    return nok(code$3)
  }
  function after$2(code$3) {
    return markdownSpace(code$3)
      ? (effects.enter(`blockQuotePrefixWhitespace`),
        effects.consume(code$3),
        effects.exit(`blockQuotePrefixWhitespace`),
        effects.exit(`blockQuotePrefix`),
        ok$2)
      : (effects.exit(`blockQuotePrefix`), ok$2(code$3))
  }
}
function tokenizeBlockQuoteContinuation(effects, ok$2, nok) {
  let self$1 = this
  return contStart
  function contStart(code$3) {
    return markdownSpace(code$3)
      ? factorySpace(
        effects,
        contBefore,
        `linePrefix`,
        self$1.parser.constructs.disable.null.includes(`codeIndented`) ? void 0 : 4,
      )(code$3)
      : contBefore(code$3)
  }
  function contBefore(code$3) {
    return effects.attempt(blockQuote, ok$2, nok)(code$3)
  }
}
function exit(effects) {
  effects.exit(`blockQuote`)
}
const characterEscape = { name: `characterEscape`, tokenize: tokenizeCharacterEscape }
function tokenizeCharacterEscape(effects, ok$2, nok) {
  return start$2
  function start$2(code$3) {
    return effects.enter(`characterEscape`),
      effects.enter(`escapeMarker`),
      effects.consume(code$3),
      effects.exit(`escapeMarker`),
      inside
  }
  function inside(code$3) {
    return asciiPunctuation(code$3)
      ? (effects.enter(`characterEscapeValue`),
        effects.consume(code$3),
        effects.exit(`characterEscapeValue`),
        effects.exit(`characterEscape`),
        ok$2)
      : nok(code$3)
  }
}
const characterReference = { name: `characterReference`, tokenize: tokenizeCharacterReference }
function tokenizeCharacterReference(effects, ok$2, nok) {
  let self$1 = this, size$14 = 0, max$12, test
  return start$2
  function start$2(code$3) {
    return effects.enter(`characterReference`),
      effects.enter(`characterReferenceMarker`),
      effects.consume(code$3),
      effects.exit(`characterReferenceMarker`),
      open
  }
  function open(code$3) {
    return code$3 === 35
      ? (effects.enter(`characterReferenceMarkerNumeric`),
        effects.consume(code$3),
        effects.exit(`characterReferenceMarkerNumeric`),
        numeric)
      : (effects.enter(`characterReferenceValue`), max$12 = 31, test = asciiAlphanumeric, value$2(code$3))
  }
  function numeric(code$3) {
    return code$3 === 88 || code$3 === 120
      ? (effects.enter(`characterReferenceMarkerHexadecimal`),
        effects.consume(code$3),
        effects.exit(`characterReferenceMarkerHexadecimal`),
        effects.enter(`characterReferenceValue`),
        max$12 = 6,
        test = asciiHexDigit,
        value$2)
      : (effects.enter(`characterReferenceValue`), max$12 = 7, test = asciiDigit, value$2(code$3))
  }
  function value$2(code$3) {
    if (code$3 === 59 && size$14) {
      let token = effects.exit(`characterReferenceValue`)
      return test === asciiAlphanumeric && !decodeNamedCharacterReference(self$1.sliceSerialize(token))
        ? nok(code$3)
        : (effects.enter(`characterReferenceMarker`),
          effects.consume(code$3),
          effects.exit(`characterReferenceMarker`),
          effects.exit(`characterReference`),
          ok$2)
    }
    return test(code$3) && size$14++ < max$12 ? (effects.consume(code$3), value$2) : nok(code$3)
  }
}
const nonLazyContinuation = { partial: !0, tokenize: tokenizeNonLazyContinuation },
  codeFenced = { concrete: !0, name: `codeFenced`, tokenize: tokenizeCodeFenced }
function tokenizeCodeFenced(effects, ok$2, nok) {
  let self$1 = this, closeStart = { partial: !0, tokenize: tokenizeCloseStart }, initialPrefix = 0, sizeOpen = 0, marker
  return start$2
  function start$2(code$3) {
    return beforeSequenceOpen(code$3)
  }
  function beforeSequenceOpen(code$3) {
    let tail = self$1.events[self$1.events.length - 1]
    return initialPrefix = tail && tail[1].type === `linePrefix` ? tail[2].sliceSerialize(tail[1], !0).length : 0,
      marker = code$3,
      effects.enter(`codeFenced`),
      effects.enter(`codeFencedFence`),
      effects.enter(`codeFencedFenceSequence`),
      sequenceOpen(code$3)
  }
  function sequenceOpen(code$3) {
    return code$3 === marker
      ? (sizeOpen++, effects.consume(code$3), sequenceOpen)
      : sizeOpen < 3
      ? nok(code$3)
      : (effects.exit(`codeFencedFenceSequence`),
        markdownSpace(code$3) ? factorySpace(effects, infoBefore, `whitespace`)(code$3) : infoBefore(code$3))
  }
  function infoBefore(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`codeFencedFence`),
        self$1.interrupt ? ok$2(code$3) : effects.check(nonLazyContinuation, atNonLazyBreak, after$2)(code$3))
      : (effects.enter(`codeFencedFenceInfo`), effects.enter(`chunkString`, { contentType: `string` }), info(code$3))
  }
  function info(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`chunkString`), effects.exit(`codeFencedFenceInfo`), infoBefore(code$3))
      : markdownSpace(code$3)
      ? (effects.exit(`chunkString`),
        effects.exit(`codeFencedFenceInfo`),
        factorySpace(effects, metaBefore, `whitespace`)(code$3))
      : code$3 === 96 && code$3 === marker
      ? nok(code$3)
      : (effects.consume(code$3), info)
  }
  function metaBefore(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? infoBefore(code$3)
      : (effects.enter(`codeFencedFenceMeta`), effects.enter(`chunkString`, { contentType: `string` }), meta(code$3))
  }
  function meta(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`chunkString`), effects.exit(`codeFencedFenceMeta`), infoBefore(code$3))
      : code$3 === 96 && code$3 === marker
      ? nok(code$3)
      : (effects.consume(code$3), meta)
  }
  function atNonLazyBreak(code$3) {
    return effects.attempt(closeStart, after$2, contentBefore)(code$3)
  }
  function contentBefore(code$3) {
    return effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), contentStart
  }
  function contentStart(code$3) {
    return initialPrefix > 0 && markdownSpace(code$3)
      ? factorySpace(effects, beforeContentChunk, `linePrefix`, initialPrefix + 1)(code$3)
      : beforeContentChunk(code$3)
  }
  function beforeContentChunk(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? effects.check(nonLazyContinuation, atNonLazyBreak, after$2)(code$3)
      : (effects.enter(`codeFlowValue`), contentChunk(code$3))
  }
  function contentChunk(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`codeFlowValue`), beforeContentChunk(code$3))
      : (effects.consume(code$3), contentChunk)
  }
  function after$2(code$3) {
    return effects.exit(`codeFenced`), ok$2(code$3)
  }
  function tokenizeCloseStart(effects$1, ok$3, nok$1) {
    let size$14 = 0
    return startBefore
    function startBefore(code$3) {
      return effects$1.enter(`lineEnding`), effects$1.consume(code$3), effects$1.exit(`lineEnding`), start$3
    }
    function start$3(code$3) {
      return effects$1.enter(`codeFencedFence`),
        markdownSpace(code$3)
          ? factorySpace(
            effects$1,
            beforeSequenceClose,
            `linePrefix`,
            self$1.parser.constructs.disable.null.includes(`codeIndented`) ? void 0 : 4,
          )(code$3)
          : beforeSequenceClose(code$3)
    }
    function beforeSequenceClose(code$3) {
      return code$3 === marker ? (effects$1.enter(`codeFencedFenceSequence`), sequenceClose(code$3)) : nok$1(code$3)
    }
    function sequenceClose(code$3) {
      return code$3 === marker
        ? (size$14++, effects$1.consume(code$3), sequenceClose)
        : size$14 >= sizeOpen
        ? (effects$1.exit(`codeFencedFenceSequence`),
          markdownSpace(code$3)
            ? factorySpace(effects$1, sequenceCloseAfter, `whitespace`)(code$3)
            : sequenceCloseAfter(code$3))
        : nok$1(code$3)
    }
    function sequenceCloseAfter(code$3) {
      return code$3 === null || markdownLineEnding(code$3)
        ? (effects$1.exit(`codeFencedFence`), ok$3(code$3))
        : nok$1(code$3)
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok$2, nok) {
  let self$1 = this
  return start$2
  function start$2(code$3) {
    return code$3 === null
      ? nok(code$3)
      : (effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), lineStart)
  }
  function lineStart(code$3) {
    return self$1.parser.lazy[self$1.now().line] ? nok(code$3) : ok$2(code$3)
  }
}
const codeIndented = { name: `codeIndented`, tokenize: tokenizeCodeIndented },
  furtherStart = { partial: !0, tokenize: tokenizeFurtherStart }
function tokenizeCodeIndented(effects, ok$2, nok) {
  let self$1 = this
  return start$2
  function start$2(code$3) {
    return effects.enter(`codeIndented`), factorySpace(effects, afterPrefix, `linePrefix`, 5)(code$3)
  }
  function afterPrefix(code$3) {
    let tail = self$1.events[self$1.events.length - 1]
    return tail && tail[1].type === `linePrefix` && tail[2].sliceSerialize(tail[1], !0).length >= 4
      ? atBreak(code$3)
      : nok(code$3)
  }
  function atBreak(code$3) {
    return code$3 === null
      ? after$2(code$3)
      : markdownLineEnding(code$3)
      ? effects.attempt(furtherStart, atBreak, after$2)(code$3)
      : (effects.enter(`codeFlowValue`), inside(code$3))
  }
  function inside(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`codeFlowValue`), atBreak(code$3))
      : (effects.consume(code$3), inside)
  }
  function after$2(code$3) {
    return effects.exit(`codeIndented`), ok$2(code$3)
  }
}
function tokenizeFurtherStart(effects, ok$2, nok) {
  let self$1 = this
  return furtherStart$1
  function furtherStart$1(code$3) {
    return self$1.parser.lazy[self$1.now().line]
      ? nok(code$3)
      : markdownLineEnding(code$3)
      ? (effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), furtherStart$1)
      : factorySpace(effects, afterPrefix, `linePrefix`, 5)(code$3)
  }
  function afterPrefix(code$3) {
    let tail = self$1.events[self$1.events.length - 1]
    return tail && tail[1].type === `linePrefix` && tail[2].sliceSerialize(tail[1], !0).length >= 4
      ? ok$2(code$3)
      : markdownLineEnding(code$3)
      ? furtherStart$1(code$3)
      : nok(code$3)
  }
}
const codeText = { name: `codeText`, previous, resolve: resolveCodeText, tokenize: tokenizeCodeText }
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4, headEnterIndex = 3, index$4, enter
  if (
    (events[headEnterIndex][1].type === `lineEnding` || events[headEnterIndex][1].type === `space`)
    && (events[tailExitIndex][1].type === `lineEnding` || events[tailExitIndex][1].type === `space`)
  ) {
    for (index$4 = headEnterIndex; ++index$4 < tailExitIndex;) {
      if (events[index$4][1].type === `codeTextData`) {
        events[headEnterIndex][1].type = `codeTextPadding`,
          events[tailExitIndex][1].type = `codeTextPadding`,
          headEnterIndex += 2,
          tailExitIndex -= 2
        break
      }
    }
  }
  for (index$4 = headEnterIndex - 1, tailExitIndex++; ++index$4 <= tailExitIndex;) {
    enter === void 0
      ? index$4 !== tailExitIndex && events[index$4][1].type !== `lineEnding` && (enter = index$4)
      : (index$4 === tailExitIndex || events[index$4][1].type === `lineEnding`)
        && (events[enter][1].type = `codeTextData`,
          index$4 !== enter + 2
          && (events[enter][1].end = events[index$4 - 1][1].end,
            events.splice(enter + 2, index$4 - enter - 2),
            tailExitIndex -= index$4 - enter - 2,
            index$4 = enter + 2),
          enter = void 0)
  }
  return events
}
function previous(code$3) {
  return code$3 !== 96 || this.events[this.events.length - 1][1].type === `characterEscape`
}
function tokenizeCodeText(effects, ok$2, nok) {
  let self$1 = this, sizeOpen = 0, size$14, token
  return start$2
  function start$2(code$3) {
    return effects.enter(`codeText`), effects.enter(`codeTextSequence`), sequenceOpen(code$3)
  }
  function sequenceOpen(code$3) {
    return code$3 === 96
      ? (effects.consume(code$3), sizeOpen++, sequenceOpen)
      : (effects.exit(`codeTextSequence`), between(code$3))
  }
  function between(code$3) {
    return code$3 === null
      ? nok(code$3)
      : code$3 === 32
      ? (effects.enter(`space`), effects.consume(code$3), effects.exit(`space`), between)
      : code$3 === 96
      ? (token = effects.enter(`codeTextSequence`), size$14 = 0, sequenceClose(code$3))
      : markdownLineEnding(code$3)
      ? (effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), between)
      : (effects.enter(`codeTextData`), data(code$3))
  }
  function data(code$3) {
    return code$3 === null || code$3 === 32 || code$3 === 96 || markdownLineEnding(code$3)
      ? (effects.exit(`codeTextData`), between(code$3))
      : (effects.consume(code$3), data)
  }
  function sequenceClose(code$3) {
    return code$3 === 96
      ? (effects.consume(code$3), size$14++, sequenceClose)
      : size$14 === sizeOpen
      ? (effects.exit(`codeTextSequence`), effects.exit(`codeText`), ok$2(code$3))
      : (token.type = `codeTextData`, data(code$3))
  }
}
var SpliceBuffer = class {
  constructor(initial) {
    this.left = initial ? [...initial] : [], this.right = []
  }
  get(index$4) {
    if (index$4 < 0 || index$4 >= this.left.length + this.right.length) {
      throw RangeError(
        'Cannot access index `' + index$4 + '` in a splice buffer of size `' + (this.left.length + this.right.length)
          + '`',
      )
    }
    return index$4 < this.left.length
      ? this.left[index$4]
      : this.right[this.right.length - index$4 + this.left.length - 1]
  }
  get length() {
    return this.left.length + this.right.length
  }
  shift() {
    return this.setCursor(0), this.right.pop()
  }
  slice(start$2, end$2) {
    let stop = end$2 ?? 1 / 0
    return stop < this.left.length
      ? this.left.slice(start$2, stop)
      : start$2 > this.left.length
      ? this.right.slice(this.right.length - stop + this.left.length, this.right.length - start$2 + this.left.length)
        .reverse()
      : this.left.slice(start$2).concat(this.right.slice(this.right.length - stop + this.left.length).reverse())
  }
  splice(start$2, deleteCount, items) {
    let count$2 = deleteCount || 0
    this.setCursor(Math.trunc(start$2))
    let removed = this.right.splice(this.right.length - count$2, 1 / 0)
    return items && chunkedPush(this.left, items), removed.reverse()
  }
  pop() {
    return this.setCursor(1 / 0), this.left.pop()
  }
  push(item) {
    this.setCursor(1 / 0), this.left.push(item)
  }
  pushMany(items) {
    this.setCursor(1 / 0), chunkedPush(this.left, items)
  }
  unshift(item) {
    this.setCursor(0), this.right.push(item)
  }
  unshiftMany(items) {
    this.setCursor(0), chunkedPush(this.right, items.reverse())
  }
  setCursor(n$19) {
    if (
      !(n$19 === this.left.length || n$19 > this.left.length && this.right.length === 0
        || n$19 < 0 && this.left.length === 0)
    ) {
      if (n$19 < this.left.length) {
        let removed = this.left.splice(n$19, 1 / 0)
        chunkedPush(this.right, removed.reverse())
      } else {
        let removed = this.right.splice(this.left.length + this.right.length - n$19, 1 / 0)
        chunkedPush(this.left, removed.reverse())
      }
    }
  }
}
function chunkedPush(list$3, right$2) {
  let chunkStart = 0
  if (right$2.length < 1e4) list$3.push(...right$2)
  else {for (; chunkStart < right$2.length;) {
      list$3.push(...right$2.slice(chunkStart, chunkStart + 1e4)), chunkStart += 1e4
    }}
}
function subtokenize(eventsArray) {
  let jumps = {},
    index$4 = -1,
    event,
    lineIndex,
    otherIndex,
    otherEvent,
    parameters,
    subevents,
    more,
    events = new SpliceBuffer(eventsArray)
  for (; ++index$4 < events.length;) {
    for (; index$4 in jumps;) index$4 = jumps[index$4]
    if (
      event = events.get(index$4),
        index$4 && event[1].type === `chunkFlow` && events.get(index$4 - 1)[1].type === `listItemPrefix`
        && (subevents = event[1]._tokenizer.events,
          otherIndex = 0,
          otherIndex < subevents.length && subevents[otherIndex][1].type === `lineEndingBlank` && (otherIndex += 2),
          otherIndex < subevents.length && subevents[otherIndex][1].type === `content`)
    ) {
      for (; ++otherIndex < subevents.length && subevents[otherIndex][1].type !== `content`;) {
        subevents[otherIndex][1].type === `chunkText`
          && (subevents[otherIndex][1]._isInFirstContentOfListItem = !0, otherIndex++)
      }
    }
    if (event[0] === `enter`) {
      event[1].contentType && (Object.assign(jumps, subcontent(events, index$4)), index$4 = jumps[index$4], more = !0)
    } else if (event[1]._container) {
      for (otherIndex = index$4, lineIndex = void 0; otherIndex--;) {
        if (
          otherEvent = events.get(otherIndex),
            otherEvent[1].type === `lineEnding` || otherEvent[1].type === `lineEndingBlank`
        ) {
          otherEvent[0] === `enter`
            && (lineIndex && (events.get(lineIndex)[1].type = `lineEndingBlank`),
              otherEvent[1].type = `lineEnding`,
              lineIndex = otherIndex)
        } else if (!(otherEvent[1].type === `linePrefix` || otherEvent[1].type === `listItemIndent`)) break
      }
      lineIndex
        && (event[1].end = { ...events.get(lineIndex)[1].start },
          parameters = events.slice(lineIndex, index$4),
          parameters.unshift(event),
          events.splice(lineIndex, index$4 - lineIndex + 1, parameters))
    }
  }
  return splice(eventsArray, 0, 1 / 0, events.slice(0)), !more
}
function subcontent(events, eventIndex) {
  let token = events.get(eventIndex)[1],
    context$2 = events.get(eventIndex)[2],
    startPosition = eventIndex - 1,
    startPositions = [],
    tokenizer = token._tokenizer
  tokenizer
    || (tokenizer = context$2.parser[token.contentType](token.start),
      token._contentTypeTextTrailing && (tokenizer._contentTypeTextTrailing = !0))
  let childEvents = tokenizer.events,
    jumps = [],
    gaps = {},
    stream,
    previous$2,
    index$4 = -1,
    current = token,
    adjust = 0,
    start$2 = 0,
    breaks = [start$2]
  for (; current;) {
    for (; events.get(++startPosition)[1] !== current;);
    startPositions.push(startPosition),
      current._tokenizer
      || (stream = context$2.sliceStream(current),
        current.next || stream.push(null),
        previous$2 && tokenizer.defineSkip(current.start),
        current._isInFirstContentOfListItem && (tokenizer._gfmTasklistFirstContentOfListItem = !0),
        tokenizer.write(stream),
        current._isInFirstContentOfListItem && (tokenizer._gfmTasklistFirstContentOfListItem = void 0)),
      previous$2 = current,
      current = current.next
  }
  for (current = token; ++index$4 < childEvents.length;) {
    childEvents[index$4][0] === `exit` && childEvents[index$4 - 1][0] === `enter`
      && childEvents[index$4][1].type === childEvents[index$4 - 1][1].type
      && childEvents[index$4][1].start.line !== childEvents[index$4][1].end.line
      && (start$2 = index$4 + 1,
        breaks.push(start$2),
        current._tokenizer = void 0,
        current.previous = void 0,
        current = current.next)
  }
  for (
    tokenizer.events = [],
      current ? (current._tokenizer = void 0, current.previous = void 0) : breaks.pop(),
      index$4 = breaks.length;
    index$4--;
  ) {
    let slice = childEvents.slice(breaks[index$4], breaks[index$4 + 1]), start$3 = startPositions.pop()
    jumps.push([start$3, start$3 + slice.length - 1]), events.splice(start$3, 2, slice)
  }
  for (jumps.reverse(), index$4 = -1; ++index$4 < jumps.length;) {
    gaps[adjust + jumps[index$4][0]] = adjust + jumps[index$4][1], adjust += jumps[index$4][1] - jumps[index$4][0] - 1
  }
  return gaps
}
const content$1 = { resolve: resolveContent, tokenize: tokenizeContent },
  continuationConstruct = { partial: !0, tokenize: tokenizeContinuation }
function resolveContent(events) {
  return subtokenize(events), events
}
function tokenizeContent(effects, ok$2) {
  let previous$2
  return chunkStart
  function chunkStart(code$3) {
    return effects.enter(`content`),
      previous$2 = effects.enter(`chunkContent`, { contentType: `content` }),
      chunkInside(code$3)
  }
  function chunkInside(code$3) {
    return code$3 === null
      ? contentEnd(code$3)
      : markdownLineEnding(code$3)
      ? effects.check(continuationConstruct, contentContinue, contentEnd)(code$3)
      : (effects.consume(code$3), chunkInside)
  }
  function contentEnd(code$3) {
    return effects.exit(`chunkContent`), effects.exit(`content`), ok$2(code$3)
  }
  function contentContinue(code$3) {
    return effects.consume(code$3),
      effects.exit(`chunkContent`),
      previous$2.next = effects.enter(`chunkContent`, { contentType: `content`, previous: previous$2 }),
      previous$2 = previous$2.next,
      chunkInside
  }
}
function tokenizeContinuation(effects, ok$2, nok) {
  let self$1 = this
  return startLookahead
  function startLookahead(code$3) {
    return effects.exit(`chunkContent`),
      effects.enter(`lineEnding`),
      effects.consume(code$3),
      effects.exit(`lineEnding`),
      factorySpace(effects, prefixed$1, `linePrefix`)
  }
  function prefixed$1(code$3) {
    if (code$3 === null || markdownLineEnding(code$3)) return nok(code$3)
    let tail = self$1.events[self$1.events.length - 1]
    return !self$1.parser.constructs.disable.null.includes(`codeIndented`) && tail && tail[1].type === `linePrefix`
        && tail[2].sliceSerialize(tail[1], !0).length >= 4
      ? ok$2(code$3)
      : effects.interrupt(self$1.parser.constructs.flow, nok, ok$2)(code$3)
  }
}
function factoryDestination(effects, ok$2, nok, type$2, literalType, literalMarkerType, rawType, stringType, max$12) {
  let limit = max$12 || 1 / 0, balance = 0
  return start$2
  function start$2(code$3) {
    return code$3 === 60
      ? (effects.enter(type$2),
        effects.enter(literalType),
        effects.enter(literalMarkerType),
        effects.consume(code$3),
        effects.exit(literalMarkerType),
        enclosedBefore)
      : code$3 === null || code$3 === 32 || code$3 === 41 || asciiControl(code$3)
      ? nok(code$3)
      : (effects.enter(type$2),
        effects.enter(rawType),
        effects.enter(stringType),
        effects.enter(`chunkString`, { contentType: `string` }),
        raw$1(code$3))
  }
  function enclosedBefore(code$3) {
    return code$3 === 62
      ? (effects.enter(literalMarkerType),
        effects.consume(code$3),
        effects.exit(literalMarkerType),
        effects.exit(literalType),
        effects.exit(type$2),
        ok$2)
      : (effects.enter(stringType), effects.enter(`chunkString`, { contentType: `string` }), enclosed(code$3))
  }
  function enclosed(code$3) {
    return code$3 === 62
      ? (effects.exit(`chunkString`), effects.exit(stringType), enclosedBefore(code$3))
      : code$3 === null || code$3 === 60 || markdownLineEnding(code$3)
      ? nok(code$3)
      : (effects.consume(code$3), code$3 === 92 ? enclosedEscape : enclosed)
  }
  function enclosedEscape(code$3) {
    return code$3 === 60 || code$3 === 62 || code$3 === 92 ? (effects.consume(code$3), enclosed) : enclosed(code$3)
  }
  function raw$1(code$3) {
    return !balance && (code$3 === null || code$3 === 41 || markdownLineEndingOrSpace(code$3))
      ? (effects.exit(`chunkString`),
        effects.exit(stringType),
        effects.exit(rawType),
        effects.exit(type$2),
        ok$2(code$3))
      : balance < limit && code$3 === 40
      ? (effects.consume(code$3), balance++, raw$1)
      : code$3 === 41
      ? (effects.consume(code$3), balance--, raw$1)
      : code$3 === null || code$3 === 32 || code$3 === 40 || asciiControl(code$3)
      ? nok(code$3)
      : (effects.consume(code$3), code$3 === 92 ? rawEscape : raw$1)
  }
  function rawEscape(code$3) {
    return code$3 === 40 || code$3 === 41 || code$3 === 92 ? (effects.consume(code$3), raw$1) : raw$1(code$3)
  }
}
function factoryLabel(effects, ok$2, nok, type$2, markerType, stringType) {
  let self$1 = this, size$14 = 0, seen$1
  return start$2
  function start$2(code$3) {
    return effects.enter(type$2),
      effects.enter(markerType),
      effects.consume(code$3),
      effects.exit(markerType),
      effects.enter(stringType),
      atBreak
  }
  function atBreak(code$3) {
    return size$14 > 999 || code$3 === null || code$3 === 91 || code$3 === 93 && !seen$1
        || code$3 === 94 && !size$14 && `_hiddenFootnoteSupport` in self$1.parser.constructs
      ? nok(code$3)
      : code$3 === 93
      ? (effects.exit(stringType),
        effects.enter(markerType),
        effects.consume(code$3),
        effects.exit(markerType),
        effects.exit(type$2),
        ok$2)
      : markdownLineEnding(code$3)
      ? (effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), atBreak)
      : (effects.enter(`chunkString`, { contentType: `string` }), labelInside(code$3))
  }
  function labelInside(code$3) {
    return code$3 === null || code$3 === 91 || code$3 === 93 || markdownLineEnding(code$3) || size$14++ > 999
      ? (effects.exit(`chunkString`), atBreak(code$3))
      : (effects.consume(code$3), seen$1 ||= !markdownSpace(code$3), code$3 === 92 ? labelEscape : labelInside)
  }
  function labelEscape(code$3) {
    return code$3 === 91 || code$3 === 92 || code$3 === 93
      ? (effects.consume(code$3), size$14++, labelInside)
      : labelInside(code$3)
  }
}
function factoryTitle(effects, ok$2, nok, type$2, markerType, stringType) {
  let marker
  return start$2
  function start$2(code$3) {
    return code$3 === 34 || code$3 === 39 || code$3 === 40
      ? (effects.enter(type$2),
        effects.enter(markerType),
        effects.consume(code$3),
        effects.exit(markerType),
        marker = code$3 === 40 ? 41 : code$3,
        begin)
      : nok(code$3)
  }
  function begin(code$3) {
    return code$3 === marker
      ? (effects.enter(markerType), effects.consume(code$3), effects.exit(markerType), effects.exit(type$2), ok$2)
      : (effects.enter(stringType), atBreak(code$3))
  }
  function atBreak(code$3) {
    return code$3 === marker
      ? (effects.exit(stringType), begin(marker))
      : code$3 === null
      ? nok(code$3)
      : markdownLineEnding(code$3)
      ? (effects.enter(`lineEnding`),
        effects.consume(code$3),
        effects.exit(`lineEnding`),
        factorySpace(effects, atBreak, `linePrefix`))
      : (effects.enter(`chunkString`, { contentType: `string` }), inside(code$3))
  }
  function inside(code$3) {
    return code$3 === marker || code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`chunkString`), atBreak(code$3))
      : (effects.consume(code$3), code$3 === 92 ? escape$2 : inside)
  }
  function escape$2(code$3) {
    return code$3 === marker || code$3 === 92 ? (effects.consume(code$3), inside) : inside(code$3)
  }
}
function factoryWhitespace(effects, ok$2) {
  let seen$1
  return start$2
  function start$2(code$3) {
    return markdownLineEnding(code$3)
      ? (effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), seen$1 = !0, start$2)
      : markdownSpace(code$3)
      ? factorySpace(effects, start$2, seen$1 ? `linePrefix` : `lineSuffix`)(code$3)
      : ok$2(code$3)
  }
}
const definition = { name: `definition`, tokenize: tokenizeDefinition },
  titleBefore = { partial: !0, tokenize: tokenizeTitleBefore }
function tokenizeDefinition(effects, ok$2, nok) {
  let self$1 = this, identifier$1
  return start$2
  function start$2(code$3) {
    return effects.enter(`definition`), before$2(code$3)
  }
  function before$2(code$3) {
    return factoryLabel.call(
      self$1,
      effects,
      labelAfter,
      nok,
      `definitionLabel`,
      `definitionLabelMarker`,
      `definitionLabelString`,
    )(code$3)
  }
  function labelAfter(code$3) {
    return identifier$1 = normalizeIdentifier(
      self$1.sliceSerialize(self$1.events[self$1.events.length - 1][1]).slice(1, -1),
    ),
      code$3 === 58
        ? (effects.enter(`definitionMarker`), effects.consume(code$3), effects.exit(`definitionMarker`), markerAfter)
        : nok(code$3)
  }
  function markerAfter(code$3) {
    return markdownLineEndingOrSpace(code$3)
      ? factoryWhitespace(effects, destinationBefore)(code$3)
      : destinationBefore(code$3)
  }
  function destinationBefore(code$3) {
    return factoryDestination(
      effects,
      destinationAfter,
      nok,
      `definitionDestination`,
      `definitionDestinationLiteral`,
      `definitionDestinationLiteralMarker`,
      `definitionDestinationRaw`,
      `definitionDestinationString`,
    )(code$3)
  }
  function destinationAfter(code$3) {
    return effects.attempt(titleBefore, after$2, after$2)(code$3)
  }
  function after$2(code$3) {
    return markdownSpace(code$3)
      ? factorySpace(effects, afterWhitespace, `whitespace`)(code$3)
      : afterWhitespace(code$3)
  }
  function afterWhitespace(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`definition`), self$1.parser.defined.push(identifier$1), ok$2(code$3))
      : nok(code$3)
  }
}
function tokenizeTitleBefore(effects, ok$2, nok) {
  return titleBefore$1
  function titleBefore$1(code$3) {
    return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, beforeMarker)(code$3) : nok(code$3)
  }
  function beforeMarker(code$3) {
    return factoryTitle(effects, titleAfter, nok, `definitionTitle`, `definitionTitleMarker`, `definitionTitleString`)(
      code$3,
    )
  }
  function titleAfter(code$3) {
    return markdownSpace(code$3)
      ? factorySpace(effects, titleAfterOptionalWhitespace, `whitespace`)(code$3)
      : titleAfterOptionalWhitespace(code$3)
  }
  function titleAfterOptionalWhitespace(code$3) {
    return code$3 === null || markdownLineEnding(code$3) ? ok$2(code$3) : nok(code$3)
  }
}
const hardBreakEscape = { name: `hardBreakEscape`, tokenize: tokenizeHardBreakEscape }
function tokenizeHardBreakEscape(effects, ok$2, nok) {
  return start$2
  function start$2(code$3) {
    return effects.enter(`hardBreakEscape`), effects.consume(code$3), after$2
  }
  function after$2(code$3) {
    return markdownLineEnding(code$3) ? (effects.exit(`hardBreakEscape`), ok$2(code$3)) : nok(code$3)
  }
}
const headingAtx = { name: `headingAtx`, resolve: resolveHeadingAtx, tokenize: tokenizeHeadingAtx }
function resolveHeadingAtx(events, context$2) {
  let contentEnd = events.length - 2, contentStart = 3, content$2, text$6
  return events[contentStart][1].type === `whitespace` && (contentStart += 2),
    contentEnd - 2 > contentStart && events[contentEnd][1].type === `whitespace` && (contentEnd -= 2),
    events[contentEnd][1].type === `atxHeadingSequence`
    && (contentStart === contentEnd - 1
      || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === `whitespace`)
    && (contentEnd -= contentStart + 1 === contentEnd ? 2 : 4),
    contentEnd > contentStart
    && (content$2 = { type: `atxHeadingText`, start: events[contentStart][1].start, end: events[contentEnd][1].end },
      text$6 = {
        type: `chunkText`,
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: `text`,
      },
      splice(events, contentStart, contentEnd - contentStart + 1, [
        [`enter`, content$2, context$2],
        [`enter`, text$6, context$2],
        [`exit`, text$6, context$2],
        [`exit`, content$2, context$2],
      ])),
    events
}
function tokenizeHeadingAtx(effects, ok$2, nok) {
  let size$14 = 0
  return start$2
  function start$2(code$3) {
    return effects.enter(`atxHeading`), before$2(code$3)
  }
  function before$2(code$3) {
    return effects.enter(`atxHeadingSequence`), sequenceOpen(code$3)
  }
  function sequenceOpen(code$3) {
    return code$3 === 35 && size$14++ < 6
      ? (effects.consume(code$3), sequenceOpen)
      : code$3 === null || markdownLineEndingOrSpace(code$3)
      ? (effects.exit(`atxHeadingSequence`), atBreak(code$3))
      : nok(code$3)
  }
  function atBreak(code$3) {
    return code$3 === 35
      ? (effects.enter(`atxHeadingSequence`), sequenceFurther(code$3))
      : code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`atxHeading`), ok$2(code$3))
      : markdownSpace(code$3)
      ? factorySpace(effects, atBreak, `whitespace`)(code$3)
      : (effects.enter(`atxHeadingText`), data(code$3))
  }
  function sequenceFurther(code$3) {
    return code$3 === 35
      ? (effects.consume(code$3), sequenceFurther)
      : (effects.exit(`atxHeadingSequence`), atBreak(code$3))
  }
  function data(code$3) {
    return code$3 === null || code$3 === 35 || markdownLineEndingOrSpace(code$3)
      ? (effects.exit(`atxHeadingText`), atBreak(code$3))
      : (effects.consume(code$3), data)
  }
}
const htmlBlockNames =
    `address.article.aside.base.basefont.blockquote.body.caption.center.col.colgroup.dd.details.dialog.dir.div.dl.dt.fieldset.figcaption.figure.footer.form.frame.frameset.h1.h2.h3.h4.h5.h6.head.header.hr.html.iframe.legend.li.link.main.menu.menuitem.nav.noframes.ol.optgroup.option.p.param.search.section.summary.table.tbody.td.tfoot.th.thead.title.tr.track.ul`
      .split(`.`),
  htmlRawNames = [`pre`, `script`, `style`, `textarea`],
  htmlFlow = { concrete: !0, name: `htmlFlow`, resolveTo: resolveToHtmlFlow, tokenize: tokenizeHtmlFlow },
  blankLineBefore = { partial: !0, tokenize: tokenizeBlankLineBefore },
  nonLazyContinuationStart = { partial: !0, tokenize: tokenizeNonLazyContinuationStart }
function resolveToHtmlFlow(events) {
  let index$4 = events.length
  for (; index$4-- && !(events[index$4][0] === `enter` && events[index$4][1].type === `htmlFlow`););
  return index$4 > 1 && events[index$4 - 2][1].type === `linePrefix`
    && (events[index$4][1].start = events[index$4 - 2][1].start,
      events[index$4 + 1][1].start = events[index$4 - 2][1].start,
      events.splice(index$4 - 2, 2)),
    events
}
function tokenizeHtmlFlow(effects, ok$2, nok) {
  let self$1 = this, marker, closingTag, buffer, index$4, markerB
  return start$2
  function start$2(code$3) {
    return before$2(code$3)
  }
  function before$2(code$3) {
    return effects.enter(`htmlFlow`), effects.enter(`htmlFlowData`), effects.consume(code$3), open
  }
  function open(code$3) {
    return code$3 === 33
      ? (effects.consume(code$3), declarationOpen)
      : code$3 === 47
      ? (effects.consume(code$3), closingTag = !0, tagCloseStart)
      : code$3 === 63
      ? (effects.consume(code$3), marker = 3, self$1.interrupt ? ok$2 : continuationDeclarationInside)
      : asciiAlpha(code$3)
      ? (effects.consume(code$3), buffer = String.fromCharCode(code$3), tagName)
      : nok(code$3)
  }
  function declarationOpen(code$3) {
    return code$3 === 45
      ? (effects.consume(code$3), marker = 2, commentOpenInside)
      : code$3 === 91
      ? (effects.consume(code$3), marker = 5, index$4 = 0, cdataOpenInside)
      : asciiAlpha(code$3)
      ? (effects.consume(code$3), marker = 4, self$1.interrupt ? ok$2 : continuationDeclarationInside)
      : nok(code$3)
  }
  function commentOpenInside(code$3) {
    return code$3 === 45
      ? (effects.consume(code$3), self$1.interrupt ? ok$2 : continuationDeclarationInside)
      : nok(code$3)
  }
  function cdataOpenInside(code$3) {
    let value$2 = `CDATA[`
    return code$3 === value$2.charCodeAt(index$4++)
      ? (effects.consume(code$3), index$4 === 6 ? self$1.interrupt ? ok$2 : continuation : cdataOpenInside)
      : nok(code$3)
  }
  function tagCloseStart(code$3) {
    return asciiAlpha(code$3) ? (effects.consume(code$3), buffer = String.fromCharCode(code$3), tagName) : nok(code$3)
  }
  function tagName(code$3) {
    if (code$3 === null || code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3)) {
      let slash = code$3 === 47, name = buffer.toLowerCase()
      return !slash && !closingTag && htmlRawNames.includes(name)
        ? (marker = 1, self$1.interrupt ? ok$2(code$3) : continuation(code$3))
        : htmlBlockNames.includes(buffer.toLowerCase())
        ? (marker = 6,
          slash ? (effects.consume(code$3), basicSelfClosing) : self$1.interrupt ? ok$2(code$3) : continuation(code$3))
        : (marker = 7,
          self$1.interrupt && !self$1.parser.lazy[self$1.now().line]
            ? nok(code$3)
            : closingTag
            ? completeClosingTagAfter(code$3)
            : completeAttributeNameBefore(code$3))
    }
    return code$3 === 45 || asciiAlphanumeric(code$3)
      ? (effects.consume(code$3), buffer += String.fromCharCode(code$3), tagName)
      : nok(code$3)
  }
  function basicSelfClosing(code$3) {
    return code$3 === 62 ? (effects.consume(code$3), self$1.interrupt ? ok$2 : continuation) : nok(code$3)
  }
  function completeClosingTagAfter(code$3) {
    return markdownSpace(code$3) ? (effects.consume(code$3), completeClosingTagAfter) : completeEnd(code$3)
  }
  function completeAttributeNameBefore(code$3) {
    return code$3 === 47
      ? (effects.consume(code$3), completeEnd)
      : code$3 === 58 || code$3 === 95 || asciiAlpha(code$3)
      ? (effects.consume(code$3), completeAttributeName)
      : markdownSpace(code$3)
      ? (effects.consume(code$3), completeAttributeNameBefore)
      : completeEnd(code$3)
  }
  function completeAttributeName(code$3) {
    return code$3 === 45 || code$3 === 46 || code$3 === 58 || code$3 === 95 || asciiAlphanumeric(code$3)
      ? (effects.consume(code$3), completeAttributeName)
      : completeAttributeNameAfter(code$3)
  }
  function completeAttributeNameAfter(code$3) {
    return code$3 === 61
      ? (effects.consume(code$3), completeAttributeValueBefore)
      : markdownSpace(code$3)
      ? (effects.consume(code$3), completeAttributeNameAfter)
      : completeAttributeNameBefore(code$3)
  }
  function completeAttributeValueBefore(code$3) {
    return code$3 === null || code$3 === 60 || code$3 === 61 || code$3 === 62 || code$3 === 96
      ? nok(code$3)
      : code$3 === 34 || code$3 === 39
      ? (effects.consume(code$3), markerB = code$3, completeAttributeValueQuoted)
      : markdownSpace(code$3)
      ? (effects.consume(code$3), completeAttributeValueBefore)
      : completeAttributeValueUnquoted(code$3)
  }
  function completeAttributeValueQuoted(code$3) {
    return code$3 === markerB
      ? (effects.consume(code$3), markerB = null, completeAttributeValueQuotedAfter)
      : code$3 === null || markdownLineEnding(code$3)
      ? nok(code$3)
      : (effects.consume(code$3), completeAttributeValueQuoted)
  }
  function completeAttributeValueUnquoted(code$3) {
    return code$3 === null || code$3 === 34 || code$3 === 39 || code$3 === 47 || code$3 === 60 || code$3 === 61
        || code$3 === 62 || code$3 === 96 || markdownLineEndingOrSpace(code$3)
      ? completeAttributeNameAfter(code$3)
      : (effects.consume(code$3), completeAttributeValueUnquoted)
  }
  function completeAttributeValueQuotedAfter(code$3) {
    return code$3 === 47 || code$3 === 62 || markdownSpace(code$3) ? completeAttributeNameBefore(code$3) : nok(code$3)
  }
  function completeEnd(code$3) {
    return code$3 === 62 ? (effects.consume(code$3), completeAfter) : nok(code$3)
  }
  function completeAfter(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? continuation(code$3)
      : markdownSpace(code$3)
      ? (effects.consume(code$3), completeAfter)
      : nok(code$3)
  }
  function continuation(code$3) {
    return code$3 === 45 && marker === 2
      ? (effects.consume(code$3), continuationCommentInside)
      : code$3 === 60 && marker === 1
      ? (effects.consume(code$3), continuationRawTagOpen)
      : code$3 === 62 && marker === 4
      ? (effects.consume(code$3), continuationClose)
      : code$3 === 63 && marker === 3
      ? (effects.consume(code$3), continuationDeclarationInside)
      : code$3 === 93 && marker === 5
      ? (effects.consume(code$3), continuationCdataInside)
      : markdownLineEnding(code$3) && (marker === 6 || marker === 7)
      ? (effects.exit(`htmlFlowData`), effects.check(blankLineBefore, continuationAfter, continuationStart)(code$3))
      : code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`htmlFlowData`), continuationStart(code$3))
      : (effects.consume(code$3), continuation)
  }
  function continuationStart(code$3) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code$3)
  }
  function continuationStartNonLazy(code$3) {
    return effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), continuationBefore
  }
  function continuationBefore(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? continuationStart(code$3)
      : (effects.enter(`htmlFlowData`), continuation(code$3))
  }
  function continuationCommentInside(code$3) {
    return code$3 === 45 ? (effects.consume(code$3), continuationDeclarationInside) : continuation(code$3)
  }
  function continuationRawTagOpen(code$3) {
    return code$3 === 47 ? (effects.consume(code$3), buffer = ``, continuationRawEndTag) : continuation(code$3)
  }
  function continuationRawEndTag(code$3) {
    if (code$3 === 62) {
      let name = buffer.toLowerCase()
      return htmlRawNames.includes(name) ? (effects.consume(code$3), continuationClose) : continuation(code$3)
    }
    return asciiAlpha(code$3) && buffer.length < 8
      ? (effects.consume(code$3), buffer += String.fromCharCode(code$3), continuationRawEndTag)
      : continuation(code$3)
  }
  function continuationCdataInside(code$3) {
    return code$3 === 93 ? (effects.consume(code$3), continuationDeclarationInside) : continuation(code$3)
  }
  function continuationDeclarationInside(code$3) {
    return code$3 === 62
      ? (effects.consume(code$3), continuationClose)
      : code$3 === 45 && marker === 2
      ? (effects.consume(code$3), continuationDeclarationInside)
      : continuation(code$3)
  }
  function continuationClose(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`htmlFlowData`), continuationAfter(code$3))
      : (effects.consume(code$3), continuationClose)
  }
  function continuationAfter(code$3) {
    return effects.exit(`htmlFlow`), ok$2(code$3)
  }
}
function tokenizeNonLazyContinuationStart(effects, ok$2, nok) {
  let self$1 = this
  return start$2
  function start$2(code$3) {
    return markdownLineEnding(code$3)
      ? (effects.enter(`lineEnding`), effects.consume(code$3), effects.exit(`lineEnding`), after$2)
      : nok(code$3)
  }
  function after$2(code$3) {
    return self$1.parser.lazy[self$1.now().line] ? nok(code$3) : ok$2(code$3)
  }
}
function tokenizeBlankLineBefore(effects, ok$2, nok) {
  return start$2
  function start$2(code$3) {
    return effects.enter(`lineEnding`),
      effects.consume(code$3),
      effects.exit(`lineEnding`),
      effects.attempt(blankLine, ok$2, nok)
  }
}
const htmlText = { name: `htmlText`, tokenize: tokenizeHtmlText }
function tokenizeHtmlText(effects, ok$2, nok) {
  let self$1 = this, marker, index$4, returnState
  return start$2
  function start$2(code$3) {
    return effects.enter(`htmlText`), effects.enter(`htmlTextData`), effects.consume(code$3), open
  }
  function open(code$3) {
    return code$3 === 33
      ? (effects.consume(code$3), declarationOpen)
      : code$3 === 47
      ? (effects.consume(code$3), tagCloseStart)
      : code$3 === 63
      ? (effects.consume(code$3), instruction)
      : asciiAlpha(code$3)
      ? (effects.consume(code$3), tagOpen)
      : nok(code$3)
  }
  function declarationOpen(code$3) {
    return code$3 === 45
      ? (effects.consume(code$3), commentOpenInside)
      : code$3 === 91
      ? (effects.consume(code$3), index$4 = 0, cdataOpenInside)
      : asciiAlpha(code$3)
      ? (effects.consume(code$3), declaration)
      : nok(code$3)
  }
  function commentOpenInside(code$3) {
    return code$3 === 45 ? (effects.consume(code$3), commentEnd) : nok(code$3)
  }
  function comment$1(code$3) {
    return code$3 === null
      ? nok(code$3)
      : code$3 === 45
      ? (effects.consume(code$3), commentClose)
      : markdownLineEnding(code$3)
      ? (returnState = comment$1, lineEndingBefore(code$3))
      : (effects.consume(code$3), comment$1)
  }
  function commentClose(code$3) {
    return code$3 === 45 ? (effects.consume(code$3), commentEnd) : comment$1(code$3)
  }
  function commentEnd(code$3) {
    return code$3 === 62 ? end$2(code$3) : code$3 === 45 ? commentClose(code$3) : comment$1(code$3)
  }
  function cdataOpenInside(code$3) {
    let value$2 = `CDATA[`
    return code$3 === value$2.charCodeAt(index$4++)
      ? (effects.consume(code$3), index$4 === 6 ? cdata : cdataOpenInside)
      : nok(code$3)
  }
  function cdata(code$3) {
    return code$3 === null
      ? nok(code$3)
      : code$3 === 93
      ? (effects.consume(code$3), cdataClose)
      : markdownLineEnding(code$3)
      ? (returnState = cdata, lineEndingBefore(code$3))
      : (effects.consume(code$3), cdata)
  }
  function cdataClose(code$3) {
    return code$3 === 93 ? (effects.consume(code$3), cdataEnd) : cdata(code$3)
  }
  function cdataEnd(code$3) {
    return code$3 === 62 ? end$2(code$3) : code$3 === 93 ? (effects.consume(code$3), cdataEnd) : cdata(code$3)
  }
  function declaration(code$3) {
    return code$3 === null || code$3 === 62
      ? end$2(code$3)
      : markdownLineEnding(code$3)
      ? (returnState = declaration, lineEndingBefore(code$3))
      : (effects.consume(code$3), declaration)
  }
  function instruction(code$3) {
    return code$3 === null
      ? nok(code$3)
      : code$3 === 63
      ? (effects.consume(code$3), instructionClose)
      : markdownLineEnding(code$3)
      ? (returnState = instruction, lineEndingBefore(code$3))
      : (effects.consume(code$3), instruction)
  }
  function instructionClose(code$3) {
    return code$3 === 62 ? end$2(code$3) : instruction(code$3)
  }
  function tagCloseStart(code$3) {
    return asciiAlpha(code$3) ? (effects.consume(code$3), tagClose) : nok(code$3)
  }
  function tagClose(code$3) {
    return code$3 === 45 || asciiAlphanumeric(code$3) ? (effects.consume(code$3), tagClose) : tagCloseBetween(code$3)
  }
  function tagCloseBetween(code$3) {
    return markdownLineEnding(code$3)
      ? (returnState = tagCloseBetween, lineEndingBefore(code$3))
      : markdownSpace(code$3)
      ? (effects.consume(code$3), tagCloseBetween)
      : end$2(code$3)
  }
  function tagOpen(code$3) {
    return code$3 === 45 || asciiAlphanumeric(code$3)
      ? (effects.consume(code$3), tagOpen)
      : code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3)
      ? tagOpenBetween(code$3)
      : nok(code$3)
  }
  function tagOpenBetween(code$3) {
    return code$3 === 47
      ? (effects.consume(code$3), end$2)
      : code$3 === 58 || code$3 === 95 || asciiAlpha(code$3)
      ? (effects.consume(code$3), tagOpenAttributeName)
      : markdownLineEnding(code$3)
      ? (returnState = tagOpenBetween, lineEndingBefore(code$3))
      : markdownSpace(code$3)
      ? (effects.consume(code$3), tagOpenBetween)
      : end$2(code$3)
  }
  function tagOpenAttributeName(code$3) {
    return code$3 === 45 || code$3 === 46 || code$3 === 58 || code$3 === 95 || asciiAlphanumeric(code$3)
      ? (effects.consume(code$3), tagOpenAttributeName)
      : tagOpenAttributeNameAfter(code$3)
  }
  function tagOpenAttributeNameAfter(code$3) {
    return code$3 === 61
      ? (effects.consume(code$3), tagOpenAttributeValueBefore)
      : markdownLineEnding(code$3)
      ? (returnState = tagOpenAttributeNameAfter, lineEndingBefore(code$3))
      : markdownSpace(code$3)
      ? (effects.consume(code$3), tagOpenAttributeNameAfter)
      : tagOpenBetween(code$3)
  }
  function tagOpenAttributeValueBefore(code$3) {
    return code$3 === null || code$3 === 60 || code$3 === 61 || code$3 === 62 || code$3 === 96
      ? nok(code$3)
      : code$3 === 34 || code$3 === 39
      ? (effects.consume(code$3), marker = code$3, tagOpenAttributeValueQuoted)
      : markdownLineEnding(code$3)
      ? (returnState = tagOpenAttributeValueBefore, lineEndingBefore(code$3))
      : markdownSpace(code$3)
      ? (effects.consume(code$3), tagOpenAttributeValueBefore)
      : (effects.consume(code$3), tagOpenAttributeValueUnquoted)
  }
  function tagOpenAttributeValueQuoted(code$3) {
    return code$3 === marker
      ? (effects.consume(code$3), marker = void 0, tagOpenAttributeValueQuotedAfter)
      : code$3 === null
      ? nok(code$3)
      : markdownLineEnding(code$3)
      ? (returnState = tagOpenAttributeValueQuoted, lineEndingBefore(code$3))
      : (effects.consume(code$3), tagOpenAttributeValueQuoted)
  }
  function tagOpenAttributeValueUnquoted(code$3) {
    return code$3 === null || code$3 === 34 || code$3 === 39 || code$3 === 60 || code$3 === 61 || code$3 === 96
      ? nok(code$3)
      : code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3)
      ? tagOpenBetween(code$3)
      : (effects.consume(code$3), tagOpenAttributeValueUnquoted)
  }
  function tagOpenAttributeValueQuotedAfter(code$3) {
    return code$3 === 47 || code$3 === 62 || markdownLineEndingOrSpace(code$3) ? tagOpenBetween(code$3) : nok(code$3)
  }
  function end$2(code$3) {
    return code$3 === 62
      ? (effects.consume(code$3), effects.exit(`htmlTextData`), effects.exit(`htmlText`), ok$2)
      : nok(code$3)
  }
  function lineEndingBefore(code$3) {
    return effects.exit(`htmlTextData`),
      effects.enter(`lineEnding`),
      effects.consume(code$3),
      effects.exit(`lineEnding`),
      lineEndingAfter
  }
  function lineEndingAfter(code$3) {
    return markdownSpace(code$3)
      ? factorySpace(
        effects,
        lineEndingAfterPrefix,
        `linePrefix`,
        self$1.parser.constructs.disable.null.includes(`codeIndented`) ? void 0 : 4,
      )(code$3)
      : lineEndingAfterPrefix(code$3)
  }
  function lineEndingAfterPrefix(code$3) {
    return effects.enter(`htmlTextData`), returnState(code$3)
  }
}
const labelEnd = {
    name: `labelEnd`,
    resolveAll: resolveAllLabelEnd,
    resolveTo: resolveToLabelEnd,
    tokenize: tokenizeLabelEnd,
  },
  resourceConstruct = { tokenize: tokenizeResource },
  referenceFullConstruct = { tokenize: tokenizeReferenceFull },
  referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed }
function resolveAllLabelEnd(events) {
  let index$4 = -1, newEvents = []
  for (; ++index$4 < events.length;) {
    let token = events[index$4][1]
    if (
      newEvents.push(events[index$4]),
        token.type === `labelImage` || token.type === `labelLink` || token.type === `labelEnd`
    ) {
      let offset$3 = token.type === `labelImage` ? 4 : 2
      token.type = `data`, index$4 += offset$3
    }
  }
  return events.length !== newEvents.length && splice(events, 0, events.length, newEvents), events
}
function resolveToLabelEnd(events, context$2) {
  let index$4 = events.length, offset$3 = 0, token, open, close$1, media
  for (; index$4--;) {
    if (token = events[index$4][1], open) {
      if (token.type === `link` || token.type === `labelLink` && token._inactive) break
      events[index$4][0] === `enter` && token.type === `labelLink` && (token._inactive = !0)
    } else if (close$1) {
      if (
        events[index$4][0] === `enter` && (token.type === `labelImage` || token.type === `labelLink`)
        && !token._balanced && (open = index$4, token.type !== `labelLink`)
      ) {
        offset$3 = 2
        break
      }
    } else token.type === `labelEnd` && (close$1 = index$4)
  }
  let group = {
      type: events[open][1].type === `labelLink` ? `link` : `image`,
      start: { ...events[open][1].start },
      end: { ...events[events.length - 1][1].end },
    },
    label = { type: `label`, start: { ...events[open][1].start }, end: { ...events[close$1][1].end } },
    text$6 = {
      type: `labelText`,
      start: { ...events[open + offset$3 + 2][1].end },
      end: { ...events[close$1 - 2][1].start },
    }
  return media = [[`enter`, group, context$2], [`enter`, label, context$2]],
    media = push(media, events.slice(open + 1, open + offset$3 + 3)),
    media = push(media, [[`enter`, text$6, context$2]]),
    media = push(
      media,
      resolveAll(
        context$2.parser.constructs.insideSpan.null,
        events.slice(open + offset$3 + 4, close$1 - 3),
        context$2,
      ),
    ),
    media = push(media, [[`exit`, text$6, context$2], events[close$1 - 2], events[close$1 - 1], [
      `exit`,
      label,
      context$2,
    ]]),
    media = push(media, events.slice(close$1 + 1)),
    media = push(media, [[`exit`, group, context$2]]),
    splice(events, open, events.length, media),
    events
}
function tokenizeLabelEnd(effects, ok$2, nok) {
  let self$1 = this, index$4 = self$1.events.length, labelStart, defined$2
  for (; index$4--;) {
    if (
      (self$1.events[index$4][1].type === `labelImage` || self$1.events[index$4][1].type === `labelLink`)
      && !self$1.events[index$4][1]._balanced
    ) {
      labelStart = self$1.events[index$4][1]
      break
    }
  }
  return start$2
  function start$2(code$3) {
    return labelStart
      ? labelStart._inactive
        ? labelEndNok(code$3)
        : (defined$2 = self$1.parser.defined.includes(
          normalizeIdentifier(self$1.sliceSerialize({ start: labelStart.end, end: self$1.now() })),
        ),
          effects.enter(`labelEnd`),
          effects.enter(`labelMarker`),
          effects.consume(code$3),
          effects.exit(`labelMarker`),
          effects.exit(`labelEnd`),
          after$2)
      : nok(code$3)
  }
  function after$2(code$3) {
    return code$3 === 40
      ? effects.attempt(resourceConstruct, labelEndOk, defined$2 ? labelEndOk : labelEndNok)(code$3)
      : code$3 === 91
      ? effects.attempt(referenceFullConstruct, labelEndOk, defined$2 ? referenceNotFull : labelEndNok)(code$3)
      : defined$2
      ? labelEndOk(code$3)
      : labelEndNok(code$3)
  }
  function referenceNotFull(code$3) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code$3)
  }
  function labelEndOk(code$3) {
    return ok$2(code$3)
  }
  function labelEndNok(code$3) {
    return labelStart._balanced = !0, nok(code$3)
  }
}
function tokenizeResource(effects, ok$2, nok) {
  return resourceStart
  function resourceStart(code$3) {
    return effects.enter(`resource`),
      effects.enter(`resourceMarker`),
      effects.consume(code$3),
      effects.exit(`resourceMarker`),
      resourceBefore
  }
  function resourceBefore(code$3) {
    return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, resourceOpen)(code$3) : resourceOpen(code$3)
  }
  function resourceOpen(code$3) {
    return code$3 === 41
      ? resourceEnd(code$3)
      : factoryDestination(
        effects,
        resourceDestinationAfter,
        resourceDestinationMissing,
        `resourceDestination`,
        `resourceDestinationLiteral`,
        `resourceDestinationLiteralMarker`,
        `resourceDestinationRaw`,
        `resourceDestinationString`,
        32,
      )(code$3)
  }
  function resourceDestinationAfter(code$3) {
    return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, resourceBetween)(code$3) : resourceEnd(code$3)
  }
  function resourceDestinationMissing(code$3) {
    return nok(code$3)
  }
  function resourceBetween(code$3) {
    return code$3 === 34 || code$3 === 39 || code$3 === 40
      ? factoryTitle(effects, resourceTitleAfter, nok, `resourceTitle`, `resourceTitleMarker`, `resourceTitleString`)(
        code$3,
      )
      : resourceEnd(code$3)
  }
  function resourceTitleAfter(code$3) {
    return markdownLineEndingOrSpace(code$3) ? factoryWhitespace(effects, resourceEnd)(code$3) : resourceEnd(code$3)
  }
  function resourceEnd(code$3) {
    return code$3 === 41
      ? (effects.enter(`resourceMarker`),
        effects.consume(code$3),
        effects.exit(`resourceMarker`),
        effects.exit(`resource`),
        ok$2)
      : nok(code$3)
  }
}
function tokenizeReferenceFull(effects, ok$2, nok) {
  let self$1 = this
  return referenceFull
  function referenceFull(code$3) {
    return factoryLabel.call(
      self$1,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      `reference`,
      `referenceMarker`,
      `referenceString`,
    )(code$3)
  }
  function referenceFullAfter(code$3) {
    return self$1.parser.defined.includes(
        normalizeIdentifier(self$1.sliceSerialize(self$1.events[self$1.events.length - 1][1]).slice(1, -1)),
      )
      ? ok$2(code$3)
      : nok(code$3)
  }
  function referenceFullMissing(code$3) {
    return nok(code$3)
  }
}
function tokenizeReferenceCollapsed(effects, ok$2, nok) {
  return referenceCollapsedStart
  function referenceCollapsedStart(code$3) {
    return effects.enter(`reference`),
      effects.enter(`referenceMarker`),
      effects.consume(code$3),
      effects.exit(`referenceMarker`),
      referenceCollapsedOpen
  }
  function referenceCollapsedOpen(code$3) {
    return code$3 === 93
      ? (effects.enter(`referenceMarker`),
        effects.consume(code$3),
        effects.exit(`referenceMarker`),
        effects.exit(`reference`),
        ok$2)
      : nok(code$3)
  }
}
const labelStartImage = { name: `labelStartImage`, resolveAll: labelEnd.resolveAll, tokenize: tokenizeLabelStartImage }
function tokenizeLabelStartImage(effects, ok$2, nok) {
  let self$1 = this
  return start$2
  function start$2(code$3) {
    return effects.enter(`labelImage`),
      effects.enter(`labelImageMarker`),
      effects.consume(code$3),
      effects.exit(`labelImageMarker`),
      open
  }
  function open(code$3) {
    return code$3 === 91
      ? (effects.enter(`labelMarker`),
        effects.consume(code$3),
        effects.exit(`labelMarker`),
        effects.exit(`labelImage`),
        after$2)
      : nok(code$3)
  }
  function after$2(code$3) {
    return code$3 === 94 && `_hiddenFootnoteSupport` in self$1.parser.constructs ? nok(code$3) : ok$2(code$3)
  }
}
const labelStartLink = { name: `labelStartLink`, resolveAll: labelEnd.resolveAll, tokenize: tokenizeLabelStartLink }
function tokenizeLabelStartLink(effects, ok$2, nok) {
  let self$1 = this
  return start$2
  function start$2(code$3) {
    return effects.enter(`labelLink`),
      effects.enter(`labelMarker`),
      effects.consume(code$3),
      effects.exit(`labelMarker`),
      effects.exit(`labelLink`),
      after$2
  }
  function after$2(code$3) {
    return code$3 === 94 && `_hiddenFootnoteSupport` in self$1.parser.constructs ? nok(code$3) : ok$2(code$3)
  }
}
const lineEnding = { name: `lineEnding`, tokenize: tokenizeLineEnding }
function tokenizeLineEnding(effects, ok$2) {
  return start$2
  function start$2(code$3) {
    return effects.enter(`lineEnding`),
      effects.consume(code$3),
      effects.exit(`lineEnding`),
      factorySpace(effects, ok$2, `linePrefix`)
  }
}
const thematicBreak$1 = { name: `thematicBreak`, tokenize: tokenizeThematicBreak }
function tokenizeThematicBreak(effects, ok$2, nok) {
  let size$14 = 0, marker
  return start$2
  function start$2(code$3) {
    return effects.enter(`thematicBreak`), before$2(code$3)
  }
  function before$2(code$3) {
    return marker = code$3, atBreak(code$3)
  }
  function atBreak(code$3) {
    return code$3 === marker
      ? (effects.enter(`thematicBreakSequence`), sequence(code$3))
      : size$14 >= 3 && (code$3 === null || markdownLineEnding(code$3))
      ? (effects.exit(`thematicBreak`), ok$2(code$3))
      : nok(code$3)
  }
  function sequence(code$3) {
    return code$3 === marker
      ? (effects.consume(code$3), size$14++, sequence)
      : (effects.exit(`thematicBreakSequence`),
        markdownSpace(code$3) ? factorySpace(effects, atBreak, `whitespace`)(code$3) : atBreak(code$3))
  }
}
const list$1 = {
    continuation: { tokenize: tokenizeListContinuation },
    exit: tokenizeListEnd,
    name: `list`,
    tokenize: tokenizeListStart,
  },
  listItemPrefixWhitespaceConstruct = { partial: !0, tokenize: tokenizeListItemPrefixWhitespace },
  indentConstruct = { partial: !0, tokenize: tokenizeIndent$1 }
function tokenizeListStart(effects, ok$2, nok) {
  let self$1 = this,
    tail = self$1.events[self$1.events.length - 1],
    initialSize = tail && tail[1].type === `linePrefix` ? tail[2].sliceSerialize(tail[1], !0).length : 0,
    size$14 = 0
  return start$2
  function start$2(code$3) {
    let kind = self$1.containerState.type
      || (code$3 === 42 || code$3 === 43 || code$3 === 45 ? `listUnordered` : `listOrdered`)
    if (
      kind === `listUnordered`
        ? !self$1.containerState.marker || code$3 === self$1.containerState.marker
        : asciiDigit(code$3)
    ) {
      if (
        self$1.containerState.type || (self$1.containerState.type = kind, effects.enter(kind, { _container: !0 })),
          kind === `listUnordered`
      ) {
        return effects.enter(`listItemPrefix`),
          code$3 === 42 || code$3 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code$3) : atMarker(code$3)
      }
      if (!self$1.interrupt || code$3 === 49) {
        return effects.enter(`listItemPrefix`), effects.enter(`listItemValue`), inside(code$3)
      }
    }
    return nok(code$3)
  }
  function inside(code$3) {
    return asciiDigit(code$3) && ++size$14 < 10
      ? (effects.consume(code$3), inside)
      : (!self$1.interrupt || size$14 < 2)
          && (self$1.containerState.marker ? code$3 === self$1.containerState.marker : code$3 === 41 || code$3 === 46)
      ? (effects.exit(`listItemValue`), atMarker(code$3))
      : nok(code$3)
  }
  function atMarker(code$3) {
    return effects.enter(`listItemMarker`),
      effects.consume(code$3),
      effects.exit(`listItemMarker`),
      self$1.containerState.marker = self$1.containerState.marker || code$3,
      effects.check(
        blankLine,
        self$1.interrupt ? nok : onBlank,
        effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix),
      )
  }
  function onBlank(code$3) {
    return self$1.containerState.initialBlankLine = !0, initialSize++, endOfPrefix(code$3)
  }
  function otherPrefix(code$3) {
    return markdownSpace(code$3)
      ? (effects.enter(`listItemPrefixWhitespace`),
        effects.consume(code$3),
        effects.exit(`listItemPrefixWhitespace`),
        endOfPrefix)
      : nok(code$3)
  }
  function endOfPrefix(code$3) {
    return self$1.containerState.size = initialSize + self$1.sliceSerialize(effects.exit(`listItemPrefix`), !0).length,
      ok$2(code$3)
  }
}
function tokenizeListContinuation(effects, ok$2, nok) {
  let self$1 = this
  return self$1.containerState._closeFlow = void 0, effects.check(blankLine, onBlank, notBlank)
  function onBlank(code$3) {
    return self$1.containerState.furtherBlankLines = self$1.containerState.furtherBlankLines
      || self$1.containerState.initialBlankLine,
      factorySpace(effects, ok$2, `listItemIndent`, self$1.containerState.size + 1)(code$3)
  }
  function notBlank(code$3) {
    return self$1.containerState.furtherBlankLines || !markdownSpace(code$3)
      ? (self$1.containerState.furtherBlankLines = void 0,
        self$1.containerState.initialBlankLine = void 0,
        notInCurrentItem(code$3))
      : (self$1.containerState.furtherBlankLines = void 0,
        self$1.containerState.initialBlankLine = void 0,
        effects.attempt(indentConstruct, ok$2, notInCurrentItem)(code$3))
  }
  function notInCurrentItem(code$3) {
    return self$1.containerState._closeFlow = !0,
      self$1.interrupt = void 0,
      factorySpace(
        effects,
        effects.attempt(list$1, ok$2, nok),
        `linePrefix`,
        self$1.parser.constructs.disable.null.includes(`codeIndented`) ? void 0 : 4,
      )(code$3)
  }
}
function tokenizeIndent$1(effects, ok$2, nok) {
  let self$1 = this
  return factorySpace(effects, afterPrefix, `listItemIndent`, self$1.containerState.size + 1)
  function afterPrefix(code$3) {
    let tail = self$1.events[self$1.events.length - 1]
    return tail && tail[1].type === `listItemIndent`
        && tail[2].sliceSerialize(tail[1], !0).length === self$1.containerState.size
      ? ok$2(code$3)
      : nok(code$3)
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type)
}
function tokenizeListItemPrefixWhitespace(effects, ok$2, nok) {
  let self$1 = this
  return factorySpace(
    effects,
    afterPrefix,
    `listItemPrefixWhitespace`,
    self$1.parser.constructs.disable.null.includes(`codeIndented`) ? void 0 : 5,
  )
  function afterPrefix(code$3) {
    let tail = self$1.events[self$1.events.length - 1]
    return !markdownSpace(code$3) && tail && tail[1].type === `listItemPrefixWhitespace` ? ok$2(code$3) : nok(code$3)
  }
}
const setextUnderline = {
  name: `setextUnderline`,
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline,
}
function resolveToSetextUnderline(events, context$2) {
  let index$4 = events.length, content$2, text$6, definition$2
  for (; index$4--;) {
    if (events[index$4][0] === `enter`) {
      if (events[index$4][1].type === `content`) {
        content$2 = index$4
        break
      }
      events[index$4][1].type === `paragraph` && (text$6 = index$4)
    } else {events[index$4][1].type === `content` && events.splice(index$4, 1),
        !definition$2 && events[index$4][1].type === `definition` && (definition$2 = index$4)}
  }
  let heading$2 = {
    type: `setextHeading`,
    start: { ...events[content$2][1].start },
    end: { ...events[events.length - 1][1].end },
  }
  return events[text$6][1].type = `setextHeadingText`,
    definition$2
      ? (events.splice(text$6, 0, [`enter`, heading$2, context$2]),
        events.splice(definition$2 + 1, 0, [`exit`, events[content$2][1], context$2]),
        events[content$2][1].end = { ...events[definition$2][1].end })
      : events[content$2][1] = heading$2,
    events.push([`exit`, heading$2, context$2]),
    events
}
function tokenizeSetextUnderline(effects, ok$2, nok) {
  let self$1 = this, marker
  return start$2
  function start$2(code$3) {
    let index$4 = self$1.events.length, paragraph$2
    for (; index$4--;) {
      if (
        self$1.events[index$4][1].type !== `lineEnding` && self$1.events[index$4][1].type !== `linePrefix`
        && self$1.events[index$4][1].type !== `content`
      ) {
        paragraph$2 = self$1.events[index$4][1].type === `paragraph`
        break
      }
    }
    return !self$1.parser.lazy[self$1.now().line] && (self$1.interrupt || paragraph$2)
      ? (effects.enter(`setextHeadingLine`), marker = code$3, before$2(code$3))
      : nok(code$3)
  }
  function before$2(code$3) {
    return effects.enter(`setextHeadingLineSequence`), inside(code$3)
  }
  function inside(code$3) {
    return code$3 === marker
      ? (effects.consume(code$3), inside)
      : (effects.exit(`setextHeadingLineSequence`),
        markdownSpace(code$3) ? factorySpace(effects, after$2, `lineSuffix`)(code$3) : after$2(code$3))
  }
  function after$2(code$3) {
    return code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`setextHeadingLine`), ok$2(code$3))
      : nok(code$3)
  }
}
const indent = { tokenize: tokenizeIndent, partial: !0 }
function gfmFootnote() {
  return {
    document: {
      91: {
        name: `gfmFootnoteDefinition`,
        tokenize: tokenizeDefinitionStart,
        continuation: { tokenize: tokenizeDefinitionContinuation },
        exit: gfmFootnoteDefinitionEnd,
      },
    },
    text: {
      91: { name: `gfmFootnoteCall`, tokenize: tokenizeGfmFootnoteCall },
      93: {
        name: `gfmPotentialFootnoteCall`,
        add: `after`,
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall,
      },
    },
  }
}
function tokenizePotentialGfmFootnoteCall(effects, ok$2, nok) {
  let self$1 = this,
    index$4 = self$1.events.length,
    defined$2 = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []),
    labelStart
  for (; index$4--;) {
    let token = self$1.events[index$4][1]
    if (token.type === `labelImage`) {
      labelStart = token
      break
    }
    if (
      token.type === `gfmFootnoteCall` || token.type === `labelLink` || token.type === `label` || token.type === `image`
      || token.type === `link`
    ) break
  }
  return start$2
  function start$2(code$3) {
    if (!labelStart || !labelStart._balanced) return nok(code$3)
    let id$2 = normalizeIdentifier(self$1.sliceSerialize({ start: labelStart.end, end: self$1.now() }))
    return id$2.codePointAt(0) !== 94 || !defined$2.includes(id$2.slice(1))
      ? nok(code$3)
      : (effects.enter(`gfmFootnoteCallLabelMarker`),
        effects.consume(code$3),
        effects.exit(`gfmFootnoteCallLabelMarker`),
        ok$2(code$3))
  }
}
function resolveToPotentialGfmFootnoteCall(events, context$2) {
  let index$4 = events.length, labelStart
  for (; index$4--;) {
    if (events[index$4][1].type === `labelImage` && events[index$4][0] === `enter`) {
      labelStart = events[index$4][1]
      break
    }
  }
  events[index$4 + 1][1].type = `data`, events[index$4 + 3][1].type = `gfmFootnoteCallLabelMarker`
  let call = {
      type: `gfmFootnoteCall`,
      start: Object.assign({}, events[index$4 + 3][1].start),
      end: Object.assign({}, events[events.length - 1][1].end),
    },
    marker = {
      type: `gfmFootnoteCallMarker`,
      start: Object.assign({}, events[index$4 + 3][1].end),
      end: Object.assign({}, events[index$4 + 3][1].end),
    }
  marker.end.column++, marker.end.offset++, marker.end._bufferIndex++
  let string$5 = {
      type: `gfmFootnoteCallString`,
      start: Object.assign({}, marker.end),
      end: Object.assign({}, events[events.length - 1][1].start),
    },
    chunk$2 = {
      type: `chunkString`,
      contentType: `string`,
      start: Object.assign({}, string$5.start),
      end: Object.assign({}, string$5.end),
    },
    replacement = [
      events[index$4 + 1],
      events[index$4 + 2],
      [`enter`, call, context$2],
      events[index$4 + 3],
      events[index$4 + 4],
      [`enter`, marker, context$2],
      [`exit`, marker, context$2],
      [`enter`, string$5, context$2],
      [`enter`, chunk$2, context$2],
      [`exit`, chunk$2, context$2],
      [`exit`, string$5, context$2],
      events[events.length - 2],
      events[events.length - 1],
      [`exit`, call, context$2],
    ]
  return events.splice(index$4, events.length - index$4 + 1, ...replacement), events
}
function tokenizeGfmFootnoteCall(effects, ok$2, nok) {
  let self$1 = this, defined$2 = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []), size$14 = 0, data
  return start$2
  function start$2(code$3) {
    return effects.enter(`gfmFootnoteCall`),
      effects.enter(`gfmFootnoteCallLabelMarker`),
      effects.consume(code$3),
      effects.exit(`gfmFootnoteCallLabelMarker`),
      callStart
  }
  function callStart(code$3) {
    return code$3 === 94
      ? (effects.enter(`gfmFootnoteCallMarker`),
        effects.consume(code$3),
        effects.exit(`gfmFootnoteCallMarker`),
        effects.enter(`gfmFootnoteCallString`),
        effects.enter(`chunkString`).contentType = `string`,
        callData)
      : nok(code$3)
  }
  function callData(code$3) {
    if (
      size$14 > 999 || code$3 === 93 && !data || code$3 === null || code$3 === 91 || markdownLineEndingOrSpace(code$3)
    ) return nok(code$3)
    if (code$3 === 93) {
      effects.exit(`chunkString`)
      let token = effects.exit(`gfmFootnoteCallString`)
      return defined$2.includes(normalizeIdentifier(self$1.sliceSerialize(token)))
        ? (effects.enter(`gfmFootnoteCallLabelMarker`),
          effects.consume(code$3),
          effects.exit(`gfmFootnoteCallLabelMarker`),
          effects.exit(`gfmFootnoteCall`),
          ok$2)
        : nok(code$3)
    }
    return markdownLineEndingOrSpace(code$3) || (data = !0),
      size$14++,
      effects.consume(code$3),
      code$3 === 92 ? callEscape : callData
  }
  function callEscape(code$3) {
    return code$3 === 91 || code$3 === 92 || code$3 === 93
      ? (effects.consume(code$3), size$14++, callData)
      : callData(code$3)
  }
}
function tokenizeDefinitionStart(effects, ok$2, nok) {
  let self$1 = this,
    defined$2 = self$1.parser.gfmFootnotes || (self$1.parser.gfmFootnotes = []),
    identifier$1,
    size$14 = 0,
    data
  return start$2
  function start$2(code$3) {
    return effects.enter(`gfmFootnoteDefinition`)._container = !0,
      effects.enter(`gfmFootnoteDefinitionLabel`),
      effects.enter(`gfmFootnoteDefinitionLabelMarker`),
      effects.consume(code$3),
      effects.exit(`gfmFootnoteDefinitionLabelMarker`),
      labelAtMarker
  }
  function labelAtMarker(code$3) {
    return code$3 === 94
      ? (effects.enter(`gfmFootnoteDefinitionMarker`),
        effects.consume(code$3),
        effects.exit(`gfmFootnoteDefinitionMarker`),
        effects.enter(`gfmFootnoteDefinitionLabelString`),
        effects.enter(`chunkString`).contentType = `string`,
        labelInside)
      : nok(code$3)
  }
  function labelInside(code$3) {
    if (
      size$14 > 999 || code$3 === 93 && !data || code$3 === null || code$3 === 91 || markdownLineEndingOrSpace(code$3)
    ) return nok(code$3)
    if (code$3 === 93) {
      effects.exit(`chunkString`)
      let token = effects.exit(`gfmFootnoteDefinitionLabelString`)
      return identifier$1 = normalizeIdentifier(self$1.sliceSerialize(token)),
        effects.enter(`gfmFootnoteDefinitionLabelMarker`),
        effects.consume(code$3),
        effects.exit(`gfmFootnoteDefinitionLabelMarker`),
        effects.exit(`gfmFootnoteDefinitionLabel`),
        labelAfter
    }
    return markdownLineEndingOrSpace(code$3) || (data = !0),
      size$14++,
      effects.consume(code$3),
      code$3 === 92 ? labelEscape : labelInside
  }
  function labelEscape(code$3) {
    return code$3 === 91 || code$3 === 92 || code$3 === 93
      ? (effects.consume(code$3), size$14++, labelInside)
      : labelInside(code$3)
  }
  function labelAfter(code$3) {
    return code$3 === 58
      ? (effects.enter(`definitionMarker`),
        effects.consume(code$3),
        effects.exit(`definitionMarker`),
        defined$2.includes(identifier$1) || defined$2.push(identifier$1),
        factorySpace(effects, whitespaceAfter, `gfmFootnoteDefinitionWhitespace`))
      : nok(code$3)
  }
  function whitespaceAfter(code$3) {
    return ok$2(code$3)
  }
}
function tokenizeDefinitionContinuation(effects, ok$2, nok) {
  return effects.check(blankLine, ok$2, effects.attempt(indent, ok$2, nok))
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit(`gfmFootnoteDefinition`)
}
function tokenizeIndent(effects, ok$2, nok) {
  let self$1 = this
  return factorySpace(effects, afterPrefix, `gfmFootnoteDefinitionIndent`, 5)
  function afterPrefix(code$3) {
    let tail = self$1.events[self$1.events.length - 1]
    return tail && tail[1].type === `gfmFootnoteDefinitionIndent` && tail[2].sliceSerialize(tail[1], !0).length === 4
      ? ok$2(code$3)
      : nok(code$3)
  }
}
function gfmStrikethrough(options$2) {
  let options_ = options$2 || {},
    single$1 = options_.singleTilde,
    tokenizer = { name: `strikethrough`, tokenize: tokenizeStrikethrough, resolveAll: resolveAllStrikethrough }
  return single$1 ??= !0,
    { text: { 126: tokenizer }, insideSpan: { null: [tokenizer] }, attentionMarkers: { null: [126] } }
  function resolveAllStrikethrough(events, context$2) {
    let index$4 = -1
    for (; ++index$4 < events.length;) {
      if (
        events[index$4][0] === `enter` && events[index$4][1].type === `strikethroughSequenceTemporary`
        && events[index$4][1]._close
      ) {
        let open = index$4
        for (; open--;) {
          if (
            events[open][0] === `exit` && events[open][1].type === `strikethroughSequenceTemporary`
            && events[open][1]._open
            && events[index$4][1].end.offset - events[index$4][1].start.offset
              === events[open][1].end.offset - events[open][1].start.offset
          ) {
            events[index$4][1].type = `strikethroughSequence`, events[open][1].type = `strikethroughSequence`
            let strikethrough$1 = {
                type: `strikethrough`,
                start: Object.assign({}, events[open][1].start),
                end: Object.assign({}, events[index$4][1].end),
              },
              text$6 = {
                type: `strikethroughText`,
                start: Object.assign({}, events[open][1].end),
                end: Object.assign({}, events[index$4][1].start),
              },
              nextEvents = [[`enter`, strikethrough$1, context$2], [`enter`, events[open][1], context$2], [
                `exit`,
                events[open][1],
                context$2,
              ], [`enter`, text$6, context$2]],
              insideSpan$1 = context$2.parser.constructs.insideSpan.null
            insideSpan$1
            && splice(
              nextEvents,
              nextEvents.length,
              0,
              resolveAll(insideSpan$1, events.slice(open + 1, index$4), context$2),
            ),
              splice(nextEvents, nextEvents.length, 0, [
                [`exit`, text$6, context$2],
                [`enter`, events[index$4][1], context$2],
                [`exit`, events[index$4][1], context$2],
                [`exit`, strikethrough$1, context$2],
              ]),
              splice(events, open - 1, index$4 - open + 3, nextEvents),
              index$4 = open + nextEvents.length - 2
            break
          }
        }
      }
    }
    for (index$4 = -1; ++index$4 < events.length;) {
      events[index$4][1].type === `strikethroughSequenceTemporary` && (events[index$4][1].type = `data`)
    }
    return events
  }
  function tokenizeStrikethrough(effects, ok$2, nok) {
    let previous$2 = this.previous, events = this.events, size$14 = 0
    return start$2
    function start$2(code$3) {
      return previous$2 === 126 && events[events.length - 1][1].type !== `characterEscape`
        ? nok(code$3)
        : (effects.enter(`strikethroughSequenceTemporary`), more(code$3))
    }
    function more(code$3) {
      let before$2 = classifyCharacter(previous$2)
      if (code$3 === 126) return size$14 > 1 ? nok(code$3) : (effects.consume(code$3), size$14++, more)
      if (size$14 < 2 && !single$1) return nok(code$3)
      let token = effects.exit(`strikethroughSequenceTemporary`), after$2 = classifyCharacter(code$3)
      return token._open = !after$2 || after$2 === 2 && !!before$2,
        token._close = !before$2 || before$2 === 2 && !!after$2,
        ok$2(code$3)
    }
  }
}
var EditMap = class {
  constructor() {
    this.map = []
  }
  add(index$4, remove$7, add$5) {
    addImplementation(this, index$4, remove$7, add$5)
  }
  consume(events) {
    if (
      this.map.sort(function(a$22, b$3) {
        return a$22[0] - b$3[0]
      }), this.map.length === 0
    ) return
    let index$4 = this.map.length, vecs = []
    for (; index$4 > 0;) {
      ;--index$4,
        vecs.push(events.slice(this.map[index$4][0] + this.map[index$4][1]), this.map[index$4][2]),
        events.length = this.map[index$4][0]
    }
    vecs.push(events.slice()), events.length = 0
    let slice = vecs.pop()
    for (; slice;) {
      for (let element$2 of slice) events.push(element$2)
      slice = vecs.pop()
    }
    this.map.length = 0
  }
}
function addImplementation(editMap, at$2, remove$7, add$5) {
  let index$4 = 0
  if (!(remove$7 === 0 && add$5.length === 0)) {
    for (; index$4 < editMap.map.length;) {
      if (editMap.map[index$4][0] === at$2) {
        editMap.map[index$4][1] += remove$7, editMap.map[index$4][2].push(...add$5)
        return
      }
      index$4 += 1
    }
    editMap.map.push([at$2, remove$7, add$5])
  }
}
function gfmTableAlign(events, index$4) {
  let inDelimiterRow = !1, align = []
  for (; index$4 < events.length;) {
    let event = events[index$4]
    if (inDelimiterRow) {
      if (event[0] === `enter`) {
        event[1].type === `tableContent`
          && align.push(events[index$4 + 1][1].type === `tableDelimiterMarker` ? `left` : `none`)
      } else if (event[1].type === `tableContent`) {
        if (events[index$4 - 1][1].type === `tableDelimiterMarker`) {
          let alignIndex = align.length - 1
          align[alignIndex] = align[alignIndex] === `left` ? `center` : `right`
        }
      } else if (event[1].type === `tableDelimiterRow`) break
    } else event[0] === `enter` && event[1].type === `tableDelimiterRow` && (inDelimiterRow = !0)
    index$4 += 1
  }
  return align
}
function gfmTable() {
  return { flow: { null: { name: `table`, tokenize: tokenizeTable, resolveAll: resolveTable } } }
}
function tokenizeTable(effects, ok$2, nok) {
  let self$1 = this, size$14 = 0, sizeB = 0, seen$1
  return start$2
  function start$2(code$3) {
    let index$4 = self$1.events.length - 1
    for (; index$4 > -1;) {
      let type$2 = self$1.events[index$4][1].type
      if (type$2 === `lineEnding` || type$2 === `linePrefix`) index$4--
      else break
    }
    let tail = index$4 > -1 ? self$1.events[index$4][1].type : null,
      next = tail === `tableHead` || tail === `tableRow` ? bodyRowStart : headRowBefore
    return next === bodyRowStart && self$1.parser.lazy[self$1.now().line] ? nok(code$3) : next(code$3)
  }
  function headRowBefore(code$3) {
    return effects.enter(`tableHead`), effects.enter(`tableRow`), headRowStart(code$3)
  }
  function headRowStart(code$3) {
    return code$3 === 124 ? headRowBreak(code$3) : (seen$1 = !0, sizeB += 1, headRowBreak(code$3))
  }
  function headRowBreak(code$3) {
    return code$3 === null
      ? nok(code$3)
      : markdownLineEnding(code$3)
      ? sizeB > 1
        ? (sizeB = 0,
          self$1.interrupt = !0,
          effects.exit(`tableRow`),
          effects.enter(`lineEnding`),
          effects.consume(code$3),
          effects.exit(`lineEnding`),
          headDelimiterStart)
        : nok(code$3)
      : markdownSpace(code$3)
      ? factorySpace(effects, headRowBreak, `whitespace`)(code$3)
      : (sizeB += 1,
        seen$1 && (seen$1 = !1, size$14 += 1),
        code$3 === 124
          ? (effects.enter(`tableCellDivider`),
            effects.consume(code$3),
            effects.exit(`tableCellDivider`),
            seen$1 = !0,
            headRowBreak)
          : (effects.enter(`data`), headRowData(code$3)))
  }
  function headRowData(code$3) {
    return code$3 === null || code$3 === 124 || markdownLineEndingOrSpace(code$3)
      ? (effects.exit(`data`), headRowBreak(code$3))
      : (effects.consume(code$3), code$3 === 92 ? headRowEscape : headRowData)
  }
  function headRowEscape(code$3) {
    return code$3 === 92 || code$3 === 124 ? (effects.consume(code$3), headRowData) : headRowData(code$3)
  }
  function headDelimiterStart(code$3) {
    return self$1.interrupt = !1,
      self$1.parser.lazy[self$1.now().line]
        ? nok(code$3)
        : (effects.enter(`tableDelimiterRow`),
          seen$1 = !1,
          markdownSpace(code$3)
            ? factorySpace(
              effects,
              headDelimiterBefore,
              `linePrefix`,
              self$1.parser.constructs.disable.null.includes(`codeIndented`) ? void 0 : 4,
            )(code$3)
            : headDelimiterBefore(code$3))
  }
  function headDelimiterBefore(code$3) {
    return code$3 === 45 || code$3 === 58
      ? headDelimiterValueBefore(code$3)
      : code$3 === 124
      ? (seen$1 = !0,
        effects.enter(`tableCellDivider`),
        effects.consume(code$3),
        effects.exit(`tableCellDivider`),
        headDelimiterCellBefore)
      : headDelimiterNok(code$3)
  }
  function headDelimiterCellBefore(code$3) {
    return markdownSpace(code$3)
      ? factorySpace(effects, headDelimiterValueBefore, `whitespace`)(code$3)
      : headDelimiterValueBefore(code$3)
  }
  function headDelimiterValueBefore(code$3) {
    return code$3 === 58
      ? (sizeB += 1,
        seen$1 = !0,
        effects.enter(`tableDelimiterMarker`),
        effects.consume(code$3),
        effects.exit(`tableDelimiterMarker`),
        headDelimiterLeftAlignmentAfter)
      : code$3 === 45
      ? (sizeB += 1, headDelimiterLeftAlignmentAfter(code$3))
      : code$3 === null || markdownLineEnding(code$3)
      ? headDelimiterCellAfter(code$3)
      : headDelimiterNok(code$3)
  }
  function headDelimiterLeftAlignmentAfter(code$3) {
    return code$3 === 45
      ? (effects.enter(`tableDelimiterFiller`), headDelimiterFiller(code$3))
      : headDelimiterNok(code$3)
  }
  function headDelimiterFiller(code$3) {
    return code$3 === 45
      ? (effects.consume(code$3), headDelimiterFiller)
      : code$3 === 58
      ? (seen$1 = !0,
        effects.exit(`tableDelimiterFiller`),
        effects.enter(`tableDelimiterMarker`),
        effects.consume(code$3),
        effects.exit(`tableDelimiterMarker`),
        headDelimiterRightAlignmentAfter)
      : (effects.exit(`tableDelimiterFiller`), headDelimiterRightAlignmentAfter(code$3))
  }
  function headDelimiterRightAlignmentAfter(code$3) {
    return markdownSpace(code$3)
      ? factorySpace(effects, headDelimiterCellAfter, `whitespace`)(code$3)
      : headDelimiterCellAfter(code$3)
  }
  function headDelimiterCellAfter(code$3) {
    return code$3 === 124
      ? headDelimiterBefore(code$3)
      : code$3 === null || markdownLineEnding(code$3)
      ? !seen$1 || size$14 !== sizeB
        ? headDelimiterNok(code$3)
        : (effects.exit(`tableDelimiterRow`), effects.exit(`tableHead`), ok$2(code$3))
      : headDelimiterNok(code$3)
  }
  function headDelimiterNok(code$3) {
    return nok(code$3)
  }
  function bodyRowStart(code$3) {
    return effects.enter(`tableRow`), bodyRowBreak(code$3)
  }
  function bodyRowBreak(code$3) {
    return code$3 === 124
      ? (effects.enter(`tableCellDivider`), effects.consume(code$3), effects.exit(`tableCellDivider`), bodyRowBreak)
      : code$3 === null || markdownLineEnding(code$3)
      ? (effects.exit(`tableRow`), ok$2(code$3))
      : markdownSpace(code$3)
      ? factorySpace(effects, bodyRowBreak, `whitespace`)(code$3)
      : (effects.enter(`data`), bodyRowData(code$3))
  }
  function bodyRowData(code$3) {
    return code$3 === null || code$3 === 124 || markdownLineEndingOrSpace(code$3)
      ? (effects.exit(`data`), bodyRowBreak(code$3))
      : (effects.consume(code$3), code$3 === 92 ? bodyRowEscape : bodyRowData)
  }
  function bodyRowEscape(code$3) {
    return code$3 === 92 || code$3 === 124 ? (effects.consume(code$3), bodyRowData) : bodyRowData(code$3)
  }
}
function resolveTable(events, context$2) {
  let index$4 = -1,
    inFirstCellAwaitingPipe = !0,
    rowKind = 0,
    lastCell = [0, 0, 0, 0],
    cell = [0, 0, 0, 0],
    afterHeadAwaitingFirstBodyRow = !1,
    lastTableEnd = 0,
    currentTable,
    currentBody,
    currentCell,
    map$20 = new EditMap()
  for (; ++index$4 < events.length;) {
    let event = events[index$4], token = event[1]
    event[0] === `enter`
      ? token.type === `tableHead`
        ? (afterHeadAwaitingFirstBodyRow = !1,
          lastTableEnd !== 0
          && (flushTableEnd(map$20, context$2, lastTableEnd, currentTable, currentBody),
            currentBody = void 0,
            lastTableEnd = 0),
          currentTable = { type: `table`, start: Object.assign({}, token.start), end: Object.assign({}, token.end) },
          map$20.add(index$4, 0, [[`enter`, currentTable, context$2]]))
        : token.type === `tableRow` || token.type === `tableDelimiterRow`
        ? (inFirstCellAwaitingPipe = !0,
          currentCell = void 0,
          lastCell = [0, 0, 0, 0],
          cell = [0, index$4 + 1, 0, 0],
          afterHeadAwaitingFirstBodyRow
          && (afterHeadAwaitingFirstBodyRow = !1,
            currentBody = {
              type: `tableBody`,
              start: Object.assign({}, token.start),
              end: Object.assign({}, token.end),
            },
            map$20.add(index$4, 0, [[`enter`, currentBody, context$2]])),
          rowKind = token.type === `tableDelimiterRow` ? 2 : currentBody ? 3 : 1)
        : rowKind
            && (token.type === `data` || token.type === `tableDelimiterMarker` || token.type === `tableDelimiterFiller`)
        ? (inFirstCellAwaitingPipe = !1,
          cell[2] === 0
          && (lastCell[1] !== 0
            && (cell[0] = cell[1],
              currentCell = flushCell(map$20, context$2, lastCell, rowKind, void 0, currentCell),
              lastCell = [0, 0, 0, 0]),
            cell[2] = index$4))
        : token.type === `tableCellDivider` && (inFirstCellAwaitingPipe
          ? inFirstCellAwaitingPipe = !1
          : (lastCell[1] !== 0
            && (cell[0] = cell[1], currentCell = flushCell(map$20, context$2, lastCell, rowKind, void 0, currentCell)),
            lastCell = cell,
            cell = [lastCell[1], index$4, 0, 0]))
      : token.type === `tableHead`
      ? (afterHeadAwaitingFirstBodyRow = !0, lastTableEnd = index$4)
      : token.type === `tableRow` || token.type === `tableDelimiterRow`
      ? (lastTableEnd = index$4,
        lastCell[1] === 0
          ? cell[1] !== 0 && (currentCell = flushCell(map$20, context$2, cell, rowKind, index$4, currentCell))
          : (cell[0] = cell[1], currentCell = flushCell(map$20, context$2, lastCell, rowKind, index$4, currentCell)),
        rowKind = 0)
      : rowKind
        && (token.type === `data` || token.type === `tableDelimiterMarker` || token.type === `tableDelimiterFiller`)
        && (cell[3] = index$4)
  }
  for (
    lastTableEnd !== 0 && flushTableEnd(map$20, context$2, lastTableEnd, currentTable, currentBody),
      map$20.consume(context$2.events),
      index$4 = -1;
    ++index$4 < context$2.events.length;
  ) {
    let event = context$2.events[index$4]
    event[0] === `enter` && event[1].type === `table` && (event[1]._align = gfmTableAlign(context$2.events, index$4))
  }
  return events
}
function flushCell(map$20, context$2, range, rowKind, rowEnd, previousCell) {
  let groupName = rowKind === 1 ? `tableHeader` : rowKind === 2 ? `tableDelimiter` : `tableData`,
    valueName = `tableContent`
  range[0] !== 0
    && (previousCell.end = Object.assign({}, getPoint(context$2.events, range[0])),
      map$20.add(range[0], 0, [[`exit`, previousCell, context$2]]))
  let now$1 = getPoint(context$2.events, range[1])
  if (
    previousCell = { type: groupName, start: Object.assign({}, now$1), end: Object.assign({}, now$1) },
      map$20.add(range[1], 0, [[`enter`, previousCell, context$2]]),
      range[2] !== 0
  ) {
    let relatedStart = getPoint(context$2.events, range[2]),
      relatedEnd = getPoint(context$2.events, range[3]),
      valueToken = { type: valueName, start: Object.assign({}, relatedStart), end: Object.assign({}, relatedEnd) }
    if (map$20.add(range[2], 0, [[`enter`, valueToken, context$2]]), rowKind !== 2) {
      let start$2 = context$2.events[range[2]], end$2 = context$2.events[range[3]]
      if (
        start$2[1].end = Object.assign({}, end$2[1].end),
          start$2[1].type = `chunkText`,
          start$2[1].contentType = `text`,
          range[3] > range[2] + 1
      ) {
        let a$22 = range[2] + 1, b$3 = range[3] - range[2] - 1
        map$20.add(a$22, b$3, [])
      }
    }
    map$20.add(range[3] + 1, 0, [[`exit`, valueToken, context$2]])
  }
  return rowEnd !== void 0
    && (previousCell.end = Object.assign({}, getPoint(context$2.events, rowEnd)),
      map$20.add(rowEnd, 0, [[`exit`, previousCell, context$2]]),
      previousCell = void 0),
    previousCell
}
function flushTableEnd(map$20, context$2, index$4, table$1, tableBody) {
  let exits = [], related = getPoint(context$2.events, index$4)
  tableBody && (tableBody.end = Object.assign({}, related), exits.push([`exit`, tableBody, context$2])),
    table$1.end = Object.assign({}, related),
    exits.push([`exit`, table$1, context$2]),
    map$20.add(index$4 + 1, 0, exits)
}
function getPoint(events, index$4) {
  let event = events[index$4], side = event[0] === `enter` ? `start` : `end`
  return event[1][side]
}
const tasklistCheck = { name: `tasklistCheck`, tokenize: tokenizeTasklistCheck }
function gfmTaskListItem() {
  return { text: { 91: tasklistCheck } }
}
function tokenizeTasklistCheck(effects, ok$2, nok) {
  let self$1 = this
  return open
  function open(code$3) {
    return self$1.previous !== null || !self$1._gfmTasklistFirstContentOfListItem
      ? nok(code$3)
      : (effects.enter(`taskListCheck`),
        effects.enter(`taskListCheckMarker`),
        effects.consume(code$3),
        effects.exit(`taskListCheckMarker`),
        inside)
  }
  function inside(code$3) {
    return markdownLineEndingOrSpace(code$3)
      ? (effects.enter(`taskListCheckValueUnchecked`),
        effects.consume(code$3),
        effects.exit(`taskListCheckValueUnchecked`),
        close$1)
      : code$3 === 88 || code$3 === 120
      ? (effects.enter(`taskListCheckValueChecked`),
        effects.consume(code$3),
        effects.exit(`taskListCheckValueChecked`),
        close$1)
      : nok(code$3)
  }
  function close$1(code$3) {
    return code$3 === 93
      ? (effects.enter(`taskListCheckMarker`),
        effects.consume(code$3),
        effects.exit(`taskListCheckMarker`),
        effects.exit(`taskListCheck`),
        after$2)
      : nok(code$3)
  }
  function after$2(code$3) {
    return markdownLineEnding(code$3)
      ? ok$2(code$3)
      : markdownSpace(code$3)
      ? effects.check({ tokenize: spaceThenNonSpace }, ok$2, nok)(code$3)
      : nok(code$3)
  }
}
function spaceThenNonSpace(effects, ok$2, nok) {
  return factorySpace(effects, after$2, `whitespace`)
  function after$2(code$3) {
    return code$3 === null ? nok(code$3) : ok$2(code$3)
  }
}
function gfm(options$2) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options$2),
    gfmTable(),
    gfmTaskListItem(),
  ])
}
const emptyOptions$1 = {}
function remarkGfm(options$2) {
  let self$1 = this,
    settings = options$2 || emptyOptions$1,
    data = self$1.data(),
    micromarkExtensions = data.micromarkExtensions ||= [],
    fromMarkdownExtensions = data.fromMarkdownExtensions ||= [],
    toMarkdownExtensions = data.toMarkdownExtensions ||= []
  micromarkExtensions.push(gfm(settings)),
    fromMarkdownExtensions.push(gfmFromMarkdown()),
    toMarkdownExtensions.push(gfmToMarkdown(settings))
}
const content = { tokenize: initializeContent }
function initializeContent(effects) {
  let contentStart = effects.attempt(
      this.parser.constructs.contentInitial,
      afterContentStartConstruct,
      paragraphInitial,
    ),
    previous$2
  return contentStart
  function afterContentStartConstruct(code$3) {
    if (code$3 === null) {
      effects.consume(code$3)
      return
    }
    return effects.enter(`lineEnding`),
      effects.consume(code$3),
      effects.exit(`lineEnding`),
      factorySpace(effects, contentStart, `linePrefix`)
  }
  function paragraphInitial(code$3) {
    return effects.enter(`paragraph`), lineStart(code$3)
  }
  function lineStart(code$3) {
    let token = effects.enter(`chunkText`, { contentType: `text`, previous: previous$2 })
    return previous$2 && (previous$2.next = token), previous$2 = token, data(code$3)
  }
  function data(code$3) {
    if (code$3 === null) {
      effects.exit(`chunkText`), effects.exit(`paragraph`), effects.consume(code$3)
      return
    }
    return markdownLineEnding(code$3)
      ? (effects.consume(code$3), effects.exit(`chunkText`), lineStart)
      : (effects.consume(code$3), data)
  }
}
const document$1 = { tokenize: initializeDocument }, containerConstruct = { tokenize: tokenizeContainer }
function initializeDocument(effects) {
  let self$1 = this, stack = [], continued = 0, childFlow, childToken, lineStartOffset
  return start$2
  function start$2(code$3) {
    if (continued < stack.length) {
      let item = stack[continued]
      return self$1.containerState = item[1],
        effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code$3)
    }
    return checkNewContainers(code$3)
  }
  function documentContinue(code$3) {
    if (continued++, self$1.containerState._closeFlow) {
      self$1.containerState._closeFlow = void 0, childFlow && closeFlow()
      let indexBeforeExits = self$1.events.length, indexBeforeFlow = indexBeforeExits, point$3
      for (; indexBeforeFlow--;) {
        if (self$1.events[indexBeforeFlow][0] === `exit` && self$1.events[indexBeforeFlow][1].type === `chunkFlow`) {
          point$3 = self$1.events[indexBeforeFlow][1].end
          break
        }
      }
      exitContainers(continued)
      let index$4 = indexBeforeExits
      for (; index$4 < self$1.events.length;) self$1.events[index$4][1].end = { ...point$3 }, index$4++
      return splice(self$1.events, indexBeforeFlow + 1, 0, self$1.events.slice(indexBeforeExits)),
        self$1.events.length = index$4,
        checkNewContainers(code$3)
    }
    return start$2(code$3)
  }
  function checkNewContainers(code$3) {
    if (continued === stack.length) {
      if (!childFlow) return documentContinued(code$3)
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) return flowStart(code$3)
      self$1.interrupt = !!(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack)
    }
    return self$1.containerState = {},
      effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code$3)
  }
  function thereIsANewContainer(code$3) {
    return childFlow && closeFlow(), exitContainers(continued), documentContinued(code$3)
  }
  function thereIsNoNewContainer(code$3) {
    return self$1.parser.lazy[self$1.now().line] = continued !== stack.length,
      lineStartOffset = self$1.now().offset,
      flowStart(code$3)
  }
  function documentContinued(code$3) {
    return self$1.containerState = {}, effects.attempt(containerConstruct, containerContinue, flowStart)(code$3)
  }
  function containerContinue(code$3) {
    return continued++, stack.push([self$1.currentConstruct, self$1.containerState]), documentContinued(code$3)
  }
  function flowStart(code$3) {
    if (code$3 === null) {
      childFlow && closeFlow(), exitContainers(0), effects.consume(code$3)
      return
    }
    return childFlow ||= self$1.parser.flow(self$1.now()),
      effects.enter(`chunkFlow`, { _tokenizer: childFlow, contentType: `flow`, previous: childToken }),
      flowContinue(code$3)
  }
  function flowContinue(code$3) {
    if (code$3 === null) {
      writeToChild(effects.exit(`chunkFlow`), !0), exitContainers(0), effects.consume(code$3)
      return
    }
    return markdownLineEnding(code$3)
      ? (effects.consume(code$3),
        writeToChild(effects.exit(`chunkFlow`)),
        continued = 0,
        self$1.interrupt = void 0,
        start$2)
      : (effects.consume(code$3), flowContinue)
  }
  function writeToChild(token, endOfFile) {
    let stream = self$1.sliceStream(token)
    if (
      endOfFile && stream.push(null),
        token.previous = childToken,
        childToken && (childToken.next = token),
        childToken = token,
        childFlow.defineSkip(token.start),
        childFlow.write(stream),
        self$1.parser.lazy[token.start.line]
    ) {
      let index$4 = childFlow.events.length
      for (; index$4--;) {
        if (
          childFlow.events[index$4][1].start.offset < lineStartOffset
          && (!childFlow.events[index$4][1].end || childFlow.events[index$4][1].end.offset > lineStartOffset)
        ) return
      }
      let indexBeforeExits = self$1.events.length, indexBeforeFlow = indexBeforeExits, seen$1, point$3
      for (; indexBeforeFlow--;) {
        if (self$1.events[indexBeforeFlow][0] === `exit` && self$1.events[indexBeforeFlow][1].type === `chunkFlow`) {
          if (seen$1) {
            point$3 = self$1.events[indexBeforeFlow][1].end
            break
          }
          seen$1 = !0
        }
      }
      for (exitContainers(continued), index$4 = indexBeforeExits; index$4 < self$1.events.length;) {
        self$1.events[index$4][1].end = { ...point$3 }, index$4++
      }
      splice(self$1.events, indexBeforeFlow + 1, 0, self$1.events.slice(indexBeforeExits)),
        self$1.events.length = index$4
    }
  }
  function exitContainers(size$14) {
    let index$4 = stack.length
    for (; index$4-- > size$14;) {
      let entry = stack[index$4]
      self$1.containerState = entry[1], entry[0].exit.call(self$1, effects)
    }
    stack.length = size$14
  }
  function closeFlow() {
    childFlow.write([null]), childToken = void 0, childFlow = void 0, self$1.containerState._closeFlow = void 0
  }
}
function tokenizeContainer(effects, ok$2, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok$2, nok),
    `linePrefix`,
    this.parser.constructs.disable.null.includes(`codeIndented`) ? void 0 : 4,
  )
}
const flow = { tokenize: initializeFlow }
function initializeFlow(effects) {
  let self$1 = this,
    initial = effects.attempt(
      blankLine,
      atBlankEnding,
      effects.attempt(
        this.parser.constructs.flowInitial,
        afterConstruct,
        factorySpace(
          effects,
          effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content$1, afterConstruct)),
          `linePrefix`,
        ),
      ),
    )
  return initial
  function atBlankEnding(code$3) {
    if (code$3 === null) {
      effects.consume(code$3)
      return
    }
    return effects.enter(`lineEndingBlank`),
      effects.consume(code$3),
      effects.exit(`lineEndingBlank`),
      self$1.currentConstruct = void 0,
      initial
  }
  function afterConstruct(code$3) {
    if (code$3 === null) {
      effects.consume(code$3)
      return
    }
    return effects.enter(`lineEnding`),
      effects.consume(code$3),
      effects.exit(`lineEnding`),
      self$1.currentConstruct = void 0,
      initial
  }
}
const resolver = { resolveAll: createResolver() },
  string = initializeFactory(`string`),
  text$1 = initializeFactory(`text`)
function initializeFactory(field) {
  return { resolveAll: createResolver(field === `text` ? resolveAllLineSuffixes : void 0), tokenize: initializeText }
  function initializeText(effects) {
    let self$1 = this,
      constructs$1 = this.parser.constructs[field],
      text$6 = effects.attempt(constructs$1, start$2, notText)
    return start$2
    function start$2(code$3) {
      return atBreak(code$3) ? text$6(code$3) : notText(code$3)
    }
    function notText(code$3) {
      if (code$3 === null) {
        effects.consume(code$3)
        return
      }
      return effects.enter(`data`), effects.consume(code$3), data
    }
    function data(code$3) {
      return atBreak(code$3) ? (effects.exit(`data`), text$6(code$3)) : (effects.consume(code$3), data)
    }
    function atBreak(code$3) {
      if (code$3 === null) return !0
      let list$3 = constructs$1[code$3], index$4 = -1
      if (list$3) {
        for (; ++index$4 < list$3.length;) {
          let item = list$3[index$4]
          if (!item.previous || item.previous.call(self$1, self$1.previous)) return !0
        }
      }
      return !1
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText
  function resolveAllText(events, context$2) {
    let index$4 = -1, enter
    for (; ++index$4 <= events.length;) {
      enter === void 0
        ? events[index$4] && events[index$4][1].type === `data` && (enter = index$4, index$4++)
        : (!events[index$4] || events[index$4][1].type !== `data`)
          && (index$4 !== enter + 2
            && (events[enter][1].end = events[index$4 - 1][1].end,
              events.splice(enter + 2, index$4 - enter - 2),
              index$4 = enter + 2),
            enter = void 0)
    }
    return extraResolver ? extraResolver(events, context$2) : events
  }
}
function resolveAllLineSuffixes(events, context$2) {
  let eventIndex = 0
  for (; ++eventIndex <= events.length;) {
    if (
      (eventIndex === events.length || events[eventIndex][1].type === `lineEnding`)
      && events[eventIndex - 1][1].type === `data`
    ) {
      let data = events[eventIndex - 1][1],
        chunks = context$2.sliceStream(data),
        index$4 = chunks.length,
        bufferIndex = -1,
        size$14 = 0,
        tabs
      for (; index$4--;) {
        let chunk$2 = chunks[index$4]
        if (typeof chunk$2 == `string`) {
          for (bufferIndex = chunk$2.length; chunk$2.charCodeAt(bufferIndex - 1) === 32;) size$14++, bufferIndex--
          if (bufferIndex) break
          bufferIndex = -1
        } else if (chunk$2 === -2) tabs = !0, size$14++
        else if (chunk$2 !== -1) {
          index$4++
          break
        }
      }
      if (context$2._contentTypeTextTrailing && eventIndex === events.length && (size$14 = 0), size$14) {
        let token = {
          type: eventIndex === events.length || tabs || size$14 < 2 ? `lineSuffix` : `hardBreakTrailing`,
          start: {
            _bufferIndex: index$4 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index$4,
            line: data.end.line,
            column: data.end.column - size$14,
            offset: data.end.offset - size$14,
          },
          end: { ...data.end },
        }
        data.end = { ...token.start },
          data.start.offset === data.end.offset
            ? Object.assign(data, token)
            : (events.splice(eventIndex, 0, [`enter`, token, context$2], [`exit`, token, context$2]), eventIndex += 2)
      }
      eventIndex++
    }
  }
  return events
}
var constructs_exports = {}
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document$2,
  flow: () => flow$1,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string$1,
  text: () => text$2,
})
const document$2 = {
    42: list$1,
    43: list$1,
    45: list$1,
    48: list$1,
    49: list$1,
    50: list$1,
    51: list$1,
    52: list$1,
    53: list$1,
    54: list$1,
    55: list$1,
    56: list$1,
    57: list$1,
    62: blockQuote,
  },
  contentInitial = { 91: definition },
  flowInitial = { [-2]: codeIndented, [-1]: codeIndented, 32: codeIndented },
  flow$1 = {
    35: headingAtx,
    42: thematicBreak$1,
    45: [setextUnderline, thematicBreak$1],
    60: htmlFlow,
    61: setextUnderline,
    95: thematicBreak$1,
    96: codeFenced,
    126: codeFenced,
  },
  string$1 = { 38: characterReference, 92: characterEscape },
  text$2 = {
    [-5]: lineEnding,
    [-4]: lineEnding,
    [-3]: lineEnding,
    33: labelStartImage,
    38: characterReference,
    42: attention,
    60: [autolink, htmlText],
    91: labelStartLink,
    92: [hardBreakEscape, characterEscape],
    93: labelEnd,
    95: attention,
    96: codeText,
  },
  insideSpan = { null: [attention, resolver] },
  attentionMarkers = { null: [42, 95] },
  disable = { null: [] }
function createTokenizer(parser, initialize, from) {
  let point$3 = {
      _bufferIndex: -1,
      _index: 0,
      line: from && from.line || 1,
      column: from && from.column || 1,
      offset: from && from.offset || 0,
    },
    columnStart = {},
    resolveAllConstructs = [],
    chunks = [],
    stack = [],
    consumed = !0,
    effects = {
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      consume,
      enter,
      exit: exit$5,
      interrupt: constructFactory(onsuccessfulcheck, { interrupt: !0 }),
    },
    context$2 = {
      code: null,
      containerState: {},
      defineSkip,
      events: [],
      now: now$1,
      parser,
      previous: null,
      sliceSerialize,
      sliceStream,
      write,
    },
    state = initialize.tokenize.call(context$2, effects),
    expectedCode
  return initialize.resolveAll && resolveAllConstructs.push(initialize), context$2
  function write(slice) {
    return chunks = push(chunks, slice),
      main(),
      chunks[chunks.length - 1] === null
        ? (addResult(initialize, 0),
          context$2.events = resolveAll(resolveAllConstructs, context$2.events, context$2),
          context$2.events)
        : []
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs)
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token)
  }
  function now$1() {
    let { _bufferIndex, _index, line, column, offset: offset$3 } = point$3
    return { _bufferIndex, _index, line, column, offset: offset$3 }
  }
  function defineSkip(value$2) {
    columnStart[value$2.line] = value$2.column, accountForPotentialSkip()
  }
  function main() {
    let chunkIndex
    for (; point$3._index < chunks.length;) {
      let chunk$2 = chunks[point$3._index]
      if (typeof chunk$2 == `string`) {
        for (
          chunkIndex = point$3._index, point$3._bufferIndex < 0 && (point$3._bufferIndex = 0);
          point$3._index === chunkIndex && point$3._bufferIndex < chunk$2.length;
        ) go$2(chunk$2.charCodeAt(point$3._bufferIndex))
      } else go$2(chunk$2)
    }
  }
  function go$2(code$3) {
    consumed = void 0, expectedCode = code$3, state = state(code$3)
  }
  function consume(code$3) {
    markdownLineEnding(code$3)
      ? (point$3.line++, point$3.column = 1, point$3.offset += code$3 === -3 ? 2 : 1, accountForPotentialSkip())
      : code$3 !== -1 && (point$3.column++, point$3.offset++),
      point$3._bufferIndex < 0
        ? point$3._index++
        : (point$3._bufferIndex++,
          point$3._bufferIndex === chunks[point$3._index].length && (point$3._bufferIndex = -1, point$3._index++)),
      context$2.previous = code$3,
      consumed = !0
  }
  function enter(type$2, fields) {
    let token = fields || {}
    return token.type = type$2,
      token.start = now$1(),
      context$2.events.push([`enter`, token, context$2]),
      stack.push(token),
      token
  }
  function exit$5(type$2) {
    let token = stack.pop()
    return token.end = now$1(), context$2.events.push([`exit`, token, context$2]), token
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from)
  }
  function onsuccessfulcheck(_$1, info) {
    info.restore()
  }
  function constructFactory(onreturn, fields) {
    return hook
    function hook(constructs$1, returnState, bogusState) {
      let listOfConstructs, constructIndex, currentConstruct, info
      return Array.isArray(constructs$1)
        ? handleListOfConstructs(constructs$1)
        : `tokenize` in constructs$1
        ? handleListOfConstructs([constructs$1])
        : handleMapOfConstructs(constructs$1)
      function handleMapOfConstructs(map$20) {
        return start$2
        function start$2(code$3) {
          let left$2 = code$3 !== null && map$20[code$3],
            all$8 = code$3 !== null && map$20.null,
            list$3 = [
              ...Array.isArray(left$2) ? left$2 : left$2 ? [left$2] : [],
              ...Array.isArray(all$8) ? all$8 : all$8 ? [all$8] : [],
            ]
          return handleListOfConstructs(list$3)(code$3)
        }
      }
      function handleListOfConstructs(list$3) {
        return listOfConstructs = list$3,
          constructIndex = 0,
          list$3.length === 0 ? bogusState : handleConstruct(list$3[constructIndex])
      }
      function handleConstruct(construct) {
        return start$2
        function start$2(code$3) {
          return info = store$1(),
            currentConstruct = construct,
            construct.partial || (context$2.currentConstruct = construct),
            construct.name && context$2.parser.constructs.disable.null.includes(construct.name)
              ? nok(code$3)
              : construct.tokenize.call(
                fields ? Object.assign(Object.create(context$2), fields) : context$2,
                effects,
                ok$2,
                nok,
              )(code$3)
        }
      }
      function ok$2(code$3) {
        return consumed = !0, onreturn(currentConstruct, info), returnState
      }
      function nok(code$3) {
        return consumed = !0,
          info.restore(),
          ++constructIndex < listOfConstructs.length ? handleConstruct(listOfConstructs[constructIndex]) : bogusState
      }
    }
  }
  function addResult(construct, from$1) {
    construct.resolveAll && !resolveAllConstructs.includes(construct) && resolveAllConstructs.push(construct),
      construct.resolve
      && splice(
        context$2.events,
        from$1,
        context$2.events.length - from$1,
        construct.resolve(context$2.events.slice(from$1), context$2),
      ),
      construct.resolveTo && (context$2.events = construct.resolveTo(context$2.events, context$2))
  }
  function store$1() {
    let startPoint = now$1(),
      startPrevious = context$2.previous,
      startCurrentConstruct = context$2.currentConstruct,
      startEventsIndex = context$2.events.length,
      startStack = Array.from(stack)
    return { from: startEventsIndex, restore }
    function restore() {
      point$3 = startPoint,
        context$2.previous = startPrevious,
        context$2.currentConstruct = startCurrentConstruct,
        context$2.events.length = startEventsIndex,
        stack = startStack,
        accountForPotentialSkip()
    }
  }
  function accountForPotentialSkip() {
    point$3.line in columnStart && point$3.column < 2
      && (point$3.column = columnStart[point$3.line], point$3.offset += columnStart[point$3.line] - 1)
  }
}
function sliceChunks(chunks, token) {
  let startIndex = token.start._index,
    startBufferIndex = token.start._bufferIndex,
    endIndex = token.end._index,
    endBufferIndex = token.end._bufferIndex,
    view
  if (startIndex === endIndex) view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]
  else {
    if (view = chunks.slice(startIndex, endIndex), startBufferIndex > -1) {
      let head$5 = view[0]
      typeof head$5 == `string` ? view[0] = head$5.slice(startBufferIndex) : view.shift()
    }
    endBufferIndex > 0 && view.push(chunks[endIndex].slice(0, endBufferIndex))
  }
  return view
}
function serializeChunks(chunks, expandTabs) {
  let index$4 = -1, result = [], atTab
  for (; ++index$4 < chunks.length;) {
    let chunk$2 = chunks[index$4], value$2
    if (typeof chunk$2 == `string`) value$2 = chunk$2
    else {switch (chunk$2) {
        case -5:
          value$2 = `\r`
          break
        case -4:
          value$2 = `
`
          break
        case -3:
          value$2 = `\r
`
          break
        case -2:
          value$2 = expandTabs ? ` ` : `	`
          break
        case -1:
          if (!expandTabs && atTab) continue
          value$2 = ` `
          break
        default:
          value$2 = String.fromCharCode(chunk$2)
      }}
    atTab = chunk$2 === -2, result.push(value$2)
  }
  return result.join(``)
}
function parse(options$2) {
  let settings = options$2 || {},
    constructs$1 = combineExtensions([constructs_exports, ...settings.extensions || []]),
    parser = {
      constructs: constructs$1,
      content: create$2(content),
      defined: [],
      document: create$2(document$1),
      flow: create$2(flow),
      lazy: {},
      string: create$2(string),
      text: create$2(text$1),
    }
  return parser
  function create$2(initial) {
    return creator
    function creator(from) {
      return createTokenizer(parser, initial, from)
    }
  }
}
function postprocess(events) {
  for (; !subtokenize(events););
  return events
}
const search = /[\0\t\n\r]/g
function preprocess() {
  let column = 1, buffer = ``, start$2 = !0, atCarriageReturn
  return preprocessor
  function preprocessor(value$2, encoding, end$2) {
    let chunks = [], match$13, next, startPosition, endPosition, code$3
    for (
      value$2 = buffer
        + (typeof value$2 == `string` ? value$2.toString() : new TextDecoder(encoding || void 0).decode(value$2)),
        startPosition = 0,
        buffer = ``,
        start$2 && (value$2.charCodeAt(0) === 65279 && startPosition++, start$2 = void 0);
      startPosition < value$2.length;
    ) {
      if (
        search.lastIndex = startPosition,
          match$13 = search.exec(value$2),
          endPosition = match$13 && match$13.index !== void 0 ? match$13.index : value$2.length,
          code$3 = value$2.charCodeAt(endPosition),
          !match$13
      ) {
        buffer = value$2.slice(startPosition)
        break
      }
      if (code$3 === 10 && startPosition === endPosition && atCarriageReturn) chunks.push(-3), atCarriageReturn = void 0
      else {switch (
          atCarriageReturn && (chunks.push(-5), atCarriageReturn = void 0),
            startPosition < endPosition
            && (chunks.push(value$2.slice(startPosition, endPosition)), column += endPosition - startPosition),
            code$3
        )
        {
          case 0:
            chunks.push(65533), column++
            break
          case 9:
            for (next = Math.ceil(column / 4) * 4, chunks.push(-2); column++ < next;) chunks.push(-1)
            break
          case 10:
            chunks.push(-4), column = 1
            break
          default:
            atCarriageReturn = !0, column = 1
        }}
      startPosition = endPosition + 1
    }
    return end$2 && (atCarriageReturn && chunks.push(-5), buffer && chunks.push(buffer), chunks.push(null)), chunks
  }
}
function stringifyPosition(value$2) {
  return !value$2 || typeof value$2 != `object`
    ? ``
    : `position` in value$2 || `type` in value$2
    ? position$1(value$2.position)
    : `start` in value$2 || `end` in value$2
    ? position$1(value$2)
    : `line` in value$2 || `column` in value$2
    ? point$2(value$2)
    : ``
}
function point$2(point$3) {
  return index$1(point$3 && point$3.line) + `:` + index$1(point$3 && point$3.column)
}
function position$1(pos) {
  return point$2(pos && pos.start) + `-` + point$2(pos && pos.end)
}
function index$1(value$2) {
  return value$2 && typeof value$2 == `number` ? value$2 : 1
}
const own$2 = {}.hasOwnProperty
function fromMarkdown(value$2, encoding, options$2) {
  return typeof encoding != `string` && (options$2 = encoding, encoding = void 0),
    compiler(options$2)(postprocess(parse(options$2).document().write(preprocess()(value$2, encoding, !0))))
}
function compiler(options$2) {
  let config = {
    transforms: [],
    canContainEols: [`emphasis`, `fragment`, `heading`, `paragraph`, `strong`],
    enter: {
      autolink: opener(link$2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading$2),
      blockQuote: opener(blockQuote$1),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText$1, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition$2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis$2),
      hardBreakEscape: opener(hardBreak$2),
      hardBreakTrailing: opener(hardBreak$2),
      htmlFlow: opener(html$6, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html$6, buffer),
      htmlTextData: onenterdata,
      image: opener(image$2),
      label: buffer,
      link: opener(link$2),
      listItem: opener(listItem$2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list$3, onenterlistordered),
      listUnordered: opener(list$3),
      paragraph: opener(paragraph$2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading$2),
      strong: opener(strong$2),
      thematicBreak: opener(thematicBreak$3),
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer(),
    },
  }
  configure(config, (options$2 || {}).mdastExtensions || [])
  let data = {}
  return compile
  function compile(events) {
    let tree = { type: `root`, children: [] },
      context$2 = { stack: [tree], tokenStack: [], config, enter, exit: exit$5, buffer, resume: resume$1, data },
      listStack = [],
      index$4 = -1
    for (; ++index$4 < events.length;) {
      if (events[index$4][1].type === `listOrdered` || events[index$4][1].type === `listUnordered`) {
        if (events[index$4][0] === `enter`) listStack.push(index$4)
        else {
          let tail = listStack.pop()
          index$4 = prepareList(events, tail, index$4)
        }
      }
    }
    for (index$4 = -1; ++index$4 < events.length;) {
      let handler = config[events[index$4][0]]
      own$2.call(handler, events[index$4][1].type)
        && handler[events[index$4][1].type].call(
          Object.assign({ sliceSerialize: events[index$4][2].sliceSerialize }, context$2),
          events[index$4][1],
        )
    }
    if (context$2.tokenStack.length > 0) {
      let tail = context$2.tokenStack[context$2.tokenStack.length - 1], handler = tail[1] || defaultOnError
      handler.call(context$2, void 0, tail[0])
    }
    for (
      tree.position = {
        start: point$1(events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }),
        end: point$1(events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }),
      }, index$4 = -1;
      ++index$4 < config.transforms.length;
    ) tree = config.transforms[index$4](tree) || tree
    return tree
  }
  function prepareList(events, start$2, length$1) {
    let index$4 = start$2 - 1,
      containerBalance = -1,
      listSpread = !1,
      listItem$3,
      lineIndex,
      firstBlankLineIndex,
      atMarker
    for (; ++index$4 <= length$1;) {
      let event = events[index$4]
      switch (event[1].type) {
        case `listUnordered`:
        case `listOrdered`:
        case `blockQuote`:
          event[0] === `enter` ? containerBalance++ : containerBalance--, atMarker = void 0
          break
        case `lineEndingBlank`:
          event[0] === `enter`
            && (listItem$3 && !atMarker && !containerBalance && !firstBlankLineIndex && (firstBlankLineIndex = index$4),
              atMarker = void 0)
          break
        case `linePrefix`:
        case `listItemValue`:
        case `listItemMarker`:
        case `listItemPrefix`:
        case `listItemPrefixWhitespace`:
          break
        default:
          atMarker = void 0
      }
      if (
        !containerBalance && event[0] === `enter` && event[1].type === `listItemPrefix`
        || containerBalance === -1 && event[0] === `exit`
          && (event[1].type === `listUnordered` || event[1].type === `listOrdered`)
      ) {
        if (listItem$3) {
          let tailIndex = index$4
          for (lineIndex = void 0; tailIndex--;) {
            let tailEvent = events[tailIndex]
            if (tailEvent[1].type === `lineEnding` || tailEvent[1].type === `lineEndingBlank`) {
              if (tailEvent[0] === `exit`) continue
              lineIndex && (events[lineIndex][1].type = `lineEndingBlank`, listSpread = !0),
                tailEvent[1].type = `lineEnding`,
                lineIndex = tailIndex
            } else if (
              !(tailEvent[1].type === `linePrefix` || tailEvent[1].type === `blockQuotePrefix`
                || tailEvent[1].type === `blockQuotePrefixWhitespace` || tailEvent[1].type === `blockQuoteMarker`
                || tailEvent[1].type === `listItemIndent`)
            ) break
          }
          firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex) && (listItem$3._spread = !0),
            listItem$3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end),
            events.splice(lineIndex || index$4, 0, [`exit`, listItem$3, event[2]]),
            index$4++,
            length$1++
        }
        if (event[1].type === `listItemPrefix`) {
          let item = { type: `listItem`, _spread: !1, start: Object.assign({}, event[1].start), end: void 0 }
          listItem$3 = item,
            events.splice(index$4, 0, [`enter`, item, event[2]]),
            index$4++,
            length$1++,
            firstBlankLineIndex = void 0,
            atMarker = !0
        }
      }
    }
    return events[start$2][1]._spread = listSpread, length$1
  }
  function opener(create$2, and) {
    return open
    function open(token) {
      enter.call(this, create$2(token), token), and && and.call(this, token)
    }
  }
  function buffer() {
    this.stack.push({ type: `fragment`, children: [] })
  }
  function enter(node$1, token, errorHandler) {
    let parent = this.stack[this.stack.length - 1], siblings$1 = parent.children
    siblings$1.push(node$1),
      this.stack.push(node$1),
      this.tokenStack.push([token, errorHandler || void 0]),
      node$1.position = { start: point$1(token.start), end: void 0 }
  }
  function closer(and) {
    return close$1
    function close$1(token) {
      and && and.call(this, token), exit$5.call(this, token)
    }
  }
  function exit$5(token, onExitError) {
    let node$1 = this.stack.pop(), open = this.tokenStack.pop()
    if (open) {
      if (open[0].type !== token.type) {
        if (onExitError) onExitError.call(this, token, open[0])
        else {
          let handler = open[1] || defaultOnError
          handler.call(this, token, open[0])
        }
      }
    } else {throw Error(
        'Cannot close `' + token.type + '` (' + stringifyPosition({ start: token.start, end: token.end })
          + `): its not open`,
      )}
    node$1.position.end = point$1(token.end)
  }
  function resume$1() {
    return toString$1(this.stack.pop())
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = !0
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      let ancestor = this.stack[this.stack.length - 2]
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10), this.data.expectingFirstListItemValue = void 0
    }
  }
  function onexitcodefencedfenceinfo() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.lang = data$1
  }
  function onexitcodefencedfencemeta() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.meta = data$1
  }
  function onexitcodefencedfence() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0)
  }
  function onexitcodefenced() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.value = data$1.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ``), this.data.flowCodeInside = void 0
  }
  function onexitcodeindented() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.value = data$1.replace(/(\r?\n|\r)$/g, ``)
  }
  function onexitdefinitionlabelstring(token) {
    let label = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.label = label, node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase()
  }
  function onexitdefinitiontitlestring() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.title = data$1
  }
  function onexitdefinitiondestinationstring() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.url = data$1
  }
  function onexitatxheadingsequence(token) {
    let node$1 = this.stack[this.stack.length - 1]
    if (!node$1.depth) {
      let depth = this.sliceSerialize(token).length
      node$1.depth = depth
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = !0
  }
  function onexitsetextheadinglinesequence(token) {
    let node$1 = this.stack[this.stack.length - 1]
    node$1.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0
  }
  function onenterdata(token) {
    let node$1 = this.stack[this.stack.length - 1],
      siblings$1 = node$1.children,
      tail = siblings$1[siblings$1.length - 1]
    ;(!tail || tail.type !== `text`)
      && (tail = text$6(), tail.position = { start: point$1(token.start), end: void 0 }, siblings$1.push(tail)),
      this.stack.push(tail)
  }
  function onexitdata(token) {
    let tail = this.stack.pop()
    tail.value += this.sliceSerialize(token), tail.position.end = point$1(token.end)
  }
  function onexitlineending(token) {
    let context$2 = this.stack[this.stack.length - 1]
    if (this.data.atHardBreak) {
      let tail = context$2.children[context$2.children.length - 1]
      tail.position.end = point$1(token.end), this.data.atHardBreak = void 0
      return
    }
    !this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context$2.type)
      && (onenterdata.call(this, token), onexitdata.call(this, token))
  }
  function onexithardbreak() {
    this.data.atHardBreak = !0
  }
  function onexithtmlflow() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.value = data$1
  }
  function onexithtmltext() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.value = data$1
  }
  function onexitcodetext() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.value = data$1
  }
  function onexitlink() {
    let node$1 = this.stack[this.stack.length - 1]
    if (this.data.inReference) {
      let referenceType = this.data.referenceType || `shortcut`
      node$1.type += `Reference`, node$1.referenceType = referenceType, delete node$1.url, delete node$1.title
    } else delete node$1.identifier, delete node$1.label
    this.data.referenceType = void 0
  }
  function onexitimage() {
    let node$1 = this.stack[this.stack.length - 1]
    if (this.data.inReference) {
      let referenceType = this.data.referenceType || `shortcut`
      node$1.type += `Reference`, node$1.referenceType = referenceType, delete node$1.url, delete node$1.title
    } else delete node$1.identifier, delete node$1.label
    this.data.referenceType = void 0
  }
  function onexitlabeltext(token) {
    let string$5 = this.sliceSerialize(token), ancestor = this.stack[this.stack.length - 2]
    ancestor.label = decodeString(string$5), ancestor.identifier = normalizeIdentifier(string$5).toLowerCase()
  }
  function onexitlabel() {
    let fragment = this.stack[this.stack.length - 1],
      value$2 = this.resume(),
      node$1 = this.stack[this.stack.length - 1]
    if (this.data.inReference = !0, node$1.type === `link`) {
      let children$3 = fragment.children
      node$1.children = children$3
    } else node$1.alt = value$2
  }
  function onexitresourcedestinationstring() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.url = data$1
  }
  function onexitresourcetitlestring() {
    let data$1 = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.title = data$1
  }
  function onexitresource() {
    this.data.inReference = void 0
  }
  function onenterreference() {
    this.data.referenceType = `collapsed`
  }
  function onexitreferencestring(token) {
    let label = this.resume(), node$1 = this.stack[this.stack.length - 1]
    node$1.label = label,
      node$1.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase(),
      this.data.referenceType = `full`
  }
  function onexitcharacterreferencemarker(token) {
    this.data.characterReferenceType = token.type
  }
  function onexitcharacterreferencevalue(token) {
    let data$1 = this.sliceSerialize(token), type$2 = this.data.characterReferenceType, value$2
    if (type$2) {
      value$2 = decodeNumericCharacterReference(data$1, type$2 === `characterReferenceMarkerNumeric` ? 10 : 16),
        this.data.characterReferenceType = void 0
    } else {
      let result = decodeNamedCharacterReference(data$1)
      value$2 = result
    }
    let tail = this.stack[this.stack.length - 1]
    tail.value += value$2
  }
  function onexitcharacterreference(token) {
    let tail = this.stack.pop()
    tail.position.end = point$1(token.end)
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token)
    let node$1 = this.stack[this.stack.length - 1]
    node$1.url = this.sliceSerialize(token)
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token)
    let node$1 = this.stack[this.stack.length - 1]
    node$1.url = `mailto:` + this.sliceSerialize(token)
  }
  function blockQuote$1() {
    return { type: `blockquote`, children: [] }
  }
  function codeFlow() {
    return { type: `code`, lang: null, meta: null, value: `` }
  }
  function codeText$1() {
    return { type: `inlineCode`, value: `` }
  }
  function definition$2() {
    return { type: `definition`, identifier: ``, label: null, title: null, url: `` }
  }
  function emphasis$2() {
    return { type: `emphasis`, children: [] }
  }
  function heading$2() {
    return { type: `heading`, depth: 0, children: [] }
  }
  function hardBreak$2() {
    return { type: `break` }
  }
  function html$6() {
    return { type: `html`, value: `` }
  }
  function image$2() {
    return { type: `image`, title: null, url: ``, alt: null }
  }
  function link$2() {
    return { type: `link`, title: null, url: ``, children: [] }
  }
  function list$3(token) {
    return { type: `list`, ordered: token.type === `listOrdered`, start: null, spread: token._spread, children: [] }
  }
  function listItem$2(token) {
    return { type: `listItem`, spread: token._spread, checked: null, children: [] }
  }
  function paragraph$2() {
    return { type: `paragraph`, children: [] }
  }
  function strong$2() {
    return { type: `strong`, children: [] }
  }
  function text$6() {
    return { type: `text`, value: `` }
  }
  function thematicBreak$3() {
    return { type: `thematicBreak` }
  }
}
function point$1(d$7) {
  return { line: d$7.line, column: d$7.column, offset: d$7.offset }
}
function configure(combined, extensions) {
  let index$4 = -1
  for (; ++index$4 < extensions.length;) {
    let value$2 = extensions[index$4]
    Array.isArray(value$2) ? configure(combined, value$2) : extension(combined, value$2)
  }
}
function extension(combined, extension$1) {
  let key$1
  for (key$1 in extension$1) {
    if (own$2.call(extension$1, key$1)) {
      switch (key$1) {
        case `canContainEols`: {
          let right$2 = extension$1[key$1]
          right$2 && combined[key$1].push(...right$2)
          break
        }
        case `transforms`: {
          let right$2 = extension$1[key$1]
          right$2 && combined[key$1].push(...right$2)
          break
        }
        case `enter`:
        case `exit`: {
          let right$2 = extension$1[key$1]
          right$2 && Object.assign(combined[key$1], right$2)
          break
        }
      }
    }
  }
}
function defaultOnError(left$2, right$2) {
  throw Error(
    left$2
      ? 'Cannot close `' + left$2.type + '` (' + stringifyPosition({ start: left$2.start, end: left$2.end })
        + '): a different token (`' + right$2.type + '`, '
        + stringifyPosition({ start: right$2.start, end: right$2.end }) + `) is open`
      : 'Cannot close document, a token (`' + right$2.type + '`, '
        + stringifyPosition({ start: right$2.start, end: right$2.end }) + `) is still open`,
  )
}
function remarkParse(options$2) {
  let self$1 = this
  self$1.parser = parser
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self$1.data(`settings`),
      ...options$2,
      extensions: self$1.data(`micromarkExtensions`) || [],
      mdastExtensions: self$1.data(`fromMarkdownExtensions`) || [],
    })
  }
}
function blockquote(state, node$1) {
  let result = { type: `element`, tagName: `blockquote`, properties: {}, children: state.wrap(state.all(node$1), !0) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function hardBreak(state, node$1) {
  let result = { type: `element`, tagName: `br`, properties: {}, children: [] }
  return state.patch(node$1, result), [state.applyData(node$1, result), {
    type: `text`,
    value: `
`,
  }]
}
function code(state, node$1) {
  let value$2 = node$1.value
      ? node$1.value + `
`
      : ``,
    properties = {}
  node$1.lang && (properties.className = [`language-` + node$1.lang])
  let result = { type: `element`, tagName: `code`, properties, children: [{ type: `text`, value: value$2 }] }
  return node$1.meta && (result.data = { meta: node$1.meta }),
    state.patch(node$1, result),
    result = state.applyData(node$1, result),
    result = { type: `element`, tagName: `pre`, properties: {}, children: [result] },
    state.patch(node$1, result),
    result
}
function strikethrough(state, node$1) {
  let result = { type: `element`, tagName: `del`, properties: {}, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function emphasis(state, node$1) {
  let result = { type: `element`, tagName: `em`, properties: {}, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function footnoteReference(state, node$1) {
  let clobberPrefix = typeof state.options.clobberPrefix == `string` ? state.options.clobberPrefix : `user-content-`,
    id$2 = String(node$1.identifier).toUpperCase(),
    safeId = normalizeUri(id$2.toLowerCase()),
    index$4 = state.footnoteOrder.indexOf(id$2),
    counter$5,
    reuseCounter = state.footnoteCounts.get(id$2)
  reuseCounter === void 0
    ? (reuseCounter = 0, state.footnoteOrder.push(id$2), counter$5 = state.footnoteOrder.length)
    : counter$5 = index$4 + 1,
    reuseCounter += 1,
    state.footnoteCounts.set(id$2, reuseCounter)
  let link$2 = {
    type: `element`,
    tagName: `a`,
    properties: {
      href: `#` + clobberPrefix + `fn-` + safeId,
      id: clobberPrefix + `fnref-` + safeId + (reuseCounter > 1 ? `-` + reuseCounter : ``),
      dataFootnoteRef: !0,
      ariaDescribedBy: [`footnote-label`],
    },
    children: [{ type: `text`, value: String(counter$5) }],
  }
  state.patch(node$1, link$2)
  let sup = { type: `element`, tagName: `sup`, properties: {}, children: [link$2] }
  return state.patch(node$1, sup), state.applyData(node$1, sup)
}
function heading(state, node$1) {
  let result = { type: `element`, tagName: `h` + node$1.depth, properties: {}, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function html(state, node$1) {
  if (state.options.allowDangerousHtml) {
    let result = { type: `raw`, value: node$1.value }
    return state.patch(node$1, result), state.applyData(node$1, result)
  }
}
function revert(state, node$1) {
  let subtype = node$1.referenceType, suffix$1 = `]`
  if (
    subtype === `collapsed`
      ? suffix$1 += `[]`
      : subtype === `full` && (suffix$1 += `[` + (node$1.label || node$1.identifier) + `]`),
      node$1.type === `imageReference`
  ) return [{ type: `text`, value: `![` + node$1.alt + suffix$1 }]
  let contents = state.all(node$1), head$5 = contents[0]
  head$5 && head$5.type === `text` ? head$5.value = `[` + head$5.value : contents.unshift({ type: `text`, value: `[` })
  let tail = contents[contents.length - 1]
  return tail && tail.type === `text` ? tail.value += suffix$1 : contents.push({ type: `text`, value: suffix$1 }),
    contents
}
function imageReference(state, node$1) {
  let id$2 = String(node$1.identifier).toUpperCase(), definition$2 = state.definitionById.get(id$2)
  if (!definition$2) return revert(state, node$1)
  let properties = { src: normalizeUri(definition$2.url || ``), alt: node$1.alt }
  definition$2.title !== null && definition$2.title !== void 0 && (properties.title = definition$2.title)
  let result = { type: `element`, tagName: `img`, properties, children: [] }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function image(state, node$1) {
  let properties = { src: normalizeUri(node$1.url) }
  node$1.alt !== null && node$1.alt !== void 0 && (properties.alt = node$1.alt),
    node$1.title !== null && node$1.title !== void 0 && (properties.title = node$1.title)
  let result = { type: `element`, tagName: `img`, properties, children: [] }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function inlineCode(state, node$1) {
  let text$6 = { type: `text`, value: node$1.value.replace(/\r?\n|\r/g, ` `) }
  state.patch(node$1, text$6)
  let result = { type: `element`, tagName: `code`, properties: {}, children: [text$6] }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function linkReference(state, node$1) {
  let id$2 = String(node$1.identifier).toUpperCase(), definition$2 = state.definitionById.get(id$2)
  if (!definition$2) return revert(state, node$1)
  let properties = { href: normalizeUri(definition$2.url || ``) }
  definition$2.title !== null && definition$2.title !== void 0 && (properties.title = definition$2.title)
  let result = { type: `element`, tagName: `a`, properties, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function link(state, node$1) {
  let properties = { href: normalizeUri(node$1.url) }
  node$1.title !== null && node$1.title !== void 0 && (properties.title = node$1.title)
  let result = { type: `element`, tagName: `a`, properties, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function listItem(state, node$1, parent) {
  let results = state.all(node$1),
    loose = parent ? listLoose(parent) : listItemLoose(node$1),
    properties = {},
    children$3 = []
  if (typeof node$1.checked == `boolean`) {
    let head$5 = results[0], paragraph$2
    head$5 && head$5.type === `element` && head$5.tagName === `p`
      ? paragraph$2 = head$5
      : (paragraph$2 = { type: `element`, tagName: `p`, properties: {}, children: [] }, results.unshift(paragraph$2)),
      paragraph$2.children.length > 0 && paragraph$2.children.unshift({ type: `text`, value: ` ` }),
      paragraph$2.children.unshift({
        type: `element`,
        tagName: `input`,
        properties: { type: `checkbox`, checked: node$1.checked, disabled: !0 },
        children: [],
      }),
      properties.className = [`task-list-item`]
  }
  let index$4 = -1
  for (; ++index$4 < results.length;) {
    let child = results[index$4]
    ;(loose || index$4 !== 0 || child.type !== `element` || child.tagName !== `p`)
      && children$3.push({
        type: `text`,
        value: `
`,
      }),
      child.type === `element` && child.tagName === `p` && !loose
        ? children$3.push(...child.children)
        : children$3.push(child)
  }
  let tail = results[results.length - 1]
  tail && (loose || tail.type !== `element` || tail.tagName !== `p`) && children$3.push({
    type: `text`,
    value: `
`,
  })
  let result = { type: `element`, tagName: `li`, properties, children: children$3 }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function listLoose(node$1) {
  let loose = !1
  if (node$1.type === `list`) {
    loose = node$1.spread || !1
    let children$3 = node$1.children, index$4 = -1
    for (; !loose && ++index$4 < children$3.length;) loose = listItemLoose(children$3[index$4])
  }
  return loose
}
function listItemLoose(node$1) {
  let spread = node$1.spread
  return spread ?? node$1.children.length > 1
}
function list(state, node$1) {
  let properties = {}, results = state.all(node$1), index$4 = -1
  for (
    typeof node$1.start == `number` && node$1.start !== 1 && (properties.start = node$1.start);
    ++index$4 < results.length;
  ) {
    let child = results[index$4]
    if (
      child.type === `element` && child.tagName === `li` && child.properties
      && Array.isArray(child.properties.className) && child.properties.className.includes(`task-list-item`)
    ) {
      properties.className = [`contains-task-list`]
      break
    }
  }
  let result = { type: `element`, tagName: node$1.ordered ? `ol` : `ul`, properties, children: state.wrap(results, !0) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function paragraph(state, node$1) {
  let result = { type: `element`, tagName: `p`, properties: {}, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function root$1(state, node$1) {
  let result = { type: `root`, children: state.wrap(state.all(node$1)) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function strong(state, node$1) {
  let result = { type: `element`, tagName: `strong`, properties: {}, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
const pointEnd = point(`end`), pointStart = point(`start`)
function point(type$2) {
  return point$3
  function point$3(node$1) {
    let point$4 = node$1 && node$1.position && node$1.position[type$2] || {}
    if (
      typeof point$4.line == `number` && point$4.line > 0 && typeof point$4.column == `number` && point$4.column > 0
    ) {
      return {
        line: point$4.line,
        column: point$4.column,
        offset: typeof point$4.offset == `number` && point$4.offset > -1 ? point$4.offset : void 0,
      }
    }
  }
}
function position(node$1) {
  let start$2 = pointStart(node$1), end$2 = pointEnd(node$1)
  if (start$2 && end$2) return { start: start$2, end: end$2 }
}
function table(state, node$1) {
  let rows = state.all(node$1), firstRow = rows.shift(), tableContent = []
  if (firstRow) {
    let head$5 = { type: `element`, tagName: `thead`, properties: {}, children: state.wrap([firstRow], !0) }
    state.patch(node$1.children[0], head$5), tableContent.push(head$5)
  }
  if (rows.length > 0) {
    let body$2 = { type: `element`, tagName: `tbody`, properties: {}, children: state.wrap(rows, !0) },
      start$2 = pointStart(node$1.children[1]),
      end$2 = pointEnd(node$1.children[node$1.children.length - 1])
    start$2 && end$2 && (body$2.position = { start: start$2, end: end$2 }), tableContent.push(body$2)
  }
  let result = { type: `element`, tagName: `table`, properties: {}, children: state.wrap(tableContent, !0) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function tableRow(state, node$1, parent) {
  let siblings$1 = parent ? parent.children : void 0,
    rowIndex = siblings$1 ? siblings$1.indexOf(node$1) : 1,
    tagName = rowIndex === 0 ? `th` : `td`,
    align = parent && parent.type === `table` ? parent.align : void 0,
    length$1 = align ? align.length : node$1.children.length,
    cellIndex = -1,
    cells$1 = []
  for (; ++cellIndex < length$1;) {
    let cell = node$1.children[cellIndex], properties = {}, alignValue = align ? align[cellIndex] : void 0
    alignValue && (properties.align = alignValue)
    let result$1 = { type: `element`, tagName, properties, children: [] }
    cell
    && (result$1.children = state.all(cell), state.patch(cell, result$1), result$1 = state.applyData(cell, result$1)),
      cells$1.push(result$1)
  }
  let result = { type: `element`, tagName: `tr`, properties: {}, children: state.wrap(cells$1, !0) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function tableCell(state, node$1) {
  let result = { type: `element`, tagName: `td`, properties: {}, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
const tab = 9, space = 32
function trimLines(value$2) {
  let source = String(value$2), search$1 = /\r?\n|\r/g, match$13 = search$1.exec(source), last$3 = 0, lines = []
  for (; match$13;) {
    lines.push(trimLine(source.slice(last$3, match$13.index), last$3 > 0, !0), match$13[0]),
      last$3 = match$13.index + match$13[0].length,
      match$13 = search$1.exec(source)
  }
  return lines.push(trimLine(source.slice(last$3), last$3 > 0, !1)), lines.join(``)
}
function trimLine(value$2, start$2, end$2) {
  let startIndex = 0, endIndex = value$2.length
  if (start$2) {
    let code$3 = value$2.codePointAt(startIndex)
    for (; code$3 === tab || code$3 === space;) startIndex++, code$3 = value$2.codePointAt(startIndex)
  }
  if (end$2) {
    let code$3 = value$2.codePointAt(endIndex - 1)
    for (; code$3 === tab || code$3 === space;) endIndex--, code$3 = value$2.codePointAt(endIndex - 1)
  }
  return endIndex > startIndex ? value$2.slice(startIndex, endIndex) : ``
}
function text(state, node$1) {
  let result = { type: `text`, value: trimLines(String(node$1.value)) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function thematicBreak(state, node$1) {
  let result = { type: `element`, tagName: `hr`, properties: {}, children: [] }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
const handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  root: root$1,
  strong,
  table,
  tableCell,
  tableRow,
  text,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore,
}
function ignore() {}
const VOID = -1,
  PRIMITIVE = 0,
  ARRAY = 1,
  OBJECT = 2,
  DATE = 3,
  REGEXP = 4,
  MAP = 5,
  SET = 6,
  ERROR = 7,
  BIGINT = 8,
  env = typeof self == `object` ? self : globalThis,
  deserializer = ($$1, _$1) => {
    let as$6 = (out, index$4) => ($$1.set(index$4, out), out),
      unpair = index$4 => {
        if ($$1.has(index$4)) return $$1.get(index$4)
        let [type$2, value$2] = _$1[index$4]
        switch (type$2) {
          case PRIMITIVE:
          case VOID:
            return as$6(value$2, index$4)
          case ARRAY: {
            let arr = as$6([], index$4)
            for (let index$5 of value$2) arr.push(unpair(index$5))
            return arr
          }
          case OBJECT: {
            let object = as$6({}, index$4)
            for (let [key$1, index$5] of value$2) object[unpair(key$1)] = unpair(index$5)
            return object
          }
          case DATE:
            return as$6(new Date(value$2), index$4)
          case REGEXP: {
            let { source, flags } = value$2
            return as$6(new RegExp(source, flags), index$4)
          }
          case MAP: {
            let map$20 = as$6(new Map(), index$4)
            for (let [key$1, index$5] of value$2) map$20.set(unpair(key$1), unpair(index$5))
            return map$20
          }
          case SET: {
            let set$6 = as$6(new Set(), index$4)
            for (let index$5 of value$2) set$6.add(unpair(index$5))
            return set$6
          }
          case ERROR: {
            let { name, message } = value$2
            return as$6(new env[name](message), index$4)
          }
          case BIGINT:
            return as$6(BigInt(value$2), index$4)
          case `BigInt`:
            return as$6(Object(BigInt(value$2)), index$4)
          case `ArrayBuffer`:
            return as$6(new Uint8Array(value$2).buffer, value$2)
          case `DataView`: {
            let { buffer } = new Uint8Array(value$2)
            return as$6(new DataView(buffer), value$2)
          }
        }
        return as$6(new env[type$2](value$2), index$4)
      }
    return unpair
  },
  deserialize = serialized => deserializer(new Map(), serialized)(0),
  EMPTY = ``,
  { toString } = {},
  { keys } = Object,
  typeOf = value$2 => {
    let type$2 = typeof value$2
    if (type$2 !== `object` || !value$2) return [PRIMITIVE, type$2]
    let asString = toString.call(value$2).slice(8, -1)
    switch (asString) {
      case `Array`:
        return [ARRAY, EMPTY]
      case `Object`:
        return [OBJECT, EMPTY]
      case `Date`:
        return [DATE, EMPTY]
      case `RegExp`:
        return [REGEXP, EMPTY]
      case `Map`:
        return [MAP, EMPTY]
      case `Set`:
        return [SET, EMPTY]
      case `DataView`:
        return [ARRAY, asString]
    }
    return asString.includes(`Array`)
      ? [ARRAY, asString]
      : asString.includes(`Error`)
      ? [ERROR, asString]
      : [OBJECT, asString]
  },
  shouldSkip = ([TYPE, type$2]) => TYPE === PRIMITIVE && (type$2 === `function` || type$2 === `symbol`),
  serializer = (strict$1, json, $$1, _$1) => {
    let as$6 = (out, value$2) => {
        let index$4 = _$1.push(out) - 1
        return $$1.set(value$2, index$4), index$4
      },
      pair = value$2 => {
        if ($$1.has(value$2)) return $$1.get(value$2)
        let [TYPE, type$2] = typeOf(value$2)
        switch (TYPE) {
          case PRIMITIVE: {
            let entry = value$2
            switch (type$2) {
              case `bigint`:
                TYPE = BIGINT, entry = value$2.toString()
                break
              case `function`:
              case `symbol`:
                if (strict$1) throw TypeError(`unable to serialize ` + type$2)
                entry = null
                break
              case `undefined`:
                return as$6([VOID], value$2)
            }
            return as$6([TYPE, entry], value$2)
          }
          case ARRAY: {
            if (type$2) {
              let spread = value$2
              return type$2 === `DataView`
                ? spread = new Uint8Array(value$2.buffer)
                : type$2 === `ArrayBuffer` && (spread = new Uint8Array(value$2)),
                as$6([type$2, [...spread]], value$2)
            }
            let arr = [], index$4 = as$6([TYPE, arr], value$2)
            for (let entry of value$2) arr.push(pair(entry))
            return index$4
          }
          case OBJECT: {
            if (type$2) {
              switch (type$2) {
                case `BigInt`:
                  return as$6([type$2, value$2.toString()], value$2)
                case `Boolean`:
                case `Number`:
                case `String`:
                  return as$6([type$2, value$2.valueOf()], value$2)
              }
            }
            if (json && `toJSON` in value$2) return pair(value$2.toJSON())
            let entries$2 = [], index$4 = as$6([TYPE, entries$2], value$2)
            for (let key$1 of keys(value$2)) {
              ;(strict$1 || !shouldSkip(typeOf(value$2[key$1]))) && entries$2.push([pair(key$1), pair(value$2[key$1])])
            }
            return index$4
          }
          case DATE:
            return as$6([TYPE, value$2.toISOString()], value$2)
          case REGEXP: {
            let { source, flags } = value$2
            return as$6([TYPE, { source, flags }], value$2)
          }
          case MAP: {
            let entries$2 = [], index$4 = as$6([TYPE, entries$2], value$2)
            for (let [key$1, entry] of value$2) {
              ;(strict$1 || !(shouldSkip(typeOf(key$1)) || shouldSkip(typeOf(entry))))
                && entries$2.push([pair(key$1), pair(entry)])
            }
            return index$4
          }
          case SET: {
            let entries$2 = [], index$4 = as$6([TYPE, entries$2], value$2)
            for (let entry of value$2) (strict$1 || !shouldSkip(typeOf(entry))) && entries$2.push(pair(entry))
            return index$4
          }
        }
        let { message } = value$2
        return as$6([TYPE, { name: type$2, message }], value$2)
      }
    return pair
  },
  serialize = (value$2, { json, lossy } = {}) => {
    let _$1 = []
    return serializer(!(json || lossy), !!json, new Map(), _$1)(value$2), _$1
  }
var esm_default = typeof structuredClone == `function`
  ? (any$2, options$2) =>
    options$2 && (`json` in options$2 || `lossy` in options$2)
      ? deserialize(serialize(any$2, options$2))
      : structuredClone(any$2)
  : (any$2, options$2) => deserialize(serialize(any$2, options$2))
function defaultFootnoteBackContent(_$1, rereferenceIndex) {
  let result = [{ type: `text`, value: `` }]
  return rereferenceIndex > 1
    && result.push({
      type: `element`,
      tagName: `sup`,
      properties: {},
      children: [{ type: `text`, value: String(rereferenceIndex) }],
    }),
    result
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return `Back to reference ` + (referenceIndex + 1) + (rereferenceIndex > 1 ? `-` + rereferenceIndex : ``)
}
function footer(state) {
  let clobberPrefix = typeof state.options.clobberPrefix == `string` ? state.options.clobberPrefix : `user-content-`,
    footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent,
    footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel,
    footnoteLabel = state.options.footnoteLabel || `Footnotes`,
    footnoteLabelTagName = state.options.footnoteLabelTagName || `h2`,
    footnoteLabelProperties = state.options.footnoteLabelProperties || { className: [`sr-only`] },
    listItems = [],
    referenceIndex = -1
  for (; ++referenceIndex < state.footnoteOrder.length;) {
    let definition$2 = state.footnoteById.get(state.footnoteOrder[referenceIndex])
    if (!definition$2) continue
    let content$2 = state.all(definition$2),
      id$2 = String(definition$2.identifier).toUpperCase(),
      safeId = normalizeUri(id$2.toLowerCase()),
      rereferenceIndex = 0,
      backReferences = [],
      counts = state.footnoteCounts.get(id$2)
    for (; counts !== void 0 && ++rereferenceIndex <= counts;) {
      backReferences.length > 0 && backReferences.push({ type: `text`, value: ` ` })
      let children$3 = typeof footnoteBackContent == `string`
        ? footnoteBackContent
        : footnoteBackContent(referenceIndex, rereferenceIndex)
      typeof children$3 == `string` && (children$3 = { type: `text`, value: children$3 }),
        backReferences.push({
          type: `element`,
          tagName: `a`,
          properties: {
            href: `#` + clobberPrefix + `fnref-` + safeId + (rereferenceIndex > 1 ? `-` + rereferenceIndex : ``),
            dataFootnoteBackref: ``,
            ariaLabel: typeof footnoteBackLabel == `string`
              ? footnoteBackLabel
              : footnoteBackLabel(referenceIndex, rereferenceIndex),
            className: [`data-footnote-backref`],
          },
          children: Array.isArray(children$3) ? children$3 : [children$3],
        })
    }
    let tail = content$2[content$2.length - 1]
    if (tail && tail.type === `element` && tail.tagName === `p`) {
      let tailTail = tail.children[tail.children.length - 1]
      tailTail && tailTail.type === `text` ? tailTail.value += ` ` : tail.children.push({ type: `text`, value: ` ` }),
        tail.children.push(...backReferences)
    } else content$2.push(...backReferences)
    let listItem$2 = {
      type: `element`,
      tagName: `li`,
      properties: { id: clobberPrefix + `fn-` + safeId },
      children: state.wrap(content$2, !0),
    }
    state.patch(definition$2, listItem$2), listItems.push(listItem$2)
  }
  if (listItems.length !== 0) {
    return {
      type: `element`,
      tagName: `section`,
      properties: { dataFootnotes: !0, className: [`footnotes`] },
      children: [
        {
          type: `element`,
          tagName: footnoteLabelTagName,
          properties: { ...esm_default(footnoteLabelProperties), id: `footnote-label` },
          children: [{ type: `text`, value: footnoteLabel }],
        },
        {
          type: `text`,
          value: `
`,
        },
        { type: `element`, tagName: `ol`, properties: {}, children: state.wrap(listItems, !0) },
        {
          type: `text`,
          value: `
`,
        },
      ],
    }
  }
}
const own$1 = {}.hasOwnProperty, emptyOptions = {}
function createState(tree, options$2) {
  let settings = options$2 || emptyOptions,
    definitionById = new Map(),
    footnoteById = new Map(),
    footnoteCounts = new Map(),
    handlers$1 = { ...handlers, ...settings.handlers },
    state = {
      all: all$8,
      applyData,
      definitionById,
      footnoteById,
      footnoteCounts,
      footnoteOrder: [],
      handlers: handlers$1,
      one: one$2,
      options: settings,
      patch,
      wrap: wrap$1,
    }
  return visit(tree, function(node$1) {
    if (node$1.type === `definition` || node$1.type === `footnoteDefinition`) {
      let map$20 = node$1.type === `definition` ? definitionById : footnoteById,
        id$2 = String(node$1.identifier).toUpperCase()
      map$20.has(id$2) || map$20.set(id$2, node$1)
    }
  }),
    state
  function one$2(node$1, parent) {
    let type$2 = node$1.type, handle$2 = state.handlers[type$2]
    if (own$1.call(state.handlers, type$2) && handle$2) return handle$2(state, node$1, parent)
    if (state.options.passThrough && state.options.passThrough.includes(type$2)) {
      if (`children` in node$1) {
        let { children: children$3, ...shallow } = node$1, result = esm_default(shallow)
        return result.children = state.all(node$1), result
      }
      return esm_default(node$1)
    }
    let unknown$1 = state.options.unknownHandler || defaultUnknownHandler
    return unknown$1(state, node$1, parent)
  }
  function all$8(parent) {
    let values$6 = []
    if (`children` in parent) {
      let nodes = parent.children, index$4 = -1
      for (; ++index$4 < nodes.length;) {
        let result = state.one(nodes[index$4], parent)
        if (result) {
          if (
            index$4 && nodes[index$4 - 1].type === `break`
            && (!Array.isArray(result) && result.type === `text`
              && (result.value = trimMarkdownSpaceStart(result.value)),
              !Array.isArray(result) && result.type === `element`)
          ) {
            let head$5 = result.children[0]
            head$5 && head$5.type === `text` && (head$5.value = trimMarkdownSpaceStart(head$5.value))
          }
          Array.isArray(result) ? values$6.push(...result) : values$6.push(result)
        }
      }
    }
    return values$6
  }
}
function patch(from, to) {
  from.position && (to.position = position(from))
}
function applyData(from, to) {
  let result = to
  if (from && from.data) {
    let hName = from.data.hName, hChildren = from.data.hChildren, hProperties = from.data.hProperties
    if (typeof hName == `string`) {
      if (result.type === `element`) result.tagName = hName
      else {
        let children$3 = `children` in result ? result.children : [result]
        result = { type: `element`, tagName: hName, properties: {}, children: children$3 }
      }
    }
    result.type === `element` && hProperties && Object.assign(result.properties, esm_default(hProperties)),
      `children` in result && result.children && hChildren != null && (result.children = hChildren)
  }
  return result
}
function defaultUnknownHandler(state, node$1) {
  let data = node$1.data || {},
    result = `value` in node$1 && !(own$1.call(data, `hProperties`) || own$1.call(data, `hChildren`))
      ? { type: `text`, value: node$1.value }
      : { type: `element`, tagName: `div`, properties: {}, children: state.all(node$1) }
  return state.patch(node$1, result), state.applyData(node$1, result)
}
function wrap$1(nodes, loose) {
  let result = [], index$4 = -1
  for (
    loose && result.push({
      type: `text`,
      value: `
`,
    });
    ++index$4 < nodes.length;
  ) {
    index$4 && result.push({
      type: `text`,
      value: `
`,
    }), result.push(nodes[index$4])
  }
  return loose && nodes.length > 0 && result.push({
    type: `text`,
    value: `
`,
  }),
    result
}
function trimMarkdownSpaceStart(value$2) {
  let index$4 = 0, code$3 = value$2.charCodeAt(index$4)
  for (; code$3 === 9 || code$3 === 32;) index$4++, code$3 = value$2.charCodeAt(index$4)
  return value$2.slice(index$4)
}
function toHast(tree, options$2) {
  let state = createState(tree, options$2),
    node$1 = state.one(tree, void 0),
    foot = footer(state),
    result = Array.isArray(node$1) ? { type: `root`, children: node$1 } : node$1 || { type: `root`, children: [] }
  return foot && (`children` in result,
    result.children.push({
      type: `text`,
      value: `
`,
    }, foot)),
    result
}
function remarkRehype(destination, options$2) {
  return destination && `run` in destination
    ? async function(tree, file) {
      let hastTree = toHast(tree, { file, ...options$2 })
      await destination.run(hastTree, file)
    }
    : function(tree, file) {
      return toHast(tree, { file, ...destination || options$2 })
    }
}
function bail(error) {
  if (error) throw error
}
var require_extend = __commonJSMin((exports, module) => {
  var hasOwn = Object.prototype.hasOwnProperty,
    toStr = Object.prototype.toString,
    defineProperty = Object.defineProperty,
    gOPD = Object.getOwnPropertyDescriptor,
    isArray = function(arr) {
      return typeof Array.isArray == `function` ? Array.isArray(arr) : toStr.call(arr) === `[object Array]`
    },
    isPlainObject$1 = function(obj) {
      if (!obj || toStr.call(obj) !== `[object Object]`) return !1
      var hasOwnConstructor = hasOwn.call(obj, `constructor`),
        hasIsPrototypeOf = obj.constructor && obj.constructor.prototype
          && hasOwn.call(obj.constructor.prototype, `isPrototypeOf`)
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return !1
      for (var key$1 in obj);
      return key$1 === void 0 || hasOwn.call(obj, key$1)
    },
    setProperty = function(target, options$2) {
      defineProperty && options$2.name === `__proto__`
        ? defineProperty(target, options$2.name, {
          enumerable: !0,
          configurable: !0,
          value: options$2.newValue,
          writable: !0,
        })
        : target[options$2.name] = options$2.newValue
    },
    getProperty = function(obj, name) {
      if (name === `__proto__`) {
        if (hasOwn.call(obj, name)) {
          if (gOPD) return gOPD(obj, name).value
          else return
        }
      }
      return obj[name]
    }
  module.exports = function extend$4() {
    var options$2,
      name,
      src,
      copy$2,
      copyIsArray,
      clone$1,
      target = arguments[0],
      i$14 = 1,
      length$1 = arguments.length,
      deep = !1
    for (
      typeof target == `boolean` && (deep = target, target = arguments[1] || {}, i$14 = 2),
        (target == null || typeof target != `object` && typeof target != `function`) && (target = {});
      i$14 < length$1;
      ++i$14
    ) {
      if (options$2 = arguments[i$14], options$2 != null) {
        for (name in options$2) {
          src = getProperty(target, name),
            copy$2 = getProperty(options$2, name),
            target !== copy$2 && (deep && copy$2 && (isPlainObject$1(copy$2) || (copyIsArray = isArray(copy$2)))
              ? (copyIsArray
                ? (copyIsArray = !1, clone$1 = src && isArray(src) ? src : [])
                : clone$1 = src && isPlainObject$1(src) ? src : {},
                setProperty(target, { name, newValue: extend$4(deep, clone$1, copy$2) }))
              : copy$2 !== void 0 && setProperty(target, { name, newValue: copy$2 }))
        }
      }
    }
    return target
  }
})
function isPlainObject(value$2) {
  if (typeof value$2 != `object` || !value$2) return !1
  let prototype = Object.getPrototypeOf(value$2)
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null)
    && !(Symbol.toStringTag in value$2) && !(Symbol.iterator in value$2)
}
function trough() {
  let fns = [], pipeline = { run, use: use$2 }
  return pipeline
  function run(...values$6) {
    let middlewareIndex = -1, callback = values$6.pop()
    if (typeof callback != `function`) throw TypeError(`Expected function as last argument, not ` + callback)
    next(null, ...values$6)
    function next(error, ...output) {
      let fn = fns[++middlewareIndex], index$4 = -1
      if (error) {
        callback(error)
        return
      }
      for (; ++index$4 < values$6.length;) {
        ;(output[index$4] === null || output[index$4] === void 0) && (output[index$4] = values$6[index$4])
      }
      values$6 = output, fn ? wrap(fn, next)(...output) : callback(null, ...output)
    }
  }
  function use$2(middelware) {
    if (typeof middelware != `function`) throw TypeError('Expected `middelware` to be a function, not ' + middelware)
    return fns.push(middelware), pipeline
  }
}
function wrap(middleware, callback) {
  let called
  return wrapped
  function wrapped(...parameters) {
    let fnExpectsCallback = middleware.length > parameters.length, result
    fnExpectsCallback && parameters.push(done$8)
    try {
      result = middleware.apply(this, parameters)
    } catch (error) {
      let exception = error
      if (fnExpectsCallback && called) throw exception
      return done$8(exception)
    }
    fnExpectsCallback
      || (result && result.then && typeof result.then == `function`
        ? result.then(then, done$8)
        : result instanceof Error
        ? done$8(result)
        : then(result))
  }
  function done$8(error, ...output) {
    called || (called = !0, callback(error, ...output))
  }
  function then(value$2) {
    done$8(null, value$2)
  }
}
var VFileMessage = class extends Error {
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super(),
      typeof optionsOrParentOrPlace == `string` && (origin = optionsOrParentOrPlace, optionsOrParentOrPlace = void 0)
    let reason = ``, options$2 = {}, legacyCause = !1
    if (
      optionsOrParentOrPlace
      && (options$2 = `line` in optionsOrParentOrPlace && `column` in optionsOrParentOrPlace
          || `start` in optionsOrParentOrPlace && `end` in optionsOrParentOrPlace
        ? { place: optionsOrParentOrPlace }
        : `type` in optionsOrParentOrPlace
        ? { ancestors: [optionsOrParentOrPlace], place: optionsOrParentOrPlace.position }
        : { ...optionsOrParentOrPlace }),
        typeof causeOrReason == `string`
          ? reason = causeOrReason
          : !options$2.cause && causeOrReason
            && (legacyCause = !0, reason = causeOrReason.message, options$2.cause = causeOrReason),
        !options$2.ruleId && !options$2.source && typeof origin == `string`
    ) {
      let index$4 = origin.indexOf(`:`)
      index$4 === -1
        ? options$2.ruleId = origin
        : (options$2.source = origin.slice(0, index$4), options$2.ruleId = origin.slice(index$4 + 1))
    }
    if (!options$2.place && options$2.ancestors && options$2.ancestors) {
      let parent = options$2.ancestors[options$2.ancestors.length - 1]
      parent && (options$2.place = parent.position)
    }
    let start$2 = options$2.place && `start` in options$2.place ? options$2.place.start : options$2.place
    this.ancestors = options$2.ancestors || void 0,
      this.cause = options$2.cause || void 0,
      this.column = start$2 ? start$2.column : void 0,
      this.fatal = void 0,
      this.file,
      this.message = reason,
      this.line = start$2 ? start$2.line : void 0,
      this.name = stringifyPosition(options$2.place) || `1:1`,
      this.place = options$2.place || void 0,
      this.reason = this.message,
      this.ruleId = options$2.ruleId || void 0,
      this.source = options$2.source || void 0,
      this.stack = legacyCause && options$2.cause && typeof options$2.cause.stack == `string`
        ? options$2.cause.stack
        : ``,
      this.actual,
      this.expected,
      this.note,
      this.url
  }
}
VFileMessage.prototype.file = ``,
  VFileMessage.prototype.name = ``,
  VFileMessage.prototype.reason = ``,
  VFileMessage.prototype.message = ``,
  VFileMessage.prototype.stack = ``,
  VFileMessage.prototype.column = void 0,
  VFileMessage.prototype.line = void 0,
  VFileMessage.prototype.ancestors = void 0,
  VFileMessage.prototype.cause = void 0,
  VFileMessage.prototype.fatal = void 0,
  VFileMessage.prototype.place = void 0,
  VFileMessage.prototype.ruleId = void 0,
  VFileMessage.prototype.source = void 0
const minpath = { basename, dirname, extname, join, sep: `/` }
function basename(path$1, extname$1) {
  if (extname$1 !== void 0 && typeof extname$1 != `string`) throw TypeError(`"ext" argument must be a string`)
  assertPath$1(path$1)
  let start$2 = 0, end$2 = -1, index$4 = path$1.length, seenNonSlash
  if (extname$1 === void 0 || extname$1.length === 0 || extname$1.length > path$1.length) {
    for (; index$4--;) {
      if (path$1.codePointAt(index$4) === 47) {
        if (seenNonSlash) {
          start$2 = index$4 + 1
          break
        }
      } else end$2 < 0 && (seenNonSlash = !0, end$2 = index$4 + 1)
    }
    return end$2 < 0 ? `` : path$1.slice(start$2, end$2)
  }
  if (extname$1 === path$1) return ``
  let firstNonSlashEnd = -1, extnameIndex = extname$1.length - 1
  for (; index$4--;) {
    if (path$1.codePointAt(index$4) === 47) {
      if (seenNonSlash) {
        start$2 = index$4 + 1
        break
      }
    } else {firstNonSlashEnd < 0 && (seenNonSlash = !0, firstNonSlashEnd = index$4 + 1),
        extnameIndex > -1 && (path$1.codePointAt(index$4) === extname$1.codePointAt(extnameIndex--)
          ? extnameIndex < 0 && (end$2 = index$4)
          : (extnameIndex = -1, end$2 = firstNonSlashEnd))}
  }
  return start$2 === end$2 ? end$2 = firstNonSlashEnd : end$2 < 0 && (end$2 = path$1.length),
    path$1.slice(start$2, end$2)
}
function dirname(path$1) {
  if (assertPath$1(path$1), path$1.length === 0) return `.`
  let end$2 = -1, index$4 = path$1.length, unmatchedSlash
  for (; --index$4;) {
    if (path$1.codePointAt(index$4) === 47) {
      if (unmatchedSlash) {
        end$2 = index$4
        break
      }
    } else unmatchedSlash ||= !0
  }
  return end$2 < 0
    ? path$1.codePointAt(0) === 47 ? `/` : `.`
    : end$2 === 1 && path$1.codePointAt(0) === 47
    ? `//`
    : path$1.slice(0, end$2)
}
function extname(path$1) {
  assertPath$1(path$1)
  let index$4 = path$1.length, end$2 = -1, startPart = 0, startDot = -1, preDotState = 0, unmatchedSlash
  for (; index$4--;) {
    let code$3 = path$1.codePointAt(index$4)
    if (code$3 === 47) {
      if (unmatchedSlash) {
        startPart = index$4 + 1
        break
      }
      continue
    }
    end$2 < 0 && (unmatchedSlash = !0, end$2 = index$4 + 1),
      code$3 === 46
        ? startDot < 0 ? startDot = index$4 : preDotState !== 1 && (preDotState = 1)
        : startDot > -1 && (preDotState = -1)
  }
  return startDot < 0 || end$2 < 0 || preDotState === 0
      || preDotState === 1 && startDot === end$2 - 1 && startDot === startPart + 1
    ? ``
    : path$1.slice(startDot, end$2)
}
function join(...segments) {
  let index$4 = -1, joined
  for (; ++index$4 < segments.length;) {
    assertPath$1(segments[index$4]),
      segments[index$4] && (joined = joined === void 0 ? segments[index$4] : joined + `/` + segments[index$4])
  }
  return joined === void 0 ? `.` : normalize(joined)
}
function normalize(path$1) {
  assertPath$1(path$1)
  let absolute = path$1.codePointAt(0) === 47, value$2 = normalizeString(path$1, !absolute)
  return value$2.length === 0 && !absolute && (value$2 = `.`),
    value$2.length > 0 && path$1.codePointAt(path$1.length - 1) === 47 && (value$2 += `/`),
    absolute ? `/` + value$2 : value$2
}
function normalizeString(path$1, allowAboveRoot) {
  let result = ``, lastSegmentLength = 0, lastSlash = -1, dots = 0, index$4 = -1, code$3, lastSlashIndex
  for (; ++index$4 <= path$1.length;) {
    if (index$4 < path$1.length) code$3 = path$1.codePointAt(index$4)
    else if (code$3 === 47) break
    else code$3 = 47
    if (code$3 === 47) {
      if (!(lastSlash === index$4 - 1 || dots === 1)) {
        if (lastSlash !== index$4 - 1 && dots === 2) {
          if (
            result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46
            || result.codePointAt(result.length - 2) !== 46
          ) {
            if (result.length > 2) {
              if (lastSlashIndex = result.lastIndexOf(`/`), lastSlashIndex !== result.length - 1) {
                lastSlashIndex < 0
                  ? (result = ``, lastSegmentLength = 0)
                  : (result = result.slice(0, lastSlashIndex),
                    lastSegmentLength = result.length - 1 - result.lastIndexOf(`/`)),
                  lastSlash = index$4,
                  dots = 0
                continue
              }
            } else if (result.length > 0) {
              result = ``, lastSegmentLength = 0, lastSlash = index$4, dots = 0
              continue
            }
          }
          allowAboveRoot && (result = result.length > 0 ? result + `/..` : `..`, lastSegmentLength = 2)
        } else {result.length > 0
            ? result += `/` + path$1.slice(lastSlash + 1, index$4)
            : result = path$1.slice(lastSlash + 1, index$4),
            lastSegmentLength = index$4 - lastSlash - 1}
      }
      lastSlash = index$4, dots = 0
    } else code$3 === 46 && dots > -1 ? dots++ : dots = -1
  }
  return result
}
function assertPath$1(path$1) {
  if (typeof path$1 != `string`) throw TypeError(`Path must be a string. Received ` + JSON.stringify(path$1))
}
const minproc = { cwd }
function cwd() {
  return `/`
}
function isUrl(fileUrlOrPath) {
  return !!(typeof fileUrlOrPath == `object` && fileUrlOrPath && `href` in fileUrlOrPath && fileUrlOrPath.href
    && `protocol` in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === void 0)
}
function urlToPath(path$1) {
  if (typeof path$1 == `string`) path$1 = new URL(path$1)
  else if (!isUrl(path$1)) {
    let error = TypeError('The "path" argument must be of type string or an instance of URL. Received `' + path$1 + '`')
    throw error.code = `ERR_INVALID_ARG_TYPE`, error
  }
  if (path$1.protocol !== `file:`) {
    let error = TypeError(`The URL must be of scheme file`)
    throw error.code = `ERR_INVALID_URL_SCHEME`, error
  }
  return getPathFromURLPosix(path$1)
}
function getPathFromURLPosix(url) {
  if (url.hostname !== ``) {
    let error = TypeError(`File URL host must be "localhost" or empty on darwin`)
    throw error.code = `ERR_INVALID_FILE_URL_HOST`, error
  }
  let pathname = url.pathname, index$4 = -1
  for (; ++index$4 < pathname.length;) {
    if (pathname.codePointAt(index$4) === 37 && pathname.codePointAt(index$4 + 1) === 50) {
      let third = pathname.codePointAt(index$4 + 2)
      if (third === 70 || third === 102) {
        let error = TypeError(`File URL path must not include encoded / characters`)
        throw error.code = `ERR_INVALID_FILE_URL_PATH`, error
      }
    }
  }
  return decodeURIComponent(pathname)
}
const order = [`history`, `path`, `basename`, `stem`, `extname`, `dirname`]
var VFile = class {
  constructor(value$2) {
    let options$2
    options$2 = value$2
      ? isUrl(value$2)
        ? { path: value$2 }
        : typeof value$2 == `string` || isUint8Array$1(value$2)
        ? { value: value$2 }
        : value$2
      : {},
      this.cwd = `cwd` in options$2 ? `` : minproc.cwd(),
      this.data = {},
      this.history = [],
      this.messages = [],
      this.value,
      this.map,
      this.result,
      this.stored
    let index$4 = -1
    for (; ++index$4 < order.length;) {
      let field$1 = order[index$4]
      field$1 in options$2 && options$2[field$1] !== void 0 && options$2[field$1] !== null
        && (this[field$1] = field$1 === `history` ? [...options$2[field$1]] : options$2[field$1])
    }
    let field
    for (field in options$2) order.includes(field) || (this[field] = options$2[field])
  }
  get basename() {
    return typeof this.path == `string` ? minpath.basename(this.path) : void 0
  }
  set basename(basename$1) {
    assertNonEmpty(basename$1, `basename`),
      assertPart(basename$1, `basename`),
      this.path = minpath.join(this.dirname || ``, basename$1)
  }
  get dirname() {
    return typeof this.path == `string` ? minpath.dirname(this.path) : void 0
  }
  set dirname(dirname$1) {
    assertPath(this.basename, `dirname`), this.path = minpath.join(dirname$1 || ``, this.basename)
  }
  get extname() {
    return typeof this.path == `string` ? minpath.extname(this.path) : void 0
  }
  set extname(extname$1) {
    if (assertPart(extname$1, `extname`), assertPath(this.dirname, `extname`), extname$1) {
      if (extname$1.codePointAt(0) !== 46) throw Error('`extname` must start with `.`')
      if (extname$1.includes(`.`, 1)) throw Error('`extname` cannot contain multiple dots')
    }
    this.path = minpath.join(this.dirname, this.stem + (extname$1 || ``))
  }
  get path() {
    return this.history[this.history.length - 1]
  }
  set path(path$1) {
    isUrl(path$1) && (path$1 = urlToPath(path$1)),
      assertNonEmpty(path$1, `path`),
      this.path !== path$1 && this.history.push(path$1)
  }
  get stem() {
    return typeof this.path == `string` ? minpath.basename(this.path, this.extname) : void 0
  }
  set stem(stem) {
    assertNonEmpty(stem, `stem`),
      assertPart(stem, `stem`),
      this.path = minpath.join(this.dirname || ``, stem + (this.extname || ``))
  }
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    let message = this.message(causeOrReason, optionsOrParentOrPlace, origin)
    throw message.fatal = !0, message
  }
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    let message = this.message(causeOrReason, optionsOrParentOrPlace, origin)
    return message.fatal = void 0, message
  }
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    let message = new VFileMessage(causeOrReason, optionsOrParentOrPlace, origin)
    return this.path && (message.name = this.path + `:` + message.name, message.file = this.path),
      message.fatal = !1,
      this.messages.push(message),
      message
  }
  toString(encoding) {
    if (this.value === void 0) return ``
    if (typeof this.value == `string`) return this.value
    let decoder$1 = new TextDecoder(encoding || void 0)
    return decoder$1.decode(this.value)
  }
}
function assertPart(part, name) {
  if (part && part.includes(minpath.sep)) {
    throw Error('`' + name + '` cannot be a path: did not expect `' + minpath.sep + '`')
  }
}
function assertNonEmpty(part, name) {
  if (!part) throw Error('`' + name + '` cannot be empty')
}
function assertPath(path$1, name) {
  if (!path$1) throw Error('Setting `' + name + '` requires `path` to be set too')
}
function isUint8Array$1(value$2) {
  return !!(value$2 && typeof value$2 == `object` && `byteLength` in value$2 && `byteOffset` in value$2)
}
const CallableInstance = function(property) {
  let self$1 = this,
    constr = self$1.constructor,
    proto$3 = constr.prototype,
    value$2 = proto$3[property],
    apply = function() {
      return value$2.apply(apply, arguments)
    }
  return Object.setPrototypeOf(apply, proto$3), apply
}
var import_extend = __toESM(require_extend())
const own = {}.hasOwnProperty
var Processor = class Processor extends CallableInstance {
  constructor() {
    super(`copy`),
      this.Compiler = void 0,
      this.Parser = void 0,
      this.attachers = [],
      this.compiler = void 0,
      this.freezeIndex = -1,
      this.frozen = void 0,
      this.namespace = {},
      this.parser = void 0,
      this.transformers = trough()
  }
  copy() {
    let destination = new Processor(), index$4 = -1
    for (; ++index$4 < this.attachers.length;) {
      let attacher = this.attachers[index$4]
      destination.use(...attacher)
    }
    return destination.data((0, import_extend.default)(!0, {}, this.namespace)), destination
  }
  data(key$1, value$2) {
    return typeof key$1 == `string`
      ? arguments.length === 2
        ? (assertUnfrozen(`data`, this.frozen), this.namespace[key$1] = value$2, this)
        : own.call(this.namespace, key$1) && this.namespace[key$1] || void 0
      : key$1
      ? (assertUnfrozen(`data`, this.frozen), this.namespace = key$1, this)
      : this.namespace
  }
  freeze() {
    if (this.frozen) return this
    let self$1 = this
    for (; ++this.freezeIndex < this.attachers.length;) {
      let [attacher, ...options$2] = this.attachers[this.freezeIndex]
      if (options$2[0] === !1) continue
      options$2[0] === !0 && (options$2[0] = void 0)
      let transformer = attacher.call(self$1, ...options$2)
      typeof transformer == `function` && this.transformers.use(transformer)
    }
    return this.frozen = !0, this.freezeIndex = 1 / 0, this
  }
  parse(file) {
    this.freeze()
    let realFile = vfile(file), parser = this.parser || this.Parser
    return assertParser(`parse`, parser), parser(String(realFile), realFile)
  }
  process(file, done$8) {
    let self$1 = this
    return this.freeze(),
      assertParser(`process`, this.parser || this.Parser),
      assertCompiler(`process`, this.compiler || this.Compiler),
      done$8 ? executor(void 0, done$8) : new Promise(executor)
    function executor(resolve, reject) {
      let realFile = vfile(file), parseTree = self$1.parse(realFile)
      self$1.run(parseTree, realFile, function(error, tree, file$1) {
        if (error || !tree || !file$1) return realDone(error)
        let compileTree = tree, compileResult = self$1.stringify(compileTree, file$1)
        looksLikeAValue(compileResult) ? file$1.value = compileResult : file$1.result = compileResult,
          realDone(error, file$1)
      })
      function realDone(error, file$1) {
        error || !file$1 ? reject(error) : resolve ? resolve(file$1) : done$8(void 0, file$1)
      }
    }
  }
  processSync(file) {
    let complete$4 = !1, result
    return this.freeze(),
      assertParser(`processSync`, this.parser || this.Parser),
      assertCompiler(`processSync`, this.compiler || this.Compiler),
      this.process(file, realDone),
      assertDone(`processSync`, `process`, complete$4),
      result
    function realDone(error, file$1) {
      complete$4 = !0, bail(error), result = file$1
    }
  }
  run(tree, file, done$8) {
    assertNode(tree), this.freeze()
    let transformers = this.transformers
    return !done$8 && typeof file == `function` && (done$8 = file, file = void 0),
      done$8 ? executor(void 0, done$8) : new Promise(executor)
    function executor(resolve, reject) {
      let realFile = vfile(file)
      transformers.run(tree, realFile, realDone)
      function realDone(error, outputTree, file$1) {
        let resultingTree = outputTree || tree
        error ? reject(error) : resolve ? resolve(resultingTree) : done$8(void 0, resultingTree, file$1)
      }
    }
  }
  runSync(tree, file) {
    let complete$4 = !1, result
    return this.run(tree, file, realDone), assertDone(`runSync`, `run`, complete$4), result
    function realDone(error, tree$1) {
      bail(error), result = tree$1, complete$4 = !0
    }
  }
  stringify(tree, file) {
    this.freeze()
    let realFile = vfile(file), compiler$1 = this.compiler || this.Compiler
    return assertCompiler(`stringify`, compiler$1), assertNode(tree), compiler$1(tree, realFile)
  }
  use(value$2, ...parameters) {
    let attachers = this.attachers, namespace = this.namespace
    if (assertUnfrozen(`use`, this.frozen), value$2 != null) {
      if (typeof value$2 == `function`) addPlugin(value$2, parameters)
      else if (typeof value$2 == `object`) Array.isArray(value$2) ? addList(value$2) : addPreset(value$2)
      else throw TypeError('Expected usable value, not `' + value$2 + '`')
    }
    return this
    function add$5(value$3) {
      if (typeof value$3 == `function`) addPlugin(value$3, [])
      else if (typeof value$3 == `object`) {
        if (Array.isArray(value$3)) {
          let [plugin, ...parameters$1] = value$3
          addPlugin(plugin, parameters$1)
        } else addPreset(value$3)
      } else throw TypeError('Expected usable value, not `' + value$3 + '`')
    }
    function addPreset(result) {
      if (!(`plugins` in result) && !(`settings` in result)) {
        throw Error(
          'Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither',
        )
      }
      addList(result.plugins),
        result.settings && (namespace.settings = (0, import_extend.default)(!0, namespace.settings, result.settings))
    }
    function addList(plugins) {
      let index$4 = -1
      if (plugins != null) {
        if (Array.isArray(plugins)) {
          for (; ++index$4 < plugins.length;) {
            let thing = plugins[index$4]
            add$5(thing)
          }
        } else throw TypeError('Expected a list of plugins, not `' + plugins + '`')
      }
    }
    function addPlugin(plugin, parameters$1) {
      let index$4 = -1, entryIndex = -1
      for (; ++index$4 < attachers.length;) {
        if (attachers[index$4][0] === plugin) {
          entryIndex = index$4
          break
        }
      }
      if (entryIndex === -1) attachers.push([plugin, ...parameters$1])
      else if (parameters$1.length > 0) {
        let [primary, ...rest] = parameters$1, currentPrimary = attachers[entryIndex][1]
        isPlainObject(currentPrimary) && isPlainObject(primary)
        && (primary = (0, import_extend.default)(!0, currentPrimary, primary)),
          attachers[entryIndex] = [plugin, primary, ...rest]
      }
    }
  }
}
const unified = new Processor().freeze()
function assertParser(name, value$2) {
  if (typeof value$2 != `function`) throw TypeError('Cannot `' + name + '` without `parser`')
}
function assertCompiler(name, value$2) {
  if (typeof value$2 != `function`) throw TypeError('Cannot `' + name + '` without `compiler`')
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw Error(
      'Cannot call `' + name
        + '` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.',
    )
  }
}
function assertNode(node$1) {
  if (!isPlainObject(node$1) || typeof node$1.type != `string`) throw TypeError('Expected node, got `' + node$1 + '`')
}
function assertDone(name, asyncName, complete$4) {
  if (!complete$4) throw Error('`' + name + '` finished async. Use `' + asyncName + '` instead')
}
function vfile(value$2) {
  return looksLikeAVFile(value$2) ? value$2 : new VFile(value$2)
}
function looksLikeAVFile(value$2) {
  return !!(value$2 && typeof value$2 == `object` && `message` in value$2 && `messages` in value$2)
}
function looksLikeAValue(value$2) {
  return typeof value$2 == `string` || isUint8Array(value$2)
}
function isUint8Array(value$2) {
  return !!(value$2 && typeof value$2 == `object` && `byteLength` in value$2 && `byteOffset` in value$2)
}
const createProcessor = () => unified().use(remarkParse).use(remarkGfm).use(remarkRehype).use(rehypeStringify),
  parseSync = content$2 => {
    let result = createProcessor().processSync(content$2)
    return String(result)
  },
  Markdown = ({ children: children$3 }) => {
    let html$6 = parseSync(children$3)
    return (0, import_jsx_runtime.jsx)(`div`, { dangerouslySetInnerHTML: { __html: html$6 } })
  },
  DeprecationReason = ({ data }) =>
    data.deprecationReason
      ? (0, import_jsx_runtime.jsx)(p$2, {
        as: `div`,
        color: `red`,
        children: (0, import_jsx_runtime.jsx)(Markdown, { children: data.deprecationReason }),
      })
      : null,
  SinceBadge = ({ since }) =>
    since._tag === `initial`
      ? (0, import_jsx_runtime.jsx)(e, { color: `blue`, variant: `soft`, size: `1`, children: `Since initial version` })
      : (0, import_jsx_runtime.jsx)(e$1, {
        href: createChangelogUrl(since.revision.date, since.schema),
        style: { textDecoration: `none` },
        children: (0, import_jsx_runtime.jsxs)(e, {
          color: `green`,
          variant: `soft`,
          size: `1`,
          style: { cursor: `pointer` },
          children: [
            `Added `,
            value(since.schema).pipe(tagsExhaustive({
              SchemaVersioned: s$14 => `${encodeSync$3(s$14.version)}@${since.revision.date}`,
              SchemaUnversioned: () => since.revision.date,
            })),
          ],
        }),
      }),
  Field = ({ data, parentTypeName, fieldNameWidth, ...boxProps }) => {
    let { schema, lifecycles } = useSchema(),
      argumentList = isOutputField(data) ? (0, import_jsx_runtime.jsx)(ArgumentListAnnotation, { field: data }) : null,
      since = parentTypeName ? getFieldSince(lifecycles, parentTypeName, data.name, schema) : null,
      removedDate = parentTypeName ? getFieldRemovedDate(lifecycles, parentTypeName, data.name, schema) : null,
      showSinceBadge = since && since._tag !== `initial`
    return (0, import_jsx_runtime.jsxs)(o, {
      ...boxProps,
      variant: `ghost`,
      id: data.name,
      children: [
        (0, import_jsx_runtime.jsxs)(p$1, {
          align: `baseline`,
          mb: `2`,
          gap: `2`,
          children: [
            (0, import_jsx_runtime.jsx)(p, {
              style: { minWidth: fieldNameWidth ? `${fieldNameWidth}ch` : `auto`, flexShrink: 0 },
              children: (0, import_jsx_runtime.jsxs)(p$1, {
                align: `center`,
                gap: `2`,
                style: { display: `inline-flex` },
                children: [
                  (0, import_jsx_runtime.jsx)(e$1, {
                    href: `#${data.name}`,
                    color: `gray`,
                    underline: `hover`,
                    style: { textDecoration: `none` },
                    children: (0, import_jsx_runtime.jsx)(p$3, {
                      size: `3`,
                      weight: `bold`,
                      variant: `ghost`,
                      children: data.name,
                    }),
                  }),
                  showSinceBadge && (0, import_jsx_runtime.jsx)(SinceBadge, { since }),
                  removedDate
                  && (0, import_jsx_runtime.jsxs)(e, {
                    color: `red`,
                    variant: `soft`,
                    size: `1`,
                    children: [`Removed `, dateToVersionString(removedDate)],
                  }),
                ],
              }),
            }),
            (0, import_jsx_runtime.jsx)(TypeAnnotation, { type: data.type }),
          ],
        }),
        data.description
        && (0, import_jsx_runtime.jsx)(p, {
          mb: `2`,
          children: (0, import_jsx_runtime.jsx)(p$2, {
            size: `2`,
            color: `gray`,
            style: { lineHeight: `1.5` },
            children: data.description,
          }),
        }),
        (0, import_jsx_runtime.jsx)(DeprecationReason, { data }),
        argumentList
        && (0, import_jsx_runtime.jsxs)(p, {
          mt: `2`,
          ml: `4`,
          children: [
            (0, import_jsx_runtime.jsx)(p$2, { size: `2`, color: `gray`, children: `Arguments:` }),
            (0, import_jsx_runtime.jsx)(p, { ml: `2`, children: argumentList }),
          ],
        }),
      ],
    })
  },
  MissingSchema = () =>
    (0, import_jsx_runtime.jsx)(`div`, { children: `No content to show. There is no schema to work with.` }),
  getExampleReferencesForType = (typeUsageIndex, typeName, version = null) => {
    let versionKey = version ?? UNVERSIONED_KEY
    return get$5(typeUsageIndex, versionKey).pipe(
      flatMap$12(versionMap => get$5(versionMap, typeName)),
      getOrElse$5(empty$29),
    )
  },
  useExamplesForType = (typeName, version = null) => {
    let typeUsageIndex = examplesCatalog?.typeUsageIndex
    return (0, import_react.useMemo)(
      () => typeUsageIndex ? getExampleReferencesForType(typeUsageIndex, typeName, version) : empty$29(),
      [typeUsageIndex, typeName, version],
    )
  },
  ExampleLink = ({ exampleRef }) => {
    let href = exampleRef.version
      ? `/examples/${exampleRef.name}?version=${encodeSync$3(exampleRef.version)}`
      : `/examples/${exampleRef.name}`
    return (0, import_jsx_runtime.jsx)(e$1, {
      href,
      style: { textDecoration: `none` },
      children: (0, import_jsx_runtime.jsx)(e, {
        variant: `soft`,
        size: `2`,
        style: { cursor: `pointer` },
        children: exampleRef.name,
      }),
    })
  },
  FieldListSection = ({ data }) => {
    if (!isFielded(data)) return null
    let fields = getFields(data)
    return fields.length === 0
      ? null
      : (0, import_jsx_runtime.jsxs)(p, {
        children: [
          (0, import_jsx_runtime.jsx)(r, { size: `5`, mb: `4`, weight: `medium`, children: `Fields` }),
          (0, import_jsx_runtime.jsx)(FieldList, { data, parentTypeName: data.name }),
        ],
      })
  },
  NamedType = ({ data }) => {
    let { schema, lifecycles } = useSchema(),
      description = data.description
        ? (0, import_jsx_runtime.jsx)(p$2, {
          as: `div`,
          size: `2`,
          color: `gray`,
          children: (0, import_jsx_runtime.jsx)(Markdown, { children: data.description }),
        })
        : null,
      since = getTypeSince(lifecycles, data.name, schema),
      removedDate = getTypeRemovedDate(lifecycles, data.name, schema),
      showSinceBadge = since && since._tag !== `initial`,
      currentVersion = is$10(schema) ? schema.version : null,
      examples = useExamplesForType(data.name, currentVersion)
    return (0, import_jsx_runtime.jsxs)(p, {
      children: [
        (0, import_jsx_runtime.jsxs)(r$1, {
          size: `1`,
          children: [
            (0, import_jsx_runtime.jsxs)(p, {
              style: { display: `flex`, alignItems: `center`, gap: `8px` },
              children: [
                (0, import_jsx_runtime.jsx)(r, {
                  size: `7`,
                  weight: `bold`,
                  children: (0, import_jsx_runtime.jsx)(TypeLink, { type: data }),
                }),
                showSinceBadge && (0, import_jsx_runtime.jsx)(SinceBadge, { since }),
                removedDate
                && (0, import_jsx_runtime.jsxs)(e, {
                  color: `red`,
                  variant: `soft`,
                  size: `1`,
                  children: [`Removed `, dateToVersionString(removedDate)],
                }),
              ],
            }),
            description && (0, import_jsx_runtime.jsx)(p, { mt: `3`, children: description }),
          ],
        }),
        size$11(examples) > 0 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [
            (0, import_jsx_runtime.jsx)(o$1, { size: `4`, my: `6` }),
            (0, import_jsx_runtime.jsxs)(r$1, {
              size: `1`,
              children: [
                (0, import_jsx_runtime.jsx)(r, { size: `5`, mb: `3`, weight: `medium`, children: `Used in Examples` }),
                (0, import_jsx_runtime.jsx)(o, {
                  variant: `surface`,
                  children: (0, import_jsx_runtime.jsx)(p, {
                    style: { display: `flex`, flexWrap: `wrap`, gap: `8px` },
                    children: [...examples].map(exampleRef =>
                      (0, import_jsx_runtime.jsx)(
                        ExampleLink,
                        { exampleRef },
                        `${exampleRef.name}-${exampleRef.version ? encodeSync$3(exampleRef.version) : `unversioned`}`,
                      )
                    ),
                  }),
                }),
              ],
            }),
          ],
        }),
        (0, import_jsx_runtime.jsx)(o$1, { size: `4`, my: `6` }),
        (0, import_jsx_runtime.jsx)(r$1, {
          size: `1`,
          children: (0, import_jsx_runtime.jsx)(FieldListSection, { data }),
        }),
      ],
    })
  },
  useReferencePath = () => {
    let params = useParams(), location = useLocation()
    return assertReferenceRoute({ pathname: location.pathname, params }), params
  },
  tryWithToast = async (fn, errorMessage) => {
    try {
      return await fn(), null
    } catch (error) {
      console.error(`Error in tryWithToast:`, error)
      let baseMessage = error instanceof Error ? error.message : String(error),
        toastMessage = errorMessage || baseMessage
      return store.error(toastMessage), error instanceof Error ? error : Error(baseMessage)
    }
  },
  ReferenceVersionPicker = ({ data, current }) => {
    let navigate = useNavigate(),
      currentPath = useReferencePath(),
      handleVersionChange = async version => {
        let newVersion = encodeSync$3(version),
          error = await tryWithToast(async () => {
            throw Error(`No catalog available`)
          }, `Failed to switch version`)
        if (error) {
          let newPath = createReferencePath({
            version: fromString(newVersion),
            type: currentPath.type || ``,
            field: currentPath.field || ``,
          })
          navigate(newPath)
        }
      }
    return (0, import_jsx_runtime.jsx)(VersionPicker, {
      versions: data,
      currentVersion: current,
      onVersionChange: handleVersionChange,
    })
  },
  routeSchema = Struct({ catalog: Catalog$1, schema: Schema$1 }),
  referenceLoader = ({ params }) =>
    fail$1(
      Error(
        `No schema catalog available. This page requires a GraphQL schema to be configured. Please ensure your Polen configuration includes a valid schema source.`,
      ),
    ),
  ReferenceView = () => {
    let params = useParams(),
      loaderData = useLoaderData(routeSchema),
      { catalog, schema } = loaderData,
      lifecycle = createFromSchema(schema)
    if (!schema) return (0, import_jsx_runtime.jsx)(MissingSchema, {})
    let kindMap = getKindMap(schema.definition),
      sidebarItems = [],
      kindEntries = Object.entries(kindMap.list).filter(([_$1, types]) => types.length > 0)
    for (let [title$1, types] of kindEntries) {
      sidebarItems.push({
        type: `ItemSection`,
        title: title$1,
        pathExp: `reference-${title$1.toLowerCase()}`,
        isLinkToo: !1,
        links: types.map(type$2 => {
          let kind = typeKindFromClass(type$2)
          return {
            type: `ItemLink`,
            title: (0, import_jsx_runtime.jsxs)(p$1, {
              align: `center`,
              gap: `1`,
              display: `inline-flex`,
              children: [(0, import_jsx_runtime.jsx)(TypeKindIcon, { kind }), type$2.name],
            }),
            pathExp: type$2.name,
          }
        }),
      })
    }
    let basePath = createReferenceBasePath(getVersion(schema)),
      viewType = getReferenceViewType({ schema, type: params.type || ``, field: params.field || `` }),
      content$2 = (() => {
        if (viewType === `index`) {
          return (0, import_jsx_runtime.jsx)(`div`, {
            children: `Select a type from the sidebar to view its documentation.`,
          })
        }
        if (viewType === `type-missing` || viewType === `field-missing`) {
          return (0, import_jsx_runtime.jsx)(MissingSchema, {})
        }
        if (viewType === `type`) {
          let type$2 = schema.definition.getType(params.type)
          return (0, import_jsx_runtime.jsx)(NamedType, { data: type$2 })
        } else if (viewType === `field`) {
          let type$2 = schema.definition.getType(params.type), fields = type$2.getFields(), field = fields[params.field]
          return (0, import_jsx_runtime.jsx)(Field, { data: field, parentTypeName: params.type })
        } else neverCase(viewType)
      })()
    return (0, import_jsx_runtime.jsx)(GraphqlLifecycleProvider, {
      lifecycle,
      schema,
      children: (0, import_jsx_runtime.jsx)(SidebarLayout, {
        sidebar: sidebarItems,
        basePath,
        topContent: (() => {
          let version = getVersion(schema)
          return catalog._tag === `CatalogVersioned` && version
            ? (0, import_jsx_runtime.jsx)(ReferenceVersionPicker, { data: getVersions(catalog), current: version })
            : null
        })(),
        children: content$2,
      }),
    })
  },
  typeAndFieldRoutes = [
    route({ index: !0, Component: ReferenceView, loader: referenceLoader, schema: routeSchema }),
    route({
      path: `:type`,
      Component: ReferenceView,
      errorElement: (0, import_jsx_runtime.jsx)(MissingSchema, {}),
      loader: referenceLoader,
      schema: routeSchema,
      children: [
        route({
          path: `:field`,
          Component: ReferenceView,
          errorElement: (0, import_jsx_runtime.jsx)(MissingSchema, {}),
          loader: referenceLoader,
          schema: routeSchema,
        }),
      ],
    }),
  ],
  reference = null,
  Component = () =>
    (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsx)(ThemeProvider, { children: (0, import_jsx_runtime.jsx)(Layout, {}) }),
        (0, import_jsx_runtime.jsx)(ScrollRestoration, {}),
      ],
    }),
  Layout = () => {
    let { appearance } = useTheme(),
      location = useLocation(),
      isHomeWithCinematicHero = location.pathname === `/` && templateConfig.home.enabled
        && templateConfig.home.hero.enabled && templateConfig.home.hero.layout === `cinematic`,
      navbarProps = {
        items: navbar,
        Item,
        Logo: () =>
          (0, import_jsx_runtime.jsx)(Link, {
            to: `/`,
            style: { color: `inherit`, textDecoration: `none` },
            children: (0, import_jsx_runtime.jsx)(p, {
              display: { initial: `block`, md: `block` },
              children: (0, import_jsx_runtime.jsx)(Logo, {
                src: logo_default,
                title: templateConfig.templateVariables.title,
                height: 30,
                showTitle: !0,
              }),
            }),
          }),
        ThemeToggle,
      },
      NavbarComponent = DefaultNavbar
    return (0, import_jsx_runtime.jsx)(R, {
      asChild: !0,
      appearance,
      ...swissSharpTheme,
      children: (0, import_jsx_runtime.jsxs)(Grid, {
        maxWidth: `1440px`,
        gutter: `var(--space-4)`,
        margins: `var(--space-5)`,
        style: { gridTemplateRows: `100px` },
        children: [
          isHomeWithCinematicHero
            ? (0, import_jsx_runtime.jsx)(R, {
              asChild: !0,
              appearance: `dark`,
              children: (0, import_jsx_runtime.jsx)(Grid, {
                position: `fixed`,
                top: `0`,
                left: `0`,
                height: `20px`,
                right: `0`,
                py: `6`,
                style: { zIndex: 100, background: `rgba(0, 0, 0, 0.2)` },
                children: (0, import_jsx_runtime.jsx)(Body, {
                  subgrid: !0,
                  children: (0, import_jsx_runtime.jsx)(NavbarComponent, { ...navbarProps }),
                }),
              }),
            })
            : (0, import_jsx_runtime.jsx)(Body, {
              subgrid: !0,
              py: `6`,
              height: `20px`,
              mb: { initial: `4`, md: `8` },
              style: { borderBottom: `1px solid var(--gray-3)` },
              children: (0, import_jsx_runtime.jsx)(NavbarComponent, { ...navbarProps }),
            }),
          (0, import_jsx_runtime.jsx)(Outlet, {}),
          (0, import_jsx_runtime.jsx)(ToastContainer, {}),
        ],
      }),
    })
  },
  children = []
templateConfig.home.enabled === !1 || children.push(index),
  children.push(pages),
  templateConfig.examples.enabled && children.push(examplesRoute),
  templateConfig.schema?.enabled
const notFoundRoute = { id: `*_not_found`, path: `*`, Component: NotFound, handle: { statusCode: 404 } }
children.push(notFoundRoute)
const root = route({ path: `/`, Component, loader: async () => ({}), children }),
  routes = [root],
  router = createBrowserRouter(routes, {
    ...window.__staticRouterHydrationData && { hydrationData: window.__staticRouterHydrationData },
    ...templateConfig.build.base !== `/` && { basename: templateConfig.build.base.slice(0, -1) },
  }),
  rootElement = document.getElementById(`app`)
if (!rootElement) throw Error(`Could not find app root element`)
import_client.hydrateRoot(
  rootElement,
  (0, import_jsx_runtime.jsx)(import_react.StrictMode, {
    children: (0, import_jsx_runtime.jsx)(RouterProvider, { router }),
  }),
)
export { __commonJSMin as b }
