import type { Config } from '#api/config/normalized'
import { Ef } from '#dep/effect'
import { FileSystem } from '@effect/platform'
import { Fs, FsLoc } from '@wollybeard/kit'

// ============================================================================
// Types
// ============================================================================

export interface TypeDefinition {
  /**
   * The name of the type definition file (without .d.ts extension).
   * Will be placed under @types/polen-generated/{name}.d.ts
   */
  name: string
  /**
   * The TypeScript type definition content.
   */
  content: string
}

export interface WriterOptions {
  /**
   * The root directory where node_modules exists.
   * Usually the project root.
   */
  projectRoot: FsLoc.AbsDir.AbsDir
}

export interface WriterOptionsWithConfig {
  /**
   * The normalized Polen configuration.
   * The generated types path will be extracted from config.paths.framework.generatedTypes
   */
  config: Config
}

// ============================================================================
// Paths
// ============================================================================

export const relativePathGeneratedTypesDir = FsLoc.fromString('node_modules/@types/polen-generated')

/**
 * Get the output directory for generated type definitions.
 */
export const getGeneratedTypesDir = (projectRoot: FsLoc.AbsDir.AbsDir): FsLoc.AbsDir.AbsDir => {
  return FsLoc.join(projectRoot, relativePathGeneratedTypesDir)
}

/**
 * Get the full path for a generated type definition file.
 */
export const getGeneratedTypePath = (projectRoot: FsLoc.AbsDir.AbsDir, name: string): FsLoc.AbsFile.AbsFile => {
  const dir = getGeneratedTypesDir(projectRoot)
  return FsLoc.join(dir, FsLoc.RelFile.decodeSync(`${name}.d.ts`))
}

// ============================================================================
// Package Structure
// ============================================================================

/**
 * Ensure the package structure exists for @types/polen-generated.
 * Creates package.json and index.d.ts if they don't exist.
 */
const ensurePackageStructure = (
  options: WriterOptions,
): Ef.Effect<void, Error, FileSystem.FileSystem> => {
  const outputDirLoc = getGeneratedTypesDir(options.projectRoot)
  const packageJsonFile = FsLoc.fromString('package.json')
  const packageJsonPathLoc = FsLoc.join(outputDirLoc, packageJsonFile)
  const indexFile = FsLoc.fromString('index.d.ts')
  const indexPathLoc = FsLoc.join(outputDirLoc, indexFile)

  return Ef.gen(function*() {
    // Ensure output directory exists
    yield* Fs.write(outputDirLoc, { recursive: true })

    // Check if package.json exists
    const packageJsonExists = yield* Fs.exists(packageJsonPathLoc)

    if (!packageJsonExists) {
      const packageJson = {
        name: '@types/polen-generated',
        version: '0.0.0',
        type: 'module',
        exports: {
          '.': {
            import: './index.d.ts',
          },
        },
      }
      yield* Fs.write(packageJsonPathLoc, JSON.stringify(packageJson, null, 2))
    }

    // Check if index.d.ts exists
    const indexExists = yield* Fs.exists(indexPathLoc)

    if (!indexExists) {
      const indexContent = `// Auto-generated index file for @types/polen-generated
// This file is automatically managed by Polen
// Do not edit this file directly

// This file exists to satisfy TypeScript's module resolution
// Individual type definition files are placed alongside this index
export {}
`
      yield* Fs.write(indexPathLoc, indexContent)
    }
  })
}

// ============================================================================
// Writer
// ============================================================================

/**
 * Write a TypeScript type definition to the generated types directory.
 *
 * @example
 * ```ts
 * // At application boundary (e.g., in Vite plugin)
 * await Ef.runPromise(
 *   Typings.write(
 *     { name: 'config.examples', content: 'declare global { ... }' },
 *     { projectRoot: '/path/to/project' }
 *   ).pipe(Ef.provide(FileSystem.layer))
 * )
 * ```
 */
export const write = (
  definition: TypeDefinition,
  options: WriterOptions,
): Ef.Effect<void, Error, FileSystem.FileSystem> => {
  const outputFileLoc = getGeneratedTypePath(options.projectRoot, definition.name)

  return Ef.gen(function*() {
    // Ensure package structure exists (package.json and index.d.ts)
    yield* ensurePackageStructure(options)

    // Write the type definition file
    yield* Fs.write(outputFileLoc, definition.content)
  })
}

/**
 * Write multiple TypeScript type definitions.
 */
export const writeMany = (
  definitions: TypeDefinition[],
  options: WriterOptions,
): Ef.Effect<void, Error, FileSystem.FileSystem> => {
  return Ef.gen(function*() {
    // Ensure package structure once before writing all definitions
    yield* ensurePackageStructure(options)

    // Write all definitions without re-checking package structure
    for (const definition of definitions) {
      const outputFileLoc = getGeneratedTypePath(options.projectRoot, definition.name)
      yield* Fs.write(outputFileLoc, definition.content)
    }
  })
}

/**
 * Remove a generated type definition file.
 */
export const remove = (
  name: string,
  options: WriterOptions,
): Ef.Effect<void, Error, FileSystem.FileSystem> => {
  const outputFile = getGeneratedTypePath(options.projectRoot, name)

  return Ef.gen(function*() {
    // Try to remove the file, ignore if it doesn't exist
    yield* Fs.remove(outputFile).pipe(
      Ef.catchIf(
        error => 'code' in error && (error as any).code === 'ENOENT',
        () => Ef.void,
      ),
    )
  })
}

/**
 * Clear all generated type definitions.
 */
export const clear = (
  options: WriterOptions,
): Ef.Effect<void, Error, FileSystem.FileSystem> => {
  const outputDir = getGeneratedTypesDir(options.projectRoot)

  return Ef.gen(function*() {
    // Try to remove the directory, ignore if it doesn't exist
    yield* Fs.remove(outputDir, { recursive: true }).pipe(
      Ef.catchIf(
        error => 'code' in error && (error as any).code === 'ENOENT',
        () => Ef.void,
      ),
    )
  })
}

// ============================================================================
// Type Definition Builders
// ============================================================================

/**
 * Create a global namespace augmentation type definition.
 *
 * @example
 * ```ts
 * const typeDef = Typings.createGlobalAugmentation(
 *   'interface Examples { readonly names: readonly ["example1", "example2"] }',
 *   'Example type definitions'
 * )
 * ```
 */
export const createGlobalAugmentation = (
  content: string,
  header?: string,
): string => {
  const headerComment = header
    ? `// ${header}\n// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`
    : `// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`

  return `${headerComment}declare global {
  namespace PolenGlobal {
    ${content.split('\n').join('\n    ')}
  }
}

// Ensure the file is treated as a module
export {}
`
}

/**
 * Create a module augmentation type definition.
 *
 * @example
 * ```ts
 * const typeDef = Typings.createModuleAugmentation(
 *   '#api/examples/config',
 *   'export type AvailableExampleNames = Polen.AvailableExampleNames'
 * )
 * ```
 */
export const createModuleAugmentation = (
  modulePath: string,
  content: string,
  header?: string,
): string => {
  const headerComment = header
    ? `// ${header}\n// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`
    : `// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`

  return `${headerComment}declare module '${modulePath}' {
  ${content.split('\n').join('\n  ')}
}

// Ensure the file is treated as a module
export {}
`
}
