import type { Config } from '#api/config/normalized'
import { FileSystem } from '@effect/platform'
import { Effect } from 'effect'
import * as Path from 'node:path'

// ============================================================================
// Types
// ============================================================================

export interface TypeDefinition {
  /**
   * The name of the type definition file (without .d.ts extension).
   * Will be placed under @types/polen-generated/{name}.d.ts
   */
  name: string
  /**
   * The TypeScript type definition content.
   */
  content: string
}

export interface WriterOptions {
  /**
   * The root directory where node_modules exists.
   * Usually the project root.
   */
  projectRoot: string
}

export interface WriterOptionsWithConfig {
  /**
   * The normalized Polen configuration.
   * The generated types path will be extracted from config.paths.framework.generatedTypes
   */
  config: Config
}

// ============================================================================
// Paths
// ============================================================================

export const relativePathGeneratedTypesDir = 'node_modules/@types/polen-generated'

/**
 * Get the output directory for generated type definitions.
 */
export const getGeneratedTypesDir = (projectRoot: string): string => {
  return Path.join(projectRoot, relativePathGeneratedTypesDir)
}

/**
 * Get the full path for a generated type definition file.
 */
export const getGeneratedTypePath = (projectRoot: string, name: string): string => {
  return Path.join(getGeneratedTypesDir(projectRoot), `${name}.d.ts`)
}

// ============================================================================
// Writer
// ============================================================================

/**
 * Write a TypeScript type definition to the generated types directory.
 *
 * @example
 * ```ts
 * await Effect.runPromise(
 *   Typings.write(
 *     { name: 'config.examples', content: 'declare global { ... }' },
 *     { projectRoot: '/path/to/project' }
 *   ).pipe(Effect.provide(FileSystem.layer))
 * )
 * ```
 */
export const write = (
  definition: TypeDefinition,
  options: WriterOptions,
): Effect.Effect<void, Error, FileSystem.FileSystem> => {
  const outputDir = getGeneratedTypesDir(options.projectRoot)
  const outputFile = getGeneratedTypePath(options.projectRoot, definition.name)

  return Effect.gen(function*() {
    const fs = yield* FileSystem.FileSystem

    // Ensure output directory exists
    yield* fs.makeDirectory(outputDir, { recursive: true })

    // Write the type definition file
    yield* fs.writeFileString(outputFile, definition.content)
  })
}

/**
 * Write multiple TypeScript type definitions.
 */
export const writeMany = (
  definitions: TypeDefinition[],
  options: WriterOptions,
): Effect.Effect<void, Error, FileSystem.FileSystem> => {
  return Effect.all(
    definitions.map(definition => write(definition, options)),
    { discard: true },
  )
}

/**
 * Remove a generated type definition file.
 */
export const remove = (
  name: string,
  options: WriterOptions,
): Effect.Effect<void, Error, FileSystem.FileSystem> => {
  const outputFile = getGeneratedTypePath(options.projectRoot, name)

  return Effect.gen(function*() {
    const fs = yield* FileSystem.FileSystem

    // Try to remove the file, ignore if it doesn't exist
    yield* fs.remove(outputFile).pipe(
      Effect.catchIf(
        error => (error as any).code === 'ENOENT',
        () => Effect.void,
      ),
    )
  })
}

/**
 * Clear all generated type definitions.
 */
export const clear = (
  options: WriterOptions,
): Effect.Effect<void, Error, FileSystem.FileSystem> => {
  const outputDir = getGeneratedTypesDir(options.projectRoot)

  return Effect.gen(function*() {
    const fs = yield* FileSystem.FileSystem

    // Try to remove the directory, ignore if it doesn't exist
    yield* fs.remove(outputDir, { recursive: true }).pipe(
      Effect.catchIf(
        error => (error as any).code === 'ENOENT',
        () => Effect.void,
      ),
    )
  })
}

// ============================================================================
// Type Definition Builders
// ============================================================================

/**
 * Create a global namespace augmentation type definition.
 *
 * @example
 * ```ts
 * const typeDef = Typings.createGlobalAugmentation(
 *   'interface Examples { readonly names: readonly ["example1", "example2"] }',
 *   'Example type definitions'
 * )
 * ```
 */
export const createGlobalAugmentation = (
  content: string,
  header?: string,
): string => {
  const headerComment = header
    ? `// ${header}\n// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`
    : `// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`

  return `${headerComment}declare global {
  namespace PolenGlobal {
    ${content.split('\n').join('\n    ')}
  }
}

// Ensure the file is treated as a module
export {}
`
}

/**
 * Create a module augmentation type definition.
 *
 * @example
 * ```ts
 * const typeDef = Typings.createModuleAugmentation(
 *   '#api/examples/config',
 *   'export type AvailableExampleNames = Polen.AvailableExampleNames'
 * )
 * ```
 */
export const createModuleAugmentation = (
  modulePath: string,
  content: string,
  header?: string,
): string => {
  const headerComment = header
    ? `// ${header}\n// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`
    : `// This file is auto-generated by Polen\n// Do not edit this file directly\n\n`

  return `${headerComment}declare module '${modulePath}' {
  ${content.split('\n').join('\n  ')}
}

// Ensure the file is treated as a module
export {}
`
}
