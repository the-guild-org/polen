import { CodeBuilder } from '../lib/code-builder/_namespace.js'
import { Fs } from '../lib/fs/_namespace.js'
import { Path } from '../lib/path/_namespace.js'
import { ViteVirtual } from '../lib/vite-virtual/_namespace.js'
import { Vite } from '../lib/vite/_namespace.js'
import { vi } from './helpers.js'
import { defu } from 'defu'

const viServerEntry = vi(`server`, `entry.jsx`)

export const Build = (parameters: {
  entryServerPath: string,
  clientEntryPath: string,
  port?: number,
  debug?: boolean,
}): Vite.Plugin[] => {
  const config = defu(parameters, { debug: false })
  let viteConfigResolved: Vite.ResolvedConfig

  return [Manifest(), {
    name: `polen:build-client`,
    apply: `build`,
    applyToEnvironment: Vite.isEnvironmentClient,
    // HACK: For some reason the ?url import doesn't lead to a rewrite in the build.
    // Furthermore we need to rely on the manifest to get its final name because it is
    // generated by the client build before the server build.
    // However, we still need the asset in development.
    // But we cannot exclude the import in build.
    // So this does that for us but it is really hacky.
    // FIXME
    // 1. Raise issue about having ?url lead to expected build path rewrite?
    // 2. And: Move asset generation to server build?
    // 3. And/or: Use Vite Environments API?
    generateBundle(_, bundle, isWrite) {
      if (isWrite) {
        for (const chunkOrAsset of Object.values(bundle)) {
          if (chunkOrAsset.type === `asset` && chunkOrAsset.names.includes(`entry.client.jsx`)) {
            // eslint-disable-next-line
            delete bundle[chunkOrAsset.fileName]
          }
        }
      }
    },
    onLog(level, message) {
      if (
        level === `warn` && message.code === codes.MODULE_LEVEL_DIRECTIVE &&
        message.id?.includes(`@radix-ui`)
      ) return
    },
    config() {
      return {
        environments: {
          client: {
            build: {
              minify: !parameters.debug,
              manifest: true,
              rollupOptions: {
                input: [parameters.clientEntryPath],
                // jsx: {
                //   mode: 'automatic',
                // },
              },
            },
          },
        },
      }
    },
  }, {
    name: `polen-ssr-build`,
    apply: `build`,
    applyToEnvironment: Vite.isEnvironmentSsr,
    configResolved(config) {
      viteConfigResolved = config
    },
    ...ViteVirtual.IdentifiedLoader.toHooks(
      {
        identifier: viServerEntry,
        loader: () => {
          const entryServerPath = Path.absolutify(
            config.entryServerPath,
            viteConfigResolved.root,
          )
          const entrServeryViteGlobPath = `/` +
            Path.relative(viteConfigResolved.root, entryServerPath)
          const staticServingPaths = {
            // todo
            // relative from CWD of process that boots node server
            // can easily break! Use path relative in server??
            dirPath: `./dist`,
            routePath: `/${viteConfigResolved.build.assetsDir}/*`,
          }

          const code = CodeBuilder.create()

          const _ = {
            app: `app`,
            entry: `entry`,
            entries: `entries`,
          }

          const honoPath = import.meta.resolve(`hono`)
          const honoNodeServerServeStaticPath = import.meta.resolve(
            `@hono/node-server/serve-static`,
          )
          const honoNodeServerPath = import.meta.resolve(`@hono/node-server`)

          // TODO turn this into a file template
          code(`import { Hono } from '${honoPath}'`)
          code(``)
          code(`const ${_.app} = new Hono()`)
          code(``)
          code(``)
          code(`// Static Files`)
          code(``)
          code(`import { serveStatic } from '${honoNodeServerServeStaticPath}'`)
          code(``)
          code(`${_.app}.use(
    				'${staticServingPaths.routePath}',
    				serveStatic({ root: '${staticServingPaths.dirPath}' })
    			)`)
          code(``)
          code(``)
          code(`// Entries`)
          code(``)
          code(`const ${_.entries} = import.meta.glob(
    				['${entrServeryViteGlobPath}'],
    				{ import: 'default', eager: true }
    			)`)
          code(``)
          code(`/** @see https://github.com/honojs/hono/issues/4051 */`)
          code(`const delegate = (app1, method, path, app2) => {
						app1.on(method, path, (c) => {
							// Throws if executionCtx is not available
							// https://hono.dev/docs/api/context#executionctx
							let maybeExecutionContext
							try { maybeExecutionContext = c.executionCtx }
							catch {}
							return app2.fetch(c.req.raw, c.env, maybeExecutionContext)
						})
					}`)
          code(`for (const ${_.entry} of Object.values(${_.entries})) {
						delegate(${_.app}, 'all', '*', ${_.entry})
    			}`)
          code(``)
          code(``)
          code(`// Start Server`)
          code(``)
          code(`import { serve } from '${honoNodeServerPath}'`)
          code(``)

          const port = config.port ?? viteConfigResolved.server.port + 1
          code(`const port = process.env.PORT || ${port.toString()}`)
          code(`serve({ fetch: ${_.app}.fetch, port })`)

          return code.render()
        },
      },
    ),
    config() {
      return {
        environments: {
          ssr: {
            build: {
              emptyOutDir: false,
              minify: !config.debug,
              rollupOptions: {
                input: viServerEntry.id,
              },
            },
          },
        },
      }
    },
    // generateBundle(_, bundle, isWrite) {
    //   if (isWrite) {
    //     for (const chunkOrAsset of Object.values(bundle)) {
    //       console.log(chunkOrAsset)
    //       if (chunkOrAsset.type === `chunk`) {
    //         if (chunkOrAsset.facadeModuleId === viClientManifest.resolved) {
    //           // eslint-disable-next-line
    //           delete bundle[chunkOrAsset.fileName]
    //         }
    //       }
    //     }
    //   }
    // },
    async closeBundle() {
      /**
       * clean up the manifest. Was generated by client. For server build. Not needed after (unless debugging).
       */
      if (!config.debug) {
        await Fs.rmDirIfExists(
          Path.join(viteConfigResolved.root, viteConfigResolved.build.outDir, `.vite`),
        )
      }
    },
  }]
}

const viClientManifest = vi(`vite`, `client`, `manifest`)

const Manifest = (): Vite.Plugin => {
  let configEnv: Vite.ConfigEnv
  let viteConfigResolved: Vite.ResolvedConfig

  return {
    name: `polen-manifest`,
    config(_, configEnv_) {
      configEnv = configEnv_
    },
    configResolved(config) {
      viteConfigResolved = config
    },
    ...ViteVirtual.IdentifiedLoader.toHooks(
      {
        identifier: viClientManifest,
        loader: async () => {
          // In development just return an empty manifest
          if (configEnv.mode === Vite.ModeName.development) {
            return `export default {}`
          }

          const manifestPath = Path.join(
            viteConfigResolved.root,
            viteConfigResolved.build.outDir,
            `.vite`,
            `manifest.json`,
          )
          const module = await import(manifestPath, { with: { type: `json` } }) as {
            default: Vite.Manifest,
          }

          return `export default ${JSON.stringify(module.default)}`
        },
      },
    ),
  }
}
const codes = {
  MODULE_LEVEL_DIRECTIVE: `MODULE_LEVEL_DIRECTIVE`,
  CIRCULAR_DEPENDENCY: `CIRCULAR_DEPENDENCY`,
}
