import { S } from '#dep/effect'
import { Diagnostic } from '#lib/diagnostic/$'
import { FsLoc } from '@wollybeard/kit'
import * as _ from '@wollybeard/kit/sch'
import { HashMap, Option, pipe } from 'effect'
import { Route } from './models/route.js'

// ============================================================================
// Schema - File Router Diagnostics
// ============================================================================

export const DiagnosticIndexConflict = Diagnostic.create({
  source: 'file-router',
  name: 'index-conflict',
  severity: 'error',
  context: {
    literal: S.Struct({
      file: FsLoc.AbsFile,
    }),
    index: S.Struct({
      file: FsLoc.AbsFile,
    }),
  },
}).annotations({
  identifier: 'DiagnosticIndexConflict',
  description: 'Diagnostic for conflicting index and literal file routes',
})
export const makeDiagnosticIndexConflict = Diagnostic.createMake(DiagnosticIndexConflict)

export const DiagnosticNumberedPrefixConflict = Diagnostic.create({
  source: 'file-router',
  name: 'numbered-prefix-conflict',
  severity: 'error',
  context: {
    kept: S.Struct({
      file: FsLoc.AbsFile,
      order: S.Number,
    }),
    dropped: S.Struct({
      file: FsLoc.AbsFile,
      order: S.Number,
    }),
  },
}).annotations({
  identifier: 'DiagnosticNumberedPrefixConflict',
  description: 'Diagnostic for conflicting routes with numbered prefixes',
})
export const makeDiagnosticNumberedPrefixConflict = Diagnostic.createMake(DiagnosticNumberedPrefixConflict)

export const DiagnosticNumberedPrefixOnIndex = Diagnostic.create({
  source: 'file-router',
  name: 'numbered-prefix-on-index',
  severity: 'warning',
  context: {
    file: FsLoc.AbsFile,
    order: S.Number,
  },
})
  .annotations({
    identifier: 'DiagnosticNumberedPrefixOnIndex',
    description: 'Diagnostic for numbered prefix on index file that has no effect',
  })

export const makeDiagnosticNumberedPrefixOnIndex = Diagnostic.createMake(DiagnosticNumberedPrefixOnIndex)

// Union of all file-router diagnostics
export const FileRouterDiagnostic = S.Union(
  DiagnosticIndexConflict,
  DiagnosticNumberedPrefixConflict,
  DiagnosticNumberedPrefixOnIndex,
).annotations({
  identifier: 'FileRouterDiagnostic',
  description: 'All diagnostics that can be generated by the file router',
})

export type Diagnostic = typeof FileRouterDiagnostic.Type

// Individual diagnostic types
export type DiagnosticIndexConflict = typeof DiagnosticIndexConflict.Type
export type DiagnosticNumberedPrefixConflict = typeof DiagnosticNumberedPrefixConflict.Type
export type DiagnosticNumberedPrefixOnIndex = typeof DiagnosticNumberedPrefixOnIndex.Type

export interface LintResult {
  diagnostics: Diagnostic[]
  routes: Route[]
}

export const lint = (routes: Route[]): LintResult => {
  const diagnostics: Diagnostic[] = []

  // Use HashMap with route.id as the key
  let seen = HashMap.empty<string, Route>()

  // ━ Check for numbered prefix on index files
  for (const route of routes) {
    if (Route.isFromIndexFile(route) && route.logical.order !== undefined) {
      const diagnostic = makeDiagnosticNumberedPrefixOnIndex({
        message: `Numbered prefix on index file has no effect. The file:\n  ${
          FsLoc.encodeSync(route.file)
        }\n\nhas a numbered prefix (${route.logical.order}_) which doesn't affect ordering since index files represent their parent directory.`,
        file: route.file,
        order: route.logical.order,
      })
      diagnostics.push(diagnostic)
    }
  }

  // ━ Check for conflicts
  for (const route of routes) {
    // Detect
    const seenRouteOption = pipe(seen, HashMap.get(route.id))
    const seenRoute = Option.getOrUndefined(seenRouteOption)

    if (seenRoute !== undefined) {
      // Check if it's a numbered prefix conflict
      if (seenRoute.logical.order !== undefined && route.logical.order !== undefined) {
        // Handle numbered prefix conflict - keep the one with higher order
        const [kept, dropped] = seenRoute.logical.order > route.logical.order ? [seenRoute, route] : [route, seenRoute]

        if (dropped === seenRoute) {
          seen = pipe(seen, HashMap.set(kept.id, kept))
        }

        const orderMessage = kept.logical.order === dropped.logical.order
          ? `Both files have the same order number (${kept.logical.order}). The file processed later is being kept based on processing order.`
          : `The file with lower order number (${dropped.logical.order}) is being dropped in favor of the one with higher order (${kept.logical.order}).`

        const diagnostic = makeDiagnosticNumberedPrefixConflict({
          // dprint-ignore
          message: `Your files represent conflicting routes due to numbered prefixes. This file:\n  ${FsLoc.encodeSync(kept.file)}\n\nconflicts with this file:\n\n  ${FsLoc.encodeSync(dropped.file)}.\n\n${orderMessage}`,
          kept: {
            file: kept.file,
            order: kept.logical.order!,
          },
          dropped: {
            file: dropped.file,
            order: dropped.logical.order!,
          },
        })
        diagnostics.push(diagnostic)
        continue
      }

      // Fix - ignore the index
      const [index, literal] = Route.isFromIndexFile(route) ? [route, seenRoute] : [seenRoute, route]
      if (seenRoute === index) {
        seen = pipe(seen, HashMap.set(route.id, route))
      }

      // Report
      const diagnostic = makeDiagnosticIndexConflict({
        // dprint-ignore
        message: `Your files represent conflicting routes. This index file route:\n  ${FsLoc.encodeSync(index.file)}\n\nconflicts with this literal file route:\n\n  ${FsLoc.encodeSync(literal.file)}.\n\nYour index route is being ignored.`,
        literal: {
          file: literal.file,
        },
        index: {
          file: index.file,
        },
      })
      diagnostics.push(diagnostic)

      continue
    }

    // Continue
    seen = pipe(seen, HashMap.set(route.id, route))
  }

  return {
    diagnostics,
    routes: Array.from(HashMap.values(seen)),
  }
}
